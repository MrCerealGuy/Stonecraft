/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: weapons_shot
 * function(itemstack, placer, pointed_thing, velocity, name) */
static int lcf1_weapons_shot (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* local dir = placer:get_look_dir() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get_look_dir");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* local playerpos = placer:getpos() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local obj = minetest.env:add_entity({x=playerpos.x+0+dir.x,y=playerpos.y+2+dir.y,z=playerpos.z+0+dir.z}, "nssm:"..name) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"add_entity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,7);
  lua_pushnumber(L,0);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,6);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,7);
  lua_pushnumber(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,6);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,7);
  lua_pushnumber(L,0);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,6);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"nssm:");
  lua_pushvalue(L,5);
  lua_concat(L,2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 8);
  
  /* local vec = {x=dir.x*velocity,y=dir.y*velocity,z=dir.z*velocity} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,6);
  lc_mul(L,-1,4);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,6);
  lc_mul(L,-1,4);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,6);
  lc_mul(L,-1,4);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 9);
  
  /* obj:setvelocity(vec) */
  lua_pushvalue(L,8);
  lua_pushliteral(L,"setvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,9);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 9);
  
  /* return itemstack */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 9);
}


/* name: hit
 * function(pos, self) */
static int lcf1_hit (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local node = nssm:node_ok(pos).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"node_ok");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* self.hit_node(self, pos, node) */
  lua_pushliteral(L,"hit_node");
  lua_gettable(L,2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,3);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 3);
  
  /* self.object:remove() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"remove");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  
  /* return */
  return 0;
  assert(lua_gettop(L) == 3);
}


/* name: activate_balls
 * function(pos) */
static int lcf1_activate_balls (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local radius = 50 */
  lua_pushnumber(L,50);
  assert(lua_gettop(L) == 2);
  
  /* local objects = minetest.env:get_objects_inside_radius(pos, radius) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 3);
  
  /* for _,obj in ipairs(objects) do
   * internal: local f, s, var = explist */
  enum { lc5 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 7
     * internal: local obj with idx 8 */
    
    
    /* if (obj:get_luaentity() and obj:get_luaentity().name == "nssm:hellzone_grenade") then */
    enum { lc6 = 8 };
    lua_pushvalue(L,8);
    lua_pushliteral(L,"get_luaentity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,8);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"nssm:hellzone_grenade");
      const int lc7 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc7);
    }
    const int lc8 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc8) {
      
      /* obj:get_luaentity().move = 1 */
      lua_pushnumber(L,1);
      lua_pushvalue(L,8);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_insert(L,-2);
      lua_pushliteral(L,"move");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc6);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc5);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <math.h>

/* __pow metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_pow(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,pow(lua_tonumber(L,idxa),lua_tonumber(L,idxb)));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__pow")||luaL_getmetafield(L,idxb,"__pow")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: search_on_step2
 * function(
 *     self,
 *     dtime,      --used to count time
 *     max_time,   --after this amount of time the entity is removec
 *     radius,     --radius in which look for entities to follow
 *     vel) */
static int lcf1_search_on_step2 (lua_State * L) {
  lua_checkstack(L,28);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* --velocity of the projectile
   * local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* --Disappear after a certain time
   * if self.life_time == 0 then */
  enum { lc10 = 6 };
  lua_pushliteral(L,"life_time");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc11 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc11);
  const int lc12 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc12) {
    
    /* self.life_time = os.time() */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"time");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushliteral(L,"life_time");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 6);
  
  /* if os.time() - self.life_time > max_time then */
  enum { lc13 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"os");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"life_time");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  const int lc14 = lua_lessthan(L,3,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc14);
  const int lc15 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc15) {
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 6);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc13);
  assert(lua_gettop(L) == 6);
  
  /* --Look for an entity to follow
   * local objects = minetest.env:get_objects_inside_radius(pos, radius) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,6);
  lua_pushvalue(L,4);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 7);
  
  /* local min_dist = 100 */
  lua_pushnumber(L,100);
  assert(lua_gettop(L) == 8);
  
  /* local obj_min = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 9);
  
  /* local obj_p = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 10);
  
  /* local vec_min = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 11);
  
  /* for _,obj in ipairs(objects) do
   * internal: local f, s, var = explist */
  enum { lc16 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,7);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 15
     * internal: local obj with idx 16 */
    
    
    /* if (obj:is_player()) then */
    enum { lc17 = 16 };
    lua_pushvalue(L,16);
    lua_pushliteral(L,"is_player");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    const int lc18 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc18) {
    }
    else {
      
      /* elseif (obj:get_luaentity() and obj:get_luaentity().name ~= "__builtin:item" and obj:get_luaentity().name ~= self.object:get_luaentity().name) then */
      enum { lc19 = 16 };
      lua_pushvalue(L,16);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,16);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"__builtin:item");
        const int lc20 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc20);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,16);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc21 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc21);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc22 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc22) {
        
        /* obj_p = obj:getpos() */
        lua_pushvalue(L,16);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_replace(L,10);
        assert(lua_gettop(L) == 16);
        
        /* local vec = {x=obj_p.x-pos.x, y=obj_p.y-pos.y, z=obj_p.z-pos.z} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lua_pushliteral(L,"x");
        lua_gettable(L,6);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,10);
        lua_pushliteral(L,"y");
        lua_gettable(L,6);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
        lua_pushliteral(L,"z");
        lua_gettable(L,6);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 17);
        
        /* local dist = (vec.x^2+vec.y^2+vec.z^2)^0.5 */
        lua_pushliteral(L,"x");
        lua_gettable(L,17);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_gettable(L,17);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,17);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0.5);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 18);
        
        /* if (dist<min_dist) then */
        enum { lc23 = 18 };
        const int lc24 = lua_lessthan(L,18,8);
        lua_pushboolean(L,lc24);
        const int lc25 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc25) {
          
          /* min_dist = dist */
          lua_pushvalue(L,18);
          lua_replace(L,8);
          assert(lua_gettop(L) == 18);
          
          /* obj_min = obj */
          lua_pushvalue(L,16);
          lua_replace(L,9);
          assert(lua_gettop(L) == 18);
          
          /* vec_min = vec */
          lua_pushvalue(L,17);
          lua_replace(L,11);
          assert(lua_gettop(L) == 18);
        }
        lua_settop(L,lc23);
        assert(lua_gettop(L) == 18);
      }
      lua_settop(L,lc19);
    }
    lua_settop(L,lc17);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc16);
  assert(lua_gettop(L) == 11);
  
  /* --Found an entity to follow:
   * if obj_min ~= nil then */
  enum { lc26 = 11 };
  lua_pushnil(L);
  const int lc27 = lua_equal(L,9,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc27);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc28 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc28) {
    
    /* local new_vel = {x=0, y=0, z=0} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 12);
    
    /* local dir = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 13);
    
    /* local max_diff = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 14);
    
    /* if (max_diff<math.abs(vec_min.x)) then */
    enum { lc29 = 14 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,11);
    lua_call(L,1,1);
    const int lc30 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc30);
    const int lc31 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc31) {
      
      /* dir = 1 */
      lua_pushnumber(L,1);
      lua_replace(L,13);
      assert(lua_gettop(L) == 14);
      
      /* max_diff = math.abs(vec_min.x) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,11);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc29);
    assert(lua_gettop(L) == 14);
    
    /* if (max_diff<math.abs(vec_min.y)) then */
    enum { lc32 = 14 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,11);
    lua_call(L,1,1);
    const int lc33 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc33);
    const int lc34 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc34) {
      
      /* dir = 2 */
      lua_pushnumber(L,2);
      lua_replace(L,13);
      assert(lua_gettop(L) == 14);
      
      /* max_diff = math.abs(vec_min.y) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,11);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc32);
    assert(lua_gettop(L) == 14);
    
    /* if (max_diff<math.abs(vec_min.z)) then */
    enum { lc35 = 14 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,11);
    lua_call(L,1,1);
    const int lc36 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc36);
    const int lc37 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc37) {
      
      /* dir = 3 */
      lua_pushnumber(L,3);
      lua_replace(L,13);
      assert(lua_gettop(L) == 14);
      
      /* max_diff = math.abs(vec_min.z) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,11);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc35);
    assert(lua_gettop(L) == 14);
    
    /* vec_min.x = (vec_min.x/max_diff)*vel */
    lua_pushliteral(L,"x");
    lua_gettable(L,11);
    lc_div(L,-1,14);
    lua_remove(L,-2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 14);
    
    /* vec_min.y = (vec_min.y/max_diff)*vel */
    lua_pushliteral(L,"y");
    lua_gettable(L,11);
    lc_div(L,-1,14);
    lua_remove(L,-2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 14);
    
    /* vec_min.z = (vec_min.z/max_diff)*vel */
    lua_pushliteral(L,"z");
    lua_gettable(L,11);
    lc_div(L,-1,14);
    lua_remove(L,-2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 14);
    
    /* obj_p = obj_min:getpos() */
    lua_pushvalue(L,9);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_replace(L,10);
    assert(lua_gettop(L) == 14);
    
    /* if min_dist <=8 and self.move==0 then */
    enum { lc38 = 14 };
    lua_pushnumber(L,8);
    const int lc39 = lc_le(L,8,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc39);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"move");
      lua_gettable(L,1);
      lua_pushnumber(L,0);
      const int lc40 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc40);
    }
    const int lc41 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc41) {
      
      /* self.object:setvelocity({x=0, y=0, z=0}) */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"setvelocity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 14);
    }
    else {
      
      /* --hit(pos,self)
       *         elseif min_dist<=1 and self.move==1 then */
      enum { lc42 = 14 };
      lua_pushnumber(L,1);
      const int lc43 = lc_le(L,8,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc43);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"move");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        const int lc44 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc44);
      }
      const int lc45 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc45) {
        
        /* hit(pos,self) */
        lc_getupvalue(L,lua_upvalueindex(1),2,3);
        lua_pushvalue(L,6);
        lua_pushvalue(L,1);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 14);
      }
      else {
        
        /* else
         * self.object:setvelocity(vec_min) */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"setvelocity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,11);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L,lc42);
    }
    lua_settop(L,lc38);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc26);
  assert(lua_gettop(L) == 11);
  
  /* local n = minetest.env:get_node(pos).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,6);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 12);
  
  /* if n ~= "air" and n ~= "default:water_source" and n ~= "default:water_flowing" then */
  enum { lc46 = 12 };
  lua_pushliteral(L,"air");
  const int lc47 = lua_equal(L,12,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc47);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:water_source");
    const int lc48 = lua_equal(L,12,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc48);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:water_flowing");
    const int lc49 = lua_equal(L,12,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc49);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc50 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc50) {
    
    /* hit(pos,self) */
    lc_getupvalue(L,lua_upvalueindex(1),2,3);
    lua_pushvalue(L,6);
    lua_pushvalue(L,1);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc46);
  assert(lua_gettop(L) == 12);
  return 0;
}


/* name: search_on_step
 * function(
 *     self,
 *     dtime,      --used to count time
 *     max_time,   --after this amount of time the entity is removec
 *     radius,     --radius in which look for entities to follow
 *     vel) */
static int lcf1_search_on_step (lua_State * L) {
  lua_checkstack(L,28);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* --velocity of the projectile
   * local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* --Disappear after a certain time
   * if self.life_time == 0 then */
  enum { lc52 = 6 };
  lua_pushliteral(L,"life_time");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc53 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc53);
  const int lc54 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc54) {
    
    /* self.life_time = os.time() */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"time");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushliteral(L,"life_time");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc52);
  assert(lua_gettop(L) == 6);
  
  /* if os.time() - self.life_time > max_time then */
  enum { lc55 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"os");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"life_time");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  const int lc56 = lua_lessthan(L,3,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc56);
  const int lc57 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc57) {
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 6);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc55);
  assert(lua_gettop(L) == 6);
  
  /* --Look for an entity to follow
   * local objects = minetest.env:get_objects_inside_radius(pos, radius) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,6);
  lua_pushvalue(L,4);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 7);
  
  /* local min_dist = 100 */
  lua_pushnumber(L,100);
  assert(lua_gettop(L) == 8);
  
  /* local obj_min = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 9);
  
  /* local obj_p = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 10);
  
  /* local vec_min = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 11);
  
  /* for _,obj in ipairs(objects) do
   * internal: local f, s, var = explist */
  enum { lc58 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,7);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 15
     * internal: local obj with idx 16 */
    
    
    /* if (obj:is_player()) then */
    enum { lc59 = 16 };
    lua_pushvalue(L,16);
    lua_pushliteral(L,"is_player");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    const int lc60 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc60) {
    }
    else {
      
      /* elseif (obj:get_luaentity() and obj:get_luaentity().name ~= "__builtin:item" and obj:get_luaentity().name ~= self.object:get_luaentity().name) then */
      enum { lc61 = 16 };
      lua_pushvalue(L,16);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,16);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"__builtin:item");
        const int lc62 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc62);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,16);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc63 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc63);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc64 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc64) {
        
        /* obj_p = obj:getpos() */
        lua_pushvalue(L,16);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_replace(L,10);
        assert(lua_gettop(L) == 16);
        
        /* local vec = {x=obj_p.x-pos.x, y=obj_p.y-pos.y, z=obj_p.z-pos.z} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lua_pushliteral(L,"x");
        lua_gettable(L,6);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,10);
        lua_pushliteral(L,"y");
        lua_gettable(L,6);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
        lua_pushliteral(L,"z");
        lua_gettable(L,6);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 17);
        
        /* local dist = (vec.x^2+vec.y^2+vec.z^2)^0.5 */
        lua_pushliteral(L,"x");
        lua_gettable(L,17);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_gettable(L,17);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,17);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0.5);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 18);
        
        /* if (dist<min_dist) then */
        enum { lc65 = 18 };
        const int lc66 = lua_lessthan(L,18,8);
        lua_pushboolean(L,lc66);
        const int lc67 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc67) {
          
          /* min_dist = dist */
          lua_pushvalue(L,18);
          lua_replace(L,8);
          assert(lua_gettop(L) == 18);
          
          /* obj_min = obj */
          lua_pushvalue(L,16);
          lua_replace(L,9);
          assert(lua_gettop(L) == 18);
          
          /* vec_min = vec */
          lua_pushvalue(L,17);
          lua_replace(L,11);
          assert(lua_gettop(L) == 18);
        }
        lua_settop(L,lc65);
        assert(lua_gettop(L) == 18);
      }
      lua_settop(L,lc61);
    }
    lua_settop(L,lc59);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc58);
  assert(lua_gettop(L) == 11);
  
  /* --Found an entity to follow:
   * if obj_min ~= nil then */
  enum { lc68 = 11 };
  lua_pushnil(L);
  const int lc69 = lua_equal(L,9,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc69);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc70 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc70) {
    
    /* local new_vel = {x=0, y=0, z=0} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 12);
    
    /* local dir = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 13);
    
    /* local max_diff = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 14);
    
    /* if (max_diff<math.abs(vec_min.x)) then */
    enum { lc71 = 14 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,11);
    lua_call(L,1,1);
    const int lc72 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc72);
    const int lc73 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc73) {
      
      /* dir = 1 */
      lua_pushnumber(L,1);
      lua_replace(L,13);
      assert(lua_gettop(L) == 14);
      
      /* max_diff = math.abs(vec_min.x) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,11);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc71);
    assert(lua_gettop(L) == 14);
    
    /* if (max_diff<math.abs(vec_min.y)) then */
    enum { lc74 = 14 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,11);
    lua_call(L,1,1);
    const int lc75 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc75);
    const int lc76 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc76) {
      
      /* dir = 2 */
      lua_pushnumber(L,2);
      lua_replace(L,13);
      assert(lua_gettop(L) == 14);
      
      /* max_diff = math.abs(vec_min.y) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,11);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc74);
    assert(lua_gettop(L) == 14);
    
    /* if (max_diff<math.abs(vec_min.z)) then */
    enum { lc77 = 14 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,11);
    lua_call(L,1,1);
    const int lc78 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc78);
    const int lc79 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc79) {
      
      /* dir = 3 */
      lua_pushnumber(L,3);
      lua_replace(L,13);
      assert(lua_gettop(L) == 14);
      
      /* max_diff = math.abs(vec_min.z) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,11);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc77);
    assert(lua_gettop(L) == 14);
    
    /* vec_min.x = (vec_min.x/max_diff)*vel */
    lua_pushliteral(L,"x");
    lua_gettable(L,11);
    lc_div(L,-1,14);
    lua_remove(L,-2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 14);
    
    /* vec_min.y = (vec_min.y/max_diff)*vel */
    lua_pushliteral(L,"y");
    lua_gettable(L,11);
    lc_div(L,-1,14);
    lua_remove(L,-2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 14);
    
    /* vec_min.z = (vec_min.z/max_diff)*vel */
    lua_pushliteral(L,"z");
    lua_gettable(L,11);
    lc_div(L,-1,14);
    lua_remove(L,-2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 14);
    
    /* obj_p = obj_min:getpos() */
    lua_pushvalue(L,9);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_replace(L,10);
    assert(lua_gettop(L) == 14);
    
    /* if min_dist < 1 then */
    enum { lc80 = 14 };
    lua_pushnumber(L,1);
    const int lc81 = lua_lessthan(L,8,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc81);
    const int lc82 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc82) {
      
      /* local node = nssm:node_ok(pos).name */
      lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
      lua_pushliteral(L,"node_ok");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,6);
      lua_call(L,2,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 15);
      
      /* self.hit_node(self, pos, node) */
      lua_pushliteral(L,"hit_node");
      lua_gettable(L,1);
      lua_pushvalue(L,1);
      lua_pushvalue(L,6);
      lua_pushvalue(L,15);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 15);
      
      /* self.object:remove() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"remove");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 15);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 15);
    }
    else {
      
      /* else
       * self.object:setvelocity(vec_min) */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"setvelocity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,11);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc80);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc68);
  assert(lua_gettop(L) == 11);
  
  /* local n = minetest.env:get_node(pos).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,6);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 12);
  
  /* if n ~= "air" and n ~= "default:water_source" and n ~= "default:water_flowing" then */
  enum { lc83 = 12 };
  lua_pushliteral(L,"air");
  const int lc84 = lua_equal(L,12,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc84);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:water_source");
    const int lc85 = lua_equal(L,12,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc85);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:water_flowing");
    const int lc86 = lua_equal(L,12,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc86);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc87 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc87) {
    
    /* local node = nssm:node_ok(pos).name */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"node_ok");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,6);
    lua_call(L,2,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 13);
    
    /* self.hit_node(self, pos, node) */
    lua_pushliteral(L,"hit_node");
    lua_gettable(L,1);
    lua_pushvalue(L,1);
    lua_pushvalue(L,6);
    lua_pushvalue(L,13);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 13);
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 13);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc83);
  assert(lua_gettop(L) == 12);
  return 0;
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: default_on_step
 * function(
 *     self,
 *     dtime,              --used to count time
 *     max_time,           --after this amount of time the entity is removec
 *     damage,             --damage dealt to the entity around
 *     dir,                --vector to specify directions in which remove blocks
 *     radius,             --radius of blocks removed aroind the projectile
 *     not_transparent,    --name of a block or of a group: when the projectile hit one of these blocks the function hit_node is called
 *     vel) */
static int lcf1_default_on_step (lua_State * L) {
  lua_checkstack(L,32);
  enum { lc_nformalargs = 8 };
  lua_settop(L,8);
  
  /* --velocity of the projectile
   * local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* if self.life_time == 0 then */
  enum { lc89 = 9 };
  lua_pushliteral(L,"life_time");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc90 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc90);
  const int lc91 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc91) {
    
    /* self.life_time = os.time() */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"time");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushliteral(L,"life_time");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc89);
  assert(lua_gettop(L) == 9);
  
  /* if os.time() - self.life_time > max_time then */
  enum { lc92 = 9 };
  lua_getfield(L,LUA_ENVIRONINDEX,"os");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"life_time");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  const int lc93 = lua_lessthan(L,3,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc93);
  const int lc94 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc94) {
    
    /* local node = nssm:node_ok(pos).name */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"node_ok");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,9);
    lua_call(L,2,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 10);
    
    /* self.hit_node(self, pos, node) */
    lua_pushliteral(L,"hit_node");
    lua_gettable(L,1);
    lua_pushvalue(L,1);
    lua_pushvalue(L,9);
    lua_pushvalue(L,10);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 10);
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 10);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc92);
  assert(lua_gettop(L) == 9);
  
  /* self.timer = self.timer + dtime */
  lua_pushliteral(L,"timer");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushliteral(L,"timer");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 9);
  
  /* --while going around it damages entities
   * local objects = minetest.env:get_objects_inside_radius(pos, 2) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,9);
  lua_pushnumber(L,2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 10);
  
  /* if self.timer > 0.3 then */
  enum { lc95 = 10 };
  lua_pushnumber(L,0.3);
  lua_pushliteral(L,"timer");
  lua_gettable(L,1);
  const int lc96 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc96);
  const int lc97 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc97) {
    
    /* for _,obj in ipairs(objects) do
     * internal: local f, s, var = explist */
    enum { lc98 = 10 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushvalue(L,10);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 14
       * internal: local obj with idx 15 */
      
      
      /* obj:set_hp(obj:get_hp()-damage) */
      lua_pushvalue(L,15);
      lua_pushliteral(L,"set_hp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,15);
      lua_pushliteral(L,"get_hp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lc_sub(L,-1,4);
      lua_remove(L,-2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 15);
      
      /* if (obj:get_hp() <= 0) then */
      enum { lc99 = 15 };
      lua_pushvalue(L,15);
      lua_pushliteral(L,"get_hp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_pushnumber(L,0);
      const int lc100 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc100);
      const int lc101 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc101) {
        
        /* if (not obj:is_player()) and obj:get_entity_name() ~= self.object:get_luaentity().name then */
        enum { lc102 = 15 };
        lua_pushvalue(L,15);
        lua_pushliteral(L,"is_player");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,15);
          lua_pushliteral(L,"get_entity_name");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"get_luaentity");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc103 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc103);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc104 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc104) {
          
          /* obj:remove() */
          lua_pushvalue(L,15);
          lua_pushliteral(L,"remove");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 15);
        }
        lua_settop(L,lc102);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc99);
      assert(lua_gettop(L) == 15);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc98);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc95);
  assert(lua_gettop(L) == 10);
  
  /* local n = minetest.env:get_node(pos).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,9);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 11);
  
  /* if n==not_transparent or minetest.get_item_group(n, not_transparent)==1 then */
  enum { lc105 = 11 };
  lua_pushvalue(L,11);
  lua_pushvalue(L,7);
  const int lc106 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc106);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_item_group");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,11);
    lua_pushvalue(L,7);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc107 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc107);
  }
  const int lc108 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc108) {
    
    /* local node = nssm:node_ok(pos).name */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"node_ok");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,9);
    lua_call(L,2,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 12);
    
    /* self.hit_node(self, pos, node) */
    lua_pushliteral(L,"hit_node");
    lua_gettable(L,1);
    lua_pushvalue(L,1);
    lua_pushvalue(L,9);
    lua_pushvalue(L,12);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 12);
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 12);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 12);
  }
  else {
    
    /* else
     * local vec = self.object:getvelocity() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* local c=vel/10 */
    lua_pushnumber(L,10);
    lc_div(L,8,-1);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 13);
    
    /* --calculate how many blocks around need to be removed
     * local max = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 14);
    
    /* local posmax = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 15);
    
    /* if max<math.abs(vec.x) then */
    enum { lc109 = 15 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,12);
    lua_call(L,1,1);
    const int lc110 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc110);
    const int lc111 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc111) {
      
      /* max = math.abs(vec.x) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 15);
      
      /* posmax = 1 */
      lua_pushnumber(L,1);
      lua_replace(L,15);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc109);
    assert(lua_gettop(L) == 15);
    
    /* if max<math.abs(vec.y) then */
    enum { lc112 = 15 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,12);
    lua_call(L,1,1);
    const int lc113 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc113);
    const int lc114 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc114) {
      
      /* max = math.abs(vec.y) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 15);
      
      /* posmax = 2 */
      lua_pushnumber(L,2);
      lua_replace(L,15);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc112);
    assert(lua_gettop(L) == 15);
    
    /* if max<math.abs(vec.z) then */
    enum { lc115 = 15 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,12);
    lua_call(L,1,1);
    const int lc116 = lua_lessthan(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc116);
    const int lc117 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc117) {
      
      /* max = math.abs(vec.z) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_replace(L,14);
      assert(lua_gettop(L) == 15);
      
      /* posmax = 3 */
      lua_pushnumber(L,3);
      lua_replace(L,15);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc115);
    assert(lua_gettop(L) == 15);
    
    /* local i = radius */
    lua_pushvalue(L,6);
    assert(lua_gettop(L) == 16);
    
    /* local j = radius */
    lua_pushvalue(L,6);
    assert(lua_gettop(L) == 17);
    
    /* local k = radius */
    lua_pushvalue(L,6);
    assert(lua_gettop(L) == 18);
    
    /* if dir.x == 0 then */
    enum { lc118 = 18 };
    lua_pushliteral(L,"x");
    lua_gettable(L,5);
    lua_pushnumber(L,0);
    const int lc119 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc119);
    const int lc120 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc120) {
      
      /* i = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,16);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc118);
    assert(lua_gettop(L) == 18);
    
    /* if dir.y == 0 then */
    enum { lc121 = 18 };
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    lua_pushnumber(L,0);
    const int lc122 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc122);
    const int lc123 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc123) {
      
      /* j = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,17);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc121);
    assert(lua_gettop(L) == 18);
    
    /* if dir.z == 0 then */
    enum { lc124 = 18 };
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    lua_pushnumber(L,0);
    const int lc125 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc125);
    const int lc126 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc126) {
      
      /* k = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,18);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc124);
    assert(lua_gettop(L) == 18);
    
    /* if posmax==1 then */
    enum { lc127 = 18 };
    lua_pushnumber(L,1);
    const int lc128 = lua_equal(L,15,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc128);
    const int lc129 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc129) {
      
      /* i = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,16);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc127);
    assert(lua_gettop(L) == 18);
    
    /* if posmax==2 then */
    enum { lc130 = 18 };
    lua_pushnumber(L,2);
    const int lc131 = lua_equal(L,15,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc131);
    const int lc132 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc132) {
      
      /* j = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,17);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc130);
    assert(lua_gettop(L) == 18);
    
    /* if posmax==3 then */
    enum { lc133 = 18 };
    lua_pushnumber(L,3);
    const int lc134 = lua_equal(L,15,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc134);
    const int lc135 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc135) {
      
      /* k = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,18);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc133);
    assert(lua_gettop(L) == 18);
    
    /* for dx = -i,i do */
    lc_unm(L,16);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,16)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc136_var = lua_tonumber(L,-1);
    const double lc137_limit = lua_tonumber(L,16);
    const double lc138_step = 1;
    lua_pop(L,1);
    enum { lc139 = 18 };
    while ((((lc138_step > 0) && (lc136_var <= lc137_limit)) || ((lc138_step <= 0) && (lc136_var >= lc137_limit)))) {
      
      /* internal: local dx at index 19 */
      lua_pushnumber(L,lc136_var);
      
      /* for dy= -j,j do */
      lc_unm(L,17);
      if (!((lua_isnumber(L,-1) && lua_isnumber(L,17)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc140_var = lua_tonumber(L,-1);
      const double lc141_limit = lua_tonumber(L,17);
      const double lc142_step = 1;
      lua_pop(L,1);
      enum { lc143 = 19 };
      while ((((lc142_step > 0) && (lc140_var <= lc141_limit)) || ((lc142_step <= 0) && (lc140_var >= lc141_limit)))) {
        
        /* internal: local dy at index 20 */
        lua_pushnumber(L,lc140_var);
        
        /* for dz = -k,k do */
        lc_unm(L,18);
        if (!((lua_isnumber(L,-1) && lua_isnumber(L,18)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc144_var = lua_tonumber(L,-1);
        const double lc145_limit = lua_tonumber(L,18);
        const double lc146_step = 1;
        lua_pop(L,1);
        enum { lc147 = 20 };
        while ((((lc146_step > 0) && (lc144_var <= lc145_limit)) || ((lc146_step <= 0) && (lc144_var >= lc145_limit)))) {
          
          /* internal: local dz at index 21 */
          lua_pushnumber(L,lc144_var);
          
          /* local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz} */
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,9);
          lc_add(L,-1,19);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,9);
          lc_add(L,-1,20);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,9);
          lc_add(L,-1,21);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          assert(lua_gettop(L) == 22);
          
          /* if not minetest.is_protected(p, "") or not minetest.get_item_group(n, "unbreakable") == 1 then */
          enum { lc148 = 22 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"is_protected");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,22);
          lua_pushliteral(L,"");
          lua_call(L,2,1);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"get_item_group");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,11);
            lua_pushliteral(L,"unbreakable");
            lua_call(L,2,1);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            const int lc149 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc149);
          }
          const int lc150 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc150) {
            
            /* minetest.env:remove_node(p) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"env");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,22);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 22);
          }
          lua_settop(L,lc148);
          assert(lua_gettop(L) == 22);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,2);
          lc144_var += lc146_step;
        }
        lua_settop(L,lc147);
        assert(lua_gettop(L) == 20);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc140_var += lc142_step;
      }
      lua_settop(L,lc143);
      assert(lua_gettop(L) == 19);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc136_var += lc138_step;
    }
    lua_settop(L,lc139);
    assert(lua_gettop(L) == 18);
  }
  lua_settop(L,lc105);
  assert(lua_gettop(L) == 11);
  return 0;
}


/* function(self, dtime) */
static int lcf152 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* def.on_step(self, dtime) */
  lc_getupvalue(L,lua_upvalueindex(1),0,9);
  lua_pushliteral(L,"on_step");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function(self, pos, node) */
static int lcf153 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* def.hit_node(self, pos, node) */
  lc_getupvalue(L,lua_upvalueindex(1),0,9);
  lua_pushliteral(L,"hit_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(itemstack, placer, pointed_thing) */
static int lcf154 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* weapons_shot(itemstack, placer, pointed_thing, def.velocity, name) */
  lc_getupvalue(L,lua_upvalueindex(1),6,2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lc_getupvalue(L,lua_upvalueindex(1),0,9);
  lua_pushliteral(L,"velocity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,8);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 3);
  
  /* return itemstack */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* function(itemstack, user, pointed_thing) */
static int lcf155 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  return 0;
}


/* name: nssm_register_weapon
 * function(name, def) */
static int lcf1_nssm_register_weapon (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc151 = 3 };
  assert((lua_gettop(L) == lc151));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,8);
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,9);
  
  /* minetest.register_entity("nssm:"..name, {
   *         textures = {name..".png"},
   *         on_step = function(self, dtime)
   *             def.on_step(self, dtime)
   *         end,
   *         hit_node = function(self, pos, node)
   *             def.hit_node(self, pos, node)
   *         end,
   *         move = def.move,
   *         life_time = 0,
   *         timer = 0
   *     }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_entity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nssm:");
  lc_getupvalue(L,lc151,0,8);
  lua_concat(L,2);
  lua_createtable(L,0,6);
  lua_pushliteral(L,"textures");
  lua_createtable(L,1,0);
  lc_getupvalue(L,lc151,0,8);
  lua_pushliteral(L,".png");
  lua_concat(L,2);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushvalue(L,lc151);
  lua_pushcclosure(L,lcf152,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_node");
  lua_pushvalue(L,lc151);
  lua_pushcclosure(L,lcf153,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"move");
  lc_getupvalue(L,lc151,0,9);
  lua_pushliteral(L,"move");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"life_time");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"timer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* minetest.register_tool("nssm:"..name.."_hand", {
   *         description = def.description,
   *         inventory_image = name.."_hand.png",
   *         on_use = function(itemstack, placer, pointed_thing)
   *             weapons_shot(itemstack, placer, pointed_thing, def.velocity, name)
   *             return itemstack
   *         end,
   *         on_drop = def.on_drop or function(itemstack, user, pointed_thing)
   * 		end,
   *     }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_tool");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nssm:");
  lc_getupvalue(L,lc151,0,8);
  lua_pushliteral(L,"_hand");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_createtable(L,0,4);
  lua_pushliteral(L,"description");
  lc_getupvalue(L,lc151,0,9);
  lua_pushliteral(L,"description");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lc_getupvalue(L,lc151,0,8);
  lua_pushliteral(L,"_hand.png");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_use");
  lua_pushvalue(L,lc151);
  lua_pushcclosure(L,lcf154,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_drop");
  lc_getupvalue(L,lc151,0,9);
  lua_pushliteral(L,"on_drop");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushcfunction(L,lcf155);
  }
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* minetest.register_craft({
   * 		output = 'nssm:'..name.."_hand",
   * 		recipe = {
   * 			{'nssm:great_energy_globe', 'nssm:great_energy_globe', 'nssm:great_energy_globe'},
   *             {'nssm:great_energy_globe', def.material, 'nssm:great_energy_globe'},
   *             {'nssm:great_energy_globe', 'nssm:great_energy_globe', 'nssm:great_energy_globe'}
   * 		}
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"nssm:");
  lc_getupvalue(L,lc151,0,8);
  lua_pushliteral(L,"_hand");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,3,0);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lc151,0,9);
  lua_pushliteral(L,"material");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"nssm:great_energy_globe");
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(self, dtime) */
static int lcf156 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* default_on_step(self, dtime, 4, 20, default_dir, 1, "stone", 25) */
  lc_getupvalue(L,lua_upvalueindex(1),0,7);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,20);
  lc_getupvalue(L,lua_upvalueindex(1),6,1);
  lua_pushnumber(L,1);
  lua_pushliteral(L,"stone");
  lua_pushnumber(L,25);
  lua_call(L,8,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function(self, pos, node) */
static int lcf157 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* nssm:explosion(pos, 6, 1) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"explosion");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushnumber(L,6);
  lua_pushnumber(L,1);
  lua_call(L,4,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(self, dtime) */
static int lcf158 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* default_on_step(self, dtime, 5, 20, {x=1, y=0, z=1}, 1, nil, 25) */
  lc_getupvalue(L,lua_upvalueindex(1),0,7);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,5);
  lua_pushnumber(L,20);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushnumber(L,1);
  lua_pushnil(L);
  lua_pushnumber(L,25);
  lua_call(L,8,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function(self, pos, node) */
static int lcf159 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  return 0;
}


/* function(self, dtime) */
static int lcf160 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* search_on_step(self, dtime, 5, 30, 25) */
  lc_getupvalue(L,lua_upvalueindex(1),1,6);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,5);
  lua_pushnumber(L,30);
  lua_pushnumber(L,25);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function(self, pos, node) */
static int lcf161 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* nssm:explosion(pos, 4, 0) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"explosion");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_call(L,4,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(self, dtime) */
static int lcf162 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* search_on_step2(self, dtime, 30, 30, 25) */
  lc_getupvalue(L,lua_upvalueindex(1),2,5);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,30);
  lua_pushnumber(L,30);
  lua_pushnumber(L,25);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function(self, pos, node) */
static int lcf163 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* nssm:explosion(pos, 4, 0) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"explosion");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_call(L,4,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(itemstack, user, pointed_thing) */
static int lcf164 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local pos = user:getpos() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* activate_balls(pos) */
  lc_getupvalue(L,lua_upvalueindex(1),3,4);
  lua_pushvalue(L,4);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* --Parameters used by some weapons
   * local default_dir = {
   *     x = 1,
   *     y = 1,
   *     z = 1,
   * } */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* --Function used to shoot:
   * local function weapons_shot(itemstack, placer, pointed_thing, velocity, name)
   *     local dir = placer:get_look_dir();
   *     local playerpos = placer:getpos();
   *     local obj = minetest.env:add_entity({x=playerpos.x+0+dir.x,y=playerpos.y+2+dir.y,z=playerpos.z+0+dir.z}, "nssm:"..name)
   *     local vec = {x=dir.x*velocity,y=dir.y*velocity,z=dir.z*velocity}
   *     obj:setvelocity(vec)
   *     return itemstack
   * end */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_pushcfunction(L,lcf1_weapons_shot);
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local function hit(pos, self)
   *     local node = nssm:node_ok(pos).name
   *     self.hit_node(self, pos, node)
   *     self.object:remove()
   *     return
   * end */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc3 = 3 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lua_pushcfunction(L,lcf1_hit);
  lua_rawseti(L,(lc3 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local function activate_balls(pos)
   *     local radius = 50
   *     local objects = minetest.env:get_objects_inside_radius(pos, radius)
   *     for _,obj in ipairs(objects) do
   *         if (obj:get_luaentity() and obj:get_luaentity().name == "nssm:hellzone_grenade") then
   *             obj:get_luaentity().move = 1
   *         end
   *     end
   * end */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 4 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_pushcfunction(L,lcf1_activate_balls);
  lua_rawseti(L,(lc4 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local function search_on_step2(
   *     self,
   *     dtime,      --used to count time
   *     max_time,   --after this amount of time the entity is removec
   *     radius,     --radius in which look for entities to follow
   *     vel)        --velocity of the projectile
   * 
   *     local pos = self.object:getpos()
   * 
   *     --Disappear after a certain time
   *     if self.life_time == 0 then
   *         self.life_time = os.time()
   *     end
   *     if os.time() - self.life_time > max_time then
   *         self.object:remove()
   *         return
   *     end
   * 
   *     --Look for an entity to follow
   *     local objects = minetest.env:get_objects_inside_radius(pos, radius)
   *     local min_dist = 100
   *     local obj_min = nil
   *     local obj_p = nil
   *     local vec_min = nil
   *     for _,obj in ipairs(objects) do
   *         if (obj:is_player()) then
   *         elseif (obj:get_luaentity() and obj:get_luaentity().name ~= "__builtin:item" and obj:get_luaentity().name ~= self.object:get_luaentity().name) then
   *             obj_p = obj:getpos()
   *             local vec = {x=obj_p.x-pos.x, y=obj_p.y-pos.y, z=obj_p.z-pos.z}
   *             local dist = (vec.x^2+vec.y^2+vec.z^2)^0.5
   *             if (dist<min_dist) then
   *                 min_dist = dist
   *                 obj_min = obj
   *                 vec_min = vec
   *             end
   *         end
   *     end
   * 
   *     --Found an entity to follow:
   *     if obj_min ~= nil then
   *         local new_vel = {x=0, y=0, z=0}
   * 
   *         local dir = 0
   *         local max_diff = 0
   * 
   *         if (max_diff<math.abs(vec_min.x)) then
   *             dir = 1
   *             max_diff = math.abs(vec_min.x)
   *         end
   *         if (max_diff<math.abs(vec_min.y)) then
   *             dir = 2
   *             max_diff = math.abs(vec_min.y)
   *         end
   *         if (max_diff<math.abs(vec_min.z)) then
   *             dir = 3
   *             max_diff = math.abs(vec_min.z)
   *         end
   * 
   *         vec_min.x = (vec_min.x/max_diff)*vel
   *         vec_min.y = (vec_min.y/max_diff)*vel
   *         vec_min.z = (vec_min.z/max_diff)*vel
   *         obj_p = obj_min:getpos()
   *         if min_dist <=8 and self.move==0 then
   *             self.object:setvelocity({x=0, y=0, z=0})
   * 
   *             --hit(pos,self)
   *         elseif min_dist<=1 and self.move==1 then
   *             hit(pos,self)
   *         else
   *             self.object:setvelocity(vec_min)
   *         end
   *     end
   * 
   *     local n = minetest.env:get_node(pos).name
   *     if n ~= "air" and n ~= "default:water_source" and n ~= "default:water_flowing" then
   *         hit(pos,self)
   *     end
   * end */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc9 = 5 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_pushvalue(L,(lc9 + lc_nextra));
  lua_pushcclosure(L,lcf1_search_on_step2,1);
  lua_rawseti(L,(lc9 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* --on_step function able to follow the mobs
   * local function search_on_step(
   *     self,
   *     dtime,      --used to count time
   *     max_time,   --after this amount of time the entity is removec
   *     radius,     --radius in which look for entities to follow
   *     vel)        --velocity of the projectile
   * 
   * 
   *     local pos = self.object:getpos()
   * 
   *     --Disappear after a certain time
   *     if self.life_time == 0 then
   *         self.life_time = os.time()
   *     end
   *     if os.time() - self.life_time > max_time then
   *         self.object:remove()
   *         return
   *     end
   * 
   * 
   *     --Look for an entity to follow
   *     local objects = minetest.env:get_objects_inside_radius(pos, radius)
   *     local min_dist = 100
   *     local obj_min = nil
   *     local obj_p = nil
   *     local vec_min = nil
   *     for _,obj in ipairs(objects) do
   *         if (obj:is_player()) then
   *         elseif (obj:get_luaentity() and obj:get_luaentity().name ~= "__builtin:item" and obj:get_luaentity().name ~= self.object:get_luaentity().name) then
   *             obj_p = obj:getpos()
   *             local vec = {x=obj_p.x-pos.x, y=obj_p.y-pos.y, z=obj_p.z-pos.z}
   *             local dist = (vec.x^2+vec.y^2+vec.z^2)^0.5
   *             if (dist<min_dist) then
   *                 min_dist = dist
   *                 obj_min = obj
   *                 vec_min = vec
   *             end
   *         end
   *     end
   * 
   *     --Found an entity to follow:
   *     if obj_min ~= nil then
   *         local new_vel = {x=0, y=0, z=0}
   * 
   *         local dir = 0
   *         local max_diff = 0
   * 
   *         if (max_diff<math.abs(vec_min.x)) then
   *             dir = 1
   *             max_diff = math.abs(vec_min.x)
   *         end
   *         if (max_diff<math.abs(vec_min.y)) then
   *             dir = 2
   *             max_diff = math.abs(vec_min.y)
   *         end
   *         if (max_diff<math.abs(vec_min.z)) then
   *             dir = 3
   *             max_diff = math.abs(vec_min.z)
   *         end
   * 
   *         vec_min.x = (vec_min.x/max_diff)*vel
   *         vec_min.y = (vec_min.y/max_diff)*vel
   *         vec_min.z = (vec_min.z/max_diff)*vel
   *         obj_p = obj_min:getpos()
   *         if min_dist < 1 then
   *             local node = nssm:node_ok(pos).name
   *             self.hit_node(self, pos, node)
   *             self.object:remove()
   *             return
   *         else
   *             self.object:setvelocity(vec_min)
   *         end
   *     end
   *     local n = minetest.env:get_node(pos).name
   *     if n ~= "air" and n ~= "default:water_source" and n ~= "default:water_flowing" then
   *         local node = nssm:node_ok(pos).name
   *         self.hit_node(self, pos, node)
   *         self.object:remove()
   *         return
   *     end
   * end */
  lc_newclosuretable(L,(lc9 + lc_nextra));
  enum { lc51 = 6 };
  assert((lua_gettop(L) == (lc51 + lc_nextra)));
  lua_pushcfunction(L,lcf1_search_on_step);
  lua_rawseti(L,(lc51 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local function default_on_step(
   *     self,
   *     dtime,              --used to count time
   *     max_time,           --after this amount of time the entity is removec
   *     damage,             --damage dealt to the entity around
   *     dir,                --vector to specify directions in which remove blocks
   *     radius,             --radius of blocks removed aroind the projectile
   *     not_transparent,    --name of a block or of a group: when the projectile hit one of these blocks the function hit_node is called
   *     vel)                --velocity of the projectile
   * 
   * 
   *     local pos = self.object:getpos()
   * 
   *     if self.life_time == 0 then
   *         self.life_time = os.time()
   *     end
   * 
   * 
   *     if os.time() - self.life_time > max_time then
   *         local node = nssm:node_ok(pos).name
   *         self.hit_node(self, pos, node)
   *         self.object:remove()
   *         return
   *     end
   * 
   *     self.timer = self.timer + dtime
   * 
   *     --while going around it damages entities
   *     local objects = minetest.env:get_objects_inside_radius(pos, 2)
   *     if self.timer > 0.3 then
   *         for _,obj in ipairs(objects) do
   *             obj:set_hp(obj:get_hp()-damage)
   *             if (obj:get_hp() <= 0) then
   *                 if (not obj:is_player()) and obj:get_entity_name() ~= self.object:get_luaentity().name then
   *                     obj:remove()
   *                 end
   *             end
   *         end
   *     end
   * 
   *     local n = minetest.env:get_node(pos).name
   *     if n==not_transparent or minetest.get_item_group(n, not_transparent)==1 then
   *         local node = nssm:node_ok(pos).name
   *         self.hit_node(self, pos, node)
   *         self.object:remove()
   *         return
   *     else
   *         local vec = self.object:getvelocity()
   *         local c=vel/10
   *         --calculate how many blocks around need to be removed
   *         local max = 0
   *         local posmax = 0
   *         if max<math.abs(vec.x) then
   *             max = math.abs(vec.x)
   *             posmax = 1
   *         end
   *         if max<math.abs(vec.y) then
   *             max = math.abs(vec.y)
   *             posmax = 2
   *         end
   *         if max<math.abs(vec.z) then
   *             max = math.abs(vec.z)
   *             posmax = 3
   *         end
   * 
   *         local i = radius
   *         local j = radius
   *         local k = radius
   * 
   *         if dir.x == 0 then
   *             i = 0
   *         end
   *         if dir.y == 0 then
   *             j = 0
   *         end
   *         if dir.z == 0 then
   *             k = 0
   *         end
   * 
   *         if posmax==1 then
   *             i = 0
   *         end
   * 
   *         if posmax==2 then
   *             j = 0
   *         end
   * 
   *         if posmax==3 then
   *             k = 0
   *         end
   * 
   *         for dx = -i,i do
   *             for dy= -j,j do
   *                 for dz = -k,k do
   *                     local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz}
   *                     if not minetest.is_protected(p, "") or not minetest.get_item_group(n, "unbreakable") == 1 then
   *                         minetest.env:remove_node(p)
   *                     end
   *                 end
   *             end
   *         end
   *     end
   * end */
  lc_newclosuretable(L,(lc51 + lc_nextra));
  enum { lc88 = 7 };
  assert((lua_gettop(L) == (lc88 + lc_nextra)));
  lua_pushcfunction(L,lcf1_default_on_step);
  lua_rawseti(L,(lc88 + lc_nextra),7);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* --[[
   * Function to register new weapons: parameters:
   *     - name of the weapon
   *     - on_step function (written by you or taken from the standard one above)
   *     - hit_node function
   *     - description of the weapon
   *     - the velocity of the projectile
   *     - one material to be used in the receipt
   * ]]
   * local function nssm_register_weapon(name, def)
   *     minetest.register_entity("nssm:"..name, {
   *         textures = {name..".png"},
   *         on_step = function(self, dtime)
   *             def.on_step(self, dtime)
   *         end,
   *         hit_node = function(self, pos, node)
   *             def.hit_node(self, pos, node)
   *         end,
   *         move = def.move,
   *         life_time = 0,
   *         timer = 0
   *     })
   * 
   *     minetest.register_tool("nssm:"..name.."_hand", {
   *         description = def.description,
   *         inventory_image = name.."_hand.png",
   *         on_use = function(itemstack, placer, pointed_thing)
   *             weapons_shot(itemstack, placer, pointed_thing, def.velocity, name)
   *             return itemstack
   *         end,
   *         on_drop = def.on_drop or function(itemstack, user, pointed_thing)
   * 		end,
   *     })
   * 
   *     minetest.register_craft({
   * 		output = 'nssm:'..name.."_hand",
   * 		recipe = {
   * 			{'nssm:great_energy_globe', 'nssm:great_energy_globe', 'nssm:great_energy_globe'},
   *             {'nssm:great_energy_globe', def.material, 'nssm:great_energy_globe'},
   *             {'nssm:great_energy_globe', 'nssm:great_energy_globe', 'nssm:great_energy_globe'}
   * 		}
   * 	})
   * 
   * end */
  lua_pushvalue(L,(lc88 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_register_weapon,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* --Registered weapons:
   * nssm_register_weapon("kamehameha", {
   *     velocity = 25,
   *     on_step = function(self, dtime)
   *         default_on_step(self, dtime, 4, 20, default_dir, 1, "stone", 25)
   *     end,
   *     hit_node = function(self, pos, node)
   *         nssm:explosion(pos, 6, 1)
   *     end,
   *     material = "default:diamondblock",
   *     description = "Kamehameha from DragonBall",
   * 
   * }) */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"kamehameha");
  lua_createtable(L,0,5);
  lua_pushliteral(L,"velocity");
  lua_pushnumber(L,25);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushvalue(L,(lc88 + lc_nextra));
  lua_pushcclosure(L,lcf156,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_node");
  lua_pushcfunction(L,lcf157);
  lua_rawset(L,-3);
  lua_pushliteral(L,"material");
  lua_pushliteral(L,"default:diamondblock");
  lua_rawset(L,-3);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Kamehameha from DragonBall");
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* nssm_register_weapon("kienzan", {
   *     velocity = 25,
   *     on_step = function(self, dtime)
   *         default_on_step(self, dtime, 5, 20, {x=1, y=0, z=1}, 1, nil, 25)
   *     end,
   *     hit_node = function(self, pos, node)
   *     end,
   *     material = "nssm:king_duck_crown",
   *     description = "Kienzan from DragonBall",
   * }) */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"kienzan");
  lua_createtable(L,0,5);
  lua_pushliteral(L,"velocity");
  lua_pushnumber(L,25);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushvalue(L,(lc88 + lc_nextra));
  lua_pushcclosure(L,lcf158,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_node");
  lua_pushcfunction(L,lcf159);
  lua_rawset(L,-3);
  lua_pushliteral(L,"material");
  lua_pushliteral(L,"nssm:king_duck_crown");
  lua_rawset(L,-3);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Kienzan from DragonBall");
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* nssm_register_weapon("spirit_ball", {
   *     velocity = 25,
   *     move = 0,
   *     on_step = function(self, dtime)
   *         search_on_step(self, dtime, 5, 30, 25)
   *     end,
   *     hit_node = function(self, pos, node)
   *         nssm:explosion(pos, 4, 0)
   *     end,
   * 
   *     material = "nssm:cursed_pumpkin_seed",
   *     description = "Spirit Ball from DragonBall",
   * }) */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"spirit_ball");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"velocity");
  lua_pushnumber(L,25);
  lua_rawset(L,-3);
  lua_pushliteral(L,"move");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushvalue(L,(lc88 + lc_nextra));
  lua_pushcclosure(L,lcf160,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_node");
  lua_pushcfunction(L,lcf161);
  lua_rawset(L,-3);
  lua_pushliteral(L,"material");
  lua_pushliteral(L,"nssm:cursed_pumpkin_seed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Spirit Ball from DragonBall");
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* nssm_register_weapon("hellzone_grenade", {
   *     velocity = 25,
   *     move = 0,
   *     on_step = function(self, dtime)
   *         search_on_step2(self, dtime, 30, 30, 25)
   *     end,
   *     hit_node = function(self, pos, node)
   *         nssm:explosion(pos, 4, 0)
   *     end,
   * 
   *     on_drop = function(itemstack, user, pointed_thing)
   *         local pos = user:getpos()
   *         activate_balls(pos)
   *     end,
   *     material = "nssm:snake_scute",
   *     description = "Hellzone grenade (Press q to activate)",
   * }) */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"hellzone_grenade");
  lua_createtable(L,0,7);
  lua_pushliteral(L,"velocity");
  lua_pushnumber(L,25);
  lua_rawset(L,-3);
  lua_pushliteral(L,"move");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushvalue(L,(lc88 + lc_nextra));
  lua_pushcclosure(L,lcf162,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_node");
  lua_pushcfunction(L,lcf163);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_drop");
  lua_pushvalue(L,(lc88 + lc_nextra));
  lua_pushcclosure(L,lcf164,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"material");
  lua_pushliteral(L,"nssm:snake_scute");
  lua_rawset(L,-3);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Hellzone grenade (Press q to activate)");
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 8);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_nssm_nssm_weapons(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


