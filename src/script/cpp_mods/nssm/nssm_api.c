/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* name: nssm:node_ok
 * function(pos, fallback) */
static int lcf1_nssm_node_ok (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* fallback = fallback or "default:dirt" */
  lua_pushvalue(L,3);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:dirt");
  }
  lua_replace(L,3);
  assert(lua_gettop(L) == 3);
  
  /* local node = minetest.get_node_or_nil(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_or_nil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* if not node then */
  enum { lc6 = 4 };
  lua_pushboolean(L,!(lua_toboolean(L,4)));
  const int lc7 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc7) {
    
    /* return minetest.registered_nodes[fallback] */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 4);
  
  /* if minetest.registered_nodes[node.name] then */
  enum { lc8 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc9 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc9) {
    
    /* return node */
    lua_pushvalue(L,4);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc8);
  assert(lua_gettop(L) == 4);
  
  /* return minetest.registered_nodes[fallback] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: nssm:check_for_death_hydra
 * function(self) */
static int lcf1_nssm_check_for_death_hydra (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local hp = self.object:get_hp() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"get_hp");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if hp > 0 then */
  enum { lc10 = 3 };
  lua_pushnumber(L,0);
  const int lc11 = lua_lessthan(L,-1,3);
  lua_pop(L,1);
  lua_pushboolean(L,lc11);
  const int lc12 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc12) {
    
    /* self.health = hp */
    lua_pushvalue(L,3);
    lua_pushliteral(L,"health");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 3);
    
    /* if self.sounds.damage ~= nil then */
    enum { lc13 = 3 };
    lua_pushliteral(L,"sounds");
    lua_gettable(L,2);
    lua_pushliteral(L,"damage");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnil(L);
    const int lc14 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc14);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc15 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc15) {
      
      /* minetest.sound_play(self.sounds.damage,{
       * 				object = self.object,
       * 				max_hear_distance = self.sounds.distance
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"sound_play");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"sounds");
      lua_gettable(L,2);
      lua_pushliteral(L,"damage");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"object");
      lua_pushliteral(L,"object");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"max_hear_distance");
      lua_pushliteral(L,"sounds");
      lua_gettable(L,2);
      lua_pushliteral(L,"distance");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc13);
    assert(lua_gettop(L) == 3);
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 3);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* local obj = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 5);
  
  /* if self.sounds.death ~= nil then */
  enum { lc16 = 5 };
  lua_pushliteral(L,"sounds");
  lua_gettable(L,2);
  lua_pushliteral(L,"death");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc17 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc17);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc18 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc18) {
    
    /* minetest.sound_play(self.sounds.death,{
     * 			object = self.object,
     * 			max_hear_distance = self.sounds.distance
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"sound_play");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sounds");
    lua_gettable(L,2);
    lua_pushliteral(L,"death");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"object");
    lua_pushliteral(L,"object");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_hear_distance");
    lua_pushliteral(L,"sounds");
    lua_gettable(L,2);
    lua_pushliteral(L,"distance");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc16);
  assert(lua_gettop(L) == 5);
  
  /* self.object:remove() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"remove");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 5);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


#include <math.h>

/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: nssm:round
 * function(n) */
static int lcf1_nssm_round (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if (n>0) then */
  enum { lc19 = 2 };
  lua_pushnumber(L,0);
  const int lc20 = lua_lessthan(L,-1,2);
  lua_pop(L,1);
  lua_pushboolean(L,lc20);
  const int lc21 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc21) {
    
    /* return n % 1 >= 0.5 and math.ceil(n) or math.floor(n) */
    lua_pushnumber(L,0.5);
    lua_pushnumber(L,1);
    lc_mod(L,2,-1);
    lua_remove(L,-2);
    const int lc22 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc22);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"ceil");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,1);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"floor");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,1);
    }
    return 1;
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* else
     * n=-n */
    lc_unm(L,2);
    lua_replace(L,2);
    assert(lua_gettop(L) == 2);
    
    /* local t = n % 1 >= 0.5 and math.ceil(n) or math.floor(n) */
    lua_pushnumber(L,0.5);
    lua_pushnumber(L,1);
    lc_mod(L,2,-1);
    lua_remove(L,-2);
    const int lc23 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc23);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"ceil");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,1);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"floor");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,1);
    }
    assert(lua_gettop(L) == 3);
    
    /* return -t */
    lc_unm(L,3);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc19);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: nssm:explosion_particles
 * function(pos, exp_radius) */
static int lcf1_nssm_explosion_particles (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* minetest.add_particlespawner(
   *         100*exp_radius/2, --amount
   *         0.1, --time
   *         {x=pos.x-exp_radius, y=pos.y-exp_radius, z=pos.z-exp_radius}, --minpos
   *         {x=pos.x+exp_radius, y=pos.y+exp_radius, z=pos.z+exp_radius}, --maxpos
   *         {x=0, y=0, z=0}, --minvel
   *         {x=0.1, y=0.3, z=0.1}, --maxvel
   *         {x=-0.5,y=1,z=-0.5}, --minacc
   *         {x=0.5,y=1,z=0.5}, --maxacc
   *         0.1, --minexptime
   *         4, --maxexptime
   *         6, --minsize
   *         12, --maxsize
   *         false, --collisiondetection
   *         "tnt_smoke.png" --texture
   *     ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"add_particlespawner");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,100);
  lc_mul(L,-1,3);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.1);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_sub(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lc_sub(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_sub(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_add(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lc_add(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_add(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,0.1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,0.3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,0.1);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,-0.5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,-0.5);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_pushnumber(L,0.1);
  lua_pushnumber(L,4);
  lua_pushnumber(L,6);
  lua_pushnumber(L,12);
  lua_pushboolean(L,0);
  lua_pushliteral(L,"tnt_smoke.png");
  lua_call(L,14,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* __pow metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_pow(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,pow(lua_tonumber(L,idxa),lua_tonumber(L,idxb)));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__pow")||luaL_getmetafield(L,idxb,"__pow")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: nssm:explosion
 * function(pos, exp_radius, fire) */
static int lcf1_nssm_explosion (lua_State * L) {
  lua_checkstack(L,35);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local radius = exp_radius */
  lua_pushvalue(L,3);
  assert(lua_gettop(L) == 5);
  
  /* -- if area protected or near map limits then no blast damage
   * if minetest.is_protected(pos, "")
   * 	or not within_limits(pos, radius) then */
  enum { lc25 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"is_protected");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"");
  lua_call(L,2,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"within_limits");
    lua_pushvalue(L,2);
    lua_pushvalue(L,5);
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc26 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc26) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc25);
  assert(lua_gettop(L) == 5);
  
  /* --sound
   * minetest.sound_play("boom", {
   *         pos = pos,
   *         max_hear_distance = exp_radius*4,
   *     }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"sound_play");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"boom");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"pos");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"max_hear_distance");
  lua_pushnumber(L,4);
  lc_mul(L,3,-1);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 5);
  
  /* --particles:
   * nssm:explosion_particles(pos, exp_radius) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"explosion_particles");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 5);
  
  /* --Damages entities around (not the player)
   * local objects = minetest.env:get_objects_inside_radius(pos, exp_radius) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 6);
  
  /* for _,obj in ipairs(objects) do
   * internal: local f, s, var = explist */
  enum { lc27 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,6);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 10
     * internal: local obj with idx 11 */
    
    
    /* local obj_p = obj:getpos() */
    lua_pushvalue(L,11);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* local vec = {x=obj_p.x-pos.x, y=obj_p.y-pos.y, z=obj_p.z-pos.z} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,12);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,12);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,12);
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 13);
    
    /* local dist = (vec.x^2+vec.y^2+vec.z^2)^0.5 */
    lua_pushliteral(L,"x");
    lua_gettable(L,13);
    lua_pushnumber(L,2);
    lc_pow(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,13);
    lua_pushnumber(L,2);
    lc_pow(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,13);
    lua_pushnumber(L,2);
    lc_pow(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,0.5);
    lc_pow(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 14);
    
    /* local damage = (-exp_radius*dist+exp_radius^2)*2 */
    lc_unm(L,3);
    lc_mul(L,-1,14);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_pow(L,3,-1);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 15);
    
    /* obj:set_hp(obj:get_hp()-damage) */
    lua_pushvalue(L,11);
    lua_pushliteral(L,"set_hp");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"get_hp");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lc_sub(L,-1,15);
    lua_remove(L,-2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 15);
    
    /* if (obj:get_hp() <= 0) then */
    enum { lc28 = 15 };
    lua_pushvalue(L,11);
    lua_pushliteral(L,"get_hp");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushnumber(L,0);
    const int lc29 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc29);
    const int lc30 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc30) {
      
      /* if (not obj:is_player()) then */
      enum { lc31 = 15 };
      lua_pushvalue(L,11);
      lua_pushliteral(L,"is_player");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc32 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc32) {
        
        /* obj:remove() */
        lua_pushvalue(L,11);
        lua_pushliteral(L,"remove");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc31);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc28);
    assert(lua_gettop(L) == 15);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,6);
  }
  lua_settop(L,lc27);
  assert(lua_gettop(L) == 6);
  
  /* --damages blocks around and if necessary put some fire
   * pos = vector.round(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"vector");
  lua_pushliteral(L,"round");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_replace(L,2);
  assert(lua_gettop(L) == 6);
  
  /* -- voxelmanip doesn't work properly unless pos is rounded ?!?!
   * local vm = VoxelManip() */
  lua_getfield(L,LUA_ENVIRONINDEX,"VoxelManip");
  lua_call(L,0,1);
  assert(lua_gettop(L) == 7);
  
  /* local minp, maxp = vm:read_from_map(vector.subtract(pos, radius), vector.add(pos, radius)) */
  lua_pushvalue(L,7);
  const int lc33 = lua_gettop(L);
  lua_pushliteral(L,"read_from_map");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"vector");
  lua_pushliteral(L,"subtract");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,5);
  lua_call(L,2,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"vector");
  lua_pushliteral(L,"add");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,5);
  lua_call(L,2,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc33),2);
  assert(lua_gettop(L) == 9);
  
  /* local a = VoxelArea:new({MinEdge = minp, MaxEdge = maxp}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"VoxelArea");
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"MinEdge");
  lua_pushvalue(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"MaxEdge");
  lua_pushvalue(L,9);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 10);
  
  /* local data = vm:get_data(dbuf) */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get_data");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,6);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 11);
  
  /* -- buffer added by MrCerealGuy
   * local p = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 12);
  
  /* local pr = PseudoRandom(os.time()) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc34 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"os");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc34),1);
  assert(lua_gettop(L) == 13);
  
  /* --remove everything near the center of the explosion
   * for dz=-radius,radius do */
  lc_unm(L,5);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,5)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc35_var = lua_tonumber(L,-1);
  const double lc36_limit = lua_tonumber(L,5);
  const double lc37_step = 1;
  lua_pop(L,1);
  enum { lc38 = 13 };
  while ((((lc37_step > 0) && (lc35_var <= lc36_limit)) || ((lc37_step <= 0) && (lc35_var >= lc36_limit)))) {
    
    /* internal: local dz at index 14 */
    lua_pushnumber(L,lc35_var);
    
    /* for dy=-radius,radius do */
    lc_unm(L,5);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,5)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc39_var = lua_tonumber(L,-1);
    const double lc40_limit = lua_tonumber(L,5);
    const double lc41_step = 1;
    lua_pop(L,1);
    enum { lc42 = 14 };
    while ((((lc41_step > 0) && (lc39_var <= lc40_limit)) || ((lc41_step <= 0) && (lc39_var >= lc40_limit)))) {
      
      /* internal: local dy at index 15 */
      lua_pushnumber(L,lc39_var);
      
      /* local vi = a:index(pos.x + (-radius), pos.y + dy, pos.z + dz) */
      lua_pushvalue(L,10);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,2);
      lc_unm(L,5);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,2);
      lc_add(L,-1,15);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,2);
      lc_add(L,-1,14);
      lua_remove(L,-2);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 16);
      
      /* for dx=-radius,radius do */
      lc_unm(L,5);
      if (!((lua_isnumber(L,-1) && lua_isnumber(L,5)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc43_var = lua_tonumber(L,-1);
      const double lc44_limit = lua_tonumber(L,5);
      const double lc45_step = 1;
      lua_pop(L,1);
      enum { lc46 = 16 };
      while ((((lc45_step > 0) && (lc43_var <= lc44_limit)) || ((lc45_step <= 0) && (lc43_var >= lc44_limit)))) {
        
        /* internal: local dx at index 17 */
        lua_pushnumber(L,lc43_var);
        
        /* local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,2);
        lc_add(L,-1,17);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,2);
        lc_add(L,-1,15);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,2);
        lc_add(L,-1,14);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 18);
        
        /* if (dx * dx) + (dy * dy) + (dz * dz) <= (radius * radius) + pr:next(-radius, radius)
         *         		and data[vi] ~= c_air
         *         		and data[vi] ~= c_ignore
         *         		and data[vi] ~= c_obsidian
         *         		and data[vi] ~= c_brick
         *         		and data[vi] ~= c_chest then */
        enum { lc47 = 18 };
        lc_mul(L,17,17);
        lc_mul(L,15,15);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_mul(L,14,14);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_mul(L,5,5);
        lua_pushvalue(L,13);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lc_unm(L,5);
        lua_pushvalue(L,5);
        lua_call(L,3,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc48 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc48);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),5,1);
          const int lc49 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc49);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),4,2);
          const int lc50 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc50);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),3,3);
          const int lc51 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc51);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),2,4);
          const int lc52 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc52);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),1,5);
          const int lc53 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc53);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc54 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc54) {
          
          /* local n = nssm:node_ok(p).name */
          lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
          lua_pushliteral(L,"node_ok");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,18);
          lua_call(L,2,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 19);
          
          /* local on_blast = minetest.registered_nodes[n].on_blast */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,19);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"on_blast");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 20);
          
          /* if on_blast then */
          enum { lc55 = 20 };
          if (lua_toboolean(L,20)) {
            
            /* return on_blast(p) */
            const int lc56 = lua_gettop(L);
            lua_pushvalue(L,20);
            lua_pushvalue(L,18);
            lua_call(L,1,LUA_MULTRET);
            return (lua_gettop(L) - lc56);
            assert(lua_gettop(L) == 20);
          }
          lua_settop(L,lc55);
          assert(lua_gettop(L) == 20);
          
          /* if minetest.get_item_group(n, "unbreakable") ~= 1 then */
          enum { lc57 = 20 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_item_group");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,19);
          lua_pushliteral(L,"unbreakable");
          lua_call(L,2,1);
          lua_pushnumber(L,1);
          const int lc58 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc58);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc59 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc59) {
            
            /* -- if chest then drop items inside
             * if n == "default:chest"
             *         				or n == "3dchest:chest"
             *         				or n == "bones:bones" then */
            enum { lc60 = 20 };
            lua_pushvalue(L,19);
            lua_pushliteral(L,"default:chest");
            const int lc61 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc61);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,19);
              lua_pushliteral(L,"3dchest:chest");
              const int lc62 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc62);
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,19);
              lua_pushliteral(L,"bones:bones");
              const int lc63 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc63);
            }
            const int lc64 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc64) {
              
              /* local meta = minetest.get_meta(p) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"get_meta");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,18);
              lua_call(L,1,1);
              assert(lua_gettop(L) == 21);
              
              /* local inv  = meta:get_inventory() */
              lua_pushvalue(L,21);
              lua_pushliteral(L,"get_inventory");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_call(L,1,1);
              assert(lua_gettop(L) == 22);
              
              /* for i = 1, inv:get_size("main") do */
              lua_pushnumber(L,1);
              lua_pushvalue(L,22);
              lua_pushliteral(L,"get_size");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushliteral(L,"main");
              lua_call(L,2,1);
              if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
                luaL_error(L,"'for' limit must be a number");
              }
              double lc65_var = lua_tonumber(L,-2);
              const double lc66_limit = lua_tonumber(L,-1);
              const double lc67_step = 1;
              lua_pop(L,2);
              enum { lc68 = 22 };
              while ((((lc67_step > 0) && (lc65_var <= lc66_limit)) || ((lc67_step <= 0) && (lc65_var >= lc66_limit)))) {
                
                /* internal: local i at index 23 */
                lua_pushnumber(L,lc65_var);
                
                /* local m_stack = inv:get_stack("main", i) */
                lua_pushvalue(L,22);
                lua_pushliteral(L,"get_stack");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushliteral(L,"main");
                lua_pushvalue(L,23);
                lua_call(L,3,1);
                assert(lua_gettop(L) == 24);
                
                /* local obj = minetest.add_item(p, m_stack) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"add_item");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,18);
                lua_pushvalue(L,24);
                lua_call(L,2,1);
                assert(lua_gettop(L) == 25);
                
                /* if obj then */
                enum { lc69 = 25 };
                if (lua_toboolean(L,25)) {
                  
                  /* obj:setvelocity({
                   *         								x = math.random(-2, 2),
                   *         								y = 7,
                   *         								z = math.random(-2, 2)
                   *         							}) */
                  lua_pushvalue(L,25);
                  lua_pushliteral(L,"setvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_createtable(L,0,3);
                  lua_pushliteral(L,"x");
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,-2);
                  lua_pushnumber(L,2);
                  lua_call(L,2,1);
                  lua_rawset(L,-3);
                  lua_pushliteral(L,"y");
                  lua_pushnumber(L,7);
                  lua_rawset(L,-3);
                  lua_pushliteral(L,"z");
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,-2);
                  lua_pushnumber(L,2);
                  lua_call(L,2,1);
                  lua_rawset(L,-3);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 25);
                }
                lua_settop(L,lc69);
                assert(lua_gettop(L) == 25);
                
                /* internal: stack cleanup on scope exit */
                lua_pop(L,3);
                lc65_var += lc67_step;
              }
              lua_settop(L,lc68);
              assert(lua_gettop(L) == 22);
            }
            lua_settop(L,lc60);
            assert(lua_gettop(L) == 20);
            
            /* -- after effects
             * if fire > 0
             *         				and (minetest.registered_nodes[n].groups.flammable
             *         				or math.random(1, 100) <= 3) then */
            enum { lc70 = 20 };
            lua_pushnumber(L,0);
            const int lc71 = lua_lessthan(L,-1,4);
            lua_pop(L,1);
            lua_pushboolean(L,lc71);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"registered_nodes");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,19);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"groups");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"flammable");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"random");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,1);
                lua_pushnumber(L,100);
                lua_call(L,2,1);
                lua_pushnumber(L,3);
                const int lc72 = lc_le(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc72);
              }
            }
            const int lc73 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc73) {
              
              /* minetest.set_node(p, {name = "fire:basic_flame"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,18);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"fire:basic_flame");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 20);
            }
            else {
              
              /* else
               * local dist = nssm:round(((pos.x-p.x)^2 + (pos.y-p.y)^2 + (pos.z-p.z)^2)^1/2) */
              lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
              lua_pushliteral(L,"round");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushliteral(L,"x");
              lua_gettable(L,2);
              lua_pushliteral(L,"x");
              lua_gettable(L,18);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,2);
              lc_pow(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"y");
              lua_gettable(L,2);
              lua_pushliteral(L,"y");
              lua_gettable(L,18);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,2);
              lc_pow(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lc_add(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"z");
              lua_gettable(L,2);
              lua_pushliteral(L,"z");
              lua_gettable(L,18);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,2);
              lc_pow(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lc_add(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,1);
              lc_pow(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,2);
              lc_div(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_call(L,2,1);
              assert(lua_gettop(L) == 21);
              
              /* local prob = 2/dist */
              lua_pushnumber(L,2);
              lc_div(L,-1,21);
              lua_remove(L,-2);
              assert(lua_gettop(L) == 22);
              
              /* if math.random(1,100)<=prob*100 then */
              enum { lc74 = 22 };
              lua_getfield(L,LUA_ENVIRONINDEX,"math");
              lua_pushliteral(L,"random");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,1);
              lua_pushnumber(L,100);
              lua_call(L,2,1);
              lua_pushnumber(L,100);
              lc_mul(L,22,-1);
              lua_remove(L,-2);
              const int lc75 = lc_le(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc75);
              const int lc76 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc76) {
                
                /* minetest.env:remove_node(p) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"env");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"remove_node");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,18);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 22);
              }
              lua_settop(L,lc74);
              assert(lua_gettop(L) == 22);
            }
            lua_settop(L,lc70);
            assert(lua_gettop(L) == 20);
          }
          lua_settop(L,lc57);
          assert(lua_gettop(L) == 20);
        }
        lua_settop(L,lc47);
        assert(lua_gettop(L) == 18);
        
        /* vi = vi+1 */
        lua_pushnumber(L,1);
        lc_add(L,16,-1);
        lua_remove(L,-2);
        lua_replace(L,16);
        assert(lua_gettop(L) == 18);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc43_var += lc45_step;
      }
      lua_settop(L,lc46);
      assert(lua_gettop(L) == 16);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc39_var += lc41_step;
    }
    lua_settop(L,lc42);
    assert(lua_gettop(L) == 14);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc35_var += lc37_step;
  }
  lua_settop(L,lc38);
  assert(lua_gettop(L) == 13);
  return 0;
}


/* name: nssm:digging_ability
 * function(
 * 	self,		--the entity of the mob
 * 	group,		--group of the blocks the mob can dig: nil=everything
 * 	max_vel,	--max velocity of the mob
 * 	dim) */
static int lcf1_nssm_digging_ability (lua_State * L) {
  lua_checkstack(L,32);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* local v = self.object:getvelocity() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* if minetest.is_protected(pos, "") then */
  enum { lc77 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"is_protected");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,7);
  lua_pushliteral(L,"");
  lua_call(L,2,1);
  const int lc78 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc78) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc77);
  assert(lua_gettop(L) == 7);
  
  /* local h = dim.y */
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  assert(lua_gettop(L) == 8);
  
  /* local max = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 9);
  
  /* --local posmax = 0 --			1 = x, -1=-x, 2 = z, -2 = -z
   * local yaw = (self.object:getyaw() + self.rotate) or 0 */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"rotate");
  lua_gettable(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  assert(lua_gettop(L) == 10);
  
  /* local x = math.sin(yaw)*-1 */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,10);
  lua_call(L,1,1);
  lua_pushnumber(L,-1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 11);
  
  /* local z = math.cos(yaw) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,10);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 12);
  
  /* local i = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 13);
  
  /* local i1 = -1 */
  lua_pushnumber(L,-1);
  assert(lua_gettop(L) == 14);
  
  /* local k = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 15);
  
  /* local k1 = -1 */
  lua_pushnumber(L,-1);
  assert(lua_gettop(L) == 16);
  
  /* local multiplier = 2 */
  lua_pushnumber(L,2);
  assert(lua_gettop(L) == 17);
  
  /* if x>0 then */
  enum { lc79 = 17 };
  lua_pushnumber(L,0);
  const int lc80 = lua_lessthan(L,-1,11);
  lua_pop(L,1);
  lua_pushboolean(L,lc80);
  const int lc81 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc81) {
    
    /* i = nssm:round(x*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,11,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 17);
  }
  else {
    
    /* else
     * i1 = nssm:round(x*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,11,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,14);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc79);
  assert(lua_gettop(L) == 17);
  
  /* if z>0 then */
  enum { lc82 = 17 };
  lua_pushnumber(L,0);
  const int lc83 = lua_lessthan(L,-1,12);
  lua_pop(L,1);
  lua_pushboolean(L,lc83);
  const int lc84 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc84) {
    
    /* k = nssm:round(z*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,12,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,15);
    assert(lua_gettop(L) == 17);
  }
  else {
    
    /* else
     * k1 = nssm:round(z*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,12,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,16);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc82);
  assert(lua_gettop(L) == 17);
  
  /* for dx = i1, i do */
  if (!((lua_isnumber(L,14) && lua_isnumber(L,13)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc85_var = lua_tonumber(L,14);
  const double lc86_limit = lua_tonumber(L,13);
  const double lc87_step = 1;
  lua_pop(L,0);
  enum { lc88 = 17 };
  while ((((lc87_step > 0) && (lc85_var <= lc86_limit)) || ((lc87_step <= 0) && (lc85_var >= lc86_limit)))) {
    
    /* internal: local dx at index 18 */
    lua_pushnumber(L,lc85_var);
    
    /* for dy = 0, h do */
    lua_pushnumber(L,0);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,8)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc89_var = lua_tonumber(L,-1);
    const double lc90_limit = lua_tonumber(L,8);
    const double lc91_step = 1;
    lua_pop(L,1);
    enum { lc92 = 18 };
    while ((((lc91_step > 0) && (lc89_var <= lc90_limit)) || ((lc91_step <= 0) && (lc89_var >= lc90_limit)))) {
      
      /* internal: local dy at index 19 */
      lua_pushnumber(L,lc89_var);
      
      /* for dz = k1, k do */
      if (!((lua_isnumber(L,16) && lua_isnumber(L,15)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc93_var = lua_tonumber(L,16);
      const double lc94_limit = lua_tonumber(L,15);
      const double lc95_step = 1;
      lua_pop(L,0);
      enum { lc96 = 19 };
      while ((((lc95_step > 0) && (lc93_var <= lc94_limit)) || ((lc95_step <= 0) && (lc93_var >= lc94_limit)))) {
        
        /* internal: local dz at index 20 */
        lua_pushnumber(L,lc93_var);
        
        /* local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lc_add(L,-1,18);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lc_add(L,-1,19);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_add(L,-1,20);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 21);
        
        /* local n = minetest.env:get_node(p).name */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"env");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,21);
        lua_call(L,2,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 22);
        
        /* --local up = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz}
         * if group == nil then */
        enum { lc97 = 22 };
        lua_pushnil(L);
        const int lc98 = lua_equal(L,3,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc98);
        const int lc99 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc99) {
          
          /* if minetest.get_item_group(n, "unbreakable") == 1 or minetest.is_protected(p, "") then */
          enum { lc100 = 22 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_item_group");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,22);
          lua_pushliteral(L,"unbreakable");
          lua_call(L,2,1);
          lua_pushnumber(L,1);
          const int lc101 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc101);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"is_protected");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,21);
            lua_pushliteral(L,"");
            lua_call(L,2,1);
          }
          const int lc102 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc102) {
          }
          else {
            
            /* else
             * minetest.env:set_node(p, {name="air"}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"env");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"set_node");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,21);
            lua_createtable(L,0,1);
            lua_pushliteral(L,"name");
            lua_pushliteral(L,"air");
            lua_rawset(L,-3);
            lua_call(L,3,0);
            assert(lua_gettop(L) == 22);
          }
          lua_settop(L,lc100);
          assert(lua_gettop(L) == 22);
        }
        else {
          
          /* else
           * if (minetest.get_item_group(n, group)==1) and (minetest.get_item_group(n, "unbreakable") ~= 1) and not (minetest.is_protected(p, "")) then */
          enum { lc103 = 22 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_item_group");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,22);
          lua_pushvalue(L,3);
          lua_call(L,2,1);
          lua_pushnumber(L,1);
          const int lc104 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc104);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"get_item_group");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,22);
            lua_pushliteral(L,"unbreakable");
            lua_call(L,2,1);
            lua_pushnumber(L,1);
            const int lc105 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc105);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"is_protected");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,21);
            lua_pushliteral(L,"");
            lua_call(L,2,1);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          const int lc106 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc106) {
            
            /* minetest.env:set_node(p, {name="air"}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"env");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"set_node");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,21);
            lua_createtable(L,0,1);
            lua_pushliteral(L,"name");
            lua_pushliteral(L,"air");
            lua_rawset(L,-3);
            lua_call(L,3,0);
            assert(lua_gettop(L) == 22);
          }
          lua_settop(L,lc103);
          assert(lua_gettop(L) == 22);
        }
        lua_settop(L,lc97);
        assert(lua_gettop(L) == 22);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,3);
        lc93_var += lc95_step;
      }
      lua_settop(L,lc96);
      assert(lua_gettop(L) == 19);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc89_var += lc91_step;
    }
    lua_settop(L,lc92);
    assert(lua_gettop(L) == 18);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc85_var += lc87_step;
  }
  lua_settop(L,lc88);
  assert(lua_gettop(L) == 17);
  return 0;
}


/* name: nssm:putting_ability
 * function(		--puts under the mob the block defined as 'p_block'
 * 	self,		--the entity of the mob
 * 	p_block, 	--definition of the block to use
 * 	max_vel) */
static int lcf1_nssm_putting_ability (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local v = self.object:getvelocity() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* local dx = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 6);
  
  /* local dz = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 7);
  
  /* if (math.abs(v.x)>math.abs(v.z)) then */
  enum { lc107 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"abs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"abs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lua_call(L,1,1);
  const int lc108 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc108);
  const int lc109 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc109) {
    
    /* if (v.x)>0 then */
    enum { lc110 = 7 };
    lua_pushnumber(L,0);
    lua_pushliteral(L,"x");
    lua_gettable(L,5);
    const int lc111 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc111);
    const int lc112 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc112) {
      
      /* dx = 1 */
      lua_pushnumber(L,1);
      lua_replace(L,6);
      assert(lua_gettop(L) == 7);
    }
    else {
      
      /* else
       * dx = -1 */
      lua_pushnumber(L,-1);
      lua_replace(L,6);
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc110);
    assert(lua_gettop(L) == 7);
  }
  else {
    
    /* else
     * if (v.z)>0 then */
    enum { lc113 = 7 };
    lua_pushnumber(L,0);
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    const int lc114 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc114);
    const int lc115 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc115) {
      
      /* dz = 1 */
      lua_pushnumber(L,1);
      lua_replace(L,7);
      assert(lua_gettop(L) == 7);
    }
    else {
      
      /* else
       * dz = -1 */
      lua_pushnumber(L,-1);
      lua_replace(L,7);
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc113);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc107);
  assert(lua_gettop(L) == 7);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* local pos1 */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 9);
  
  /* pos.y=pos.y-1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,8);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 9);
  
  /* pos1 = {x = pos.x+dx, y = pos.y, z = pos.z+dz} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,8);
  lc_add(L,-1,6);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,8);
  lc_add(L,-1,7);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_replace(L,9);
  assert(lua_gettop(L) == 9);
  
  /* local n = minetest.env:get_node(pos).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,8);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 10);
  
  /* local n1 = minetest.env:get_node(pos1).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,9);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 11);
  
  /* if n~=p_block and not minetest.is_protected(pos, "") then */
  enum { lc116 = 11 };
  const int lc117 = lua_equal(L,10,3);
  lua_pushboolean(L,lc117);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"is_protected");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,8);
    lua_pushliteral(L,"");
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc118 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc118) {
    
    /* minetest.env:set_node(pos, {name=p_block}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"env");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,8);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushvalue(L,3);
    lua_rawset(L,-3);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc116);
  assert(lua_gettop(L) == 11);
  
  /* if n1~=p_block and not minetest.is_protected(pos1, "") then */
  enum { lc119 = 11 };
  const int lc120 = lua_equal(L,11,3);
  lua_pushboolean(L,lc120);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"is_protected");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,9);
    lua_pushliteral(L,"");
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc121 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc121) {
    
    /* minetest.env:set_node(pos1, {name=p_block}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"env");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,9);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushvalue(L,3);
    lua_rawset(L,-3);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc119);
  assert(lua_gettop(L) == 11);
  return 0;
}


/* name: nssm:webber_ability
 * function(		--puts randomly around the block defined as w_block
 * 	self,		--the entity of the mob
 * 	w_block, 	--definition of the block to use
 * 	radius) */
static int lcf1_nssm_webber_ability (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* if (math.random(1,5)==1) then */
  enum { lc122 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,5);
  lua_call(L,2,1);
  lua_pushnumber(L,1);
  const int lc123 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc123);
  const int lc124 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc124) {
    
    /* local dx=math.random(1,radius) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushvalue(L,4);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 6);
    
    /* local dz=math.random(1,radius) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushvalue(L,4);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 7);
    
    /* local p = {x=pos.x+dx, y=pos.y-1, z=pos.z+dz} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,5);
    lc_add(L,-1,6);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    lc_add(L,-1,7);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 8);
    
    /* local t = {x=pos.x+dx, y=pos.y, z=pos.z+dz} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,5);
    lc_add(L,-1,6);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    lc_add(L,-1,7);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 9);
    
    /* local n = minetest.env:get_node(p).name */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"env");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,8);
    lua_call(L,2,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 10);
    
    /* local k = minetest.env:get_node(t).name */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"env");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,9);
    lua_call(L,2,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 11);
    
    /* if ((n~="air")and(k=="air")) and not minetest.is_protected(t, "") then */
    enum { lc125 = 11 };
    lua_pushliteral(L,"air");
    const int lc126 = lua_equal(L,10,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc126);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,11);
      lua_pushliteral(L,"air");
      const int lc127 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc127);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"is_protected");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_pushliteral(L,"");
      lua_call(L,2,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc128 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc128) {
      
      /* minetest.env:set_node(t, {name=w_block}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"env");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,9);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lua_pushvalue(L,3);
      lua_rawset(L,-3);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc125);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc122);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: nssm:midas_ability
 * function(		--ability to transform every blocks it touches in the m_block block
 * 	self,		--the entity of the mob
 * 	m_block,
 * 	max_vel,	--max velocity of the mob
 * 	mult, 		--multiplier of the dimensions of the area around that need the transformation
 * 	height) */
static int lcf1_nssm_midas_ability (lua_State * L) {
  lua_checkstack(L,32);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* local v = self.object:getvelocity() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* if minetest.is_protected(pos, "") then */
  enum { lc129 = 8 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"is_protected");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,8);
  lua_pushliteral(L,"");
  lua_call(L,2,1);
  const int lc130 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc130) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc129);
  assert(lua_gettop(L) == 8);
  
  /* local max = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 9);
  
  /* local yaw = (self.object:getyaw() + self.rotate) or 0 */
  lua_pushliteral(L,"object");
  lua_gettable(L,2);
  lua_pushliteral(L,"getyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"rotate");
  lua_gettable(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  assert(lua_gettop(L) == 10);
  
  /* local x = math.sin(yaw)*-1 */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,10);
  lua_call(L,1,1);
  lua_pushnumber(L,-1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 11);
  
  /* local z = math.cos(yaw) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,10);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 12);
  
  /* local i = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 13);
  
  /* local i1 = -1 */
  lua_pushnumber(L,-1);
  assert(lua_gettop(L) == 14);
  
  /* local k = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 15);
  
  /* local k1 = -1 */
  lua_pushnumber(L,-1);
  assert(lua_gettop(L) == 16);
  
  /* local multiplier = mult */
  lua_pushvalue(L,5);
  assert(lua_gettop(L) == 17);
  
  /* if x>0 then */
  enum { lc131 = 17 };
  lua_pushnumber(L,0);
  const int lc132 = lua_lessthan(L,-1,11);
  lua_pop(L,1);
  lua_pushboolean(L,lc132);
  const int lc133 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc133) {
    
    /* i = nssm:round(x*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,11,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 17);
  }
  else {
    
    /* else
     * i1 = nssm:round(x*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,11,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,14);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc131);
  assert(lua_gettop(L) == 17);
  
  /* if z>0 then */
  enum { lc134 = 17 };
  lua_pushnumber(L,0);
  const int lc135 = lua_lessthan(L,-1,12);
  lua_pop(L,1);
  lua_pushboolean(L,lc135);
  const int lc136 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc136) {
    
    /* k = nssm:round(z*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,12,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,15);
    assert(lua_gettop(L) == 17);
  }
  else {
    
    /* else
     * k1 = nssm:round(z*max_vel)*multiplier */
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"round");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lc_mul(L,12,4);
    lua_call(L,2,1);
    lc_mul(L,-1,17);
    lua_remove(L,-2);
    lua_replace(L,16);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc134);
  assert(lua_gettop(L) == 17);
  
  /* for dx = i1, i do */
  if (!((lua_isnumber(L,14) && lua_isnumber(L,13)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc137_var = lua_tonumber(L,14);
  const double lc138_limit = lua_tonumber(L,13);
  const double lc139_step = 1;
  lua_pop(L,0);
  enum { lc140 = 17 };
  while ((((lc139_step > 0) && (lc137_var <= lc138_limit)) || ((lc139_step <= 0) && (lc137_var >= lc138_limit)))) {
    
    /* internal: local dx at index 18 */
    lua_pushnumber(L,lc137_var);
    
    /* for dy = -1, height do */
    lua_pushnumber(L,-1);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,6)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc141_var = lua_tonumber(L,-1);
    const double lc142_limit = lua_tonumber(L,6);
    const double lc143_step = 1;
    lua_pop(L,1);
    enum { lc144 = 18 };
    while ((((lc143_step > 0) && (lc141_var <= lc142_limit)) || ((lc143_step <= 0) && (lc141_var >= lc142_limit)))) {
      
      /* internal: local dy at index 19 */
      lua_pushnumber(L,lc141_var);
      
      /* for dz = k1, k do */
      if (!((lua_isnumber(L,16) && lua_isnumber(L,15)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc145_var = lua_tonumber(L,16);
      const double lc146_limit = lua_tonumber(L,15);
      const double lc147_step = 1;
      lua_pop(L,0);
      enum { lc148 = 19 };
      while ((((lc147_step > 0) && (lc145_var <= lc146_limit)) || ((lc147_step <= 0) && (lc145_var >= lc146_limit)))) {
        
        /* internal: local dz at index 20 */
        lua_pushnumber(L,lc145_var);
        
        /* local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,8);
        lc_add(L,-1,18);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,8);
        lc_add(L,-1,19);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,8);
        lc_add(L,-1,20);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 21);
        
        /* local n = minetest.env:get_node(p).name */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"env");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,21);
        lua_call(L,2,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 22);
        
        /* if minetest.get_item_group(n, "unbreakable") == 1 or minetest.is_protected(p, "") or n=="air" then */
        enum { lc149 = 22 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_item_group");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,22);
        lua_pushliteral(L,"unbreakable");
        lua_call(L,2,1);
        lua_pushnumber(L,1);
        const int lc150 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc150);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"is_protected");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,21);
          lua_pushliteral(L,"");
          lua_call(L,2,1);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,22);
          lua_pushliteral(L,"air");
          const int lc151 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc151);
        }
        const int lc152 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc152) {
        }
        else {
          
          /* else
           * minetest.env:set_node(p, {name=m_block}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"env");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,21);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushvalue(L,3);
          lua_rawset(L,-3);
          lua_call(L,3,0);
          assert(lua_gettop(L) == 22);
        }
        lua_settop(L,lc149);
        assert(lua_gettop(L) == 22);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,3);
        lc145_var += lc147_step;
      }
      lua_settop(L,lc148);
      assert(lua_gettop(L) == 19);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc141_var += lc143_step;
    }
    lua_settop(L,lc144);
    assert(lua_gettop(L) == 18);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc137_var += lc139_step;
  }
  lua_settop(L,lc140);
  assert(lua_gettop(L) == 17);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- set content id's
   * local c_air = minetest.get_content_id("air") */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local c_ignore = minetest.get_content_id("ignore") */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ignore");
  lua_call(L,1,1);
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local c_obsidian = minetest.get_content_id("default:obsidian") */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc3 = 3 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:obsidian");
  lua_call(L,1,1);
  lua_rawseti(L,(lc3 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local c_brick = minetest.get_content_id("default:obsidianbrick") */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 4 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:obsidianbrick");
  lua_call(L,1,1);
  lua_rawseti(L,(lc4 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local c_chest = minetest.get_content_id("default:chest_locked") */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc5 = 5 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:chest_locked");
  lua_call(L,1,1);
  lua_rawseti(L,(lc5 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* -- get node but use fallback for nil or unknown
   * function nssm:node_ok(pos, fallback)
   * 	fallback = fallback or "default:dirt"
   * 	local node = minetest.get_node_or_nil(pos)
   * 	if not node then
   * 		return minetest.registered_nodes[fallback]
   * 	end
   * 	if minetest.registered_nodes[node.name] then
   * 		return node
   * 	end
   * 	return minetest.registered_nodes[fallback]
   * end */
  lua_pushcfunction(L,lcf1_nssm_node_ok);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"node_ok");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* --check_for_death functions customized for monsters who respawns (Masticone)
   * function nssm:check_for_death_hydra(self)
   * 	local hp = self.object:get_hp()
   * 	if hp > 0 then
   * 		self.health = hp
   * 		if self.sounds.damage ~= nil then
   * 			minetest.sound_play(self.sounds.damage,{
   * 				object = self.object,
   * 				max_hear_distance = self.sounds.distance
   * 			})
   * 		end
   * 		return false
   * 	end
   * 	local pos = self.object:getpos()
   * 	local obj = nil
   * 	if self.sounds.death ~= nil then
   * 		minetest.sound_play(self.sounds.death,{
   * 			object = self.object,
   * 			max_hear_distance = self.sounds.distance
   * 		})
   * 	end
   * 		self.object:remove()
   * 	return true
   * end */
  lua_pushcfunction(L,lcf1_nssm_check_for_death_hydra);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"check_for_death_hydra");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* function nssm:round(n)
   * 	if (n>0) then
   * 		return n % 1 >= 0.5 and math.ceil(n) or math.floor(n)
   * 	else
   * 		n=-n
   * 		local t = n % 1 >= 0.5 and math.ceil(n) or math.floor(n)
   * 		return -t
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_nssm_round);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"round");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* function nssm:explosion_particles(pos, exp_radius)
   *     minetest.add_particlespawner(
   *         100*exp_radius/2, --amount
   *         0.1, --time
   *         {x=pos.x-exp_radius, y=pos.y-exp_radius, z=pos.z-exp_radius}, --minpos
   *         {x=pos.x+exp_radius, y=pos.y+exp_radius, z=pos.z+exp_radius}, --maxpos
   *         {x=0, y=0, z=0}, --minvel
   *         {x=0.1, y=0.3, z=0.1}, --maxvel
   *         {x=-0.5,y=1,z=-0.5}, --minacc
   *         {x=0.5,y=1,z=0.5}, --maxacc
   *         0.1, --minexptime
   *         4, --maxexptime
   *         6, --minsize
   *         12, --maxsize
   *         false, --collisiondetection
   *         "tnt_smoke.png" --texture
   *     )
   * end */
  lua_pushcfunction(L,lcf1_nssm_explosion_particles);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"explosion_particles");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* -- buffer for vm:get_data, added by MrCerealGuy
   * local dbuf = {} */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc24 = 6 };
  assert((lua_gettop(L) == (lc24 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc24 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* function nssm:explosion(pos, exp_radius, fire)
   *     local radius = exp_radius
   *     -- if area protected or near map limits then no blast damage
   * 	if minetest.is_protected(pos, "")
   * 	or not within_limits(pos, radius) then
   * 		return
   * 	end
   * 
   *     --sound
   *     minetest.sound_play("boom", {
   *         pos = pos,
   *         max_hear_distance = exp_radius*4,
   *     })
   * 
   *     --particles:
   *     nssm:explosion_particles(pos, exp_radius)
   * 
   *     --Damages entities around (not the player)
   *     local objects = minetest.env:get_objects_inside_radius(pos, exp_radius)
   *     for _,obj in ipairs(objects) do
   *         local obj_p = obj:getpos()
   *         local vec = {x=obj_p.x-pos.x, y=obj_p.y-pos.y, z=obj_p.z-pos.z}
   *         local dist = (vec.x^2+vec.y^2+vec.z^2)^0.5
   * 		local damage = (-exp_radius*dist+exp_radius^2)*2
   * 		obj:set_hp(obj:get_hp()-damage)
   *         if (obj:get_hp() <= 0) then
   *             if (not obj:is_player()) then
   *                 obj:remove()
   *             end
   *         end
   *     end
   * 
   *     --damages blocks around and if necessary put some fire
   *     pos = vector.round(pos) -- voxelmanip doesn't work properly unless pos is rounded ?!?!
   *     local vm = VoxelManip()
   *     local minp, maxp = vm:read_from_map(vector.subtract(pos, radius), vector.add(pos, radius))
   * 	local a = VoxelArea:new({MinEdge = minp, MaxEdge = maxp})
   * 	local data = vm:get_data(dbuf)	-- buffer added by MrCerealGuy
   * 	local p = {}
   * 	local pr = PseudoRandom(os.time())
   * 
   *     --remove everything near the center of the explosion
   *     for dz=-radius,radius do
   *         for dy=-radius,radius do
   *         	local vi = a:index(pos.x + (-radius), pos.y + dy, pos.z + dz)
   *             for dx=-radius,radius do
   *                 local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz}
   * 
   *                 if (dx * dx) + (dy * dy) + (dz * dz) <= (radius * radius) + pr:next(-radius, radius)
   *         		and data[vi] ~= c_air
   *         		and data[vi] ~= c_ignore
   *         		and data[vi] ~= c_obsidian
   *         		and data[vi] ~= c_brick
   *         		and data[vi] ~= c_chest then
   * 
   *                     local n = nssm:node_ok(p).name
   *         			local on_blast = minetest.registered_nodes[n].on_blast
   * 
   *         			if on_blast then
   *         				return on_blast(p)
   *         			end
   * 
   *         			if minetest.get_item_group(n, "unbreakable") ~= 1 then
   * 
   *         				-- if chest then drop items inside
   *         				if n == "default:chest"
   *         				or n == "3dchest:chest"
   *         				or n == "bones:bones" then
   * 
   *         					local meta = minetest.get_meta(p)
   *         					local inv  = meta:get_inventory()
   * 
   *         					for i = 1, inv:get_size("main") do
   * 
   *         						local m_stack = inv:get_stack("main", i)
   *         						local obj = minetest.add_item(p, m_stack)
   * 
   *         						if obj then
   * 
   *         							obj:setvelocity({
   *         								x = math.random(-2, 2),
   *         								y = 7,
   *         								z = math.random(-2, 2)
   *         							})
   *         						end
   *         					end
   *         				end
   * 
   *         				-- after effects
   *         				if fire > 0
   *         				and (minetest.registered_nodes[n].groups.flammable
   *         				or math.random(1, 100) <= 3) then
   *         					minetest.set_node(p, {name = "fire:basic_flame"})
   *         				else
   *                             local dist = nssm:round(((pos.x-p.x)^2 + (pos.y-p.y)^2 + (pos.z-p.z)^2)^1/2)
   *                             local prob = 2/dist
   *                             if math.random(1,100)<=prob*100 then
   *                                 minetest.env:remove_node(p)
   *                             end
   *         				end
   *         			end
   *                 end
   *                 vi = vi+1
   *             end
   *         end
   *     end
   * end */
  lua_pushvalue(L,(lc24 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_explosion,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"explosion");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* --			SPECIAL ABILITIES OF SOME MOBS
   * function nssm:digging_ability(
   * 	self,		--the entity of the mob
   * 	group,		--group of the blocks the mob can dig: nil=everything
   * 	max_vel,	--max velocity of the mob
   * 	dim 		--vector representing the dimensions of the mob
   * 	)
   * 
   * 	local v = self.object:getvelocity()
   * 	local pos = self.object:getpos()
   * 
   * 	if minetest.is_protected(pos, "") then
   * 		return
   * 	end
   * 
   * 	local h = dim.y
   * 
   * 	local max = 0
   * 	--local posmax = 0 --			1 = x, -1=-x, 2 = z, -2 = -z
   * 	local yaw = (self.object:getyaw() + self.rotate) or 0
   * 	local x = math.sin(yaw)*-1
   * 	local z = math.cos(yaw)
   * 
   * 	local i = 1
   * 	local i1 = -1
   * 	local k = 1
   * 	local k1 = -1
   * 
   * 	local multiplier = 2
   * 
   * 	if x>0 then
   * 		i = nssm:round(x*max_vel)*multiplier
   * 	else
   * 		i1 = nssm:round(x*max_vel)*multiplier
   * 	end
   * 
   * 	if z>0 then
   * 		k = nssm:round(z*max_vel)*multiplier
   * 	else
   * 		k1 = nssm:round(z*max_vel)*multiplier
   * 	end
   * 
   * 	for dx = i1, i do
   * 		for dy = 0, h do
   * 			for dz = k1, k do
   * 				local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz}
   * 
   * 				local n = minetest.env:get_node(p).name
   * 				--local up = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz}
   * 				if group == nil then
   * 					if minetest.get_item_group(n, "unbreakable") == 1 or minetest.is_protected(p, "") then
   * 					else
   * 						minetest.env:set_node(p, {name="air"})
   * 					end
   * 				else
   * 					if (minetest.get_item_group(n, group)==1) and (minetest.get_item_group(n, "unbreakable") ~= 1) and not (minetest.is_protected(p, "")) then
   * 						minetest.env:set_node(p, {name="air"})
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_nssm_digging_ability);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"digging_ability");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* function nssm:putting_ability(		--puts under the mob the block defined as 'p_block'
   * 	self,		--the entity of the mob
   * 	p_block, 	--definition of the block to use
   * 	max_vel	--max velocity of the mob
   * 	)
   * 
   * 	local v = self.object:getvelocity()
   * 
   * 	local dx = 0
   * 	local dz = 0
   * 
   * 	if (math.abs(v.x)>math.abs(v.z)) then
   * 		if (v.x)>0 then
   * 			dx = 1
   * 		else
   * 			dx = -1
   * 		end
   * 	else
   * 		if (v.z)>0 then
   * 			dz = 1
   * 		else
   * 			dz = -1
   * 		end
   * 	end
   * 
   * 	local pos = self.object:getpos()
   * 	local pos1
   * 	pos.y=pos.y-1
   * 	pos1 = {x = pos.x+dx, y = pos.y, z = pos.z+dz}
   * 	local n = minetest.env:get_node(pos).name
   * 	local n1 = minetest.env:get_node(pos1).name
   * 	if n~=p_block and not minetest.is_protected(pos, "") then
   * 		minetest.env:set_node(pos, {name=p_block})
   * 	end
   * 	if n1~=p_block and not minetest.is_protected(pos1, "") then
   * 		minetest.env:set_node(pos1, {name=p_block})
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_nssm_putting_ability);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"putting_ability");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* function nssm:webber_ability(		--puts randomly around the block defined as w_block
   * 	self,		--the entity of the mob
   * 	w_block, 	--definition of the block to use
   * 	radius		--max distance the block can be put
   * 	)
   * 
   * 	local pos = self.object:getpos()
   * 	if (math.random(1,5)==1) then
   * 		local dx=math.random(1,radius)
   * 		local dz=math.random(1,radius)
   * 		local p = {x=pos.x+dx, y=pos.y-1, z=pos.z+dz}
   * 		local t = {x=pos.x+dx, y=pos.y, z=pos.z+dz}
   * 		local n = minetest.env:get_node(p).name
   * 		local k = minetest.env:get_node(t).name
   * 		if ((n~="air")and(k=="air")) and not minetest.is_protected(t, "") then
   * 			minetest.env:set_node(t, {name=w_block})
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_nssm_webber_ability);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"webber_ability");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* function nssm:midas_ability(		--ability to transform every blocks it touches in the m_block block
   * 	self,		--the entity of the mob
   * 	m_block,
   * 	max_vel,	--max velocity of the mob
   * 	mult, 		--multiplier of the dimensions of the area around that need the transformation
   * 	height 		--height of the mob
   * 	)
   * 
   * 	local v = self.object:getvelocity()
   * 	local pos = self.object:getpos()
   * 
   * 	if minetest.is_protected(pos, "") then
   * 		return
   * 	end
   * 
   * 	local max = 0
   * 	local yaw = (self.object:getyaw() + self.rotate) or 0
   * 	local x = math.sin(yaw)*-1
   * 	local z = math.cos(yaw)
   * 
   * 	local i = 1
   * 	local i1 = -1
   * 	local k = 1
   * 	local k1 = -1
   * 
   * 	local multiplier = mult
   * 
   * 	if x>0 then
   * 		i = nssm:round(x*max_vel)*multiplier
   * 	else
   * 		i1 = nssm:round(x*max_vel)*multiplier
   * 	end
   * 
   * 	if z>0 then
   * 		k = nssm:round(z*max_vel)*multiplier
   * 	else
   * 		k1 = nssm:round(z*max_vel)*multiplier
   * 	end
   * 
   * 	for dx = i1, i do
   * 		for dy = -1, height do
   * 			for dz = k1, k do
   * 				local p = {x=pos.x+dx, y=pos.y+dy, z=pos.z+dz}
   * 				local n = minetest.env:get_node(p).name
   * 
   * 				if minetest.get_item_group(n, "unbreakable") == 1 or minetest.is_protected(p, "") or n=="air" then
   * 				else
   * 					minetest.env:set_node(p, {name=m_block})
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_nssm_midas_ability);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"midas_ability");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 6);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_nssm_nssm_api(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


