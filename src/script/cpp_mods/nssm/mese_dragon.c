/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* function(self) */
static int lcf1 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* nssm:midas_ability(self, "default:mese_block", self.run_velocity,2, 3) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"midas_ability");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_pushliteral(L,"default:mese_block");
  lua_pushliteral(L,"run_velocity");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lua_pushnumber(L,3);
  lua_call(L,6,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* function(self) */
static int lcf25 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if self.timer > 1 then */
  enum { lc2 = 1 };
  lua_pushnumber(L,1);
  lua_pushliteral(L,"timer");
  lua_gettable(L,1);
  const int lc3 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc3);
  const int lc4 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc4) {
    
    /* self.timer = 0 */
    lua_pushnumber(L,0);
    lua_pushliteral(L,"timer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 1);
    
    /* self.attack_rip = self.attack_rip+1 */
    lua_pushliteral(L,"attack_rip");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"attack_rip");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 1);
    
    /* local s = self.object:getpos() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 2);
    
    /* local p = self.attack:getpos() */
    lua_pushliteral(L,"attack");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 3);
    
    /* p.y = p.y + 1.5 */
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushnumber(L,1.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,3);
    assert(lua_gettop(L) == 3);
    
    /* s.y = s.y + 1.5 */
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 3);
    
    /* if minetest.line_of_sight(p, s) == true then */
    enum { lc5 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"line_of_sight");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_call(L,2,1);
    lua_pushboolean(L,1);
    const int lc6 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc6);
    const int lc7 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc7) {
      
      /* -- play attack sound
       * if self.sounds.attack then */
      enum { lc8 = 3 };
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"attack");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc9 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc9) {
        
        /* minetest.sound_play(self.sounds.attack, {
         * 						object = self.object,
         * 						max_hear_distance = self.sounds.distance
         * 					}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"sound_play");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"sounds");
        lua_gettable(L,1);
        lua_pushliteral(L,"attack");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"object");
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"max_hear_distance");
        lua_pushliteral(L,"sounds");
        lua_gettable(L,1);
        lua_pushliteral(L,"distance");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L,lc8);
      assert(lua_gettop(L) == 3);
      
      /* -- punch player
       * self.attack:punch(self.object, 1.0,  {
       * 					full_punch_interval=1.0,
       * 					damage_groups = {fleshy=self.damage}
       * 				}, nil) */
      lua_pushliteral(L,"attack");
      lua_gettable(L,1);
      lua_pushliteral(L,"punch");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"full_punch_interval");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"damage_groups");
      lua_createtable(L,0,1);
      lua_pushliteral(L,"fleshy");
      lua_pushliteral(L,"damage");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_rawset(L,-3);
      lua_pushnil(L);
      lua_call(L,5,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc5);
    assert(lua_gettop(L) == 3);
    
    /* if self.attack_rip>=8 then */
    enum { lc10 = 3 };
    lua_pushnumber(L,8);
    lua_pushliteral(L,"attack_rip");
    lua_gettable(L,1);
    const int lc11 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc11);
    const int lc12 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc12) {
      
      /* self.attack_rip =0 */
      lua_pushnumber(L,0);
      lua_pushliteral(L,"attack_rip");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 3);
      
      /* set_animation("punch1") */
      lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
      lua_pushliteral(L,"punch1");
      lua_call(L,1,0);
      assert(lua_gettop(L) == 3);
      
      /* for dx = -17,17 do */
      lua_pushnumber(L,-17);
      lua_pushnumber(L,17);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc13_var = lua_tonumber(L,-2);
      const double lc14_limit = lua_tonumber(L,-1);
      const double lc15_step = 1;
      lua_pop(L,2);
      enum { lc16 = 3 };
      while ((((lc15_step > 0) && (lc13_var <= lc14_limit)) || ((lc15_step <= 0) && (lc13_var >= lc14_limit)))) {
        
        /* internal: local dx at index 4 */
        lua_pushnumber(L,lc13_var);
        
        /* for dz= -17,17 do */
        lua_pushnumber(L,-17);
        lua_pushnumber(L,17);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc17_var = lua_tonumber(L,-2);
        const double lc18_limit = lua_tonumber(L,-1);
        const double lc19_step = 1;
        lua_pop(L,2);
        enum { lc20 = 4 };
        while ((((lc19_step > 0) && (lc17_var <= lc18_limit)) || ((lc19_step <= 0) && (lc17_var >= lc18_limit)))) {
          
          /* internal: local dz at index 5 */
          lua_pushnumber(L,lc17_var);
          
          /* local k = {x = s.x+dx, y=s.y+20, z=s.z+dz} */
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,2);
          lc_add(L,-1,4);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,2);
          lua_pushnumber(L,20);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,2);
          lc_add(L,-1,5);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          assert(lua_gettop(L) == 6);
          
          /* local n = minetest.env:get_node(k).name */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"env");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"get_node");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,6);
          lua_call(L,2,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 7);
          
          /* if n=="air" and math.random(1,23)==1 then */
          enum { lc21 = 7 };
          lua_pushvalue(L,7);
          lua_pushliteral(L,"air");
          const int lc22 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc22);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"math");
            lua_pushliteral(L,"random");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lua_pushnumber(L,23);
            lua_call(L,2,1);
            lua_pushnumber(L,1);
            const int lc23 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc23);
          }
          const int lc24 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc24) {
            
            /* minetest.env:set_node(k, {name="nssm:mese_meteor"}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"env");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"set_node");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,6);
            lua_createtable(L,0,1);
            lua_pushliteral(L,"name");
            lua_pushliteral(L,"nssm:mese_meteor");
            lua_rawset(L,-3);
            lua_call(L,3,0);
            assert(lua_gettop(L) == 7);
            
            /* nodeupdate(k) */
            lua_getfield(L,LUA_ENVIRONINDEX,"nodeupdate");
            lua_pushvalue(L,6);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 7);
          }
          lua_settop(L,lc21);
          assert(lua_gettop(L) == 7);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
          lc17_var += lc19_step;
        }
        lua_settop(L,lc20);
        assert(lua_gettop(L) == 4);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc13_var += lc15_step;
      }
      lua_settop(L,lc16);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc10);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc2);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* nssm:register_mob("nssm:mese_dragon", {
   * 	type = "monster",
   * 	hp_max = 333,
   * 	hp_min = 333,
   * 	collisionbox = {-1, 0, -1, 1, 5, 1},
   * 	visual = "mesh",
   * 	mesh = "mese_dragon.x",
   * 	textures = {{"mese_dragon.png"}},
   * 	visual_size = {x=12, y=12},
   * 	makes_footstep_sound = true,
   * 	view_range = 45,
   * 	rotate = 270,
   * 	fear_height = 5,
   * 	walk_velocity = 2,
   * 	run_velocity = 4,
   *     sounds = {
   * 		shoot_attack = "mesed",
   * 		attack = "mese_dragon",
   * 		distance = 60,
   * 	},
   * 	damage = 16,
   * 	jump = true,
   * 	jump_height = 10,
   * 	drops = {
   * 		{name = "nssm:rainbow_staff",
   * 		chance = 1,
   * 		min = 1,
   * 		max = 1},
   * 		{name = "nssm:energy_globe",
   * 		chance = 1,
   * 		min = 99,
   * 		max = 99},
   *     },
   * 	armor = 60,
   * 	drawtype = "front",
   * 	water_damage = 0,
   * 	lava_damage = 0,
   * 	light_damage = 0,
   * 	on_rightclick = nil,
   * 	attack_type = "dogshoot",
   * 	dogshoot_stop = true,
   * 	arrow = "nssm:roar_of_the_dragon",
   * 	reach = 5,
   * 	shoot_interval = 3,
   * 	shoot_offset = -1,
   * 	animation = {
   * 		speed_normal = 15,
   * 		speed_run = 25,
   * 		stand_start = 60,
   * 		stand_end = 120,
   * 		walk_start = 161,
   * 		walk_end = 205,
   * 		run_start = 206,
   * 		run_end = 242,
   * 		punch_start = 242,
   * 		punch_end = 275,
   * 		punch1_start = 330,
   * 		punch1_end = 370,
   *     dattack_start = 120,
   *     dattack_end = 160,
   * 	},
   * 	do_custom = function(self)
   * 		nssm:midas_ability(self, "default:mese_block", self.run_velocity,2, 3)
   * 	end,
   * 
   * 	custom_attack = function(self)
   * 		if self.timer > 1 then
   * 			self.timer = 0
   * 			self.attack_rip = self.attack_rip+1
   * 
   * 			local s = self.object:getpos()
   * 			local p = self.attack:getpos()
   * 
   * 			p.y = p.y + 1.5
   * 			s.y = s.y + 1.5
   * 
   * 			if minetest.line_of_sight(p, s) == true then
   * 				-- play attack sound
   * 				if self.sounds.attack then
   * 					minetest.sound_play(self.sounds.attack, {
   * 						object = self.object,
   * 						max_hear_distance = self.sounds.distance
   * 					})
   * 				end
   * 				-- punch player
   * 				self.attack:punch(self.object, 1.0,  {
   * 					full_punch_interval=1.0,
   * 					damage_groups = {fleshy=self.damage}
   * 				}, nil)
   * 			end
   * 			if self.attack_rip>=8 then
   * 				self.attack_rip =0
   * 				set_animation("punch1")
   * 				for dx = -17,17 do
   * 					for dz= -17,17 do
   * 						local k = {x = s.x+dx, y=s.y+20, z=s.z+dz}
   * 						local n = minetest.env:get_node(k).name
   * 						if n=="air" and math.random(1,23)==1 then
   * 							minetest.env:set_node(k, {name="nssm:mese_meteor"})
   * 							nodeupdate(k)
   * 						end
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"register_mob");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"nssm:mese_dragon");
  lua_createtable(L,0,34);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"monster");
  lua_rawset(L,-3);
  lua_pushliteral(L,"hp_max");
  lua_pushnumber(L,333);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hp_min");
  lua_pushnumber(L,333);
  lua_rawset(L,-3);
  lua_pushliteral(L,"collisionbox");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-1);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-1);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,5);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual");
  lua_pushliteral(L,"mesh");
  lua_rawset(L,-3);
  lua_pushliteral(L,"mesh");
  lua_pushliteral(L,"mese_dragon.x");
  lua_rawset(L,-3);
  lua_pushliteral(L,"textures");
  lua_createtable(L,1,0);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"mese_dragon.png");
  lua_rawseti(L,-2,1);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual_size");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,12);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,12);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"makes_footstep_sound");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"view_range");
  lua_pushnumber(L,45);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rotate");
  lua_pushnumber(L,270);
  lua_rawset(L,-3);
  lua_pushliteral(L,"fear_height");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walk_velocity");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"run_velocity");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"shoot_attack");
  lua_pushliteral(L,"mesed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"attack");
  lua_pushliteral(L,"mese_dragon");
  lua_rawset(L,-3);
  lua_pushliteral(L,"distance");
  lua_pushnumber(L,60);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"damage");
  lua_pushnumber(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"jump");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"jump_height");
  lua_pushnumber(L,10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drops");
  lua_createtable(L,2,0);
  lua_createtable(L,0,4);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"nssm:rainbow_staff");
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"min");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,4);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"nssm:energy_globe");
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"min");
  lua_pushnumber(L,99);
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,99);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"armor");
  lua_pushnumber(L,60);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"front");
  lua_rawset(L,-3);
  lua_pushliteral(L,"water_damage");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"lava_damage");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"light_damage");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_rightclick");
  lua_pushnil(L);
  lua_rawset(L,-3);
  lua_pushliteral(L,"attack_type");
  lua_pushliteral(L,"dogshoot");
  lua_rawset(L,-3);
  lua_pushliteral(L,"dogshoot_stop");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"arrow");
  lua_pushliteral(L,"nssm:roar_of_the_dragon");
  lua_rawset(L,-3);
  lua_pushliteral(L,"reach");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"shoot_interval");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"shoot_offset");
  lua_pushnumber(L,-1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"animation");
  lua_createtable(L,0,14);
  lua_pushliteral(L,"speed_normal");
  lua_pushnumber(L,15);
  lua_rawset(L,-3);
  lua_pushliteral(L,"speed_run");
  lua_pushnumber(L,25);
  lua_rawset(L,-3);
  lua_pushliteral(L,"stand_start");
  lua_pushnumber(L,60);
  lua_rawset(L,-3);
  lua_pushliteral(L,"stand_end");
  lua_pushnumber(L,120);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walk_start");
  lua_pushnumber(L,161);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walk_end");
  lua_pushnumber(L,205);
  lua_rawset(L,-3);
  lua_pushliteral(L,"run_start");
  lua_pushnumber(L,206);
  lua_rawset(L,-3);
  lua_pushliteral(L,"run_end");
  lua_pushnumber(L,242);
  lua_rawset(L,-3);
  lua_pushliteral(L,"punch_start");
  lua_pushnumber(L,242);
  lua_rawset(L,-3);
  lua_pushliteral(L,"punch_end");
  lua_pushnumber(L,275);
  lua_rawset(L,-3);
  lua_pushliteral(L,"punch1_start");
  lua_pushnumber(L,330);
  lua_rawset(L,-3);
  lua_pushliteral(L,"punch1_end");
  lua_pushnumber(L,370);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dattack_start");
  lua_pushnumber(L,120);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dattack_end");
  lua_pushnumber(L,160);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"do_custom");
  lua_pushcfunction(L,lcf1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"custom_attack");
  lua_pushcfunction(L,lcf25);
  lua_rawset(L,-3);
  lua_call(L,3,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_nssm_mese_dragon(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


