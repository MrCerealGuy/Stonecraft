/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* name: atan
 * function(x) */
static int lcf1_atan (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if x ~= x then */
  enum { lc15 = 1 };
  const int lc16 = lua_equal(L,1,1);
  lua_pushboolean(L,lc16);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc17 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc17) {
    
    /* --error("atan bassed NaN")
     * print ("atan based NaN") */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"atan based NaN");
    lua_call(L,1,0);
    assert(lua_gettop(L) == 1);
    
    /* return 0 */
    lua_pushnumber(L,0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* else
     * return math.atan(x) */
    const int lc18 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"atan");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,LUA_MULTRET);
    return (lua_gettop(L) - lc18);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc15);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: do_attack
 * function(self, player) */
static int lcf1_do_attack (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if self.state ~= "attack" then */
  enum { lc19 = 2 };
  lua_pushliteral(L,"state");
  lua_gettable(L,1);
  lua_pushliteral(L,"attack");
  const int lc20 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc20);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc21 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc21) {
    
    /* if math.random(0,100) < 90
     * 		and self.sounds.war_cry then */
    enum { lc22 = 2 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,0);
    lua_pushnumber(L,100);
    lua_call(L,2,1);
    lua_pushnumber(L,90);
    const int lc23 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc23);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"war_cry");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc24 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc24) {
      
      /* minetest.sound_play(self.sounds.war_cry,{
       * 				object = self.object,
       * 				max_hear_distance = self.sounds.distance
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"sound_play");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"war_cry");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"object");
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"max_hear_distance");
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"distance");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc22);
    assert(lua_gettop(L) == 2);
    
    /* self.state = "attack" */
    lua_pushliteral(L,"attack");
    lua_pushliteral(L,"state");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 2);
    
    /* self.attack = player */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"attack");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc19);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: set_velocity
 * function(self, v) */
static int lcf1_set_velocity (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* v = v or 0 */
  lua_pushvalue(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_replace(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local yaw = (self.object:getyaw() + self.rotate) or 0 */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"rotate");
  lua_gettable(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  assert(lua_gettop(L) == 3);
  
  /* self.object:setvelocity({
   * 		x = math.sin(yaw) * -v,
   * 		y = self.object:getvelocity().y,
   * 		z = math.cos(yaw) * v
   * 	}) */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"setvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lc_unm(L,2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"y");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lc_mul(L,-1,2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


#include <math.h>

/* __pow metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_pow(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,pow(lua_tonumber(L,idxa),lua_tonumber(L,idxb)));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__pow")||luaL_getmetafield(L,idxb,"__pow")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: get_velocity
 * function(self) */
static int lcf1_get_velocity (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local v = self.object:getvelocity() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getvelocity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* return (v.x * v.x + v.z * v.z) ^ 0.5 */
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.5);
  lc_pow(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* name: set_animation
 * function(self, type) */
static int lcf1_set_animation (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if not self.animation then */
  enum { lc25 = 2 };
  lua_pushliteral(L,"animation");
  lua_gettable(L,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc26 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc26) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc25);
  assert(lua_gettop(L) == 2);
  
  /* self.animation.current = self.animation.current or "" */
  lua_pushliteral(L,"animation");
  lua_gettable(L,1);
  lua_pushliteral(L,"current");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"");
  }
  lua_pushliteral(L,"animation");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"current");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 2);
  
  /* self.animation.speed_normal = self.animation.speed_normal or 15 */
  lua_pushliteral(L,"animation");
  lua_gettable(L,1);
  lua_pushliteral(L,"speed_normal");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,15);
  }
  lua_pushliteral(L,"animation");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"speed_normal");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 2);
  
  /* if type == "stand"
   * 	and self.animation.current ~= "stand" then */
  enum { lc27 = 2 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"stand");
  const int lc28 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc28);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"animation");
    lua_gettable(L,1);
    lua_pushliteral(L,"current");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"stand");
    const int lc29 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc29);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc30 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc30) {
    
    /* if self.animation.stand_start
     * 		and self.animation.stand_end
     * 		and self.animation.speed_normal then */
    enum { lc31 = 2 };
    lua_pushliteral(L,"animation");
    lua_gettable(L,1);
    lua_pushliteral(L,"stand_start");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"stand_end");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"speed_normal");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc32 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc32) {
      
      /* self.object:set_animation({
       * 				x = self.animation.stand_start,
       * 				y = self.animation.stand_end},
       * 				self.animation.speed_normal, 0) */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"set_animation");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"stand_start");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"stand_end");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"speed_normal");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_call(L,4,0);
      assert(lua_gettop(L) == 2);
      
      /* self.animation.current = "stand" */
      lua_pushliteral(L,"stand");
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_insert(L,-2);
      lua_pushliteral(L,"current");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc31);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* elseif type == "walk"
     * 	and self.animation.current ~= "walk" then */
    enum { lc33 = 2 };
    lua_pushvalue(L,2);
    lua_pushliteral(L,"walk");
    const int lc34 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc34);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"current");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"walk");
      const int lc35 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc35);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc36 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc36) {
      
      /* if self.animation.walk_start
       * 		and self.animation.walk_end
       * 		and self.animation.speed_normal then */
      enum { lc37 = 2 };
      lua_pushliteral(L,"animation");
      lua_gettable(L,1);
      lua_pushliteral(L,"walk_start");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"walk_end");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"speed_normal");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      const int lc38 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc38) {
        
        /* self.object:set_animation({
         * 				x = self.animation.walk_start,
         * 				y = self.animation.walk_end},
         * 				self.animation.speed_normal, 0) */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"set_animation");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"walk_start");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"walk_end");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"speed_normal");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0);
        lua_call(L,4,0);
        assert(lua_gettop(L) == 2);
        
        /* self.animation.current = "walk" */
        lua_pushliteral(L,"walk");
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_insert(L,-2);
        lua_pushliteral(L,"current");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 2);
      }
      lua_settop(L,lc37);
      assert(lua_gettop(L) == 2);
    }
    else {
      
      /* elseif type == "run"
       * 	and self.animation.current ~= "run" then */
      enum { lc39 = 2 };
      lua_pushvalue(L,2);
      lua_pushliteral(L,"run");
      const int lc40 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc40);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"current");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"run");
        const int lc41 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc41);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc42 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc42) {
        
        /* if self.animation.run_start
         * 		and self.animation.run_end
         * 		and self.animation.speed_run then */
        enum { lc43 = 2 };
        lua_pushliteral(L,"animation");
        lua_gettable(L,1);
        lua_pushliteral(L,"run_start");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"run_end");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"speed_run");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        const int lc44 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc44) {
          
          /* self.object:set_animation({
           * 				x = self.animation.run_start,
           * 				y = self.animation.run_end},
           * 				(self.animation.speed_run or self.animation.speed_normal), 0) */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"set_animation");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_createtable(L,0,2);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"run_start");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"run_end");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"speed_run");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"speed_normal");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          lua_pushnumber(L,0);
          lua_call(L,4,0);
          assert(lua_gettop(L) == 2);
          
          /* self.animation.current = "run" */
          lua_pushliteral(L,"run");
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_insert(L,-2);
          lua_pushliteral(L,"current");
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 2);
        }
        lua_settop(L,lc43);
        assert(lua_gettop(L) == 2);
      }
      else {
        
        /* elseif type == "punch"
         * 	and self.animation.current ~= "punch" then */
        enum { lc45 = 2 };
        lua_pushvalue(L,2);
        lua_pushliteral(L,"punch");
        const int lc46 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc46);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"current");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"punch");
          const int lc47 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc47);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc48 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc48) {
          
          /* if self.animation.punch_start
           * 		and self.animation.punch_end
           * 		and self.animation.speed_normal then */
          enum { lc49 = 2 };
          lua_pushliteral(L,"animation");
          lua_gettable(L,1);
          lua_pushliteral(L,"punch_start");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"punch_end");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"speed_normal");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          const int lc50 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc50) {
            
            /* self.object:set_animation({
             * 				x = self.animation.punch_start,
             * 				y = self.animation.punch_end},
             * 				(self.animation.speed_punch or self.animation.speed_normal), 0) */
            lua_pushliteral(L,"object");
            lua_gettable(L,1);
            lua_pushliteral(L,"set_animation");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_createtable(L,0,2);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"punch_start");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"punch_end");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"speed_punch");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"speed_normal");
              lua_gettable(L,-2);
              lua_remove(L,-2);
            }
            lua_pushnumber(L,0);
            lua_call(L,4,0);
            assert(lua_gettop(L) == 2);
            
            /* self.animation.current = "punch" */
            lua_pushliteral(L,"punch");
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_insert(L,-2);
            lua_pushliteral(L,"current");
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 2);
          }
          lua_settop(L,lc49);
          assert(lua_gettop(L) == 2);
        }
        else {
          
          /* --NSSM additions:
           * 
           * 	elseif type == "punch1"
           * 		and self.animation.current ~= "punch1" then */
          enum { lc51 = 2 };
          lua_pushvalue(L,2);
          lua_pushliteral(L,"punch1");
          const int lc52 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc52);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"current");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"punch1");
            const int lc53 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc53);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          const int lc54 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc54) {
            
            /* if self.animation.punch1_start
             * 			and self.animation.punch1_end
             * 			and self.animation.speed_normal then */
            enum { lc55 = 2 };
            lua_pushliteral(L,"animation");
            lua_gettable(L,1);
            lua_pushliteral(L,"punch1_start");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"punch1_end");
              lua_gettable(L,-2);
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"speed_normal");
              lua_gettable(L,-2);
              lua_remove(L,-2);
            }
            const int lc56 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc56) {
              
              /* self.object:set_animation({
               * 					x = self.animation.punch1_start,
               * 					y = self.animation.punch1_end},
               * 					self.animation.speed_normal, 0) */
              lua_pushliteral(L,"object");
              lua_gettable(L,1);
              lua_pushliteral(L,"set_animation");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_createtable(L,0,2);
              lua_pushliteral(L,"x");
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"punch1_start");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"punch1_end");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"speed_normal");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,0);
              lua_call(L,4,0);
              assert(lua_gettop(L) == 2);
              
              /* self.animation.current = "punch1" */
              lua_pushliteral(L,"punch1");
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_insert(L,-2);
              lua_pushliteral(L,"current");
              lua_insert(L,-2);
              lua_settable(L,-3);
              lua_pop(L,1);
              assert(lua_gettop(L) == 2);
            }
            lua_settop(L,lc55);
            assert(lua_gettop(L) == 2);
          }
          else {
            
            /* elseif type == "dattack"
             * 		and self.animation.current ~= "dattack" then */
            enum { lc57 = 2 };
            lua_pushvalue(L,2);
            lua_pushliteral(L,"dattack");
            const int lc58 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc58);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"current");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"dattack");
              const int lc59 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc59);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc60 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc60) {
              
              /* if self.animation.dattack_start
               * 			and self.animation.dattack_end
               * 			and self.animation.speed_normal then */
              enum { lc61 = 2 };
              lua_pushliteral(L,"animation");
              lua_gettable(L,1);
              lua_pushliteral(L,"dattack_start");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"animation");
                lua_gettable(L,1);
                lua_pushliteral(L,"dattack_end");
                lua_gettable(L,-2);
                lua_remove(L,-2);
              }
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"animation");
                lua_gettable(L,1);
                lua_pushliteral(L,"speed_normal");
                lua_gettable(L,-2);
                lua_remove(L,-2);
              }
              const int lc62 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc62) {
                
                /* self.object:set_animation({
                 * 					x = self.animation.dattack_start,
                 * 					y = self.animation.dattack_end},
                 * 					self.animation.speed_normal, 0) */
                lua_pushliteral(L,"object");
                lua_gettable(L,1);
                lua_pushliteral(L,"set_animation");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_createtable(L,0,2);
                lua_pushliteral(L,"x");
                lua_pushliteral(L,"animation");
                lua_gettable(L,1);
                lua_pushliteral(L,"dattack_start");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_rawset(L,-3);
                lua_pushliteral(L,"y");
                lua_pushliteral(L,"animation");
                lua_gettable(L,1);
                lua_pushliteral(L,"dattack_end");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_rawset(L,-3);
                lua_pushliteral(L,"animation");
                lua_gettable(L,1);
                lua_pushliteral(L,"speed_normal");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,0);
                lua_call(L,4,0);
                assert(lua_gettop(L) == 2);
                
                /* self.animation.current = "dattack" */
                lua_pushliteral(L,"dattack");
                lua_pushliteral(L,"animation");
                lua_gettable(L,1);
                lua_insert(L,-2);
                lua_pushliteral(L,"current");
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 2);
              }
              lua_settop(L,lc61);
              assert(lua_gettop(L) == 2);
            }
            lua_settop(L,lc57);
          }
          lua_settop(L,lc51);
        }
        lua_settop(L,lc45);
      }
      lua_settop(L,lc39);
    }
    lua_settop(L,lc33);
  }
  lua_settop(L,lc27);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: line_of_sight_water
 * function(self, pos1, pos2, stepsize) */
static int lcf1_line_of_sight_water (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local s, pos_w = minetest.line_of_sight(pos1, pos2, stepsize) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"line_of_sight");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 6);
  
  /* -- normal walking and flying nssm can see you through air
   * if s == true then */
  enum { lc63 = 6 };
  lua_pushboolean(L,1);
  const int lc64 = lua_equal(L,5,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc64);
  const int lc65 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc65) {
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc63);
  assert(lua_gettop(L) == 6);
  
  /* -- swimming nssm can see you through water
   * if s == false
   * 	and self.fly
   * 	and self.fly_in == "default:water_source" then */
  enum { lc66 = 6 };
  lua_pushvalue(L,5);
  lua_pushboolean(L,0);
  const int lc67 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc67);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"fly");
    lua_gettable(L,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"fly_in");
    lua_gettable(L,1);
    lua_pushliteral(L,"default:water_source");
    const int lc68 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc68);
  }
  const int lc69 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc69) {
    
    /* local nod = minetest.get_node(pos_w).name */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 7);
    
    /* if nod == "default:water_source"
     * 		or nod == "default:water_flowing" then */
    enum { lc70 = 7 };
    lua_pushvalue(L,7);
    lua_pushliteral(L,"default:water_source");
    const int lc71 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc71);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,7);
      lua_pushliteral(L,"default:water_flowing");
      const int lc72 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc72);
    }
    const int lc73 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc73) {
      
      /* return true */
      lua_pushboolean(L,1);
      return 1;
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc70);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc66);
  assert(lua_gettop(L) == 6);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 6);
}


/* name: effect
 * function(pos, amount, texture, max_size) */
static int lcf1_effect (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* minetest.add_particlespawner({
   * 		amount = amount,
   * 		time = 0.25,
   * 		minpos = pos,
   * 		maxpos = pos,
   * 		minvel = {x = -0, y = -2, z = -0},
   * 		maxvel = {x = 2,  y = 2,  z = 2},
   * 		minacc = {x = -4, y = -4, z = -4},
   * 		maxacc = {x = 4, y = 4, z = 4},
   * 		minexptime = 0.1,
   * 		maxexptime = 1,
   * 		minsize = 0.5,
   * 		maxsize = (max_size or 1),
   * 		texture = texture,
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"add_particlespawner");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,13);
  lua_pushliteral(L,"amount");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"time");
  lua_pushnumber(L,0.25);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minpos");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxpos");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minvel");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,-0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,-0);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxvel");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minacc");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,-4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,-4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,-4);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxacc");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minexptime");
  lua_pushnumber(L,0.1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxexptime");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minsize");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxsize");
  lua_pushvalue(L,4);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"texture");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: update_tag
 * function(self) */
static int lcf1_update_tag (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local col = "#00FF00" */
  lua_pushliteral(L,"#00FF00");
  assert(lua_gettop(L) == 2);
  
  /* local qua = self.hp_max / 4 */
  lua_pushliteral(L,"hp_max");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* if self.health <= math.floor(qua * 3) then */
  enum { lc74 = 3 };
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,3);
  lc_mul(L,3,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  const int lc75 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc75);
  const int lc76 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc76) {
    
    /* col = "#FFFF00" */
    lua_pushliteral(L,"#FFFF00");
    lua_replace(L,2);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc74);
  assert(lua_gettop(L) == 3);
  
  /* if self.health <= math.floor(qua * 2) then */
  enum { lc77 = 3 };
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_mul(L,3,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  const int lc78 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc78);
  const int lc79 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc79) {
    
    /* col = "#FF6600" */
    lua_pushliteral(L,"#FF6600");
    lua_replace(L,2);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc77);
  assert(lua_gettop(L) == 3);
  
  /* if self.health <= math.floor(qua) then */
  enum { lc80 = 3 };
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  const int lc81 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc81);
  const int lc82 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc82) {
    
    /* col = "#FF0000" */
    lua_pushliteral(L,"#FF0000");
    lua_replace(L,2);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc80);
  assert(lua_gettop(L) == 3);
  
  /* self.object:set_properties({
   * 		nametag = self.nametag,
   * 		nametag_color = col
   * 	}) */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"set_properties");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"nametag");
  lua_pushliteral(L,"nametag");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"nametag_color");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: check_for_death
 * function(self) */
static int lcf1_check_for_death (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* -- has health actually changed?
   * if self.health == self.old_health then */
  enum { lc83 = 1 };
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_pushliteral(L,"old_health");
  lua_gettable(L,1);
  const int lc84 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc84);
  const int lc85 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc85) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc83);
  assert(lua_gettop(L) == 1);
  
  /* self.old_health = self.health */
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_pushliteral(L,"old_health");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* -- still got some health? play hurt sound
   * if self.health > 0 then */
  enum { lc86 = 1 };
  lua_pushnumber(L,0);
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  const int lc87 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc87);
  const int lc88 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc88) {
    
    /* if self.sounds.damage then */
    enum { lc89 = 1 };
    lua_pushliteral(L,"sounds");
    lua_gettable(L,1);
    lua_pushliteral(L,"damage");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc90 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc90) {
      
      /* minetest.sound_play(self.sounds.damage,{
       * 				object = self.object,
       * 				gain = 1.0,
       * 				max_hear_distance = self.sounds.distance
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"sound_play");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"damage");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"object");
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"gain");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"max_hear_distance");
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"distance");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 1);
    }
    lua_settop(L,lc89);
    assert(lua_gettop(L) == 1);
    
    /* -- make sure health isn't higher than max
     * if self.health > self.hp_max then */
    enum { lc91 = 1 };
    lua_pushliteral(L,"hp_max");
    lua_gettable(L,1);
    lua_pushliteral(L,"health");
    lua_gettable(L,1);
    const int lc92 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc92);
    const int lc93 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc93) {
      
      /* self.health = self.hp_max */
      lua_pushliteral(L,"hp_max");
      lua_gettable(L,1);
      lua_pushliteral(L,"health");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 1);
    }
    lua_settop(L,lc91);
    assert(lua_gettop(L) == 1);
    
    /* update_tag(self) */
    lua_getfield(L,LUA_ENVIRONINDEX,"update_tag");
    lua_pushvalue(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 1);
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc86);
  assert(lua_gettop(L) == 1);
  
  /* -- drop items when dead
   * local obj */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 2);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* for _,drop in pairs(self.drops) do
   * internal: local f, s, var = explist */
  enum { lc94 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushliteral(L,"drops");
  lua_gettable(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 7
     * internal: local drop with idx 8 */
    
    
    /* if math.random(1, drop.chance) == 1 then */
    enum { lc95 = 8 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushliteral(L,"chance");
    lua_gettable(L,8);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc96 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc96);
    const int lc97 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc97) {
      
      /* obj = minetest.add_item(pos,
       * 				ItemStack(drop.name .. " "
       * 					.. math.random(drop.min, drop.max))) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"add_item");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc98 = lua_gettop(L);
      lua_pushvalue(L,3);
      lua_getfield(L,LUA_ENVIRONINDEX,"ItemStack");
      lua_pushliteral(L,"name");
      lua_gettable(L,8);
      lua_pushliteral(L," ");
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"min");
      lua_gettable(L,8);
      lua_pushliteral(L,"max");
      lua_gettable(L,8);
      lua_call(L,2,1);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc98),1);
      lua_replace(L,2);
      assert(lua_gettop(L) == 8);
      
      /* if obj then */
      enum { lc99 = 8 };
      if (lua_toboolean(L,2)) {
        
        /* obj:setvelocity({
         * 					x = math.random(-1, 1),
         * 					y = 6,
         * 					z = math.random(-1, 1)
         * 				}) */
        lua_pushvalue(L,2);
        lua_pushliteral(L,"setvelocity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,-1);
        lua_pushnumber(L,1);
        lua_call(L,2,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushnumber(L,6);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,-1);
        lua_pushnumber(L,1);
        lua_call(L,2,1);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc99);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc95);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc94);
  assert(lua_gettop(L) == 3);
  
  /* -- play death sound
   * if self.sounds.death then */
  enum { lc100 = 3 };
  lua_pushliteral(L,"sounds");
  lua_gettable(L,1);
  lua_pushliteral(L,"death");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc101 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc101) {
    
    /* minetest.sound_play(self.sounds.death,{
     * 			object = self.object,
     * 			gain = 1.0,
     * 			max_hear_distance = self.sounds.distance
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"sound_play");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sounds");
    lua_gettable(L,1);
    lua_pushliteral(L,"death");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"object");
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"gain");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_hear_distance");
    lua_pushliteral(L,"sounds");
    lua_gettable(L,1);
    lua_pushliteral(L,"distance");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc100);
  assert(lua_gettop(L) == 3);
  
  /* -- execute custom death function
   * if self.on_die then */
  enum { lc102 = 3 };
  lua_pushliteral(L,"on_die");
  lua_gettable(L,1);
  const int lc103 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc103) {
    
    /* self.on_die(self, pos) */
    lua_pushliteral(L,"on_die");
    lua_gettable(L,1);
    lua_pushvalue(L,1);
    lua_pushvalue(L,3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc102);
  assert(lua_gettop(L) == 3);
  
  /* self.object:remove() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"remove");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: within_limits
 * function(pos, radius) */
static int lcf1_within_limits (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if  (pos.x - radius) > -30913
   * 	and (pos.x + radius) <  30928
   * 	and (pos.y - radius) > -30913
   * 	and (pos.y + radius) <  30928
   * 	and (pos.z - radius) > -30913
   * 	and (pos.z + radius) <  30928 then */
  enum { lc104 = 2 };
  lua_pushnumber(L,-30913);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_sub(L,-1,2);
  lua_remove(L,-2);
  const int lc105 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc105);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lc_add(L,-1,2);
    lua_remove(L,-2);
    lua_pushnumber(L,30928);
    const int lc106 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc106);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,-30913);
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_sub(L,-1,2);
    lua_remove(L,-2);
    const int lc107 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc107);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_add(L,-1,2);
    lua_remove(L,-2);
    lua_pushnumber(L,30928);
    const int lc108 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc108);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,-30913);
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lc_sub(L,-1,2);
    lua_remove(L,-2);
    const int lc109 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc109);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lc_add(L,-1,2);
    lua_remove(L,-2);
    lua_pushnumber(L,30928);
    const int lc110 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc110);
  }
  const int lc111 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc111) {
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc104);
  assert(lua_gettop(L) == 2);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* name: is_at_cliff
 * function(self) */
static int lcf1_is_at_cliff (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if self.fear_height == 0 then */
  enum { lc113 = 1 };
  lua_pushliteral(L,"fear_height");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc114 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc114);
  const int lc115 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc115) {
    
    /* -- if 0, no falling protection!
     * return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc113);
  assert(lua_gettop(L) == 1);
  
  /* local yaw = self.object:getyaw() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* local dir_x = -math.sin(yaw) * (self.collisionbox[4] + 0.5) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lc_unm(L,-1);
  lua_remove(L,-2);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.5);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local dir_z = math.cos(yaw) * (self.collisionbox[4] + 0.5) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.5);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* local ypos = pos.y + self.collisionbox[2] */
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 6);
  
  /* -- just above floor
   * if minetest.line_of_sight(
   * 		{x = pos.x + dir_x, y = ypos, z = pos.z + dir_z},
   * 		{x = pos.x + dir_x, y = ypos - self.fear_height, z = pos.z + dir_z}
   * 	, 1) then */
  enum { lc116 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"line_of_sight");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lc_add(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lc_add(L,-1,4);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lc_add(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"fear_height");
  lua_gettable(L,1);
  lc_sub(L,6,-1);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lc_add(L,-1,4);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushnumber(L,1);
  lua_call(L,3,1);
  const int lc117 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc117) {
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc116);
  assert(lua_gettop(L) == 6);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 6);
}


/* name: node_ok
 * function(pos, fallback) */
static int lcf1_node_ok (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* fallback = fallback or "default:dirt" */
  lua_pushvalue(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:dirt");
  }
  lua_replace(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local node = minetest.get_node_or_nil(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_or_nil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if not node then */
  enum { lc119 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc120 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc120) {
    
    /* return minetest.registered_nodes[fallback] */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc119);
  assert(lua_gettop(L) == 3);
  
  /* if minetest.registered_nodes[node.name] then */
  enum { lc121 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc122 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc122) {
    
    /* return node */
    lua_pushvalue(L,3);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc121);
  assert(lua_gettop(L) == 3);
  
  /* return minetest.registered_nodes[fallback] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: do_env_damage
 * function(self) */
static int lcf1_do_env_damage (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* -- feed/tame text timer (so mob 'full' messages dont spam chat)
   * if self.htimer > 0 then */
  enum { lc123 = 1 };
  lua_pushnumber(L,0);
  lua_pushliteral(L,"htimer");
  lua_gettable(L,1);
  const int lc124 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc124);
  const int lc125 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc125) {
    
    /* self.htimer = self.htimer - 1 */
    lua_pushliteral(L,"htimer");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"htimer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc123);
  assert(lua_gettop(L) == 1);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* self.time_of_day = minetest.get_timeofday() */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_timeofday");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"time_of_day");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 2);
  
  /* -- remove mob if beyond map limits
   * if not within_limits(pos, 0) then */
  enum { lc126 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"within_limits");
  lua_pushvalue(L,2);
  lua_pushnumber(L,0);
  lua_call(L,2,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc127 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc127) {
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 2);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc126);
  assert(lua_gettop(L) == 2);
  
  /* -- daylight above ground
   * if self.light_damage ~= 0
   * 	and pos.y > 0
   * 	and self.time_of_day > 0.2
   * 	and self.time_of_day < 0.8
   * 	and (minetest.get_node_light(pos) or 0) > 12 then */
  enum { lc128 = 2 };
  lua_pushliteral(L,"light_damage");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc129 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc129);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    const int lc130 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc130);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0.2);
    lua_pushliteral(L,"time_of_day");
    lua_gettable(L,1);
    const int lc131 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc131);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"time_of_day");
    lua_gettable(L,1);
    lua_pushnumber(L,0.8);
    const int lc132 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc132);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,12);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node_light");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,1,1);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    const int lc133 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc133);
  }
  const int lc134 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc134) {
    
    /* self.health = self.health - self.light_damage */
    lua_pushliteral(L,"health");
    lua_gettable(L,1);
    lua_pushliteral(L,"light_damage");
    lua_gettable(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"health");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 2);
    
    /* effect(pos, 5, "tnt_smoke.png") */
    lua_getfield(L,LUA_ENVIRONINDEX,"effect");
    lua_pushvalue(L,2);
    lua_pushnumber(L,5);
    lua_pushliteral(L,"tnt_smoke.png");
    lua_call(L,3,0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc128);
  assert(lua_gettop(L) == 2);
  
  /* -- what is mob standing in?
   * pos.y = pos.y + self.collisionbox[2] + 0.1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* -- foot level
   * self.standing_in = node_ok(pos, "air").name */
  lc_getupvalue(L,lua_upvalueindex(1),0,15);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"air");
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"standing_in");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 2);
  
  /* --print ("standing in " .. self.standing_in)
   * if self.water_damage ~= 0
   * 	or self.lava_damage ~= 0 then */
  enum { lc135 = 2 };
  lua_pushliteral(L,"water_damage");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc136 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc136);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"lava_damage");
    lua_gettable(L,1);
    lua_pushnumber(L,0);
    const int lc137 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc137);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc138 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc138) {
    
    /* local nodef = minetest.registered_nodes[self.standing_in] */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"standing_in");
    lua_gettable(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 3);
    
    /* pos.y = pos.y + 1 */
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 3);
    
    /* -- water
     * if self.water_damage ~= 0
     * 		and nodef.groups.water then */
    enum { lc139 = 3 };
    lua_pushliteral(L,"water_damage");
    lua_gettable(L,1);
    lua_pushnumber(L,0);
    const int lc140 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc140);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"groups");
      lua_gettable(L,3);
      lua_pushliteral(L,"water");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc141 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc141) {
      
      /* self.health = self.health - self.water_damage */
      lua_pushliteral(L,"health");
      lua_gettable(L,1);
      lua_pushliteral(L,"water_damage");
      lua_gettable(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"health");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 3);
      
      /* effect(pos, 5, "bubble.png") */
      lua_getfield(L,LUA_ENVIRONINDEX,"effect");
      lua_pushvalue(L,2);
      lua_pushnumber(L,5);
      lua_pushliteral(L,"bubble.png");
      lua_call(L,3,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc139);
    assert(lua_gettop(L) == 3);
    
    /* -- lava or fire
     * if self.lava_damage ~= 0
     * 		and (nodef.groups.lava
     * 		or self.standing_in == "fire:basic_flame"
     * 		or self.standing_in == "fire:permanent_flame") then */
    enum { lc142 = 3 };
    lua_pushliteral(L,"lava_damage");
    lua_gettable(L,1);
    lua_pushnumber(L,0);
    const int lc143 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc143);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"groups");
      lua_gettable(L,3);
      lua_pushliteral(L,"lava");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"standing_in");
        lua_gettable(L,1);
        lua_pushliteral(L,"fire:basic_flame");
        const int lc144 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc144);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"standing_in");
        lua_gettable(L,1);
        lua_pushliteral(L,"fire:permanent_flame");
        const int lc145 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc145);
      }
    }
    const int lc146 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc146) {
      
      /* self.health = self.health - self.lava_damage */
      lua_pushliteral(L,"health");
      lua_gettable(L,1);
      lua_pushliteral(L,"lava_damage");
      lua_gettable(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"health");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 3);
      
      /* effect(pos, 5, "fire_basic_flame.png") */
      lua_getfield(L,LUA_ENVIRONINDEX,"effect");
      lua_pushvalue(L,2);
      lua_pushnumber(L,5);
      lua_pushliteral(L,"fire_basic_flame.png");
      lua_call(L,3,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc142);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc135);
  assert(lua_gettop(L) == 2);
  
  /* --NSSM modifications:
   * if not self.hydra then */
  enum { lc147 = 2 };
  lua_pushliteral(L,"hydra");
  lua_gettable(L,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc148 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc148) {
    
    /* if check_for_death(self) then */
    enum { lc149 = 2 };
    lua_getfield(L,LUA_ENVIRONINDEX,"check_for_death");
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    const int lc150 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc150) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc149);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* else
     * if nssm:check_for_death_hydra(self) then */
    enum { lc151 = 2 };
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"check_for_death_hydra");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,2,1);
    const int lc152 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc152) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc151);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc147);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: do_jump
 * function(self) */
static int lcf1_do_jump (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if self.fly
   * 	or self.child then */
  enum { lc153 = 1 };
  lua_pushliteral(L,"fly");
  lua_gettable(L,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"child");
    lua_gettable(L,1);
  }
  const int lc154 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc154) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc153);
  assert(lua_gettop(L) == 1);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* -- what is mob standing on?
   * pos.y = pos.y + self.collisionbox[2] - 0.2 */
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local nod = node_ok(pos) */
  lc_getupvalue(L,lua_upvalueindex(1),0,15);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* --print ("standing on:", nod.name, pos.y)
   * if minetest.registered_nodes[nod.name].walkable == false then */
  enum { lc155 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"walkable");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,0);
  const int lc156 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc156);
  const int lc157 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc157) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc155);
  assert(lua_gettop(L) == 3);
  
  /* -- where is front
   * local yaw = self.object:getyaw() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* local dir_x = -math.sin(yaw) * (self.collisionbox[4] + 0.5) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  lc_unm(L,-1);
  lua_remove(L,-2);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.5);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* local dir_z = math.cos(yaw) * (self.collisionbox[4] + 0.5) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.5);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 6);
  
  /* -- what is in front of mob?
   * local nod = node_ok({
   * 		x = pos.x + dir_x,
   * 		y = pos.y + 0.5,
   * 		z = pos.z + dir_z
   * 	}) */
  lc_getupvalue(L,lua_upvalueindex(1),0,15);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_add(L,-1,5);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_pushnumber(L,0.5);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_add(L,-1,6);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* -- thin blocks that do not need to be jumped
   * if nod.name == "default:snow" then */
  enum { lc158 = 7 };
  lua_pushliteral(L,"name");
  lua_gettable(L,7);
  lua_pushliteral(L,"default:snow");
  const int lc159 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc159);
  const int lc160 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc160) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc158);
  assert(lua_gettop(L) == 7);
  
  /* --print ("in front:", nod.name, pos.y + 0.5)
   * if (minetest.registered_items[nod.name].walkable
   * 	and not nod.name:find("fence")
   * 	and not nod.name:find("gate"))
   * 	or self.walk_chance == 0 then */
  enum { lc161 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_items");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,7);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"walkable");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,7);
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"fence");
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,7);
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"gate");
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"walk_chance");
    lua_gettable(L,1);
    lua_pushnumber(L,0);
    const int lc162 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc162);
  }
  const int lc163 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc163) {
    
    /* local v = self.object:getvelocity() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 8);
    
    /* v.y = self.jump_height + 1 */
    lua_pushliteral(L,"jump_height");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
    
    /* v.x = v.x * 2.2 */
    lua_pushliteral(L,"x");
    lua_gettable(L,8);
    lua_pushnumber(L,2.2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
    
    /* v.z = v.z * 2.2 */
    lua_pushliteral(L,"z");
    lua_gettable(L,8);
    lua_pushnumber(L,2.2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
    
    /* self.object:setvelocity(v) */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"setvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,8);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 8);
    
    /* if self.sounds.jump then */
    enum { lc164 = 8 };
    lua_pushliteral(L,"sounds");
    lua_gettable(L,1);
    lua_pushliteral(L,"jump");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc165 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc165) {
      
      /* minetest.sound_play(self.sounds.jump, {
       * 				object = self.object,
       * 				gain = 1.0,
       * 				max_hear_distance = self.sounds.distance
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"sound_play");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"jump");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"object");
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"gain");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"max_hear_distance");
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"distance");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc164);
    assert(lua_gettop(L) == 8);
  }
  else {
    
    /* else
     * if self.state ~= "attack" then */
    enum { lc166 = 7 };
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc167 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc167);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc168 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc168) {
      
      /* self.state = "stand" */
      lua_pushliteral(L,"stand");
      lua_pushliteral(L,"state");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 7);
      
      /* set_animation(self, "stand") */
      lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
      lua_pushvalue(L,1);
      lua_pushliteral(L,"stand");
      lua_call(L,2,0);
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc166);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc161);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: get_distance
 * function(a, b) */
static int lcf1_get_distance (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local x, y, z = a.x - b.x, a.y - b.y, a.z - b.z */
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* return square(x * x + y * y + z * z) */
  const int lc170 = lua_gettop(L);
  lc_getupvalue(L,lua_upvalueindex(1),3,12);
  lc_mul(L,3,3);
  lc_mul(L,4,4);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,5,5);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,LUA_MULTRET);
  return (lua_gettop(L) - lc170);
  assert(lua_gettop(L) == 5);
}


/* name: entity_physics
 * function(pos, radius) */
static int lcf1_entity_physics (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* radius = radius * 2 */
  lua_pushnumber(L,2);
  lc_mul(L,2,-1);
  lua_remove(L,-2);
  lua_replace(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local objs = minetest.get_objects_inside_radius(pos, radius) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 3);
  
  /* local obj_pos, dist */
  lua_settop(L,(lua_gettop(L) + 2));
  assert(lua_gettop(L) == 5);
  
  /* for _, obj in pairs(objs) do
   * internal: local f, s, var = explist */
  enum { lc171 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 9
     * internal: local obj with idx 10 */
    
    
    /* obj_pos = obj:getpos() */
    lua_pushvalue(L,10);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 10);
    
    /* dist = math.max(1, get_distance(pos, obj_pos)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc172 = lua_gettop(L);
    lua_pushnumber(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,16);
    lua_pushvalue(L,1);
    lua_pushvalue(L,4);
    lua_call(L,2,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc172),1);
    lua_replace(L,5);
    assert(lua_gettop(L) == 10);
    
    /* local damage = math.floor((4 / dist) * radius) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,4);
    lc_div(L,-1,5);
    lua_remove(L,-2);
    lc_mul(L,-1,2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 11);
    
    /* local ent = obj:get_luaentity() */
    lua_pushvalue(L,10);
    lua_pushliteral(L,"get_luaentity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* if obj:is_player() then */
    enum { lc173 = 12 };
    lua_pushvalue(L,10);
    lua_pushliteral(L,"is_player");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    const int lc174 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc174) {
      
      /* obj:set_hp(obj:get_hp() - damage) */
      lua_pushvalue(L,10);
      lua_pushliteral(L,"set_hp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,10);
      lua_pushliteral(L,"get_hp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lc_sub(L,-1,11);
      lua_remove(L,-2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 12);
    }
    else {
      
      /* elseif ent.health then */
      enum { lc175 = 12 };
      lua_pushliteral(L,"health");
      lua_gettable(L,12);
      const int lc176 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc176) {
        
        /* obj:punch(obj, 1.0, {
         * 				full_punch_interval = 1.0,
         * 				damage_groups = {fleshy = damage},
         * 			}, nil) */
        lua_pushvalue(L,10);
        lua_pushliteral(L,"punch");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,10);
        lua_pushnumber(L,1);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"full_punch_interval");
        lua_pushnumber(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"damage_groups");
        lua_createtable(L,0,1);
        lua_pushliteral(L,"fleshy");
        lua_pushvalue(L,11);
        lua_rawset(L,-3);
        lua_rawset(L,-3);
        lua_pushnil(L);
        lua_call(L,5,0);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc175);
    }
    lua_settop(L,lc173);
    assert(lua_gettop(L) == 12);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
  }
  lua_settop(L,lc171);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: follow_holding
 * function(self, clicker) */
static int lcf1_follow_holding (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local item = clicker:get_wielded_item() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get_wielded_item");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* local t = type(self.follow) */
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushliteral(L,"follow");
  lua_gettable(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* -- single item
   * if t == "string"
   * 	and item:get_name() == self.follow then */
  enum { lc177 = 4 };
  lua_pushvalue(L,4);
  lua_pushliteral(L,"string");
  const int lc178 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc178);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"follow");
    lua_gettable(L,1);
    const int lc179 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc179);
  }
  const int lc180 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc180) {
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* -- multiple items
     * 	elseif t == "table" then */
    enum { lc181 = 4 };
    lua_pushliteral(L,"table");
    const int lc182 = lua_equal(L,4,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc182);
    const int lc183 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc183) {
      
      /* for no = 1, #self.follow do */
      lua_pushnumber(L,1);
      lua_pushliteral(L,"follow");
      lua_gettable(L,1);
      const double lc187 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc187);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc184_var = lua_tonumber(L,-2);
      const double lc185_limit = lua_tonumber(L,-1);
      const double lc186_step = 1;
      lua_pop(L,2);
      enum { lc188 = 4 };
      while ((((lc186_step > 0) && (lc184_var <= lc185_limit)) || ((lc186_step <= 0) && (lc184_var >= lc185_limit)))) {
        
        /* internal: local no at index 5 */
        lua_pushnumber(L,lc184_var);
        
        /* if self.follow[no] == item:get_name() then */
        enum { lc189 = 5 };
        lua_pushliteral(L,"follow");
        lua_gettable(L,1);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,3);
        lua_pushliteral(L,"get_name");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        const int lc190 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc190);
        const int lc191 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc191) {
          
          /* return true */
          lua_pushboolean(L,1);
          return 1;
          assert(lua_gettop(L) == 5);
        }
        lua_settop(L,lc189);
        assert(lua_gettop(L) == 5);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc184_var += lc186_step;
      }
      lua_settop(L,lc188);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc181);
  }
  lua_settop(L,lc177);
  assert(lua_gettop(L) == 4);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* function(dtime) */
static int lcf233 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local mob = minetest.add_entity(pos, self.name) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"add_entity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,19);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 2);
  
  /* local ent2 = mob:get_luaentity() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get_luaentity");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* local textures = self.base_texture */
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_texture");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* if self.child_texture then */
  enum { lc231 = 4 };
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"child_texture");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc232 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc232) {
    
    /* textures = self.child_texture[1] */
    lc_getupvalue(L,lua_upvalueindex(1),1,18);
    lua_pushliteral(L,"child_texture");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc231);
  assert(lua_gettop(L) == 4);
  
  /* mob:set_properties({
   * 						textures = textures,
   * 						visual_size = {
   * 							x = self.base_size.x / 2,
   * 							y = self.base_size.y / 2
   * 						},
   * 						collisionbox = {
   * 							self.base_colbox[1] / 2,
   * 							self.base_colbox[2] / 2,
   * 							self.base_colbox[3] / 2,
   * 							self.base_colbox[4] / 2,
   * 							self.base_colbox[5] / 2,
   * 							self.base_colbox[6] / 2
   * 						},
   * 					}) */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"set_properties");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"textures");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual_size");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_size");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_size");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"collisionbox");
  lua_createtable(L,6,0);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,2);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,3);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,4);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,5);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,5);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,6);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* ent2.child = true */
  lua_pushboolean(L,1);
  lua_pushliteral(L,"child");
  lua_insert(L,-2);
  lua_settable(L,3);
  assert(lua_gettop(L) == 4);
  
  /* ent2.tamed = true */
  lua_pushboolean(L,1);
  lua_pushliteral(L,"tamed");
  lua_insert(L,-2);
  lua_settable(L,3);
  assert(lua_gettop(L) == 4);
  
  /* ent2.owner = self.owner */
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_pushliteral(L,"owner");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"owner");
  lua_insert(L,-2);
  lua_settable(L,3);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* name: breed
 * function(self) */
static int lcf1_breed (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc193 = 2 };
  assert((lua_gettop(L) == lc193));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,18);
  
  /* -- child take 240 seconds before growing into adult
   * if self.child == true then */
  enum { lc194 = 2 };
  lc_getupvalue(L,lc193,0,18);
  lua_pushliteral(L,"child");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc195 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc195);
  const int lc196 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc196) {
    
    /* self.hornytimer = self.hornytimer + 1 */
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"hornytimer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc193,0,18);
    lua_insert(L,-2);
    lua_pushliteral(L,"hornytimer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 2);
    
    /* if self.hornytimer > 240 then */
    enum { lc197 = 2 };
    lua_pushnumber(L,240);
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"hornytimer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc198 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc198);
    const int lc199 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc199) {
      
      /* self.child = false */
      lua_pushboolean(L,0);
      lc_getupvalue(L,lc193,0,18);
      lua_insert(L,-2);
      lua_pushliteral(L,"child");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
      
      /* self.hornytimer = 0 */
      lua_pushnumber(L,0);
      lc_getupvalue(L,lc193,0,18);
      lua_insert(L,-2);
      lua_pushliteral(L,"hornytimer");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
      
      /* self.object:set_properties({
       * 				textures = self.base_texture,
       * 				mesh = self.base_mesh,
       * 				visual_size = self.base_size,
       * 				collisionbox = self.base_colbox,
       * 			}) */
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"object");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"set_properties");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,4);
      lua_pushliteral(L,"textures");
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"base_texture");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"mesh");
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"base_mesh");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"visual_size");
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"base_size");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"collisionbox");
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"base_colbox");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 2);
      
      /* -- jump when fully grown so not to fall into ground
       * self.object:setvelocity({
       * 				x = 0,
       * 				y = self.jump_height,
       * 				z = 0
       * 			}) */
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"object");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"setvelocity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lc_getupvalue(L,lc193,0,18);
      lua_pushliteral(L,"jump_height");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc197);
    assert(lua_gettop(L) == 2);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc194);
  assert(lua_gettop(L) == 2);
  
  /* -- horny animal can mate for 40 seconds,
   * -- afterwards horny animal cannot mate again for 200 seconds
   * if self.horny == true
   * 	and self.hornytimer < 240 then */
  enum { lc200 = 2 };
  lc_getupvalue(L,lc193,0,18);
  lua_pushliteral(L,"horny");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc201 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc201);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"hornytimer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,240);
    const int lc202 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc202);
  }
  const int lc203 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc203) {
    
    /* self.hornytimer = self.hornytimer + 1 */
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"hornytimer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc193,0,18);
    lua_insert(L,-2);
    lua_pushliteral(L,"hornytimer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 2);
    
    /* if self.hornytimer >= 240 then */
    enum { lc204 = 2 };
    lua_pushnumber(L,240);
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"hornytimer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc205 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc205);
    const int lc206 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc206) {
      
      /* self.hornytimer = 0 */
      lua_pushnumber(L,0);
      lc_getupvalue(L,lc193,0,18);
      lua_insert(L,-2);
      lua_pushliteral(L,"hornytimer");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
      
      /* self.horny = false */
      lua_pushboolean(L,0);
      lc_getupvalue(L,lc193,0,18);
      lua_insert(L,-2);
      lua_pushliteral(L,"horny");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc204);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc200);
  assert(lua_gettop(L) == 2);
  
  /* -- find another same animal who is also horny and mate if close enough
   * if self.horny == true
   * 	and self.hornytimer <= 40 then */
  enum { lc207 = 2 };
  lc_getupvalue(L,lc193,0,18);
  lua_pushliteral(L,"horny");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc208 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc208);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"hornytimer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,40);
    const int lc209 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc209);
  }
  const int lc210 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc210) {
    
    /* local pos = self.object:getpos() */
    lc_newclosuretable(L,lc193);
    enum { lc211 = 3 };
    assert((lua_gettop(L) == lc211));
    lc_getupvalue(L,lc193,0,18);
    lua_pushliteral(L,"object");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_rawseti(L,lc211,19);
    assert(lua_gettop(L) == 3);
    
    /* effect({x = pos.x, y = pos.y + 1, z = pos.z}, 4, "heart.png") */
    lua_getfield(L,LUA_ENVIRONINDEX,"effect");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lc_getupvalue(L,lc211,0,19);
    lua_pushliteral(L,"x");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lc_getupvalue(L,lc211,0,19);
    lua_pushliteral(L,"y");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lc_getupvalue(L,lc211,0,19);
    lua_pushliteral(L,"z");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushnumber(L,4);
    lua_pushliteral(L,"heart.png");
    lua_call(L,3,0);
    assert(lua_gettop(L) == 3);
    
    /* local ents = minetest.get_objects_inside_radius(pos, 3) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_objects_inside_radius");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc211,0,19);
    lua_pushnumber(L,3);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 4);
    
    /* local num = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 5);
    
    /* local ent = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 6);
    
    /* for i, obj in pairs(ents) do
     * internal: local f, s, var = explist */
    enum { lc212 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    lua_pushvalue(L,4);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local i with idx 10
       * internal: local obj with idx 11 */
      
      
      /* ent = obj:get_luaentity() */
      lua_pushvalue(L,11);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_replace(L,6);
      assert(lua_gettop(L) == 11);
      
      /* -- check for same animal with different colour
       * local canmate = false */
      lua_pushboolean(L,0);
      assert(lua_gettop(L) == 12);
      
      /* if ent then */
      enum { lc213 = 12 };
      if (lua_toboolean(L,6)) {
        
        /* if ent.name == self.name then */
        enum { lc214 = 12 };
        lua_pushliteral(L,"name");
        lua_gettable(L,6);
        lc_getupvalue(L,lc211,1,18);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc215 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc215);
        const int lc216 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc216) {
          
          /* canmate = true */
          lua_pushboolean(L,1);
          lua_replace(L,12);
          assert(lua_gettop(L) == 12);
        }
        else {
          
          /* else
           * local entname = string.split(ent.name,":") */
          lua_getfield(L,LUA_ENVIRONINDEX,"string");
          lua_pushliteral(L,"split");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"name");
          lua_gettable(L,6);
          lua_pushliteral(L,":");
          lua_call(L,2,1);
          assert(lua_gettop(L) == 13);
          
          /* local selfname = string.split(self.name,":") */
          lua_getfield(L,LUA_ENVIRONINDEX,"string");
          lua_pushliteral(L,"split");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lc_getupvalue(L,lc211,1,18);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,":");
          lua_call(L,2,1);
          assert(lua_gettop(L) == 14);
          
          /* if entname[1] == selfname[1] then */
          enum { lc217 = 14 };
          lua_pushnumber(L,1);
          lua_gettable(L,13);
          lua_pushnumber(L,1);
          lua_gettable(L,14);
          const int lc218 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc218);
          const int lc219 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc219) {
            
            /* entname = string.split(entname[2],"_") */
            lua_getfield(L,LUA_ENVIRONINDEX,"string");
            lua_pushliteral(L,"split");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,2);
            lua_gettable(L,13);
            lua_pushliteral(L,"_");
            lua_call(L,2,1);
            lua_replace(L,13);
            assert(lua_gettop(L) == 14);
            
            /* selfname = string.split(selfname[2],"_") */
            lua_getfield(L,LUA_ENVIRONINDEX,"string");
            lua_pushliteral(L,"split");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,2);
            lua_gettable(L,14);
            lua_pushliteral(L,"_");
            lua_call(L,2,1);
            lua_replace(L,14);
            assert(lua_gettop(L) == 14);
            
            /* if entname[1] == selfname[1] then */
            enum { lc220 = 14 };
            lua_pushnumber(L,1);
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lua_gettable(L,14);
            const int lc221 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc221);
            const int lc222 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc222) {
              
              /* canmate = true */
              lua_pushboolean(L,1);
              lua_replace(L,12);
              assert(lua_gettop(L) == 14);
            }
            lua_settop(L,lc220);
            assert(lua_gettop(L) == 14);
          }
          lua_settop(L,lc217);
          assert(lua_gettop(L) == 14);
        }
        lua_settop(L,lc214);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc213);
      assert(lua_gettop(L) == 12);
      
      /* if ent
       * 			and canmate == true
       * 			and ent.horny == true
       * 			and ent.hornytimer <= 40 then */
      enum { lc223 = 12 };
      lua_pushvalue(L,6);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,12);
        lua_pushboolean(L,1);
        const int lc224 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc224);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"horny");
        lua_gettable(L,6);
        lua_pushboolean(L,1);
        const int lc225 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc225);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"hornytimer");
        lua_gettable(L,6);
        lua_pushnumber(L,40);
        const int lc226 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc226);
      }
      const int lc227 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc227) {
        
        /* num = num + 1 */
        lua_pushnumber(L,1);
        lc_add(L,5,-1);
        lua_remove(L,-2);
        lua_replace(L,5);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc223);
      assert(lua_gettop(L) == 12);
      
      /* -- found your mate? then have a baby
       * if num > 1 then */
      enum { lc228 = 12 };
      lua_pushnumber(L,1);
      const int lc229 = lua_lessthan(L,-1,5);
      lua_pop(L,1);
      lua_pushboolean(L,lc229);
      const int lc230 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc230) {
        
        /* self.hornytimer = 41 */
        lua_pushnumber(L,41);
        lc_getupvalue(L,lc211,1,18);
        lua_insert(L,-2);
        lua_pushliteral(L,"hornytimer");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 12);
        
        /* ent.hornytimer = 41 */
        lua_pushnumber(L,41);
        lua_pushliteral(L,"hornytimer");
        lua_insert(L,-2);
        lua_settable(L,6);
        assert(lua_gettop(L) == 12);
        
        /* -- spawn baby
         * minetest.after(5, function(dtime)
         * 
         * 					local mob = minetest.add_entity(pos, self.name)
         * 					local ent2 = mob:get_luaentity()
         * 					local textures = self.base_texture
         * 
         * 					if self.child_texture then
         * 						textures = self.child_texture[1]
         * 					end
         * 
         * 					mob:set_properties({
         * 						textures = textures,
         * 						visual_size = {
         * 							x = self.base_size.x / 2,
         * 							y = self.base_size.y / 2
         * 						},
         * 						collisionbox = {
         * 							self.base_colbox[1] / 2,
         * 							self.base_colbox[2] / 2,
         * 							self.base_colbox[3] / 2,
         * 							self.base_colbox[4] / 2,
         * 							self.base_colbox[5] / 2,
         * 							self.base_colbox[6] / 2
         * 						},
         * 					})
         * 					ent2.child = true
         * 					ent2.tamed = true
         * 					ent2.owner = self.owner
         * 				end) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"after");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,5);
        lua_pushvalue(L,lc211);
        lua_pushcclosure(L,lcf233,1);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 12);
        
        /* num = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,5);
        assert(lua_gettop(L) == 12);
        
        /* break */
        break;
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc228);
      assert(lua_gettop(L) == 12);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
    }
    lua_settop(L,lc212);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc207);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: replace
 * function(self, pos) */
static int lcf1_replace (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if self.replace_rate
   * 	and self.child == false
   * 	and math.random(1, self.replace_rate) == 1 then */
  enum { lc234 = 2 };
  lua_pushliteral(L,"replace_rate");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"child");
    lua_gettable(L,1);
    lua_pushboolean(L,0);
    const int lc235 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc235);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushliteral(L,"replace_rate");
    lua_gettable(L,1);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc236 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc236);
  }
  const int lc237 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc237) {
    
    /* local pos = self.object:getpos() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 3);
    
    /* pos.y = pos.y + self.replace_offset */
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"replace_offset");
    lua_gettable(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,3);
    assert(lua_gettop(L) == 3);
    
    /* -- print ("replace node = ".. minetest.get_node(pos).name, pos.y)
     * if self.replace_what
     * 		and self.replace_with
     * 		and self.object:getvelocity().y == 0
     * 		and #minetest.find_nodes_in_area(pos, pos, self.replace_what) > 0 then */
    enum { lc238 = 3 };
    lua_pushliteral(L,"replace_what");
    lua_gettable(L,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_with");
      lua_gettable(L,1);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"getvelocity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"y");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      const int lc239 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc239);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_nodes_in_area");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,3);
      lua_pushliteral(L,"replace_what");
      lua_gettable(L,1);
      lua_call(L,3,1);
      const double lc240 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc240);
      const int lc241 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc241);
    }
    const int lc242 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc242) {
      
      /* minetest.set_node(pos, {name = self.replace_with}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lua_pushliteral(L,"replace_with");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 3);
      
      /* -- when cow/sheep eats grass, replace wool and milk
       * if self.gotten == true then */
      enum { lc243 = 3 };
      lua_pushliteral(L,"gotten");
      lua_gettable(L,1);
      lua_pushboolean(L,1);
      const int lc244 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc244);
      const int lc245 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc245) {
        
        /* self.gotten = false */
        lua_pushboolean(L,0);
        lua_pushliteral(L,"gotten");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 3);
        
        /* self.object:set_properties(self) */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"set_properties");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L,lc243);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc238);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc234);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: day_docile
 * function(self) */
static int lcf1_day_docile (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if self.docile_by_day == false then */
  enum { lc246 = 1 };
  lua_pushliteral(L,"docile_by_day");
  lua_gettable(L,1);
  lua_pushboolean(L,0);
  const int lc247 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc247);
  const int lc248 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc248) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* elseif self.docile_by_day == true
     * 	and self.time_of_day > 0.2
     * 	and self.time_of_day < 0.8 then */
    enum { lc249 = 1 };
    lua_pushliteral(L,"docile_by_day");
    lua_gettable(L,1);
    lua_pushboolean(L,1);
    const int lc250 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc250);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,0.2);
      lua_pushliteral(L,"time_of_day");
      lua_gettable(L,1);
      const int lc251 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc251);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"time_of_day");
      lua_gettable(L,1);
      lua_pushnumber(L,0.8);
      const int lc252 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc252);
    }
    const int lc253 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc253) {
      
      /* return true */
      lua_pushboolean(L,1);
      return 1;
      assert(lua_gettop(L) == 1);
    }
    lua_settop(L,lc249);
  }
  lua_settop(L,lc246);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: smart_nssm
 * function(self, s, p, dist, dtime) */
static int lcf1_smart_nssm (lua_State * L) {
  lua_checkstack(L,23);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* local s1 = self.path.lastpos */
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_pushliteral(L,"lastpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 6);
  
  /* -- is it becoming stuck?
   * if math.abs(s1.x - s.x) + math.abs(s1.z - s.z) < 1.5 then */
  enum { lc254 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"abs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,6);
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"abs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,6);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1.5);
  const int lc255 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc255);
  const int lc256 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc256) {
    
    /* self.path.stuck_timer = self.path.stuck_timer + dtime */
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_pushliteral(L,"stuck_timer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_add(L,-1,5);
    lua_remove(L,-2);
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_insert(L,-2);
    lua_pushliteral(L,"stuck_timer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* else
     * self.path.stuck_timer = 0 */
    lua_pushnumber(L,0);
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_insert(L,-2);
    lua_pushliteral(L,"stuck_timer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc254);
  assert(lua_gettop(L) == 6);
  
  /* self.path.lastpos = {x = s.x, y = s.y, z = s.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"lastpos");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 6);
  
  /* -- im stuck, search for path
   * if (self.path.stuck_timer > stuck_timeout and not self.path.following)
   * 	or (self.path.stuck_timer > stuck_path_timeout
   * 	and self.path.following) then */
  enum { lc257 = 6 };
  lc_getupvalue(L,lua_upvalueindex(1),8,9);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_pushliteral(L,"stuck_timer");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc258 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc258);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_pushliteral(L,"following");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),7,10);
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_pushliteral(L,"stuck_timer");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc259 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc259);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"path");
      lua_gettable(L,1);
      lua_pushliteral(L,"following");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
  }
  const int lc260 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc260) {
    
    /* self.path.stuck_timer = 0 */
    lua_pushnumber(L,0);
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_insert(L,-2);
    lua_pushliteral(L,"stuck_timer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 6);
    
    /* -- lets try find a path, first take care of positions
     * -- since pathfinder is very sensitive
     * local sheight = self.collisionbox[5] - self.collisionbox[2] */
    lua_pushliteral(L,"collisionbox");
    lua_gettable(L,1);
    lua_pushnumber(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"collisionbox");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 7);
    
    /* -- round position to center of node to avoid stuck in walls
     * -- also adjust height for player models!
     * s.x = math.floor(s.x + 0.5) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,0.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 7);
    
    /* s.y = math.floor(s.y + 0.5) - sheight */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,0.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lc_sub(L,-1,7);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 7);
    
    /* s.z = math.floor(s.z + 0.5) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,0.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 7);
    
    /* local ssight, sground */
    lua_settop(L,(lua_gettop(L) + 2));
    assert(lua_gettop(L) == 9);
    
    /* ssight, sground = minetest.line_of_sight(s, {
     * 			x = s.x, y = s.y - 4, z = s.z}, 1) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"line_of_sight");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,4);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushnumber(L,1);
    lua_call(L,3,2);
    lua_replace(L,9);
    lua_replace(L,8);
    assert(lua_gettop(L) == 9);
    
    /* -- determine node above ground
     * if not ssight then */
    enum { lc261 = 9 };
    lua_pushboolean(L,!(lua_toboolean(L,8)));
    const int lc262 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc262) {
      
      /* s.y = sground.y + 1 */
      lua_pushliteral(L,"y");
      lua_gettable(L,9);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_insert(L,-2);
      lua_settable(L,2);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc261);
    assert(lua_gettop(L) == 9);
    
    /* local p1 = self.attack:getpos() */
    lua_pushliteral(L,"attack");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 10);
    
    /* p1.x = math.floor(p1.x + 0.5) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,10);
    lua_pushnumber(L,0.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 10);
    
    /* p1.y = math.floor(p1.y + 0.5) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,10);
    lua_pushnumber(L,0.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 10);
    
    /* p1.z = math.floor(p1.z + 0.5) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,10);
    lua_pushnumber(L,0.5);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 10);
    
    /* self.path.way = minetest.find_path(s, p1, 16, 2, 6, "Dijkstra") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"find_path");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_pushvalue(L,10);
    lua_pushnumber(L,16);
    lua_pushnumber(L,2);
    lua_pushnumber(L,6);
    lua_pushliteral(L,"Dijkstra");
    lua_call(L,6,1);
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_insert(L,-2);
    lua_pushliteral(L,"way");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 10);
    
    /* --"A*_noprefetch")
     * -- attempt to unstick mob that is "daydreaming"
     * self.object:setpos({
     * 			x = s.x + 0.1 * (math.random() * 2 - 1),
     * 			y = s.y + 1,
     * 			z = s.z + 0.1 * (math.random() * 2 - 1)
     * 		}) */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"setpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,0.1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushnumber(L,2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,0.1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushnumber(L,2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 10);
    
    /* self.state = "" */
    lua_pushliteral(L,"");
    lua_pushliteral(L,"state");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 10);
    
    /* do_attack(self, self.attack) */
    lua_getfield(L,LUA_ENVIRONINDEX,"do_attack");
    lua_pushvalue(L,1);
    lua_pushliteral(L,"attack");
    lua_gettable(L,1);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 10);
    
    /* -- no path found, try something else
     * if not self.path.way then */
    enum { lc263 = 10 };
    lua_pushliteral(L,"path");
    lua_gettable(L,1);
    lua_pushliteral(L,"way");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc264 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc264) {
      
      /* self.path.following = false */
      lua_pushboolean(L,0);
      lua_pushliteral(L,"path");
      lua_gettable(L,1);
      lua_insert(L,-2);
      lua_pushliteral(L,"following");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 10);
      
      /* --			self.path.stuck = true
       * -- lets make way by digging/building if not accessible
       * if enable_pathfind_digging then */
      enum { lc265 = 10 };
      lc_getupvalue(L,lua_upvalueindex(1),9,8);
      const int lc266 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc266) {
        
        /* -- add block and remove one block above so
         * -- there is room to jump if needed
         * if s.y < p1.y then */
        enum { lc267 = 10 };
        lua_pushliteral(L,"y");
        lua_gettable(L,2);
        lua_pushliteral(L,"y");
        lua_gettable(L,10);
        const int lc268 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc268);
        const int lc269 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc269) {
          
          /* if not minetest.is_protected(s, "") then */
          enum { lc270 = 10 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"is_protected");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,2);
          lua_pushliteral(L,"");
          lua_call(L,2,1);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc271 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc271) {
            
            /* minetest.set_node(s, {name = "default:dirt"}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"set_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,2);
            lua_createtable(L,0,1);
            lua_pushliteral(L,"name");
            lua_pushliteral(L,"default:dirt");
            lua_rawset(L,-3);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 10);
          }
          lua_settop(L,lc270);
          assert(lua_gettop(L) == 10);
          
          /* local sheight = math.ceil(self.collisionbox[5]) + 1 */
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"ceil");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"collisionbox");
          lua_gettable(L,1);
          lua_pushnumber(L,5);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 11);
          
          /* -- assume mob is 2 blocks high so it digs above its head
           * s.y = s.y + sheight */
          lua_pushliteral(L,"y");
          lua_gettable(L,2);
          lc_add(L,-1,11);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_insert(L,-2);
          lua_settable(L,2);
          assert(lua_gettop(L) == 11);
          
          /* if not minetest.is_protected(s, "") then */
          enum { lc272 = 11 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"is_protected");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,2);
          lua_pushliteral(L,"");
          lua_call(L,2,1);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc273 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc273) {
            
            /* local node1 = minetest.get_node(s).name */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"get_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,2);
            lua_call(L,1,1);
            lua_pushliteral(L,"name");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 12);
            
            /* if node1 ~= "air"
             * 						and node1 ~= "ignore" then */
            enum { lc274 = 12 };
            lua_pushliteral(L,"air");
            const int lc275 = lua_equal(L,12,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc275);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"ignore");
              const int lc276 = lua_equal(L,12,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc276);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc277 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc277) {
              
              /* minetest.set_node(s, {name = "air"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,2);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"air");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 12);
              
              /* minetest.add_item(s, ItemStack(node1)) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"add_item");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc278 = lua_gettop(L);
              lua_pushvalue(L,2);
              lua_getfield(L,LUA_ENVIRONINDEX,"ItemStack");
              lua_pushvalue(L,12);
              lua_call(L,1,LUA_MULTRET);
              lua_call(L,(lua_gettop(L) - lc278),0);
              assert(lua_gettop(L) == 12);
            }
            lua_settop(L,lc274);
            assert(lua_gettop(L) == 12);
          }
          lua_settop(L,lc272);
          assert(lua_gettop(L) == 11);
          
          /* s.y = s.y - sheight */
          lua_pushliteral(L,"y");
          lua_gettable(L,2);
          lc_sub(L,-1,11);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_insert(L,-2);
          lua_settable(L,2);
          assert(lua_gettop(L) == 11);
          
          /* self.object:setpos({x = s.x, y = s.y + 2, z = s.z}) */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"setpos");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,2);
          lua_pushnumber(L,2);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,2);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 11);
        }
        else {
          
          /* else
           * -- dig 2 blocks to make door toward player direction
           * local yaw1 = self.object:getyaw() + pi / 2 */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"getyaw");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lc_getupvalue(L,lua_upvalueindex(1),6,11);
          lua_pushnumber(L,2);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 11);
          
          /* local p1 = {
           * 						x = s.x + math.cos(yaw1),
           * 						y = s.y,
           * 						z = s.z + math.sin(yaw1)
           * 					} */
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,2);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"cos");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,11);
          lua_call(L,1,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,2);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"sin");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,11);
          lua_call(L,1,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          assert(lua_gettop(L) == 12);
          
          /* if not minetest.is_protected(p1, "") then */
          enum { lc279 = 12 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"is_protected");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,12);
          lua_pushliteral(L,"");
          lua_call(L,2,1);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc280 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc280) {
            
            /* local node1 = minetest.get_node(p1).name */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"get_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,12);
            lua_call(L,1,1);
            lua_pushliteral(L,"name");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 13);
            
            /* if node1 ~= "air"
             * 						and node1 ~= "ignore" then */
            enum { lc281 = 13 };
            lua_pushliteral(L,"air");
            const int lc282 = lua_equal(L,13,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc282);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"ignore");
              const int lc283 = lua_equal(L,13,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc283);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc284 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc284) {
              
              /* minetest.add_item(p1, ItemStack(node1)) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"add_item");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc285 = lua_gettop(L);
              lua_pushvalue(L,12);
              lua_getfield(L,LUA_ENVIRONINDEX,"ItemStack");
              lua_pushvalue(L,13);
              lua_call(L,1,LUA_MULTRET);
              lua_call(L,(lua_gettop(L) - lc285),0);
              assert(lua_gettop(L) == 13);
              
              /* minetest.set_node(p1, {name = "air"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"air");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 13);
            }
            lua_settop(L,lc281);
            assert(lua_gettop(L) == 13);
            
            /* p1.y = p1.y + 1 */
            lua_pushliteral(L,"y");
            lua_gettable(L,12);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"y");
            lua_insert(L,-2);
            lua_settable(L,12);
            assert(lua_gettop(L) == 13);
            
            /* node1 = minetest.get_node(p1).name */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"get_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,12);
            lua_call(L,1,1);
            lua_pushliteral(L,"name");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_replace(L,13);
            assert(lua_gettop(L) == 13);
            
            /* if node1 ~= "air"
             * 						and node1 ~= "ignore" then */
            enum { lc286 = 13 };
            lua_pushliteral(L,"air");
            const int lc287 = lua_equal(L,13,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc287);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"ignore");
              const int lc288 = lua_equal(L,13,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc288);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc289 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc289) {
              
              /* minetest.add_item(p1, ItemStack(node1)) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"add_item");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc290 = lua_gettop(L);
              lua_pushvalue(L,12);
              lua_getfield(L,LUA_ENVIRONINDEX,"ItemStack");
              lua_pushvalue(L,13);
              lua_call(L,1,LUA_MULTRET);
              lua_call(L,(lua_gettop(L) - lc290),0);
              assert(lua_gettop(L) == 13);
              
              /* minetest.set_node(p1, {name = "air"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"air");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 13);
            }
            lua_settop(L,lc286);
            assert(lua_gettop(L) == 13);
          }
          lua_settop(L,lc279);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc267);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc265);
      assert(lua_gettop(L) == 10);
      
      /* -- will try again in 2 second
       * self.path.stuck_timer = stuck_timeout - 2 */
      lc_getupvalue(L,lua_upvalueindex(1),8,9);
      lua_pushnumber(L,2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"path");
      lua_gettable(L,1);
      lua_insert(L,-2);
      lua_pushliteral(L,"stuck_timer");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 10);
      
      /* -- frustration! cant find the damn path :(
       * if self.sounds.random then */
      enum { lc291 = 10 };
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc292 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc292) {
        
        /* minetest.sound_play(self.sounds.random, {
         * 					object = self.object,
         * 					max_hear_distance = self.sounds.distance
         * 				}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"sound_play");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"sounds");
        lua_gettable(L,1);
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"object");
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"max_hear_distance");
        lua_pushliteral(L,"sounds");
        lua_gettable(L,1);
        lua_pushliteral(L,"distance");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc291);
      assert(lua_gettop(L) == 10);
    }
    else {
      
      /* else
       * -- yay i found path
       * if self.sounds.attack then */
      enum { lc293 = 10 };
      lua_pushliteral(L,"sounds");
      lua_gettable(L,1);
      lua_pushliteral(L,"attack");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc294 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc294) {
        
        /* set_velocity(self, self.walk_velocity) */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"walk_velocity");
        lua_gettable(L,1);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 10);
        
        /* minetest.sound_play(self.sounds.attack, {
         * 					object = self.object,
         * 					max_hear_distance = self.sounds.distance
         * 				}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"sound_play");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"sounds");
        lua_gettable(L,1);
        lua_pushliteral(L,"attack");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"object");
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"max_hear_distance");
        lua_pushliteral(L,"sounds");
        lua_gettable(L,1);
        lua_pushliteral(L,"distance");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc293);
      assert(lua_gettop(L) == 10);
      
      /* -- follow path now that it has it
       * self.path.following = true */
      lua_pushboolean(L,1);
      lua_pushliteral(L,"path");
      lua_gettable(L,1);
      lua_insert(L,-2);
      lua_pushliteral(L,"following");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc263);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc257);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* function(self, dtime) */
static int lcf670 (lua_State * L) {
  lua_checkstack(L,28);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* local yaw = self.object:getyaw() or 0 */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  assert(lua_gettop(L) == 4);
  
  /* if self.metatimer == 0 then */
  enum { lc296 = 4 };
  lua_pushliteral(L,"metatimer");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc297 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc297);
  const int lc298 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc298) {
    
    /* self.metatimer = os.time() */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"time");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushliteral(L,"metatimer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc296);
  assert(lua_gettop(L) == 4);
  
  /* -- when lifetimer expires remove mob (except npc and tamed)
   * if self.type ~= "npc"
   * 		and not self.tamed
   * 		and self.state ~= "attack" then */
  enum { lc299 = 4 };
  lua_pushliteral(L,"type");
  lua_gettable(L,1);
  lua_pushliteral(L,"npc");
  const int lc300 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc300);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"tamed");
    lua_gettable(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc301 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc301);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc302 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc302) {
    
    /* self.lifetimer = self.lifetimer - dtime */
    lua_pushliteral(L,"lifetimer");
    lua_gettable(L,1);
    lc_sub(L,-1,2);
    lua_remove(L,-2);
    lua_pushliteral(L,"lifetimer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
    
    /* if self.lifetimer <= 0 then */
    enum { lc303 = 4 };
    lua_pushliteral(L,"lifetimer");
    lua_gettable(L,1);
    lua_pushnumber(L,0);
    const int lc304 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc304);
    const int lc305 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc305) {
      
      /* -- only despawn away from player
       * local objs = minetest.get_objects_inside_radius(pos, 10) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_objects_inside_radius");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushnumber(L,10);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 5);
      
      /* for _,oir in pairs(objs) do
       * internal: local f, s, var = explist */
      enum { lc306 = 5 };
      lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
      lua_pushvalue(L,5);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local _ with idx 9
         * internal: local oir with idx 10 */
        
        
        /* if oir:is_player() then */
        enum { lc307 = 10 };
        lua_pushvalue(L,10);
        lua_pushliteral(L,"is_player");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        const int lc308 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc308) {
          
          /* self.lifetimer = 20 */
          lua_pushnumber(L,20);
          lua_pushliteral(L,"lifetimer");
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 10);
          
          /* return */
          return 0;
          assert(lua_gettop(L) == 10);
        }
        lua_settop(L,lc307);
        assert(lua_gettop(L) == 10);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc306);
      assert(lua_gettop(L) == 5);
      
      /* minetest.log("action",
       * 					"lifetimer expired, removed " .. self.name) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"action");
      lua_pushliteral(L,"lifetimer expired, removed ");
      lua_pushliteral(L,"name");
      lua_gettable(L,1);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 5);
      
      /* effect(pos, 15, "tnt_smoke.png") */
      lua_getfield(L,LUA_ENVIRONINDEX,"effect");
      lua_pushvalue(L,3);
      lua_pushnumber(L,15);
      lua_pushliteral(L,"tnt_smoke.png");
      lua_call(L,3,0);
      assert(lua_gettop(L) == 5);
      
      /* self.object:remove() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"remove");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 5);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc303);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc299);
  assert(lua_gettop(L) == 4);
  
  /* if not self.fly then */
  enum { lc309 = 4 };
  lua_pushliteral(L,"fly");
  lua_gettable(L,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc310 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc310) {
    
    /* -- floating in water (or falling)
     * local v = self.object:getvelocity() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 5);
    
    /* -- going up then apply gravity
     * if v.y > 0.1 then */
    enum { lc311 = 5 };
    lua_pushnumber(L,0.1);
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    const int lc312 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc312);
    const int lc313 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc313) {
      
      /* self.object:setacceleration({
       * 					x = 0,
       * 					y = self.fall_speed,
       * 					z = 0
       * 				}) */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"setacceleration");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"fall_speed");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc311);
    assert(lua_gettop(L) == 5);
    
    /* -- in water then float up
     * if minetest.registered_nodes[node_ok(pos).name].groups.liquid then */
    enum { lc314 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lua_upvalueindex(1),3,15);
    lua_pushvalue(L,3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"groups");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"liquid");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc315 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc315) {
      
      /* -- water then
       * if self.floats == 1 then */
      enum { lc316 = 5 };
      lua_pushliteral(L,"floats");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      const int lc317 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc317);
      const int lc318 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc318) {
        
        /* self.object:setacceleration({
         * 						x = 0,
         * 						y = -self.fall_speed / (math.max(1, v.y) ^ 2),
         * 						z = 0
         * 					}) */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"setacceleration");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushnumber(L,0);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"fall_speed");
        lua_gettable(L,1);
        lc_unm(L,-1);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"max");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushliteral(L,"y");
        lua_gettable(L,5);
        lua_call(L,2,1);
        lua_pushnumber(L,2);
        lc_pow(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushnumber(L,0);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc316);
      assert(lua_gettop(L) == 5);
    }
    else {
      
      /* else
       * -- fall downwards
       * self.object:setacceleration({
       * 					x = 0,
       * 					y = self.fall_speed,
       * 					z = 0
       * 				}) */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"setacceleration");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"fall_speed");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 5);
      
      /* -- fall damage
       * if self.fall_damage == 1
       * 				and self.object:getvelocity().y == 0 then */
      enum { lc319 = 5 };
      lua_pushliteral(L,"fall_damage");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      const int lc320 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc320);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"getvelocity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"y");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0);
        const int lc321 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc321);
      }
      const int lc322 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc322) {
        
        /* local d = self.old_y - self.object:getpos().y */
        lua_pushliteral(L,"old_y");
        lua_gettable(L,1);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"y");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 6);
        
        /* if d > 5 then */
        enum { lc323 = 6 };
        lua_pushnumber(L,5);
        const int lc324 = lua_lessthan(L,-1,6);
        lua_pop(L,1);
        lua_pushboolean(L,lc324);
        const int lc325 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc325) {
          
          /* --self.object:set_hp(self.object:get_hp() - math.floor(d - 5))
           * self.health = self.health - math.floor(d - 5) */
          lua_pushliteral(L,"health");
          lua_gettable(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"floor");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,5);
          lc_sub(L,6,-1);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"health");
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 6);
          
          /* effect(pos, 5, "tnt_smoke.png") */
          lua_getfield(L,LUA_ENVIRONINDEX,"effect");
          lua_pushvalue(L,3);
          lua_pushnumber(L,5);
          lua_pushliteral(L,"tnt_smoke.png");
          lua_call(L,3,0);
          assert(lua_gettop(L) == 6);
          
          /* if check_for_death(self) then */
          enum { lc326 = 6 };
          lua_getfield(L,LUA_ENVIRONINDEX,"check_for_death");
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          const int lc327 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc327) {
            
            /* return */
            return 0;
            assert(lua_gettop(L) == 6);
          }
          lua_settop(L,lc326);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc323);
        assert(lua_gettop(L) == 6);
        
        /* self.old_y = self.object:getpos().y */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"y");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"old_y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc319);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc314);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc309);
  assert(lua_gettop(L) == 4);
  
  /* -- knockback timer
   * if self.pause_timer > 0 then */
  enum { lc328 = 4 };
  lua_pushnumber(L,0);
  lua_pushliteral(L,"pause_timer");
  lua_gettable(L,1);
  const int lc329 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc329);
  const int lc330 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc330) {
    
    /* self.pause_timer = self.pause_timer - dtime */
    lua_pushliteral(L,"pause_timer");
    lua_gettable(L,1);
    lc_sub(L,-1,2);
    lua_remove(L,-2);
    lua_pushliteral(L,"pause_timer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
    
    /* if self.pause_timer < 1 then */
    enum { lc331 = 4 };
    lua_pushliteral(L,"pause_timer");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    const int lc332 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc332);
    const int lc333 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc333) {
      
      /* self.pause_timer = 0 */
      lua_pushnumber(L,0);
      lua_pushliteral(L,"pause_timer");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc331);
    assert(lua_gettop(L) == 4);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc328);
  assert(lua_gettop(L) == 4);
  
  /* -- attack timer
   * self.timer = self.timer + dtime */
  lua_pushliteral(L,"timer");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushliteral(L,"timer");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 4);
  
  /* if self.state ~= "attack" then */
  enum { lc334 = 4 };
  lua_pushliteral(L,"state");
  lua_gettable(L,1);
  lua_pushliteral(L,"attack");
  const int lc335 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc335);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc336 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc336) {
    
    /* if self.timer < 1 then */
    enum { lc337 = 4 };
    lua_pushliteral(L,"timer");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    const int lc338 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc338);
    const int lc339 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc339) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc337);
    assert(lua_gettop(L) == 4);
    
    /* self.timer = 0 */
    lua_pushnumber(L,0);
    lua_pushliteral(L,"timer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc334);
  assert(lua_gettop(L) == 4);
  
  /* -- never go over 100
   * if self.timer > 100 then */
  enum { lc340 = 4 };
  lua_pushnumber(L,100);
  lua_pushliteral(L,"timer");
  lua_gettable(L,1);
  const int lc341 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc341);
  const int lc342 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc342) {
    
    /* self.timer = 1 */
    lua_pushnumber(L,1);
    lua_pushliteral(L,"timer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc340);
  assert(lua_gettop(L) == 4);
  
  /* -- node replace check (cow eats grass etc.)
   * replace(self, pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"replace");
  lua_pushvalue(L,1);
  lua_pushvalue(L,3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* -- mob plays random sound at times
   * if self.sounds.random
   * 		and math.random(1, 100) == 1 then */
  enum { lc343 = 4 };
  lua_pushliteral(L,"sounds");
  lua_gettable(L,1);
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,100);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc344 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc344);
  }
  const int lc345 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc345) {
    
    /* minetest.sound_play(self.sounds.random, {
     * 				object = self.object,
     * 				max_hear_distance = self.sounds.distance
     * 			}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"sound_play");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sounds");
    lua_gettable(L,1);
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"object");
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_hear_distance");
    lua_pushliteral(L,"sounds");
    lua_gettable(L,1);
    lua_pushliteral(L,"distance");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc343);
  assert(lua_gettop(L) == 4);
  
  /* -- environmental damage timer (every 1 second)
   * self.env_damage_timer = self.env_damage_timer + dtime */
  lua_pushliteral(L,"env_damage_timer");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushliteral(L,"env_damage_timer");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 4);
  
  /* if (self.state == "attack" and self.env_damage_timer > 1)
   * 		or self.state ~= "attack" then */
  enum { lc346 = 4 };
  lua_pushliteral(L,"state");
  lua_gettable(L,1);
  lua_pushliteral(L,"attack");
  const int lc347 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc347);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
    lua_pushliteral(L,"env_damage_timer");
    lua_gettable(L,1);
    const int lc348 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc348);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc349 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc349);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc350 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc350) {
    
    /* self.env_damage_timer = 0 */
    lua_pushnumber(L,0);
    lua_pushliteral(L,"env_damage_timer");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
    
    /* do_env_damage(self) */
    lua_getfield(L,LUA_ENVIRONINDEX,"do_env_damage");
    lua_pushvalue(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
    
    /* -- custom function (defined in mob lua file)
     * if self.do_custom then */
    enum { lc351 = 4 };
    lua_pushliteral(L,"do_custom");
    lua_gettable(L,1);
    const int lc352 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc352) {
      
      /* self.do_custom(self) */
      lua_pushliteral(L,"do_custom");
      lua_gettable(L,1);
      lua_pushvalue(L,1);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc351);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc346);
  assert(lua_gettop(L) == 4);
  
  /* -- find someone to attack
   * if self.type == "monster"
   * 		and damage_enabled
   * 		and self.state ~= "attack"
   * 		and not day_docile(self) then */
  enum { lc353 = 4 };
  lua_pushliteral(L,"type");
  lua_gettable(L,1);
  lua_pushliteral(L,"monster");
  const int lc354 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc354);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),17,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc355 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc355);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"day_docile");
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc356 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc356) {
    
    /* local s = self.object:getpos() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 5);
    
    /* local p, sp, dist */
    lua_settop(L,(lua_gettop(L) + 3));
    assert(lua_gettop(L) == 8);
    
    /* local player = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 9);
    
    /* local type = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 10);
    
    /* local obj = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 11);
    
    /* local min_dist = self.view_range + 1 */
    lua_pushliteral(L,"view_range");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 12);
    
    /* local min_player = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 13);
    
    /* for _,oir in pairs(minetest.get_objects_inside_radius(s, self.view_range)) do
     * internal: local f, s, var = explist */
    enum { lc357 = 13 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    const int lc358 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_objects_inside_radius");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_pushliteral(L,"view_range");
    lua_gettable(L,1);
    lua_call(L,2,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc358),3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 17
       * internal: local oir with idx 18 */
      
      
      /* if oir:is_player() then */
      enum { lc359 = 18 };
      lua_pushvalue(L,18);
      lua_pushliteral(L,"is_player");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      const int lc360 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc360) {
        
        /* player = oir */
        lua_pushvalue(L,18);
        lua_replace(L,9);
        assert(lua_gettop(L) == 18);
        
        /* type = "player" */
        lua_pushliteral(L,"player");
        lua_replace(L,10);
        assert(lua_gettop(L) == 18);
      }
      else {
        
        /* else
         * obj = oir:get_luaentity() */
        lua_pushvalue(L,18);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_replace(L,11);
        assert(lua_gettop(L) == 18);
        
        /* if obj then */
        enum { lc361 = 18 };
        if (lua_toboolean(L,11)) {
          
          /* player = obj.object */
          lua_pushliteral(L,"object");
          lua_gettable(L,11);
          lua_replace(L,9);
          assert(lua_gettop(L) == 18);
          
          /* type = obj.type */
          lua_pushliteral(L,"type");
          lua_gettable(L,11);
          lua_replace(L,10);
          assert(lua_gettop(L) == 18);
        }
        lua_settop(L,lc361);
        assert(lua_gettop(L) == 18);
      }
      lua_settop(L,lc359);
      assert(lua_gettop(L) == 18);
      
      /* if type == "player"
       * 				or type == "npc" then */
      enum { lc362 = 18 };
      lua_pushvalue(L,10);
      lua_pushliteral(L,"player");
      const int lc363 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc363);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
        lua_pushliteral(L,"npc");
        const int lc364 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc364);
      }
      const int lc365 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc365) {
        
        /* s = self.object:getpos() */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_replace(L,5);
        assert(lua_gettop(L) == 18);
        
        /* p = player:getpos() */
        lua_pushvalue(L,9);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_replace(L,6);
        assert(lua_gettop(L) == 18);
        
        /* sp = s */
        lua_pushvalue(L,5);
        lua_replace(L,7);
        assert(lua_gettop(L) == 18);
        
        /* -- aim higher to make looking up hills more realistic
         * p.y = p.y + 1 */
        lua_pushliteral(L,"y");
        lua_gettable(L,6);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,6);
        assert(lua_gettop(L) == 18);
        
        /* sp.y = sp.y + 1 */
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 18);
        
        /* dist = get_distance(p, s) */
        lc_getupvalue(L,lua_upvalueindex(1),2,16);
        lua_pushvalue(L,6);
        lua_pushvalue(L,5);
        lua_call(L,2,1);
        lua_replace(L,8);
        assert(lua_gettop(L) == 18);
        
        /* if dist < self.view_range then */
        enum { lc366 = 18 };
        lua_pushliteral(L,"view_range");
        lua_gettable(L,1);
        const int lc367 = lua_lessthan(L,8,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc367);
        const int lc368 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc368) {
          
          /* -- field of view check goes here
           * -- choose closest player to attack
           * --if minetest.line_of_sight(sp, p, 2) == true
           * if line_of_sight_water(self, sp, p, 2) == true
           * 						and dist < min_dist then */
          enum { lc369 = 18 };
          lua_getfield(L,LUA_ENVIRONINDEX,"line_of_sight_water");
          lua_pushvalue(L,1);
          lua_pushvalue(L,7);
          lua_pushvalue(L,6);
          lua_pushnumber(L,2);
          lua_call(L,4,1);
          lua_pushboolean(L,1);
          const int lc370 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc370);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            const int lc371 = lua_lessthan(L,8,12);
            lua_pushboolean(L,lc371);
          }
          const int lc372 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc372) {
            
            /* min_dist = dist */
            lua_pushvalue(L,8);
            lua_replace(L,12);
            assert(lua_gettop(L) == 18);
            
            /* min_player = player */
            lua_pushvalue(L,9);
            lua_replace(L,13);
            assert(lua_gettop(L) == 18);
          }
          lua_settop(L,lc369);
          assert(lua_gettop(L) == 18);
        }
        lua_settop(L,lc366);
        assert(lua_gettop(L) == 18);
      }
      lua_settop(L,lc362);
      assert(lua_gettop(L) == 18);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc357);
    assert(lua_gettop(L) == 13);
    
    /* -- attack player
     * if min_player then */
    enum { lc373 = 13 };
    if (lua_toboolean(L,13)) {
      
      /* do_attack(self, min_player) */
      lua_getfield(L,LUA_ENVIRONINDEX,"do_attack");
      lua_pushvalue(L,1);
      lua_pushvalue(L,13);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 13);
    }
    lua_settop(L,lc373);
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc353);
  assert(lua_gettop(L) == 4);
  
  /* -- npc, find closest monster to attack
   * local min_dist = self.view_range + 1 */
  lua_pushliteral(L,"view_range");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* local min_player = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 6);
  
  /* if self.type == "npc"
   * 		and self.attacks_monsters
   * 		and self.state ~= "attack" then */
  enum { lc374 = 6 };
  lua_pushliteral(L,"type");
  lua_gettable(L,1);
  lua_pushliteral(L,"npc");
  const int lc375 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc375);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"attacks_monsters");
    lua_gettable(L,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc376 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc376);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc377 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc377) {
    
    /* local s = self.object:getpos() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 7);
    
    /* local obj = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 8);
    
    /* for _, oir in pairs(minetest.get_objects_inside_radius(s, self.view_range)) do
     * internal: local f, s, var = explist */
    enum { lc378 = 8 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    const int lc379 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_objects_inside_radius");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"view_range");
    lua_gettable(L,1);
    lua_call(L,2,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc379),3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 12
       * internal: local oir with idx 13 */
      
      
      /* obj = oir:get_luaentity() */
      lua_pushvalue(L,13);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_replace(L,8);
      assert(lua_gettop(L) == 13);
      
      /* if obj
       * 				and obj.type == "monster" then */
      enum { lc380 = 13 };
      lua_pushvalue(L,8);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"type");
        lua_gettable(L,8);
        lua_pushliteral(L,"monster");
        const int lc381 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc381);
      }
      const int lc382 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc382) {
        
        /* -- attack monster
         * p = obj.object:getpos() */
        lua_pushliteral(L,"object");
        lua_gettable(L,8);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_setfield(L,LUA_ENVIRONINDEX,"p");
        assert(lua_gettop(L) == 13);
        
        /* dist = get_distance(p, s) */
        lc_getupvalue(L,lua_upvalueindex(1),2,16);
        lua_getfield(L,LUA_ENVIRONINDEX,"p");
        lua_pushvalue(L,7);
        lua_call(L,2,1);
        lua_setfield(L,LUA_ENVIRONINDEX,"dist");
        assert(lua_gettop(L) == 13);
        
        /* if dist < min_dist then */
        enum { lc383 = 13 };
        lua_getfield(L,LUA_ENVIRONINDEX,"dist");
        const int lc384 = lua_lessthan(L,-1,5);
        lua_pop(L,1);
        lua_pushboolean(L,lc384);
        const int lc385 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc385) {
          
          /* min_dist = dist */
          lua_getfield(L,LUA_ENVIRONINDEX,"dist");
          lua_replace(L,5);
          assert(lua_gettop(L) == 13);
          
          /* min_player = obj.object */
          lua_pushliteral(L,"object");
          lua_gettable(L,8);
          lua_replace(L,6);
          assert(lua_gettop(L) == 13);
        }
        lua_settop(L,lc383);
        assert(lua_gettop(L) == 13);
      }
      lua_settop(L,lc380);
      assert(lua_gettop(L) == 13);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc378);
    assert(lua_gettop(L) == 8);
    
    /* if min_player then */
    enum { lc386 = 8 };
    if (lua_toboolean(L,6)) {
      
      /* do_attack(self, min_player) */
      lua_getfield(L,LUA_ENVIRONINDEX,"do_attack");
      lua_pushvalue(L,1);
      lua_pushvalue(L,6);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc386);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc374);
  assert(lua_gettop(L) == 6);
  
  /* -- breed and grow children
   * breed(self) */
  lc_getupvalue(L,lua_upvalueindex(1),1,17);
  lua_pushvalue(L,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 6);
  
  /* -- find player to follow
   * if (self.follow ~= ""
   * 		or self.order == "follow")
   * 		and not self.following
   * 		and self.state ~= "attack"
   * 		and self.state ~= "runaway" then */
  enum { lc387 = 6 };
  lua_pushliteral(L,"follow");
  lua_gettable(L,1);
  lua_pushliteral(L,"");
  const int lc388 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc388);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"order");
    lua_gettable(L,1);
    lua_pushliteral(L,"follow");
    const int lc389 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc389);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"following");
    lua_gettable(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc390 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc390);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"runaway");
    const int lc391 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc391);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc392 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc392) {
    
    /* local s, p, dist */
    lua_settop(L,(lua_gettop(L) + 3));
    assert(lua_gettop(L) == 9);
    
    /* for _,player in pairs(minetest.get_connected_players()) do
     * internal: local f, s, var = explist */
    enum { lc393 = 9 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    const int lc394 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_connected_players");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc394),3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 13
       * internal: local player with idx 14 */
      
      
      /* s = self.object:getpos() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_replace(L,7);
      assert(lua_gettop(L) == 14);
      
      /* p = player:getpos() */
      lua_pushvalue(L,14);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_replace(L,8);
      assert(lua_gettop(L) == 14);
      
      /* dist = get_distance(p, s) */
      lc_getupvalue(L,lua_upvalueindex(1),2,16);
      lua_pushvalue(L,8);
      lua_pushvalue(L,7);
      lua_call(L,2,1);
      lua_replace(L,9);
      assert(lua_gettop(L) == 14);
      
      /* if dist < self.view_range then */
      enum { lc395 = 14 };
      lua_pushliteral(L,"view_range");
      lua_gettable(L,1);
      const int lc396 = lua_lessthan(L,9,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc396);
      const int lc397 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc397) {
        
        /* self.following = player */
        lua_pushvalue(L,14);
        lua_pushliteral(L,"following");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 14);
        
        /* break */
        break;
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L,lc395);
      assert(lua_gettop(L) == 14);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc393);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc387);
  assert(lua_gettop(L) == 6);
  
  /* if self.type == "npc"
   * 		and self.order == "follow"
   * 		and self.state ~= "attack"
   * 		and self.owner ~= "" then */
  enum { lc398 = 6 };
  lua_pushliteral(L,"type");
  lua_gettable(L,1);
  lua_pushliteral(L,"npc");
  const int lc399 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc399);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"order");
    lua_gettable(L,1);
    lua_pushliteral(L,"follow");
    const int lc400 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc400);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"attack");
    const int lc401 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc401);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"owner");
    lua_gettable(L,1);
    lua_pushliteral(L,"");
    const int lc402 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc402);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc403 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc403) {
    
    /* -- npc stop following player if not owner
     * if self.following
     * 			and self.owner
     * 			and self.owner ~= self.following:get_player_name() then */
    enum { lc404 = 6 };
    lua_pushliteral(L,"following");
    lua_gettable(L,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"owner");
      lua_gettable(L,1);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"owner");
      lua_gettable(L,1);
      lua_pushliteral(L,"following");
      lua_gettable(L,1);
      lua_pushliteral(L,"get_player_name");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      const int lc405 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc405);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc406 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc406) {
      
      /* self.following = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"following");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc404);
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* else
     * -- stop following player if not holding specific item
     * if self.following
     * 			and self.following:is_player()
     * 			and follow_holding(self, self.following) == false then */
    enum { lc407 = 6 };
    lua_pushliteral(L,"following");
    lua_gettable(L,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"following");
      lua_gettable(L,1);
      lua_pushliteral(L,"is_player");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"follow_holding");
      lua_pushvalue(L,1);
      lua_pushliteral(L,"following");
      lua_gettable(L,1);
      lua_call(L,2,1);
      lua_pushboolean(L,0);
      const int lc408 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc408);
    }
    const int lc409 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc409) {
      
      /* self.following = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"following");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc407);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc398);
  assert(lua_gettop(L) == 6);
  
  /* -- follow that thing
   * if self.following then */
  enum { lc410 = 6 };
  lua_pushliteral(L,"following");
  lua_gettable(L,1);
  const int lc411 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc411) {
    
    /* local s = self.object:getpos() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 7);
    
    /* local p */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 8);
    
    /* if self.following:is_player() then */
    enum { lc412 = 8 };
    lua_pushliteral(L,"following");
    lua_gettable(L,1);
    lua_pushliteral(L,"is_player");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    const int lc413 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc413) {
      
      /* p = self.following:getpos() */
      lua_pushliteral(L,"following");
      lua_gettable(L,1);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_replace(L,8);
      assert(lua_gettop(L) == 8);
    }
    else {
      
      /* elseif self.following.object then */
      enum { lc414 = 8 };
      lua_pushliteral(L,"following");
      lua_gettable(L,1);
      lua_pushliteral(L,"object");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc415 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc415) {
        
        /* p = self.following.object:getpos() */
        lua_pushliteral(L,"following");
        lua_gettable(L,1);
        lua_pushliteral(L,"object");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_replace(L,8);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc414);
    }
    lua_settop(L,lc412);
    assert(lua_gettop(L) == 8);
    
    /* if p then */
    enum { lc416 = 8 };
    if (lua_toboolean(L,8)) {
      
      /* local dist = get_distance(p, s) */
      lc_getupvalue(L,lua_upvalueindex(1),2,16);
      lua_pushvalue(L,8);
      lua_pushvalue(L,7);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 9);
      
      /* -- dont follow if out of range
       * if dist > self.view_range then */
      enum { lc417 = 9 };
      lua_pushliteral(L,"view_range");
      lua_gettable(L,1);
      const int lc418 = lua_lessthan(L,-1,9);
      lua_pop(L,1);
      lua_pushboolean(L,lc418);
      const int lc419 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc419) {
        
        /* self.following = nil */
        lua_pushnil(L);
        lua_pushliteral(L,"following");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* else
         * local vec = {
         * 						x = p.x - s.x,
         * 						y = p.y - s.y,
         * 						z = p.z - s.z
         * 					} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,8);
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,8);
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,8);
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 10);
        
        /* if vec.x ~= 0
         * 					and vec.z ~= 0 then */
        enum { lc420 = 10 };
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lua_pushnumber(L,0);
        const int lc421 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc421);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"z");
          lua_gettable(L,10);
          lua_pushnumber(L,0);
          const int lc422 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc422);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc423 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc423) {
          
          /* yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate */
          lc_getupvalue(L,lua_upvalueindex(1),5,13);
          lua_pushliteral(L,"z");
          lua_gettable(L,10);
          lua_pushliteral(L,"x");
          lua_gettable(L,10);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lc_getupvalue(L,lua_upvalueindex(1),7,11);
          lua_pushnumber(L,2);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"rotate");
          lua_gettable(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,4);
          assert(lua_gettop(L) == 10);
          
          /* if p.x > s.x then */
          enum { lc424 = 10 };
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lua_pushliteral(L,"x");
          lua_gettable(L,8);
          const int lc425 = lua_lessthan(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc425);
          const int lc426 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc426) {
            
            /* yaw = yaw + pi */
            lc_getupvalue(L,lua_upvalueindex(1),7,11);
            lc_add(L,4,-1);
            lua_remove(L,-2);
            lua_replace(L,4);
            assert(lua_gettop(L) == 10);
          }
          lua_settop(L,lc424);
          assert(lua_gettop(L) == 10);
          
          /* self.object:setyaw(yaw) */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"setyaw");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,4);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 10);
        }
        lua_settop(L,lc420);
        assert(lua_gettop(L) == 10);
        
        /* -- anyone but standing npc's can move along
         * if dist > self.reach
         * 					and self.order ~= "stand" then */
        enum { lc427 = 10 };
        lua_pushliteral(L,"reach");
        lua_gettable(L,1);
        const int lc428 = lua_lessthan(L,-1,9);
        lua_pop(L,1);
        lua_pushboolean(L,lc428);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"order");
          lua_gettable(L,1);
          lua_pushliteral(L,"stand");
          const int lc429 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc429);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc430 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc430) {
          
          /* if (self.jump
           * 						and get_velocity(self) <= 0.5
           * 						and self.object:getvelocity().y == 0)
           * 						or (self.object:getvelocity().y == 0
           * 						and self.jump_chance > 0) then */
          enum { lc431 = 10 };
          lua_pushliteral(L,"jump");
          lua_gettable(L,1);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"get_velocity");
            lua_pushvalue(L,1);
            lua_call(L,1,1);
            lua_pushnumber(L,0.5);
            const int lc432 = lc_le(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc432);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"object");
            lua_gettable(L,1);
            lua_pushliteral(L,"getvelocity");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_call(L,1,1);
            lua_pushliteral(L,"y");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,0);
            const int lc433 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc433);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushliteral(L,"object");
            lua_gettable(L,1);
            lua_pushliteral(L,"getvelocity");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_call(L,1,1);
            lua_pushliteral(L,"y");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,0);
            const int lc434 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc434);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushnumber(L,0);
              lua_pushliteral(L,"jump_chance");
              lua_gettable(L,1);
              const int lc435 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc435);
            }
          }
          const int lc436 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc436) {
            
            /* do_jump(self) */
            lua_getfield(L,LUA_ENVIRONINDEX,"do_jump");
            lua_pushvalue(L,1);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 10);
          }
          lua_settop(L,lc431);
          assert(lua_gettop(L) == 10);
          
          /* set_velocity(self, self.walk_velocity) */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
          lua_pushvalue(L,1);
          lua_pushliteral(L,"walk_velocity");
          lua_gettable(L,1);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 10);
          
          /* if self.walk_chance ~= 0 then */
          enum { lc437 = 10 };
          lua_pushliteral(L,"walk_chance");
          lua_gettable(L,1);
          lua_pushnumber(L,0);
          const int lc438 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc438);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc439 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc439) {
            
            /* set_animation(self, "walk") */
            lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
            lua_pushvalue(L,1);
            lua_pushliteral(L,"walk");
            lua_call(L,2,0);
            assert(lua_gettop(L) == 10);
          }
          lua_settop(L,lc437);
          assert(lua_gettop(L) == 10);
        }
        else {
          
          /* else
           * set_velocity(self, 0) */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
          lua_pushvalue(L,1);
          lua_pushnumber(L,0);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 10);
          
          /* set_animation(self, "stand") */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
          lua_pushvalue(L,1);
          lua_pushliteral(L,"stand");
          lua_call(L,2,0);
          assert(lua_gettop(L) == 10);
        }
        lua_settop(L,lc427);
        assert(lua_gettop(L) == 10);
        
        /* return */
        return 0;
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc417);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc416);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc410);
  assert(lua_gettop(L) == 6);
  
  /* -- water swimmers flop when on land
   * if self.fly
   * 		and self.fly_in == "default:water_source"
   * 		and self.standing_in ~= self.fly_in then */
  enum { lc440 = 6 };
  lua_pushliteral(L,"fly");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"fly_in");
    lua_gettable(L,1);
    lua_pushliteral(L,"default:water_source");
    const int lc441 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc441);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"standing_in");
    lua_gettable(L,1);
    lua_pushliteral(L,"fly_in");
    lua_gettable(L,1);
    const int lc442 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc442);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc443 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc443) {
    
    /* self.state = "flop" */
    lua_pushliteral(L,"flop");
    lua_pushliteral(L,"state");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 6);
    
    /* self.object:setvelocity({x = 0, y = -5, z = 0}) */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"setvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushnumber(L,-5);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
    
    /* set_animation(self, "stand") */
    lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
    lua_pushvalue(L,1);
    lua_pushliteral(L,"stand");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc440);
  assert(lua_gettop(L) == 6);
  
  /* if self.state == "stand" then */
  enum { lc444 = 6 };
  lua_pushliteral(L,"state");
  lua_gettable(L,1);
  lua_pushliteral(L,"stand");
  const int lc445 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc445);
  const int lc446 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc446) {
    
    /* if math.random(1, 4) == 1 then */
    enum { lc447 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,4);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc448 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc448);
    const int lc449 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc449) {
      
      /* local lp = nil */
      lua_pushnil(L);
      assert(lua_gettop(L) == 7);
      
      /* local s = self.object:getpos() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 8);
      
      /* if self.type == "npc" then */
      enum { lc450 = 8 };
      lua_pushliteral(L,"type");
      lua_gettable(L,1);
      lua_pushliteral(L,"npc");
      const int lc451 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc451);
      const int lc452 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc452) {
        
        /* local o = minetest.get_objects_inside_radius(self.object:getpos(), 3) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_objects_inside_radius");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"getpos");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushnumber(L,3);
        lua_call(L,2,1);
        assert(lua_gettop(L) == 9);
        
        /* for _,o in pairs(o) do
         * internal: local f, s, var = explist */
        enum { lc453 = 9 };
        lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
        lua_pushvalue(L,9);
        lua_call(L,1,3);
        while (1) {
          
          /* internal: local var_1, ..., var_n = f(s, var)
           *           if var_1 == nil then break end
           *           var = var_1 */
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_call(L,2,2);
          if (lua_isnil(L,-2)) {
            break;
          }
          lua_pushvalue(L,-2);
          lua_replace(L,-4);
          
          /* internal: local _ with idx 13
           * internal: local o with idx 14 */
          
          
          /* if o:is_player() then */
          enum { lc454 = 14 };
          lua_pushvalue(L,14);
          lua_pushliteral(L,"is_player");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          const int lc455 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc455) {
            
            /* lp = o:getpos() */
            lua_pushvalue(L,14);
            lua_pushliteral(L,"getpos");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_call(L,1,1);
            lua_replace(L,7);
            assert(lua_gettop(L) == 14);
            
            /* break */
            break;
            assert(lua_gettop(L) == 14);
          }
          lua_settop(L,lc454);
          assert(lua_gettop(L) == 14);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,2);
        }
        lua_settop(L,lc453);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc450);
      assert(lua_gettop(L) == 8);
      
      /* -- look at any players nearby, otherwise turn randomly
       * if lp then */
      enum { lc456 = 8 };
      if (lua_toboolean(L,7)) {
        
        /* local vec = {
         * 						x = lp.x - s.x,
         * 						y = lp.y - s.y,
         * 						z = lp.z - s.z
         * 					} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushliteral(L,"x");
        lua_gettable(L,8);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lua_pushliteral(L,"y");
        lua_gettable(L,8);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lua_pushliteral(L,"z");
        lua_gettable(L,8);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 9);
        
        /* if vec.x ~= 0
         * 					and vec.z ~= 0 then */
        enum { lc457 = 9 };
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushnumber(L,0);
        const int lc458 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc458);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"z");
          lua_gettable(L,9);
          lua_pushnumber(L,0);
          const int lc459 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc459);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc460 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc460) {
          
          /* yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate */
          lc_getupvalue(L,lua_upvalueindex(1),5,13);
          lua_pushliteral(L,"z");
          lua_gettable(L,9);
          lua_pushliteral(L,"x");
          lua_gettable(L,9);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lc_getupvalue(L,lua_upvalueindex(1),7,11);
          lua_pushnumber(L,2);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"rotate");
          lua_gettable(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,4);
          assert(lua_gettop(L) == 9);
          
          /* if lp.x > s.x then */
          enum { lc461 = 9 };
          lua_pushliteral(L,"x");
          lua_gettable(L,8);
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          const int lc462 = lua_lessthan(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc462);
          const int lc463 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc463) {
            
            /* yaw = yaw + pi */
            lc_getupvalue(L,lua_upvalueindex(1),7,11);
            lc_add(L,4,-1);
            lua_remove(L,-2);
            lua_replace(L,4);
            assert(lua_gettop(L) == 9);
          }
          lua_settop(L,lc461);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc457);
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* else
         * yaw = (math.random(0, 360) - 180) / 180 * pi */
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0);
        lua_pushnumber(L,360);
        lua_call(L,2,1);
        lua_pushnumber(L,180);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,180);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_getupvalue(L,lua_upvalueindex(1),7,11);
        lc_mul(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,4);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc456);
      assert(lua_gettop(L) == 8);
      
      /* self.object:setyaw(yaw) */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"setyaw");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,4);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc447);
    assert(lua_gettop(L) == 6);
    
    /* set_velocity(self, 0) */
    lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
    lua_pushvalue(L,1);
    lua_pushnumber(L,0);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
    
    /* set_animation(self, "stand") */
    lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
    lua_pushvalue(L,1);
    lua_pushliteral(L,"stand");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
    
    /* -- npc's ordered to stand stay standing
     * if self.type ~= "npc"
     * 			or self.order ~= "stand" then */
    enum { lc464 = 6 };
    lua_pushliteral(L,"type");
    lua_gettable(L,1);
    lua_pushliteral(L,"npc");
    const int lc465 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc465);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"order");
      lua_gettable(L,1);
      lua_pushliteral(L,"stand");
      const int lc466 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc466);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc467 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc467) {
      
      /* if self.walk_chance ~= 0
       * 				and math.random(1, 100) <= self.walk_chance
       * 				and is_at_cliff(self) == false then */
      enum { lc468 = 6 };
      lua_pushliteral(L,"walk_chance");
      lua_gettable(L,1);
      lua_pushnumber(L,0);
      const int lc469 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc469);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushnumber(L,100);
        lua_call(L,2,1);
        lua_pushliteral(L,"walk_chance");
        lua_gettable(L,1);
        const int lc470 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc470);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),4,14);
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        lua_pushboolean(L,0);
        const int lc471 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc471);
      }
      const int lc472 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc472) {
        
        /* set_velocity(self, self.walk_velocity) */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"walk_velocity");
        lua_gettable(L,1);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 6);
        
        /* self.state = "walk" */
        lua_pushliteral(L,"walk");
        lua_pushliteral(L,"state");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 6);
        
        /* set_animation(self, "walk") */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"walk");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc468);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc464);
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* elseif self.state == "walk" then */
    enum { lc473 = 6 };
    lua_pushliteral(L,"state");
    lua_gettable(L,1);
    lua_pushliteral(L,"walk");
    const int lc474 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc474);
    const int lc475 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc475) {
      
      /* local s = self.object:getpos() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 7);
      
      /* local lp = minetest.find_node_near(s, 1, {"group:water"}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_node_near");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,7);
      lua_pushnumber(L,1);
      lua_createtable(L,1,0);
      lua_pushliteral(L,"group:water");
      lua_rawseti(L,-2,1);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 8);
      
      /* -- if water nearby then turn away
       * if lp then */
      enum { lc476 = 8 };
      if (lua_toboolean(L,8)) {
        
        /* local vec = {
         * 					x = lp.x - s.x,
         * 					y = lp.y - s.y,
         * 					z = lp.z - s.z
         * 				} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,8);
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,8);
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,8);
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 9);
        
        /* if vec.x ~= 0
         * 				and vec.z ~= 0 then */
        enum { lc477 = 9 };
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushnumber(L,0);
        const int lc478 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc478);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"z");
          lua_gettable(L,9);
          lua_pushnumber(L,0);
          const int lc479 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc479);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc480 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc480) {
          
          /* yaw = atan(vec.z / vec.x) + 3 * pi / 2 - self.rotate */
          lc_getupvalue(L,lua_upvalueindex(1),5,13);
          lua_pushliteral(L,"z");
          lua_gettable(L,9);
          lua_pushliteral(L,"x");
          lua_gettable(L,9);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lua_pushnumber(L,3);
          lc_getupvalue(L,lua_upvalueindex(1),7,11);
          lc_mul(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"rotate");
          lua_gettable(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,4);
          assert(lua_gettop(L) == 9);
          
          /* if lp.x > s.x then */
          enum { lc481 = 9 };
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lua_pushliteral(L,"x");
          lua_gettable(L,8);
          const int lc482 = lua_lessthan(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc482);
          const int lc483 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc483) {
            
            /* yaw = yaw + pi */
            lc_getupvalue(L,lua_upvalueindex(1),7,11);
            lc_add(L,4,-1);
            lua_remove(L,-2);
            lua_replace(L,4);
            assert(lua_gettop(L) == 9);
          }
          lua_settop(L,lc481);
          assert(lua_gettop(L) == 9);
          
          /* self.object:setyaw(yaw) */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"setyaw");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,4);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc477);
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* -- otherwise randomly turn
         * 			elseif math.random(1, 100) <= 30 then */
        enum { lc484 = 8 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushnumber(L,100);
        lua_call(L,2,1);
        lua_pushnumber(L,30);
        const int lc485 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc485);
        const int lc486 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc486) {
          
          /* yaw = (math.random(0, 360) - 180) / 180 * pi */
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          lua_pushnumber(L,360);
          lua_call(L,2,1);
          lua_pushnumber(L,180);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,180);
          lc_div(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lc_getupvalue(L,lua_upvalueindex(1),7,11);
          lc_mul(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,4);
          assert(lua_gettop(L) == 8);
          
          /* self.object:setyaw(yaw) */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"setyaw");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,4);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 8);
        }
        lua_settop(L,lc484);
      }
      lua_settop(L,lc476);
      assert(lua_gettop(L) == 8);
      
      /* -- stand for great fall in front
       * local temp_is_cliff = is_at_cliff(self) */
      lc_getupvalue(L,lua_upvalueindex(1),4,14);
      lua_pushvalue(L,1);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 9);
      
      /* -- jump when walking comes to a halt
       * if temp_is_cliff == false
       * 			and self.jump
       * 			and get_velocity(self) <= 0.5
       * 			and self.object:getvelocity().y == 0 then */
      enum { lc487 = 9 };
      lua_pushvalue(L,9);
      lua_pushboolean(L,0);
      const int lc488 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc488);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"jump");
        lua_gettable(L,1);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"get_velocity");
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        lua_pushnumber(L,0.5);
        const int lc489 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc489);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"getvelocity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"y");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0);
        const int lc490 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc490);
      }
      const int lc491 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc491) {
        
        /* do_jump(self) */
        lua_getfield(L,LUA_ENVIRONINDEX,"do_jump");
        lua_pushvalue(L,1);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc487);
      assert(lua_gettop(L) == 9);
      
      /* if temp_is_cliff
       * 			or math.random(1, 100) <= 30 then */
      enum { lc492 = 9 };
      lua_pushvalue(L,9);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushnumber(L,100);
        lua_call(L,2,1);
        lua_pushnumber(L,30);
        const int lc493 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc493);
      }
      const int lc494 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc494) {
        
        /* set_velocity(self, 0) */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
        lua_pushvalue(L,1);
        lua_pushnumber(L,0);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 9);
        
        /* self.state = "stand" */
        lua_pushliteral(L,"stand");
        lua_pushliteral(L,"state");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* set_animation(self, "stand") */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"stand");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* else
         * set_velocity(self, self.walk_velocity) */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"walk_velocity");
        lua_gettable(L,1);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 9);
        
        /* set_animation(self, "walk") */
        lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"walk");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc492);
      assert(lua_gettop(L) == 9);
    }
    else {
      
      /* -- runaway when punched
       * 		elseif self.state == "runaway" then */
      enum { lc495 = 6 };
      lua_pushliteral(L,"state");
      lua_gettable(L,1);
      lua_pushliteral(L,"runaway");
      const int lc496 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc496);
      const int lc497 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc497) {
        
        /* self.runaway_timer = self.runaway_timer + 1 */
        lua_pushliteral(L,"runaway_timer");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"runaway_timer");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 6);
        
        /* -- stop after 3 seconds or when at cliff
         * if self.runaway_timer > 3
         * 			or is_at_cliff(self) then */
        enum { lc498 = 6 };
        lua_pushnumber(L,3);
        lua_pushliteral(L,"runaway_timer");
        lua_gettable(L,1);
        const int lc499 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc499);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),4,14);
          lua_pushvalue(L,1);
          lua_call(L,1,1);
        }
        const int lc500 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc500) {
          
          /* self.runaway_timer = 0 */
          lua_pushnumber(L,0);
          lua_pushliteral(L,"runaway_timer");
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 6);
          
          /* set_velocity(self, 0) */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
          lua_pushvalue(L,1);
          lua_pushnumber(L,0);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
          
          /* self.state = "stand" */
          lua_pushliteral(L,"stand");
          lua_pushliteral(L,"state");
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 6);
          
          /* set_animation(self, "stand") */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
          lua_pushvalue(L,1);
          lua_pushliteral(L,"stand");
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
        }
        else {
          
          /* else
           * set_velocity(self, self.run_velocity) */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
          lua_pushvalue(L,1);
          lua_pushliteral(L,"run_velocity");
          lua_gettable(L,1);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
          
          /* set_animation(self, "walk") */
          lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
          lua_pushvalue(L,1);
          lua_pushliteral(L,"walk");
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc498);
        assert(lua_gettop(L) == 6);
        
        /* -- jump when walking comes to a halt
         * if self.jump
         * 			and get_velocity(self) <= 0.5
         * 			and self.object:getvelocity().y == 0 then */
        enum { lc501 = 6 };
        lua_pushliteral(L,"jump");
        lua_gettable(L,1);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"get_velocity");
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          lua_pushnumber(L,0.5);
          const int lc502 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc502);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"getvelocity");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"y");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc503 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc503);
        }
        const int lc504 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc504) {
          
          /* do_jump(self) */
          lua_getfield(L,LUA_ENVIRONINDEX,"do_jump");
          lua_pushvalue(L,1);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc501);
        assert(lua_gettop(L) == 6);
      }
      else {
        
        /* -- attack routines (explode, dogfight, shoot, dogshoot)
         * 		elseif self.state == "attack" then */
        enum { lc505 = 6 };
        lua_pushliteral(L,"state");
        lua_gettable(L,1);
        lua_pushliteral(L,"attack");
        const int lc506 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc506);
        const int lc507 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc507) {
          
          /* -- calculate distance from mob and enemy
           * local s = self.object:getpos() */
          lua_pushliteral(L,"object");
          lua_gettable(L,1);
          lua_pushliteral(L,"getpos");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          assert(lua_gettop(L) == 7);
          
          /* local p = self.attack:getpos() or s */
          lua_pushliteral(L,"attack");
          lua_gettable(L,1);
          lua_pushliteral(L,"getpos");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,7);
          }
          assert(lua_gettop(L) == 8);
          
          /* local dist = get_distance(p, s) */
          lc_getupvalue(L,lua_upvalueindex(1),2,16);
          lua_pushvalue(L,8);
          lua_pushvalue(L,7);
          lua_call(L,2,1);
          assert(lua_gettop(L) == 9);
          
          /* -- stop attacking if player or out of range
           * if dist > self.view_range
           * 		or not self.attack
           * 		or not self.attack:getpos()
           * 		or self.attack:get_hp() <= 0 then */
          enum { lc508 = 9 };
          lua_pushliteral(L,"view_range");
          lua_gettable(L,1);
          const int lc509 = lua_lessthan(L,-1,9);
          lua_pop(L,1);
          lua_pushboolean(L,lc509);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushliteral(L,"attack");
            lua_gettable(L,1);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushliteral(L,"attack");
            lua_gettable(L,1);
            lua_pushliteral(L,"getpos");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_call(L,1,1);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushliteral(L,"attack");
            lua_gettable(L,1);
            lua_pushliteral(L,"get_hp");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_call(L,1,1);
            lua_pushnumber(L,0);
            const int lc510 = lc_le(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc510);
          }
          const int lc511 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc511) {
            
            /* --print(" ** stop attacking **", dist, self.view_range)
             * self.state = "stand" */
            lua_pushliteral(L,"stand");
            lua_pushliteral(L,"state");
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 9);
            
            /* set_velocity(self, 0) */
            lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
            lua_pushvalue(L,1);
            lua_pushnumber(L,0);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 9);
            
            /* set_animation(self, "stand") */
            lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
            lua_pushvalue(L,1);
            lua_pushliteral(L,"stand");
            lua_call(L,2,0);
            assert(lua_gettop(L) == 9);
            
            /* self.attack = nil */
            lua_pushnil(L);
            lua_pushliteral(L,"attack");
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 9);
            
            /* self.v_start = false */
            lua_pushboolean(L,0);
            lua_pushliteral(L,"v_start");
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 9);
            
            /* self.timer = 0 */
            lua_pushnumber(L,0);
            lua_pushliteral(L,"timer");
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 9);
            
            /* self.blinktimer = 0 */
            lua_pushnumber(L,0);
            lua_pushliteral(L,"blinktimer");
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 9);
            
            /* return */
            return 0;
            assert(lua_gettop(L) == 9);
          }
          lua_settop(L,lc508);
          assert(lua_gettop(L) == 9);
          
          /* if self.attack_type == "explode" then */
          enum { lc512 = 9 };
          lua_pushliteral(L,"attack_type");
          lua_gettable(L,1);
          lua_pushliteral(L,"explode");
          const int lc513 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc513);
          const int lc514 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc514) {
            
            /* local vec = {
             * 				x = p.x - s.x,
             * 				y = p.y - s.y,
             * 				z = p.z - s.z
             * 			} */
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,8);
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,8);
            lua_pushliteral(L,"y");
            lua_gettable(L,7);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,8);
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            assert(lua_gettop(L) == 10);
            
            /* if vec.x ~= 0
             * 			and vec.z ~= 0 then */
            enum { lc515 = 10 };
            lua_pushliteral(L,"x");
            lua_gettable(L,10);
            lua_pushnumber(L,0);
            const int lc516 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc516);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"z");
              lua_gettable(L,10);
              lua_pushnumber(L,0);
              const int lc517 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc517);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc518 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc518) {
              
              /* yaw = atan(vec.z / vec.x) + pi / 2 - self.rotate */
              lc_getupvalue(L,lua_upvalueindex(1),5,13);
              lua_pushliteral(L,"z");
              lua_gettable(L,10);
              lua_pushliteral(L,"x");
              lua_gettable(L,10);
              lc_div(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_call(L,1,1);
              lc_getupvalue(L,lua_upvalueindex(1),7,11);
              lua_pushnumber(L,2);
              lc_div(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lc_add(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"rotate");
              lua_gettable(L,1);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_replace(L,4);
              assert(lua_gettop(L) == 10);
              
              /* if p.x > s.x then */
              enum { lc519 = 10 };
              lua_pushliteral(L,"x");
              lua_gettable(L,7);
              lua_pushliteral(L,"x");
              lua_gettable(L,8);
              const int lc520 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc520);
              const int lc521 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc521) {
                
                /* yaw = yaw + pi */
                lc_getupvalue(L,lua_upvalueindex(1),7,11);
                lc_add(L,4,-1);
                lua_remove(L,-2);
                lua_replace(L,4);
                assert(lua_gettop(L) == 10);
              }
              lua_settop(L,lc519);
              assert(lua_gettop(L) == 10);
              
              /* self.object:setyaw(yaw) */
              lua_pushliteral(L,"object");
              lua_gettable(L,1);
              lua_pushliteral(L,"setyaw");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,4);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 10);
            }
            lua_settop(L,lc515);
            assert(lua_gettop(L) == 10);
            
            /* if dist > self.reach then */
            enum { lc522 = 10 };
            lua_pushliteral(L,"reach");
            lua_gettable(L,1);
            const int lc523 = lua_lessthan(L,-1,9);
            lua_pop(L,1);
            lua_pushboolean(L,lc523);
            const int lc524 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc524) {
              
              /* if not self.v_start then */
              enum { lc525 = 10 };
              lua_pushliteral(L,"v_start");
              lua_gettable(L,1);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
              const int lc526 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc526) {
                
                /* self.v_start = true */
                lua_pushboolean(L,1);
                lua_pushliteral(L,"v_start");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
                
                /* set_velocity(self, self.run_velocity) */
                lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                lua_pushvalue(L,1);
                lua_pushliteral(L,"run_velocity");
                lua_gettable(L,1);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 10);
                
                /* self.timer = 0 */
                lua_pushnumber(L,0);
                lua_pushliteral(L,"timer");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
                
                /* self.blinktimer = 0 */
                lua_pushnumber(L,0);
                lua_pushliteral(L,"blinktimer");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
              }
              else {
                
                /* else
                 * self.timer = 0 */
                lua_pushnumber(L,0);
                lua_pushliteral(L,"timer");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
                
                /* self.blinktimer = 0 */
                lua_pushnumber(L,0);
                lua_pushliteral(L,"blinktimer");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
                
                /* if get_velocity(self) <= 0.5
                 * 					and self.object:getvelocity().y == 0 then */
                enum { lc527 = 10 };
                lua_getfield(L,LUA_ENVIRONINDEX,"get_velocity");
                lua_pushvalue(L,1);
                lua_call(L,1,1);
                lua_pushnumber(L,0.5);
                const int lc528 = lc_le(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc528);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"getvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_call(L,1,1);
                  lua_pushliteral(L,"y");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,0);
                  const int lc529 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc529);
                }
                const int lc530 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc530) {
                  
                  /* local v = self.object:getvelocity() */
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"getvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_call(L,1,1);
                  assert(lua_gettop(L) == 11);
                  
                  /* v.y = 5 */
                  lua_pushnumber(L,5);
                  lua_pushliteral(L,"y");
                  lua_insert(L,-2);
                  lua_settable(L,11);
                  assert(lua_gettop(L) == 11);
                  
                  /* self.object:setvelocity(v) */
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"setvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 11);
                }
                lua_settop(L,lc527);
                assert(lua_gettop(L) == 10);
                
                /* set_velocity(self, self.run_velocity) */
                lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                lua_pushvalue(L,1);
                lua_pushliteral(L,"run_velocity");
                lua_gettable(L,1);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 10);
              }
              lua_settop(L,lc525);
              assert(lua_gettop(L) == 10);
              
              /* set_animation(self, "run") */
              lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
              lua_pushvalue(L,1);
              lua_pushliteral(L,"run");
              lua_call(L,2,0);
              assert(lua_gettop(L) == 10);
            }
            else {
              
              /* else
               * set_velocity(self, 0) */
              lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
              lua_pushvalue(L,1);
              lua_pushnumber(L,0);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 10);
              
              /* --NSSM additions:
               * set_animation(self, "punch") */
              lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
              lua_pushvalue(L,1);
              lua_pushliteral(L,"punch");
              lua_call(L,2,0);
              assert(lua_gettop(L) == 10);
              
              /* --end of NSSM additions
               * self.timer = self.timer + dtime */
              lua_pushliteral(L,"timer");
              lua_gettable(L,1);
              lc_add(L,-1,2);
              lua_remove(L,-2);
              lua_pushliteral(L,"timer");
              lua_insert(L,-2);
              lua_settable(L,1);
              assert(lua_gettop(L) == 10);
              
              /* self.blinktimer = (self.blinktimer or 0) + dtime */
              lua_pushliteral(L,"blinktimer");
              lua_gettable(L,1);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushnumber(L,0);
              }
              lc_add(L,-1,2);
              lua_remove(L,-2);
              lua_pushliteral(L,"blinktimer");
              lua_insert(L,-2);
              lua_settable(L,1);
              assert(lua_gettop(L) == 10);
              
              /* if self.blinktimer > 0.2 then */
              enum { lc531 = 10 };
              lua_pushnumber(L,0.2);
              lua_pushliteral(L,"blinktimer");
              lua_gettable(L,1);
              const int lc532 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc532);
              const int lc533 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc533) {
                
                /* self.blinktimer = 0 */
                lua_pushnumber(L,0);
                lua_pushliteral(L,"blinktimer");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
                
                /* if self.blinkstatus then */
                enum { lc534 = 10 };
                lua_pushliteral(L,"blinkstatus");
                lua_gettable(L,1);
                const int lc535 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc535) {
                  
                  /* self.object:settexturemod("") */
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"settexturemod");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushliteral(L,"");
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                }
                else {
                  
                  /* else
                   * self.object:settexturemod("^[brighten") */
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"settexturemod");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushliteral(L,"^[brighten");
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc534);
                assert(lua_gettop(L) == 10);
                
                /* self.blinkstatus = not self.blinkstatus */
                lua_pushliteral(L,"blinkstatus");
                lua_gettable(L,1);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
                lua_pushliteral(L,"blinkstatus");
                lua_insert(L,-2);
                lua_settable(L,1);
                assert(lua_gettop(L) == 10);
              }
              lua_settop(L,lc531);
              assert(lua_gettop(L) == 10);
              
              /* if self.timer > 3 then */
              enum { lc536 = 10 };
              lua_pushnumber(L,3);
              lua_pushliteral(L,"timer");
              lua_gettable(L,1);
              const int lc537 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc537);
              const int lc538 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc538) {
                
                /* local pos = self.object:getpos() */
                lua_pushliteral(L,"object");
                lua_gettable(L,1);
                lua_pushliteral(L,"getpos");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_call(L,1,1);
                assert(lua_gettop(L) == 11);
                
                /* local radius = self.explosion_radius or 1 */
                lua_pushliteral(L,"explosion_radius");
                lua_gettable(L,1);
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushnumber(L,1);
                }
                assert(lua_gettop(L) == 12);
                
                /* -- hurt player/nssm caught in blast area
                 * --entity_physics(pos, radius)		--NSSM modification (the damage function is part of the explosion one now)
                 * -- dont damage anything if area protected or next to water
                 * if minetest.find_node_near(pos, 1, {"group:water"})
                 * 					or minetest.is_protected(pos, "") then */
                enum { lc539 = 12 };
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"find_node_near");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,11);
                lua_pushnumber(L,1);
                lua_createtable(L,1,0);
                lua_pushliteral(L,"group:water");
                lua_rawseti(L,-2,1);
                lua_call(L,3,1);
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                  lua_pushliteral(L,"is_protected");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushliteral(L,"");
                  lua_call(L,2,1);
                }
                const int lc540 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc540) {
                  
                  /* if self.sounds.explode then */
                  enum { lc541 = 12 };
                  lua_pushliteral(L,"sounds");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"explode");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc542 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc542) {
                    
                    /* minetest.sound_play(self.sounds.explode, {
                     * 								object = self.object,
                     * 								gain = 1.0,
                     * 								max_hear_distance = 16
                     * 							}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"sound_play");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"sounds");
                    lua_gettable(L,1);
                    lua_pushliteral(L,"explode");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_createtable(L,0,3);
                    lua_pushliteral(L,"object");
                    lua_pushliteral(L,"object");
                    lua_gettable(L,1);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"gain");
                    lua_pushnumber(L,1);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"max_hear_distance");
                    lua_pushnumber(L,16);
                    lua_rawset(L,-3);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 12);
                  }
                  lua_settop(L,lc541);
                  assert(lua_gettop(L) == 12);
                  
                  /* self.object:remove() */
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"remove");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_call(L,1,0);
                  assert(lua_gettop(L) == 12);
                  
                  /* effect(pos, 15, "tnt_smoke.png", 5) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"effect");
                  lua_pushvalue(L,11);
                  lua_pushnumber(L,15);
                  lua_pushliteral(L,"tnt_smoke.png");
                  lua_pushnumber(L,5);
                  lua_call(L,4,0);
                  assert(lua_gettop(L) == 12);
                  
                  /* return */
                  return 0;
                  assert(lua_gettop(L) == 12);
                }
                lua_settop(L,lc539);
                assert(lua_gettop(L) == 12);
                
                /* pos.y = pos.y - 1 */
                lua_pushliteral(L,"y");
                lua_gettable(L,11);
                lua_pushnumber(L,1);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"y");
                lua_insert(L,-2);
                lua_settable(L,11);
                assert(lua_gettop(L) == 12);
                
                /* --NSSM modifications:
                 * if self.explosion_radius==0 then */
                enum { lc543 = 12 };
                lua_pushliteral(L,"explosion_radius");
                lua_gettable(L,1);
                lua_pushnumber(L,0);
                const int lc544 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc544);
                const int lc545 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc545) {
                  
                  /* nssm:explosion(pos, 5, 0, 1, self.sounds.explode) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
                  lua_pushliteral(L,"explosion");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushnumber(L,5);
                  lua_pushnumber(L,0);
                  lua_pushnumber(L,1);
                  lua_pushliteral(L,"sounds");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"explode");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_call(L,6,0);
                  assert(lua_gettop(L) == 12);
                }
                else {
                  
                  /* else
                   * nssm:explosion(pos, self.explosion_radius, 0, 1, self.sounds.explode) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
                  lua_pushliteral(L,"explosion");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushliteral(L,"explosion_radius");
                  lua_gettable(L,1);
                  lua_pushnumber(L,0);
                  lua_pushnumber(L,1);
                  lua_pushliteral(L,"sounds");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"explode");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_call(L,6,0);
                  assert(lua_gettop(L) == 12);
                }
                lua_settop(L,lc543);
                assert(lua_gettop(L) == 12);
                
                /* --end of NSSM modifications
                 * self.object:remove() */
                lua_pushliteral(L,"object");
                lua_gettable(L,1);
                lua_pushliteral(L,"remove");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_call(L,1,0);
                assert(lua_gettop(L) == 12);
                
                /* return */
                return 0;
                assert(lua_gettop(L) == 12);
              }
              lua_settop(L,lc536);
              assert(lua_gettop(L) == 10);
            }
            lua_settop(L,lc522);
            assert(lua_gettop(L) == 10);
          }
          else {
            
            /* elseif self.attack_type == "dogfight"
             * 		or (self.attack_type == "dogshoot" and dist <= self.reach)
             * 		or (self.attack_type == "dogshoot" and self.dogshoot_stop and self.direct_hit) then */
            enum { lc546 = 9 };
            lua_pushliteral(L,"attack_type");
            lua_gettable(L,1);
            lua_pushliteral(L,"dogfight");
            const int lc547 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc547);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushliteral(L,"attack_type");
              lua_gettable(L,1);
              lua_pushliteral(L,"dogshoot");
              const int lc548 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc548);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"reach");
                lua_gettable(L,1);
                const int lc549 = lc_le(L,9,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc549);
              }
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushliteral(L,"attack_type");
              lua_gettable(L,1);
              lua_pushliteral(L,"dogshoot");
              const int lc550 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc550);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"dogshoot_stop");
                lua_gettable(L,1);
              }
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"direct_hit");
                lua_gettable(L,1);
              }
            }
            const int lc551 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc551) {
              
              /* if self.fly
               * 			and dist > self.reach then */
              enum { lc552 = 9 };
              lua_pushliteral(L,"fly");
              lua_gettable(L,1);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"reach");
                lua_gettable(L,1);
                const int lc553 = lua_lessthan(L,-1,9);
                lua_pop(L,1);
                lua_pushboolean(L,lc553);
              }
              const int lc554 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc554) {
                
                /* local nod = node_ok(s) */
                lc_getupvalue(L,lua_upvalueindex(1),3,15);
                lua_pushvalue(L,7);
                lua_call(L,1,1);
                assert(lua_gettop(L) == 10);
                
                /* local p1 = s */
                lua_pushvalue(L,7);
                assert(lua_gettop(L) == 11);
                
                /* local me_y = math.floor(p1.y) */
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"floor");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"y");
                lua_gettable(L,11);
                lua_call(L,1,1);
                assert(lua_gettop(L) == 12);
                
                /* local p2 = p */
                lua_pushvalue(L,8);
                assert(lua_gettop(L) == 13);
                
                /* local p_y = math.floor(p2.y + 1) */
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"floor");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"y");
                lua_gettable(L,13);
                lua_pushnumber(L,1);
                lc_add(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_call(L,1,1);
                assert(lua_gettop(L) == 14);
                
                /* local v = self.object:getvelocity() */
                lua_pushliteral(L,"object");
                lua_gettable(L,1);
                lua_pushliteral(L,"getvelocity");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_call(L,1,1);
                assert(lua_gettop(L) == 15);
                
                /* if nod.name == self.fly_in then */
                enum { lc555 = 15 };
                lua_pushliteral(L,"name");
                lua_gettable(L,10);
                lua_pushliteral(L,"fly_in");
                lua_gettable(L,1);
                const int lc556 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc556);
                const int lc557 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc557) {
                  
                  /* if me_y < p_y then */
                  enum { lc558 = 15 };
                  const int lc559 = lua_lessthan(L,12,14);
                  lua_pushboolean(L,lc559);
                  const int lc560 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc560) {
                    
                    /* self.object:setvelocity({
                     * 							x = v.x,
                     * 							y = 1 * self.walk_velocity,
                     * 							z = v.z
                     * 						}) */
                    lua_pushliteral(L,"object");
                    lua_gettable(L,1);
                    lua_pushliteral(L,"setvelocity");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_createtable(L,0,3);
                    lua_pushliteral(L,"x");
                    lua_pushliteral(L,"x");
                    lua_gettable(L,15);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"y");
                    lua_pushnumber(L,1);
                    lua_pushliteral(L,"walk_velocity");
                    lua_gettable(L,1);
                    lc_mul(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"z");
                    lua_pushliteral(L,"z");
                    lua_gettable(L,15);
                    lua_rawset(L,-3);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 15);
                  }
                  else {
                    
                    /* elseif me_y > p_y then */
                    enum { lc561 = 15 };
                    const int lc562 = lua_lessthan(L,14,12);
                    lua_pushboolean(L,lc562);
                    const int lc563 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc563) {
                      
                      /* self.object:setvelocity({
                       * 							x = v.x,
                       * 							y = -1 * self.walk_velocity,
                       * 							z = v.z
                       * 						}) */
                      lua_pushliteral(L,"object");
                      lua_gettable(L,1);
                      lua_pushliteral(L,"setvelocity");
                      lua_gettable(L,-2);
                      lua_insert(L,-2);
                      lua_createtable(L,0,3);
                      lua_pushliteral(L,"x");
                      lua_pushliteral(L,"x");
                      lua_gettable(L,15);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"y");
                      lua_pushnumber(L,-1);
                      lua_pushliteral(L,"walk_velocity");
                      lua_gettable(L,1);
                      lc_mul(L,-2,-1);
                      lua_remove(L,-2);
                      lua_remove(L,-2);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"z");
                      lua_pushliteral(L,"z");
                      lua_gettable(L,15);
                      lua_rawset(L,-3);
                      lua_call(L,2,0);
                      assert(lua_gettop(L) == 15);
                    }
                    lua_settop(L,lc561);
                  }
                  lua_settop(L,lc558);
                  assert(lua_gettop(L) == 15);
                }
                else {
                  
                  /* else
                   * if me_y < p_y then */
                  enum { lc564 = 15 };
                  const int lc565 = lua_lessthan(L,12,14);
                  lua_pushboolean(L,lc565);
                  const int lc566 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc566) {
                    
                    /* self.object:setvelocity({
                     * 							x = v.x,
                     * 							y = 0.01,
                     * 							z = v.z
                     * 						}) */
                    lua_pushliteral(L,"object");
                    lua_gettable(L,1);
                    lua_pushliteral(L,"setvelocity");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_createtable(L,0,3);
                    lua_pushliteral(L,"x");
                    lua_pushliteral(L,"x");
                    lua_gettable(L,15);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"y");
                    lua_pushnumber(L,0.01);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"z");
                    lua_pushliteral(L,"z");
                    lua_gettable(L,15);
                    lua_rawset(L,-3);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 15);
                  }
                  else {
                    
                    /* elseif me_y > p_y then */
                    enum { lc567 = 15 };
                    const int lc568 = lua_lessthan(L,14,12);
                    lua_pushboolean(L,lc568);
                    const int lc569 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc569) {
                      
                      /* self.object:setvelocity({
                       * 							x = v.x,
                       * 							y = -0.01,
                       * 							z = v.z
                       * 						}) */
                      lua_pushliteral(L,"object");
                      lua_gettable(L,1);
                      lua_pushliteral(L,"setvelocity");
                      lua_gettable(L,-2);
                      lua_insert(L,-2);
                      lua_createtable(L,0,3);
                      lua_pushliteral(L,"x");
                      lua_pushliteral(L,"x");
                      lua_gettable(L,15);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"y");
                      lua_pushnumber(L,-0.01);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"z");
                      lua_pushliteral(L,"z");
                      lua_gettable(L,15);
                      lua_rawset(L,-3);
                      lua_call(L,2,0);
                      assert(lua_gettop(L) == 15);
                    }
                    lua_settop(L,lc567);
                  }
                  lua_settop(L,lc564);
                  assert(lua_gettop(L) == 15);
                }
                lua_settop(L,lc555);
                assert(lua_gettop(L) == 15);
              }
              lua_settop(L,lc552);
              assert(lua_gettop(L) == 9);
              
              /* -- rnd: new movement direction
               * if self.path.following
               * 			and self.path.way
               * 			and self.attack_type ~= "dogshoot" then */
              enum { lc570 = 9 };
              lua_pushliteral(L,"path");
              lua_gettable(L,1);
              lua_pushliteral(L,"following");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"path");
                lua_gettable(L,1);
                lua_pushliteral(L,"way");
                lua_gettable(L,-2);
                lua_remove(L,-2);
              }
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"attack_type");
                lua_gettable(L,1);
                lua_pushliteral(L,"dogshoot");
                const int lc571 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc571);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
              }
              const int lc572 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc572) {
                
                /* -- no paths longer than 50
                 * if #self.path.way > 50
                 * 				or dist < self.reach then */
                enum { lc573 = 9 };
                lua_pushnumber(L,50);
                lua_pushliteral(L,"path");
                lua_gettable(L,1);
                lua_pushliteral(L,"way");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                const double lc574 = lua_objlen(L,-1);
                lua_pop(L,1);
                lua_pushnumber(L,lc574);
                const int lc575 = lua_lessthan(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc575);
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"reach");
                  lua_gettable(L,1);
                  const int lc576 = lua_lessthan(L,9,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc576);
                }
                const int lc577 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc577) {
                  
                  /* self.path.following = false */
                  lua_pushboolean(L,0);
                  lua_pushliteral(L,"path");
                  lua_gettable(L,1);
                  lua_insert(L,-2);
                  lua_pushliteral(L,"following");
                  lua_insert(L,-2);
                  lua_settable(L,-3);
                  lua_pop(L,1);
                  assert(lua_gettop(L) == 9);
                  
                  /* return */
                  return 0;
                  assert(lua_gettop(L) == 9);
                }
                lua_settop(L,lc573);
                assert(lua_gettop(L) == 9);
                
                /* local p1 = self.path.way[1] */
                lua_pushliteral(L,"path");
                lua_gettable(L,1);
                lua_pushliteral(L,"way");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,1);
                lua_gettable(L,-2);
                lua_remove(L,-2);
                assert(lua_gettop(L) == 10);
                
                /* if not p1 then */
                enum { lc578 = 10 };
                lua_pushboolean(L,!(lua_toboolean(L,10)));
                const int lc579 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc579) {
                  
                  /* self.path.following = false */
                  lua_pushboolean(L,0);
                  lua_pushliteral(L,"path");
                  lua_gettable(L,1);
                  lua_insert(L,-2);
                  lua_pushliteral(L,"following");
                  lua_insert(L,-2);
                  lua_settable(L,-3);
                  lua_pop(L,1);
                  assert(lua_gettop(L) == 10);
                  
                  /* return */
                  return 0;
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc578);
                assert(lua_gettop(L) == 10);
                
                /* if math.abs(p1.x-s.x) + math.abs(p1.z - s.z) < 0.6 then */
                enum { lc580 = 10 };
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"abs");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"x");
                lua_gettable(L,10);
                lua_pushliteral(L,"x");
                lua_gettable(L,7);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_call(L,1,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"abs");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"z");
                lua_gettable(L,10);
                lua_pushliteral(L,"z");
                lua_gettable(L,7);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_call(L,1,1);
                lc_add(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,0.6);
                const int lc581 = lua_lessthan(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc581);
                const int lc582 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc582) {
                  
                  /* -- reached waypoint, remove it from queue
                   * table.remove(self.path.way, 1) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"table");
                  lua_pushliteral(L,"remove");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushliteral(L,"path");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"way");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,1);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc580);
                assert(lua_gettop(L) == 10);
                
                /* -- set new temporary target
                 * p = {x = p1.x, y = p1.y, z = p1.z} */
                lua_createtable(L,0,3);
                lua_pushliteral(L,"x");
                lua_pushliteral(L,"x");
                lua_gettable(L,10);
                lua_rawset(L,-3);
                lua_pushliteral(L,"y");
                lua_pushliteral(L,"y");
                lua_gettable(L,10);
                lua_rawset(L,-3);
                lua_pushliteral(L,"z");
                lua_pushliteral(L,"z");
                lua_gettable(L,10);
                lua_rawset(L,-3);
                lua_replace(L,8);
                assert(lua_gettop(L) == 10);
              }
              lua_settop(L,lc570);
              assert(lua_gettop(L) == 9);
              
              /* local vec = {
               * 				x = p.x - s.x,
               * 				y = p.y - s.y,
               * 				z = p.z - s.z
               * 			} */
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushliteral(L,"x");
              lua_gettable(L,8);
              lua_pushliteral(L,"x");
              lua_gettable(L,7);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushliteral(L,"y");
              lua_gettable(L,8);
              lua_pushliteral(L,"y");
              lua_gettable(L,7);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushliteral(L,"z");
              lua_gettable(L,8);
              lua_pushliteral(L,"z");
              lua_gettable(L,7);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              assert(lua_gettop(L) == 10);
              
              /* if vec.x ~= 0
               * 			and vec.z ~= 0 then */
              enum { lc583 = 10 };
              lua_pushliteral(L,"x");
              lua_gettable(L,10);
              lua_pushnumber(L,0);
              const int lc584 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc584);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"z");
                lua_gettable(L,10);
                lua_pushnumber(L,0);
                const int lc585 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc585);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
              }
              const int lc586 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc586) {
                
                /* yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate */
                lc_getupvalue(L,lua_upvalueindex(1),5,13);
                lua_pushliteral(L,"z");
                lua_gettable(L,10);
                lua_pushliteral(L,"x");
                lua_gettable(L,10);
                lc_div(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_call(L,1,1);
                lc_getupvalue(L,lua_upvalueindex(1),7,11);
                lua_pushnumber(L,2);
                lc_div(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lc_add(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"rotate");
                lua_gettable(L,1);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_replace(L,4);
                assert(lua_gettop(L) == 10);
                
                /* if p.x > s.x then */
                enum { lc587 = 10 };
                lua_pushliteral(L,"x");
                lua_gettable(L,7);
                lua_pushliteral(L,"x");
                lua_gettable(L,8);
                const int lc588 = lua_lessthan(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc588);
                const int lc589 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc589) {
                  
                  /* yaw = yaw + pi */
                  lc_getupvalue(L,lua_upvalueindex(1),7,11);
                  lc_add(L,4,-1);
                  lua_remove(L,-2);
                  lua_replace(L,4);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc587);
                assert(lua_gettop(L) == 10);
                
                /* self.object:setyaw(yaw) */
                lua_pushliteral(L,"object");
                lua_gettable(L,1);
                lua_pushliteral(L,"setyaw");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,4);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 10);
              }
              lua_settop(L,lc583);
              assert(lua_gettop(L) == 10);
              
              /* -- move towards enemy if beyond mob reach
               * if dist > self.reach then */
              enum { lc590 = 10 };
              lua_pushliteral(L,"reach");
              lua_gettable(L,1);
              const int lc591 = lua_lessthan(L,-1,9);
              lua_pop(L,1);
              lua_pushboolean(L,lc591);
              const int lc592 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc592) {
                
                /* -- path finding by rnd
                 * if self.pathfinding -- only if mob has pathfinding enabled
                 * 				and enable_pathfinding then */
                enum { lc593 = 10 };
                lua_pushliteral(L,"pathfinding");
                lua_gettable(L,1);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lc_getupvalue(L,lua_upvalueindex(1),11,7);
                }
                const int lc594 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc594) {
                  
                  /* smart_nssm(self, s, p, dist, dtime) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"smart_nssm");
                  lua_pushvalue(L,1);
                  lua_pushvalue(L,7);
                  lua_pushvalue(L,8);
                  lua_pushvalue(L,9);
                  lua_pushvalue(L,2);
                  lua_call(L,5,0);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc593);
                assert(lua_gettop(L) == 10);
                
                /* -- jump attack
                 * if (self.jump
                 * 				and get_velocity(self) <= 0.5
                 * 				and self.object:getvelocity().y == 0)
                 * 				or (self.object:getvelocity().y == 0
                 * 				and self.jump_chance > 0) then */
                enum { lc595 = 10 };
                lua_pushliteral(L,"jump");
                lua_gettable(L,1);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"get_velocity");
                  lua_pushvalue(L,1);
                  lua_call(L,1,1);
                  lua_pushnumber(L,0.5);
                  const int lc596 = lc_le(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc596);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"getvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_call(L,1,1);
                  lua_pushliteral(L,"y");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,0);
                  const int lc597 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc597);
                }
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"getvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_call(L,1,1);
                  lua_pushliteral(L,"y");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,0);
                  const int lc598 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc598);
                  if (lua_toboolean(L,-1)) {
                    lua_pop(L,1);
                    lua_pushnumber(L,0);
                    lua_pushliteral(L,"jump_chance");
                    lua_gettable(L,1);
                    const int lc599 = lua_lessthan(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc599);
                  }
                }
                const int lc600 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc600) {
                  
                  /* do_jump(self) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"do_jump");
                  lua_pushvalue(L,1);
                  lua_call(L,1,0);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc595);
                assert(lua_gettop(L) == 10);
                
                /* if is_at_cliff(self) then */
                enum { lc601 = 10 };
                lc_getupvalue(L,lua_upvalueindex(1),4,14);
                lua_pushvalue(L,1);
                lua_call(L,1,1);
                const int lc602 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc602) {
                  
                  /* set_velocity(self, 0) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                  lua_pushvalue(L,1);
                  lua_pushnumber(L,0);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                  
                  /* set_animation(self, "stand") */
                  lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
                  lua_pushvalue(L,1);
                  lua_pushliteral(L,"stand");
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                }
                else {
                  
                  /* else
                   * if self.path.stuck then */
                  enum { lc603 = 10 };
                  lua_pushliteral(L,"path");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"stuck");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc604 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc604) {
                    
                    /* set_velocity(self, self.walk_velocity) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                    lua_pushvalue(L,1);
                    lua_pushliteral(L,"walk_velocity");
                    lua_gettable(L,1);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 10);
                  }
                  else {
                    
                    /* else
                     * set_velocity(self, self.run_velocity) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                    lua_pushvalue(L,1);
                    lua_pushliteral(L,"run_velocity");
                    lua_gettable(L,1);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 10);
                  }
                  lua_settop(L,lc603);
                  assert(lua_gettop(L) == 10);
                  
                  /* set_animation(self, "run") */
                  lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
                  lua_pushvalue(L,1);
                  lua_pushliteral(L,"run");
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc601);
                assert(lua_gettop(L) == 10);
              }
              else {
                
                /* else
                 * -- rnd: if inside reach range
                 * self.path.stuck = false */
                lua_pushboolean(L,0);
                lua_pushliteral(L,"path");
                lua_gettable(L,1);
                lua_insert(L,-2);
                lua_pushliteral(L,"stuck");
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 10);
                
                /* self.path.stuck_timer = 0 */
                lua_pushnumber(L,0);
                lua_pushliteral(L,"path");
                lua_gettable(L,1);
                lua_insert(L,-2);
                lua_pushliteral(L,"stuck_timer");
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 10);
                
                /* self.path.following = false */
                lua_pushboolean(L,0);
                lua_pushliteral(L,"path");
                lua_gettable(L,1);
                lua_insert(L,-2);
                lua_pushliteral(L,"following");
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 10);
                
                /* -- not stuck anymore
                 * set_velocity(self, 0) */
                lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                lua_pushvalue(L,1);
                lua_pushnumber(L,0);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 10);
                
                /* --NSSM modifications:
                 * --modifications to add multiple melee attack animations
                 * --ATTACK ANIMATIONS:
                 * if self.mele_number>1 then */
                enum { lc605 = 10 };
                lua_pushnumber(L,1);
                lua_pushliteral(L,"mele_number");
                lua_gettable(L,1);
                const int lc606 = lua_lessthan(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc606);
                const int lc607 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc607) {
                  
                  /* if randattack==1 then */
                  enum { lc608 = 10 };
                  lua_getfield(L,LUA_ENVIRONINDEX,"randattack");
                  lua_pushnumber(L,1);
                  const int lc609 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc609);
                  const int lc610 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc610) {
                    
                    /* set_animation(self, "punch") */
                    lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
                    lua_pushvalue(L,1);
                    lua_pushliteral(L,"punch");
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 10);
                  }
                  else {
                    
                    /* else
                     * local attack = "punch"..(randattack-1) */
                    lua_pushliteral(L,"punch");
                    lua_getfield(L,LUA_ENVIRONINDEX,"randattack");
                    lua_pushnumber(L,1);
                    lc_sub(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_concat(L,2);
                    assert(lua_gettop(L) == 11);
                    
                    /* set_animation(self, attack) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
                    lua_pushvalue(L,1);
                    lua_pushvalue(L,11);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 11);
                  }
                  lua_settop(L,lc608);
                  assert(lua_gettop(L) == 10);
                }
                else {
                  
                  /* else
                   * set_animation(self, "punch") */
                  lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
                  lua_pushvalue(L,1);
                  lua_pushliteral(L,"punch");
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc605);
                assert(lua_gettop(L) == 10);
                
                /* --modifications to add special attacks to some monster:
                 * if not def.custom_attack then */
                enum { lc611 = 10 };
                lc_getupvalue(L,lua_upvalueindex(1),0,20);
                lua_pushliteral(L,"custom_attack");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
                const int lc612 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc612) {
                  
                  /* if self.timer > 1 then */
                  enum { lc613 = 10 };
                  lua_pushnumber(L,1);
                  lua_pushliteral(L,"timer");
                  lua_gettable(L,1);
                  const int lc614 = lua_lessthan(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc614);
                  const int lc615 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc615) {
                    
                    /* self.timer = 0 */
                    lua_pushnumber(L,0);
                    lua_pushliteral(L,"timer");
                    lua_insert(L,-2);
                    lua_settable(L,1);
                    assert(lua_gettop(L) == 10);
                    
                    /* local p2 = p */
                    lua_pushvalue(L,8);
                    assert(lua_gettop(L) == 11);
                    
                    /* local s2 = s */
                    lua_pushvalue(L,7);
                    assert(lua_gettop(L) == 12);
                    
                    /* p2.y = p2.y + 1.5 */
                    lua_pushliteral(L,"y");
                    lua_gettable(L,11);
                    lua_pushnumber(L,1.5);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"y");
                    lua_insert(L,-2);
                    lua_settable(L,11);
                    assert(lua_gettop(L) == 12);
                    
                    /* s2.y = s2.y + 1.5 */
                    lua_pushliteral(L,"y");
                    lua_gettable(L,12);
                    lua_pushnumber(L,1.5);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"y");
                    lua_insert(L,-2);
                    lua_settable(L,12);
                    assert(lua_gettop(L) == 12);
                    
                    /* if line_of_sight_water(self,p2,s2,1) then */
                    enum { lc616 = 12 };
                    lua_getfield(L,LUA_ENVIRONINDEX,"line_of_sight_water");
                    lua_pushvalue(L,1);
                    lua_pushvalue(L,11);
                    lua_pushvalue(L,12);
                    lua_pushnumber(L,1);
                    lua_call(L,4,1);
                    const int lc617 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc617) {
                      
                      /* -- play attack sound
                       * if self.sounds.attack then */
                      enum { lc618 = 12 };
                      lua_pushliteral(L,"sounds");
                      lua_gettable(L,1);
                      lua_pushliteral(L,"attack");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      const int lc619 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc619) {
                        
                        /* minetest.sound_play(self.sounds.attack, {
                         * 									object = self.object,
                         * 									max_hear_distance = self.sounds.distance
                         * 								}) */
                        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                        lua_pushliteral(L,"sound_play");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_pushliteral(L,"sounds");
                        lua_gettable(L,1);
                        lua_pushliteral(L,"attack");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_createtable(L,0,2);
                        lua_pushliteral(L,"object");
                        lua_pushliteral(L,"object");
                        lua_gettable(L,1);
                        lua_rawset(L,-3);
                        lua_pushliteral(L,"max_hear_distance");
                        lua_pushliteral(L,"sounds");
                        lua_gettable(L,1);
                        lua_pushliteral(L,"distance");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_rawset(L,-3);
                        lua_call(L,2,0);
                        assert(lua_gettop(L) == 12);
                      }
                      lua_settop(L,lc618);
                      assert(lua_gettop(L) == 12);
                      
                      /* -- punch player
                       * self.attack:punch(self.object, 1.0, {
                       * 								full_punch_interval = 1.0,
                       * 								damage_groups = {fleshy = self.damage}
                       * 							}, nil) */
                      lua_pushliteral(L,"attack");
                      lua_gettable(L,1);
                      lua_pushliteral(L,"punch");
                      lua_gettable(L,-2);
                      lua_insert(L,-2);
                      lua_pushliteral(L,"object");
                      lua_gettable(L,1);
                      lua_pushnumber(L,1);
                      lua_createtable(L,0,2);
                      lua_pushliteral(L,"full_punch_interval");
                      lua_pushnumber(L,1);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"damage_groups");
                      lua_createtable(L,0,1);
                      lua_pushliteral(L,"fleshy");
                      lua_pushliteral(L,"damage");
                      lua_gettable(L,1);
                      lua_rawset(L,-3);
                      lua_rawset(L,-3);
                      lua_pushnil(L);
                      lua_call(L,5,0);
                      assert(lua_gettop(L) == 12);
                      
                      /* --NSSM Modifications for dogshoot nssm
                       * if (self.dogshoot_stop) then */
                      enum { lc620 = 12 };
                      lua_pushliteral(L,"dogshoot_stop");
                      lua_gettable(L,1);
                      const int lc621 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc621) {
                        
                        /* self.num_mele_attacks=self.num_mele_attacks+1 */
                        lua_pushliteral(L,"num_mele_attacks");
                        lua_gettable(L,1);
                        lua_pushnumber(L,1);
                        lc_add(L,-2,-1);
                        lua_remove(L,-2);
                        lua_remove(L,-2);
                        lua_pushliteral(L,"num_mele_attacks");
                        lua_insert(L,-2);
                        lua_settable(L,1);
                        assert(lua_gettop(L) == 12);
                        
                        /* --minetest.chat_send_all("num_mele_attacks= "..self.num_mele_attacks)
                         * if (self.num_mele_attacks>3) then */
                        enum { lc622 = 12 };
                        lua_pushnumber(L,3);
                        lua_pushliteral(L,"num_mele_attacks");
                        lua_gettable(L,1);
                        const int lc623 = lua_lessthan(L,-2,-1);
                        lua_pop(L,2);
                        lua_pushboolean(L,lc623);
                        const int lc624 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc624) {
                          
                          /* self.num_sons=0 */
                          lua_pushnumber(L,0);
                          lua_pushliteral(L,"num_sons");
                          lua_insert(L,-2);
                          lua_settable(L,1);
                          assert(lua_gettop(L) == 12);
                          
                          /* self.num_mele_attacks=0 */
                          lua_pushnumber(L,0);
                          lua_pushliteral(L,"num_mele_attacks");
                          lua_insert(L,-2);
                          lua_settable(L,1);
                          assert(lua_gettop(L) == 12);
                          
                          /* self.direct_hit=false */
                          lua_pushboolean(L,0);
                          lua_pushliteral(L,"direct_hit");
                          lua_insert(L,-2);
                          lua_settable(L,1);
                          assert(lua_gettop(L) == 12);
                        }
                        lua_settop(L,lc622);
                        assert(lua_gettop(L) == 12);
                      }
                      lua_settop(L,lc620);
                      assert(lua_gettop(L) == 12);
                    }
                    lua_settop(L,lc616);
                    assert(lua_gettop(L) == 12);
                  }
                  lua_settop(L,lc613);
                  assert(lua_gettop(L) == 10);
                }
                else {
                  
                  /* else
                   * if def.custom_attack then */
                  enum { lc625 = 10 };
                  lc_getupvalue(L,lua_upvalueindex(1),0,20);
                  lua_pushliteral(L,"custom_attack");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc626 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc626) {
                    
                    /* def.custom_attack(self) */
                    lc_getupvalue(L,lua_upvalueindex(1),0,20);
                    lua_pushliteral(L,"custom_attack");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,1);
                    lua_call(L,1,0);
                    assert(lua_gettop(L) == 10);
                  }
                  lua_settop(L,lc625);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L,lc611);
                assert(lua_gettop(L) == 10);
              }
              lua_settop(L,lc590);
              assert(lua_gettop(L) == 10);
            }
            else {
              
              /* --end of NSSM modifications
               * 
               * 		elseif self.attack_type == "shoot"
               * 		or (self.attack_type == "dogshoot" and dist > self.reach and not self.dogshoot_stop)	--NSSM modification
               * 		or (self.attack_type == "dogshoot" and self.dogshoot_stop and not self.direct_hit) then */
              enum { lc627 = 9 };
              lua_pushliteral(L,"attack_type");
              lua_gettable(L,1);
              lua_pushliteral(L,"shoot");
              const int lc628 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc628);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushliteral(L,"attack_type");
                lua_gettable(L,1);
                lua_pushliteral(L,"dogshoot");
                const int lc629 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc629);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"reach");
                  lua_gettable(L,1);
                  const int lc630 = lua_lessthan(L,-1,9);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc630);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"dogshoot_stop");
                  lua_gettable(L,1);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushliteral(L,"attack_type");
                lua_gettable(L,1);
                lua_pushliteral(L,"dogshoot");
                const int lc631 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc631);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"dogshoot_stop");
                  lua_gettable(L,1);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"direct_hit");
                  lua_gettable(L,1);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
              }
              const int lc632 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc632) {
                
                /* p.y = p.y - .5 */
                lua_pushliteral(L,"y");
                lua_gettable(L,8);
                lua_pushnumber(L,0.5);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"y");
                lua_insert(L,-2);
                lua_settable(L,8);
                assert(lua_gettop(L) == 9);
                
                /* s.y = s.y + .5 */
                lua_pushliteral(L,"y");
                lua_gettable(L,7);
                lua_pushnumber(L,0.5);
                lc_add(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"y");
                lua_insert(L,-2);
                lua_settable(L,7);
                assert(lua_gettop(L) == 9);
                
                /* local dist = get_distance(p, s) */
                lc_getupvalue(L,lua_upvalueindex(1),2,16);
                lua_pushvalue(L,8);
                lua_pushvalue(L,7);
                lua_call(L,2,1);
                assert(lua_gettop(L) == 10);
                
                /* local vec = {
                 * 				x = p.x - s.x,
                 * 				y = p.y - s.y,
                 * 				z = p.z - s.z
                 * 			} */
                lua_createtable(L,0,3);
                lua_pushliteral(L,"x");
                lua_pushliteral(L,"x");
                lua_gettable(L,8);
                lua_pushliteral(L,"x");
                lua_gettable(L,7);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_rawset(L,-3);
                lua_pushliteral(L,"y");
                lua_pushliteral(L,"y");
                lua_gettable(L,8);
                lua_pushliteral(L,"y");
                lua_gettable(L,7);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_rawset(L,-3);
                lua_pushliteral(L,"z");
                lua_pushliteral(L,"z");
                lua_gettable(L,8);
                lua_pushliteral(L,"z");
                lua_gettable(L,7);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_rawset(L,-3);
                assert(lua_gettop(L) == 11);
                
                /* if vec.x ~= 0
                 * 			and vec.z ~= 0 then */
                enum { lc633 = 11 };
                lua_pushliteral(L,"x");
                lua_gettable(L,11);
                lua_pushnumber(L,0);
                const int lc634 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc634);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"z");
                  lua_gettable(L,11);
                  lua_pushnumber(L,0);
                  const int lc635 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc635);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
                const int lc636 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc636) {
                  
                  /* yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate */
                  lc_getupvalue(L,lua_upvalueindex(1),5,13);
                  lua_pushliteral(L,"z");
                  lua_gettable(L,11);
                  lua_pushliteral(L,"x");
                  lua_gettable(L,11);
                  lc_div(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lua_call(L,1,1);
                  lc_getupvalue(L,lua_upvalueindex(1),7,11);
                  lua_pushnumber(L,2);
                  lc_div(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lc_add(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lua_pushliteral(L,"rotate");
                  lua_gettable(L,1);
                  lc_sub(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lua_replace(L,4);
                  assert(lua_gettop(L) == 11);
                  
                  /* if p.x > s.x then */
                  enum { lc637 = 11 };
                  lua_pushliteral(L,"x");
                  lua_gettable(L,7);
                  lua_pushliteral(L,"x");
                  lua_gettable(L,8);
                  const int lc638 = lua_lessthan(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc638);
                  const int lc639 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc639) {
                    
                    /* yaw = yaw + pi */
                    lc_getupvalue(L,lua_upvalueindex(1),7,11);
                    lc_add(L,4,-1);
                    lua_remove(L,-2);
                    lua_replace(L,4);
                    assert(lua_gettop(L) == 11);
                  }
                  lua_settop(L,lc637);
                  assert(lua_gettop(L) == 11);
                  
                  /* self.object:setyaw(yaw) */
                  lua_pushliteral(L,"object");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"setyaw");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,4);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 11);
                }
                lua_settop(L,lc633);
                assert(lua_gettop(L) == 11);
                
                /* set_velocity(self, 0) */
                lua_getfield(L,LUA_ENVIRONINDEX,"set_velocity");
                lua_pushvalue(L,1);
                lua_pushnumber(L,0);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 11);
                
                /* if self.shoot_interval
                 * 			and self.timer > self.shoot_interval
                 * 			and math.random(1, 100) <= 60 then */
                enum { lc640 = 11 };
                lua_pushliteral(L,"shoot_interval");
                lua_gettable(L,1);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"shoot_interval");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"timer");
                  lua_gettable(L,1);
                  const int lc641 = lua_lessthan(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc641);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,1);
                  lua_pushnumber(L,100);
                  lua_call(L,2,1);
                  lua_pushnumber(L,60);
                  const int lc642 = lc_le(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc642);
                }
                const int lc643 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc643) {
                  
                  /* self.timer = 0 */
                  lua_pushnumber(L,0);
                  lua_pushliteral(L,"timer");
                  lua_insert(L,-2);
                  lua_settable(L,1);
                  assert(lua_gettop(L) == 11);
                  
                  /* set_animation(self, "dattack") */
                  lua_getfield(L,LUA_ENVIRONINDEX,"set_animation");
                  lua_pushvalue(L,1);
                  lua_pushliteral(L,"dattack");
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 11);
                  
                  /* --NSSM modification
                   * -- play shoot attack sound
                   * if self.sounds.shoot_attack then */
                  enum { lc644 = 11 };
                  lua_pushliteral(L,"sounds");
                  lua_gettable(L,1);
                  lua_pushliteral(L,"shoot_attack");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc645 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc645) {
                    
                    /* minetest.sound_play(self.sounds.shoot_attack, {
                     * 						object = self.object,
                     * 						max_hear_distance = self.sounds.distance
                     * 					}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"sound_play");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"sounds");
                    lua_gettable(L,1);
                    lua_pushliteral(L,"shoot_attack");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_createtable(L,0,2);
                    lua_pushliteral(L,"object");
                    lua_pushliteral(L,"object");
                    lua_gettable(L,1);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"max_hear_distance");
                    lua_pushliteral(L,"sounds");
                    lua_gettable(L,1);
                    lua_pushliteral(L,"distance");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_rawset(L,-3);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 11);
                  }
                  lua_settop(L,lc644);
                  assert(lua_gettop(L) == 11);
                  
                  /* if not self.true_dist_attack then */
                  enum { lc646 = 11 };
                  lua_pushliteral(L,"true_dist_attack");
                  lua_gettable(L,1);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                  const int lc647 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc647) {
                    
                    /* --NSSM addition
                     * local p = self.object:getpos() */
                    lua_pushliteral(L,"object");
                    lua_gettable(L,1);
                    lua_pushliteral(L,"getpos");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_call(L,1,1);
                    assert(lua_gettop(L) == 12);
                    
                    /* p.y = p.y + (self.collisionbox[2] + self.collisionbox[5]) / 2 */
                    lua_pushliteral(L,"y");
                    lua_gettable(L,12);
                    lua_pushliteral(L,"collisionbox");
                    lua_gettable(L,1);
                    lua_pushnumber(L,2);
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"collisionbox");
                    lua_gettable(L,1);
                    lua_pushnumber(L,5);
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushnumber(L,2);
                    lc_div(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"y");
                    lua_insert(L,-2);
                    lua_settable(L,12);
                    assert(lua_gettop(L) == 12);
                    
                    /* local obj = minetest.add_entity(p, self.arrow) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"add_entity");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,12);
                    lua_pushliteral(L,"arrow");
                    lua_gettable(L,1);
                    lua_call(L,2,1);
                    assert(lua_gettop(L) == 13);
                    
                    /* local ent = obj:get_luaentity() */
                    lua_pushvalue(L,13);
                    lua_pushliteral(L,"get_luaentity");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_call(L,1,1);
                    assert(lua_gettop(L) == 14);
                    
                    /* local amount = (vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) ^ 0.5 */
                    lua_pushliteral(L,"x");
                    lua_gettable(L,11);
                    lua_pushliteral(L,"x");
                    lua_gettable(L,11);
                    lc_mul(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"y");
                    lua_gettable(L,11);
                    lua_pushliteral(L,"y");
                    lua_gettable(L,11);
                    lc_mul(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"z");
                    lua_gettable(L,11);
                    lua_pushliteral(L,"z");
                    lua_gettable(L,11);
                    lc_mul(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushnumber(L,0.5);
                    lc_pow(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    assert(lua_gettop(L) == 15);
                    
                    /* local v = ent.velocity */
                    lua_pushliteral(L,"velocity");
                    lua_gettable(L,14);
                    assert(lua_gettop(L) == 16);
                    
                    /* ent.switch = 1 */
                    lua_pushnumber(L,1);
                    lua_pushliteral(L,"switch");
                    lua_insert(L,-2);
                    lua_settable(L,14);
                    assert(lua_gettop(L) == 16);
                    
                    /* --NSSM additions:
                     * if (self.dogshoot_stop) then */
                    enum { lc648 = 16 };
                    lua_pushliteral(L,"dogshoot_stop");
                    lua_gettable(L,1);
                    const int lc649 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc649) {
                      
                      /* self.num_sons=self.num_sons+1 */
                      lua_pushliteral(L,"num_sons");
                      lua_gettable(L,1);
                      lua_pushnumber(L,1);
                      lc_add(L,-2,-1);
                      lua_remove(L,-2);
                      lua_remove(L,-2);
                      lua_pushliteral(L,"num_sons");
                      lua_insert(L,-2);
                      lua_settable(L,1);
                      assert(lua_gettop(L) == 16);
                      
                      /* --minetest.chat_send_all("num_sons="..self.num_sons)
                       * if (self.num_sons>2) then */
                      enum { lc650 = 16 };
                      lua_pushnumber(L,2);
                      lua_pushliteral(L,"num_sons");
                      lua_gettable(L,1);
                      const int lc651 = lua_lessthan(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc651);
                      const int lc652 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc652) {
                        
                        /* self.direct_hit=true */
                        lua_pushboolean(L,1);
                        lua_pushliteral(L,"direct_hit");
                        lua_insert(L,-2);
                        lua_settable(L,1);
                        assert(lua_gettop(L) == 16);
                      }
                      lua_settop(L,lc650);
                      assert(lua_gettop(L) == 16);
                    }
                    lua_settop(L,lc648);
                    assert(lua_gettop(L) == 16);
                    
                    /* --end of NSSM additions
                     * -- offset makes shoot aim accurate
                     * vec.y = vec.y + self.shoot_offset */
                    lua_pushliteral(L,"y");
                    lua_gettable(L,11);
                    lua_pushliteral(L,"shoot_offset");
                    lua_gettable(L,1);
                    lc_add(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"y");
                    lua_insert(L,-2);
                    lua_settable(L,11);
                    assert(lua_gettop(L) == 16);
                    
                    /* vec.x = vec.x * v / amount */
                    lua_pushliteral(L,"x");
                    lua_gettable(L,11);
                    lc_mul(L,-1,16);
                    lua_remove(L,-2);
                    lc_div(L,-1,15);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"x");
                    lua_insert(L,-2);
                    lua_settable(L,11);
                    assert(lua_gettop(L) == 16);
                    
                    /* vec.y = vec.y * v / amount */
                    lua_pushliteral(L,"y");
                    lua_gettable(L,11);
                    lc_mul(L,-1,16);
                    lua_remove(L,-2);
                    lc_div(L,-1,15);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"y");
                    lua_insert(L,-2);
                    lua_settable(L,11);
                    assert(lua_gettop(L) == 16);
                    
                    /* vec.z = vec.z * v / amount */
                    lua_pushliteral(L,"z");
                    lua_gettable(L,11);
                    lc_mul(L,-1,16);
                    lua_remove(L,-2);
                    lc_div(L,-1,15);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"z");
                    lua_insert(L,-2);
                    lua_settable(L,11);
                    assert(lua_gettop(L) == 16);
                    
                    /* obj:setvelocity(vec) */
                    lua_pushvalue(L,13);
                    lua_pushliteral(L,"setvelocity");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_pushvalue(L,11);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 16);
                  }
                  else {
                    
                    /* else
                     * if math.random(1,100)<=50 then */
                    enum { lc653 = 11 };
                    lua_getfield(L,LUA_ENVIRONINDEX,"math");
                    lua_pushliteral(L,"random");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushnumber(L,1);
                    lua_pushnumber(L,100);
                    lua_call(L,2,1);
                    lua_pushnumber(L,50);
                    const int lc654 = lc_le(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc654);
                    const int lc655 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc655) {
                      
                      /* self.on_dist_attack(self, self.attack) */
                      lua_pushliteral(L,"on_dist_attack");
                      lua_gettable(L,1);
                      lua_pushvalue(L,1);
                      lua_pushliteral(L,"attack");
                      lua_gettable(L,1);
                      lua_call(L,2,0);
                      assert(lua_gettop(L) == 11);
                      
                      /* if (self.dogshoot_stop) then */
                      enum { lc656 = 11 };
                      lua_pushliteral(L,"dogshoot_stop");
                      lua_gettable(L,1);
                      const int lc657 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc657) {
                        
                        /* self.num_sons=self.num_sons+1 */
                        lua_pushliteral(L,"num_sons");
                        lua_gettable(L,1);
                        lua_pushnumber(L,1);
                        lc_add(L,-2,-1);
                        lua_remove(L,-2);
                        lua_remove(L,-2);
                        lua_pushliteral(L,"num_sons");
                        lua_insert(L,-2);
                        lua_settable(L,1);
                        assert(lua_gettop(L) == 11);
                        
                        /* --minetest.chat_send_all("num_sons="..self.num_sons)
                         * if (self.num_sons>2) then */
                        enum { lc658 = 11 };
                        lua_pushnumber(L,2);
                        lua_pushliteral(L,"num_sons");
                        lua_gettable(L,1);
                        const int lc659 = lua_lessthan(L,-2,-1);
                        lua_pop(L,2);
                        lua_pushboolean(L,lc659);
                        const int lc660 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc660) {
                          
                          /* self.direct_hit=true */
                          lua_pushboolean(L,1);
                          lua_pushliteral(L,"direct_hit");
                          lua_insert(L,-2);
                          lua_settable(L,1);
                          assert(lua_gettop(L) == 11);
                        }
                        lua_settop(L,lc658);
                        assert(lua_gettop(L) == 11);
                      }
                      lua_settop(L,lc656);
                      assert(lua_gettop(L) == 11);
                    }
                    lua_settop(L,lc653);
                    assert(lua_gettop(L) == 11);
                  }
                  lua_settop(L,lc646);
                  assert(lua_gettop(L) == 11);
                }
                lua_settop(L,lc640);
                assert(lua_gettop(L) == 11);
              }
              lua_settop(L,lc627);
            }
            lua_settop(L,lc546);
          }
          lua_settop(L,lc512);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc505);
      }
      lua_settop(L,lc495);
    }
    lua_settop(L,lc473);
  }
  lua_settop(L,lc444);
  assert(lua_gettop(L) == 6);
  
  /* -- END if self.state == "attack"
   * --NSSM additions:
   * --larva and mantis
   * if self.metamorphosis == true then */
  enum { lc661 = 6 };
  lua_pushliteral(L,"metamorphosis");
  lua_gettable(L,1);
  lua_pushboolean(L,1);
  const int lc662 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc662);
  const int lc663 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc663) {
    
    /* if os.time() - self.metatimer >20 then */
    enum { lc664 = 6 };
    lua_pushnumber(L,20);
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"time");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushliteral(L,"metatimer");
    lua_gettable(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    const int lc665 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc665);
    const int lc666 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc666) {
      
      /* minetest.log("action",
       * 					"metatimer expired, metamorphosis! ") */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"action");
      lua_pushliteral(L,"metatimer expired, metamorphosis! ");
      lua_call(L,2,0);
      assert(lua_gettop(L) == 6);
      
      /* local pos=self.object:getpos() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 7);
      
      /* self.object:remove() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"remove");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 7);
      
      /* minetest.add_particlespawner(
       * 					200, --amount
       * 					0.1, --time
       * 					{x=pos.x-1, y=pos.y-1, z=pos.z-1}, --minpos
       * 					{x=pos.x+1, y=pos.y+1, z=pos.z+1}, --maxpos
       * 					{x=-0, y=-0, z=-0}, --minvel
       * 					{x=1, y=1, z=1}, --maxvel
       * 					{x=-0.5,y=5,z=-0.5}, --minacc
       * 					{x=0.5,y=5,z=0.5}, --maxacc
       * 					0.1, --minexptime
       * 					1, --maxexptime
       * 					3, --minsize
       * 					4, --maxsize
       * 					false, --collisiondetection
       * 					"tnt_smoke.png" --texture
       * 				) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"add_particlespawner");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,200);
      lua_pushnumber(L,0.1);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,-0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushnumber(L,-0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,-0);
      lua_rawset(L,-3);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,-0.5);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushnumber(L,5);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,-0.5);
      lua_rawset(L,-3);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushnumber(L,0.5);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushnumber(L,5);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushnumber(L,0.5);
      lua_rawset(L,-3);
      lua_pushnumber(L,0.1);
      lua_pushnumber(L,1);
      lua_pushnumber(L,3);
      lua_pushnumber(L,4);
      lua_pushboolean(L,0);
      lua_pushliteral(L,"tnt_smoke.png");
      lua_call(L,14,0);
      assert(lua_gettop(L) == 7);
      
      /* if math.random(1,2)==1 then */
      enum { lc667 = 7 };
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,2);
      lua_call(L,2,1);
      lua_pushnumber(L,1);
      const int lc668 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc668);
      const int lc669 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc669) {
        
        /* minetest.add_entity(pos, "nssm:mantis") */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"add_entity");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_pushliteral(L,"nssm:mantis");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 7);
      }
      else {
        
        /* else
         * minetest.add_entity(pos, "nssm:mantis_beast") */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"add_entity");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_pushliteral(L,"nssm:mantis_beast");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 7);
      }
      lua_settop(L,lc667);
      assert(lua_gettop(L) == 7);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc664);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc661);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* function() */
static int lcf699 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* self.object:settexturemod("") */
  lc_getupvalue(L,lua_upvalueindex(1),0,21);
  lua_pushliteral(L,"object");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"settexturemod");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* function() */
static int lcf700 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* self.object:settexturemod("^[colorize:#c9900070") */
  lc_getupvalue(L,lua_upvalueindex(1),0,21);
  lua_pushliteral(L,"object");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"settexturemod");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"^[colorize:#c9900070");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 0);
  
  /* core.after(0.3, function()
   * 				self.object:settexturemod("")
   * 			end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"core");
  lua_pushliteral(L,"after");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.3);
  lua_pushvalue(L,lua_upvalueindex(1));
  lua_pushcclosure(L,lcf699,1);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* function(self, hitter, tflp, tool_capabilities, dir) */
static int lcf734 (lua_State * L) {
  lua_checkstack(L,27);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc671 = 6 };
  assert((lua_gettop(L) == lc671));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,21);
  
  /* -- direction error check
   * dir = dir or {x = 0, y = 0, z = 0} */
  lua_pushvalue(L,5);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
  }
  lua_replace(L,5);
  assert(lua_gettop(L) == 6);
  
  /* -- weapon wear
   * local weapon = hitter:get_wielded_item() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get_wielded_item");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local punch_interval = 1.4 */
  lua_pushnumber(L,1.4);
  assert(lua_gettop(L) == 8);
  
  /* -- calculate mob damage
   * local damage = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 9);
  
  /* local armor = self.object:get_armor_groups() or {} */
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"object");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_armor_groups");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_newtable(L);
  }
  assert(lua_gettop(L) == 10);
  
  /* local tmp */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 11);
  
  /* -- added by MrCerealGuy 2016-04-14, if tool_capabilities is nil, then set default values (see default/tools.lua)
   * if tool_capabilities == nil then */
  enum { lc672 = 11 };
  lua_pushnil(L);
  const int lc673 = lua_equal(L,4,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc673);
  const int lc674 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc674) {
    
    /* tool_capabilities = {
     * 		        full_punch_interval = 0.9,
     * 		        max_drop_level = 0,
     * 		        groupcaps = {
     * 			        crumbly = {times={[2]=3.00, [3]=0.70}, uses=0, maxlevel=1},
     * 			        snappy = {times={[3]=0.40}, uses=0, maxlevel=1},
     * 			        oddly_breakable_by_hand = {times={[1]=3.50,[2]=2.00,[3]=0.70}, uses=0}
     * 		        },
     * 		        damage_groups = {fleshy=1},
     * 	        } */
    lua_createtable(L,0,4);
    lua_pushliteral(L,"full_punch_interval");
    lua_pushnumber(L,0.9);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_drop_level");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groupcaps");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"crumbly");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"times");
    lua_createtable(L,0,2);
    lua_pushnumber(L,2);
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushnumber(L,3);
    lua_pushnumber(L,0.7);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"uses");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"maxlevel");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"snappy");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"times");
    lua_createtable(L,0,1);
    lua_pushnumber(L,3);
    lua_pushnumber(L,0.4);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"uses");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"maxlevel");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"oddly_breakable_by_hand");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"times");
    lua_createtable(L,0,3);
    lua_pushnumber(L,1);
    lua_pushnumber(L,3.5);
    lua_rawset(L,-3);
    lua_pushnumber(L,2);
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushnumber(L,3);
    lua_pushnumber(L,0.7);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"uses");
    lua_pushnumber(L,0);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"damage_groups");
    lua_createtable(L,0,1);
    lua_pushliteral(L,"fleshy");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_replace(L,4);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc672);
  assert(lua_gettop(L) == 11);
  
  /* if tflp == nil then */
  enum { lc675 = 11 };
  lua_pushnil(L);
  const int lc676 = lua_equal(L,3,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc676);
  const int lc677 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc677) {
    
    /* tflp = 1 */
    lua_pushnumber(L,1);
    lua_replace(L,3);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc675);
  assert(lua_gettop(L) == 11);
  
  /* for group,_ in pairs(tool_capabilities.damage_groups) do
   * internal: local f, s, var = explist */
  enum { lc678 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushliteral(L,"damage_groups");
  lua_gettable(L,4);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local group with idx 15
     * internal: local _ with idx 16 */
    
    
    /* tmp = tflp / tool_capabilities.full_punch_interval */
    lua_pushliteral(L,"full_punch_interval");
    lua_gettable(L,4);
    lc_div(L,3,-1);
    lua_remove(L,-2);
    lua_replace(L,11);
    assert(lua_gettop(L) == 16);
    
    /* if tmp < 0 then */
    enum { lc679 = 16 };
    lua_pushnumber(L,0);
    const int lc680 = lua_lessthan(L,11,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc680);
    const int lc681 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc681) {
      
      /* tmp = 0.0 */
      lua_pushnumber(L,0);
      lua_replace(L,11);
      assert(lua_gettop(L) == 16);
    }
    else {
      
      /* elseif tmp > 1 then */
      enum { lc682 = 16 };
      lua_pushnumber(L,1);
      const int lc683 = lua_lessthan(L,-1,11);
      lua_pop(L,1);
      lua_pushboolean(L,lc683);
      const int lc684 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc684) {
        
        /* tmp = 1.0 */
        lua_pushnumber(L,1);
        lua_replace(L,11);
        assert(lua_gettop(L) == 16);
      }
      lua_settop(L,lc682);
    }
    lua_settop(L,lc679);
    assert(lua_gettop(L) == 16);
    
    /* damage = damage + (tool_capabilities.damage_groups[group] or 0)
     * 			    * tmp * ((armor[group] or 0) / 100.0) */
    lua_pushliteral(L,"damage_groups");
    lua_gettable(L,4);
    lua_pushvalue(L,15);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    lc_mul(L,-1,11);
    lua_remove(L,-2);
    lua_pushvalue(L,15);
    lua_gettable(L,10);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    lua_pushnumber(L,100);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_add(L,9,-1);
    lua_remove(L,-2);
    lua_replace(L,9);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc678);
  assert(lua_gettop(L) == 11);
  
  /* -- check for tool immunity or special damage
   * for _, no in pairs(self.immune_to) do
   * internal: local f, s, var = explist */
  enum { lc685 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"immune_to");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 15
     * internal: local no with idx 16 */
    
    
    /* if no[1] == weapon:get_name() then */
    enum { lc686 = 16 };
    lua_pushnumber(L,1);
    lua_gettable(L,16);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"get_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    const int lc687 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc687);
    const int lc688 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc688) {
      
      /* damage = no[2] or 0 */
      lua_pushnumber(L,2);
      lua_gettable(L,16);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushnumber(L,0);
      }
      lua_replace(L,9);
      assert(lua_gettop(L) == 16);
      
      /* break */
      break;
      assert(lua_gettop(L) == 16);
    }
    lua_settop(L,lc686);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc685);
  assert(lua_gettop(L) == 11);
  
  /* -- print ("Mob Damage is", damage)
   * -- add weapon wear
   * if tool_capabilities then */
  enum { lc689 = 11 };
  if (lua_toboolean(L,4)) {
    
    /* punch_interval = tool_capabilities.full_punch_interval or 1.4 */
    lua_pushliteral(L,"full_punch_interval");
    lua_gettable(L,4);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,1.4);
    }
    lua_replace(L,8);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc689);
  assert(lua_gettop(L) == 11);
  
  /* if weapon:get_definition()
   * 		and weapon:get_definition().tool_capabilities then */
  enum { lc690 = 11 };
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get_definition");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"get_definition");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"tool_capabilities");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc691 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc691) {
    
    /* weapon:add_wear(math.floor((punch_interval / 75) * 9000)) */
    lua_pushvalue(L,7);
    const int lc692 = lua_gettop(L);
    lua_pushliteral(L,"add_wear");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,75);
    lc_div(L,8,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,9000);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc692),0);
    assert(lua_gettop(L) == 11);
    
    /* hitter:set_wielded_item(weapon) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"set_wielded_item");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,7);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc690);
  assert(lua_gettop(L) == 11);
  
  /* -- weapon sounds
   * if weapon:get_definition().sounds ~= nil then */
  enum { lc693 = 11 };
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get_definition");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"sounds");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc694 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc694);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc695 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc695) {
    
    /* local s = math.random(0, #weapon:get_definition().sounds) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,0);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"get_definition");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"sounds");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc696 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc696);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 12);
    
    /* minetest.sound_play(weapon:get_definition().sounds[s], {
     * 				object = hitter,
     * 				max_hear_distance = 8
     * 			}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"sound_play");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"get_definition");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"sounds");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,12);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"object");
    lua_pushvalue(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_hear_distance");
    lua_pushnumber(L,8);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 12);
  }
  else {
    
    /* else
     * minetest.sound_play("default_punch", {
     * 				object = hitter,
     * 				max_hear_distance = 5
     * 			}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"sound_play");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default_punch");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"object");
    lua_pushvalue(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_hear_distance");
    lua_pushnumber(L,5);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc693);
  assert(lua_gettop(L) == 11);
  
  /* -- do damage
   * self.health = self.health - math.floor(damage) */
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"health");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,9);
  lua_call(L,1,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc671,0,21);
  lua_insert(L,-2);
  lua_pushliteral(L,"health");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 11);
  
  /* -- exit here if dead
   * if check_for_death(self) then */
  enum { lc697 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"check_for_death");
  lc_getupvalue(L,lc671,0,21);
  lua_call(L,1,1);
  const int lc698 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc698) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc697);
  assert(lua_gettop(L) == 11);
  
  /* -- add healthy afterglow when hit
   * core.after(0.1, function()
   * 			self.object:settexturemod("^[colorize:#c9900070")
   * 
   * 			core.after(0.3, function()
   * 				self.object:settexturemod("")
   * 			end)
   * 		end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"core");
  lua_pushliteral(L,"after");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.1);
  lua_pushvalue(L,lc671);
  lua_pushcclosure(L,lcf700,1);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 11);
  
  /* -- blood_particles
   * if self.blood_amount > 0
   * 		and not disable_blood then */
  enum { lc701 = 11 };
  lua_pushnumber(L,0);
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"blood_amount");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc702 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc702);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lc671,16,3);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc703 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc703) {
    
    /* local pos = self.object:getpos() */
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"object");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* pos.y = pos.y + (-self.collisionbox[2] + self.collisionbox[5]) / 2 */
    lua_pushliteral(L,"y");
    lua_gettable(L,12);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"collisionbox");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_unm(L,-1);
    lua_remove(L,-2);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"collisionbox");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,12);
    assert(lua_gettop(L) == 12);
    
    /* effect(pos, self.blood_amount, self.blood_texture) */
    lua_getfield(L,LUA_ENVIRONINDEX,"effect");
    lua_pushvalue(L,12);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"blood_amount");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"blood_texture");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc701);
  assert(lua_gettop(L) == 11);
  
  /* -- knock back effect (only on full punch)
   * if self.knock_back > 0
   * 		and tflp > punch_interval then */
  enum { lc704 = 11 };
  lua_pushnumber(L,0);
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"knock_back");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc705 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc705);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    const int lc706 = lua_lessthan(L,8,3);
    lua_pushboolean(L,lc706);
  }
  const int lc707 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc707) {
    
    /* local v = self.object:getvelocity() */
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"object");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"getvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* local r = 1.4 - math.min(punch_interval, 1.4) */
    lua_pushnumber(L,1.4);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,8);
    lua_pushnumber(L,1.4);
    lua_call(L,2,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 13);
    
    /* local kb = r * 5 */
    lua_pushnumber(L,5);
    lc_mul(L,13,-1);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 14);
    
    /* local up = 2 */
    lua_pushnumber(L,2);
    assert(lua_gettop(L) == 15);
    
    /* -- if already in air then dont go up anymore when hit
     * if v.y > 0
     * 			or self.fly then */
    enum { lc708 = 15 };
    lua_pushnumber(L,0);
    lua_pushliteral(L,"y");
    lua_gettable(L,12);
    const int lc709 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc709);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lc_getupvalue(L,lc671,0,21);
      lua_pushliteral(L,"fly");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc710 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc710) {
      
      /* up = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,15);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc708);
    assert(lua_gettop(L) == 15);
    
    /* self.object:setvelocity({
     * 				x = dir.x * kb,
     * 				y = up,
     * 				z = dir.z * kb
     * 			}) */
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"object");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"setvelocity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,5);
    lc_mul(L,-1,14);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushvalue(L,15);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    lc_mul(L,-1,14);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 15);
    
    /* self.pause_timer = r */
    lua_pushvalue(L,13);
    lc_getupvalue(L,lc671,0,21);
    lua_insert(L,-2);
    lua_pushliteral(L,"pause_timer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 15);
  }
  lua_settop(L,lc704);
  assert(lua_gettop(L) == 11);
  
  /* -- if skittish then run away
   * if self.runaway == true then */
  enum { lc711 = 11 };
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"runaway");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc712 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc712);
  const int lc713 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc713) {
    
    /* local lp = hitter:getpos() */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* local s = self.object:getpos() */
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"object");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 13);
    
    /* local vec = {
     * 				x = lp.x - s.x,
     * 				y = lp.y - s.y,
     * 				z = lp.z - s.z
     * 			} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,12);
    lua_pushliteral(L,"x");
    lua_gettable(L,13);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,12);
    lua_pushliteral(L,"y");
    lua_gettable(L,13);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,12);
    lua_pushliteral(L,"z");
    lua_gettable(L,13);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 14);
    
    /* if vec.x ~= 0
     * 			and vec.z ~= 0 then */
    enum { lc714 = 14 };
    lua_pushliteral(L,"x");
    lua_gettable(L,14);
    lua_pushnumber(L,0);
    const int lc715 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc715);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"z");
      lua_gettable(L,14);
      lua_pushnumber(L,0);
      const int lc716 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc716);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc717 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc717) {
      
      /* local yaw = atan(vec.z / vec.x) + 3 * pi / 2 - self.rotate */
      lc_getupvalue(L,lc671,6,13);
      lua_pushliteral(L,"z");
      lua_gettable(L,14);
      lua_pushliteral(L,"x");
      lua_gettable(L,14);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushnumber(L,3);
      lc_getupvalue(L,lc671,8,11);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lc671,0,21);
      lua_pushliteral(L,"rotate");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 15);
      
      /* if lp.x > s.x then */
      enum { lc718 = 15 };
      lua_pushliteral(L,"x");
      lua_gettable(L,13);
      lua_pushliteral(L,"x");
      lua_gettable(L,12);
      const int lc719 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc719);
      const int lc720 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc720) {
        
        /* yaw = yaw + pi */
        lc_getupvalue(L,lc671,8,11);
        lc_add(L,15,-1);
        lua_remove(L,-2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc718);
      assert(lua_gettop(L) == 15);
      
      /* self.object:setyaw(yaw) */
      lc_getupvalue(L,lc671,0,21);
      lua_pushliteral(L,"object");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"setyaw");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,15);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc714);
    assert(lua_gettop(L) == 14);
    
    /* self.state = "runaway" */
    lua_pushliteral(L,"runaway");
    lc_getupvalue(L,lc671,0,21);
    lua_insert(L,-2);
    lua_pushliteral(L,"state");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 14);
    
    /* self.runaway_timer = 0 */
    lua_pushnumber(L,0);
    lc_getupvalue(L,lc671,0,21);
    lua_insert(L,-2);
    lua_pushliteral(L,"runaway_timer");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 14);
    
    /* self.following = nil */
    lua_pushnil(L);
    lc_getupvalue(L,lc671,0,21);
    lua_insert(L,-2);
    lua_pushliteral(L,"following");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc711);
  assert(lua_gettop(L) == 11);
  
  /* -- attack puncher and call other nssm for help
   * if self.passive == false
   * 		and self.state ~= "flop"
   * 		and self.child == false
   * 		and hitter:get_player_name() ~= self.owner then */
  enum { lc721 = 11 };
  lc_getupvalue(L,lc671,0,21);
  lua_pushliteral(L,"passive");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,0);
  const int lc722 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc722);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"state");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"flop");
    const int lc723 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc723);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"child");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,0);
    const int lc724 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc724);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lc_getupvalue(L,lc671,0,21);
    lua_pushliteral(L,"owner");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc725 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc725);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc726 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc726) {
    
    /* -- attack whoever punched mob
     * self.state = "" */
    lua_pushliteral(L,"");
    lc_getupvalue(L,lc671,0,21);
    lua_insert(L,-2);
    lua_pushliteral(L,"state");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 11);
    
    /* do_attack(self, hitter) */
    lua_getfield(L,LUA_ENVIRONINDEX,"do_attack");
    lc_getupvalue(L,lc671,0,21);
    lua_pushvalue(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
    
    /* -- alert others to the attack
     * local obj = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 12);
    
    /* for _, oir in pairs(minetest.get_objects_inside_radius(hitter:getpos(), 5)) do
     * internal: local f, s, var = explist */
    enum { lc727 = 12 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    const int lc728 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_objects_inside_radius");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"getpos");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushnumber(L,5);
    lua_call(L,2,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc728),3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 16
       * internal: local oir with idx 17 */
      
      
      /* obj = oir:get_luaentity() */
      lua_pushvalue(L,17);
      lua_pushliteral(L,"get_luaentity");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_replace(L,12);
      assert(lua_gettop(L) == 17);
      
      /* if obj then */
      enum { lc729 = 17 };
      if (lua_toboolean(L,12)) {
        
        /* if obj.group_attack == true
         * 					and obj.state ~= "attack" then */
        enum { lc730 = 17 };
        lua_pushliteral(L,"group_attack");
        lua_gettable(L,12);
        lua_pushboolean(L,1);
        const int lc731 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc731);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"state");
          lua_gettable(L,12);
          lua_pushliteral(L,"attack");
          const int lc732 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc732);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc733 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc733) {
          
          /* do_attack(obj, hitter) */
          lua_getfield(L,LUA_ENVIRONINDEX,"do_attack");
          lua_pushvalue(L,12);
          lua_pushvalue(L,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 17);
        }
        lua_settop(L,lc730);
        assert(lua_gettop(L) == 17);
      }
      lua_settop(L,lc729);
      assert(lua_gettop(L) == 17);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc727);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc721);
  assert(lua_gettop(L) == 11);
  return 0;
}


/* function(self, staticdata, dtime_s) */
static int lcf760 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- remove monsters in peaceful mode, or when no data
   * if (self.type == "monster" and peaceful_only)
   * 		or not staticdata then */
  enum { lc735 = 3 };
  lua_pushliteral(L,"type");
  lua_gettable(L,1);
  lua_pushliteral(L,"monster");
  const int lc736 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc736);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),16,2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,2)));
  }
  const int lc737 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc737) {
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc735);
  assert(lua_gettop(L) == 3);
  
  /* -- load entity variables
   * local tmp = minetest.deserialize(staticdata) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"deserialize");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* if tmp then */
  enum { lc738 = 4 };
  if (lua_toboolean(L,4)) {
    
    /* for _,stat in pairs(tmp) do
     * internal: local f, s, var = explist */
    enum { lc739 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    lua_pushvalue(L,4);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 8
       * internal: local stat with idx 9 */
      
      
      /* self[_] = stat */
      lua_pushvalue(L,9);
      lua_pushvalue(L,8);
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 9);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc739);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc738);
  assert(lua_gettop(L) == 4);
  
  /* -- select random texture, set model and size
   * if not self.base_texture then */
  enum { lc740 = 4 };
  lua_pushliteral(L,"base_texture");
  lua_gettable(L,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc741 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc741) {
    
    /* self.base_texture = def.textures[math.random(1, #def.textures)] */
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"textures");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"textures");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc742 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc742);
    lua_call(L,2,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"base_texture");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
    
    /* self.base_mesh = def.mesh */
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"mesh");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"base_mesh");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
    
    /* self.base_size = self.visual_size */
    lua_pushliteral(L,"visual_size");
    lua_gettable(L,1);
    lua_pushliteral(L,"base_size");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
    
    /* self.base_colbox = self.collisionbox */
    lua_pushliteral(L,"collisionbox");
    lua_gettable(L,1);
    lua_pushliteral(L,"base_colbox");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc740);
  assert(lua_gettop(L) == 4);
  
  /* --NSSM addition, random melee attack:
   * if self.mele_number>1 then */
  enum { lc743 = 4 };
  lua_pushnumber(L,1);
  lua_pushliteral(L,"mele_number");
  lua_gettable(L,1);
  const int lc744 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc744);
  const int lc745 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc745) {
    
    /* randattack=math.random(1,self.mele_number) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushliteral(L,"mele_number");
    lua_gettable(L,1);
    lua_call(L,2,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"randattack");
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc743);
  assert(lua_gettop(L) == 4);
  
  /* --end of NSSM additions
   * -- set texture, model and size
   * local textures = self.base_texture */
  lua_pushliteral(L,"base_texture");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 5);
  
  /* local mesh = self.base_mesh */
  lua_pushliteral(L,"base_mesh");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 6);
  
  /* local vis_size = self.base_size */
  lua_pushliteral(L,"base_size");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 7);
  
  /* local colbox = self.base_colbox */
  lua_pushliteral(L,"base_colbox");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* -- specific texture if gotten
   * if self.gotten == true
   * 		and def.gotten_texture then */
  enum { lc746 = 8 };
  lua_pushliteral(L,"gotten");
  lua_gettable(L,1);
  lua_pushboolean(L,1);
  const int lc747 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc747);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"gotten_texture");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc748 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc748) {
    
    /* textures = def.gotten_texture */
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"gotten_texture");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,5);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc746);
  assert(lua_gettop(L) == 8);
  
  /* -- specific mesh if gotten
   * if self.gotten == true
   * 		and def.gotten_mesh then */
  enum { lc749 = 8 };
  lua_pushliteral(L,"gotten");
  lua_gettable(L,1);
  lua_pushboolean(L,1);
  const int lc750 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc750);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"gotten_mesh");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc751 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc751) {
    
    /* mesh = def.gotten_mesh */
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"gotten_mesh");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,6);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc749);
  assert(lua_gettop(L) == 8);
  
  /* -- set child objects to half size
   * if self.child == true then */
  enum { lc752 = 8 };
  lua_pushliteral(L,"child");
  lua_gettable(L,1);
  lua_pushboolean(L,1);
  const int lc753 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc753);
  const int lc754 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc754) {
    
    /* vis_size = {
     * 				x = self.base_size.x / 2,
     * 				y = self.base_size.y / 2
     * 			} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"base_size");
    lua_gettable(L,1);
    lua_pushliteral(L,"x");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"base_size");
    lua_gettable(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_replace(L,7);
    assert(lua_gettop(L) == 8);
    
    /* if def.child_texture then */
    enum { lc755 = 8 };
    lc_getupvalue(L,lua_upvalueindex(1),0,20);
    lua_pushliteral(L,"child_texture");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc756 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc756) {
      
      /* textures = def.child_texture[1] */
      lc_getupvalue(L,lua_upvalueindex(1),0,20);
      lua_pushliteral(L,"child_texture");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_replace(L,5);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc755);
    assert(lua_gettop(L) == 8);
    
    /* colbox = {
     * 				self.base_colbox[1] / 2,
     * 				self.base_colbox[2] / 2,
     * 				self.base_colbox[3] / 2,
     * 				self.base_colbox[4] / 2,
     * 				self.base_colbox[5] / 2,
     * 				self.base_colbox[6] / 2
     * 			} */
    lua_createtable(L,6,0);
    lua_pushliteral(L,"base_colbox");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"base_colbox");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"base_colbox");
    lua_gettable(L,1);
    lua_pushnumber(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"base_colbox");
    lua_gettable(L,1);
    lua_pushnumber(L,4);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"base_colbox");
    lua_gettable(L,1);
    lua_pushnumber(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"base_colbox");
    lua_gettable(L,1);
    lua_pushnumber(L,6);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,6);
    lua_replace(L,8);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc752);
  assert(lua_gettop(L) == 8);
  
  /* if self.health == 0 then */
  enum { lc757 = 8 };
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc758 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc758);
  const int lc759 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc759) {
    
    /* self.health = math.random(self.hp_min, self.hp_max) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"hp_min");
    lua_gettable(L,1);
    lua_pushliteral(L,"hp_max");
    lua_gettable(L,1);
    lua_call(L,2,1);
    lua_pushliteral(L,"health");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc757);
  assert(lua_gettop(L) == 8);
  
  /* -- rnd: pathfinding init
   * self.path = {} */
  lua_newtable(L);
  lua_pushliteral(L,"path");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.path.way = {} */
  lua_newtable(L);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"way");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* -- path to follow, table of positions
   * self.path.lastpos = {x = 0, y = 0, z = 0} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"lastpos");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.path.stuck = false */
  lua_pushboolean(L,0);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"stuck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.path.following = false */
  lua_pushboolean(L,0);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"following");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* -- currently following path?
   * self.path.stuck_timer = 0 */
  lua_pushnumber(L,0);
  lua_pushliteral(L,"path");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"stuck_timer");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* -- if stuck for too long search for path
   * -- end init
   * self.object:set_armor_groups({immortal = 1, fleshy = self.armor}) */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"set_armor_groups");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"immortal");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"fleshy");
  lua_pushliteral(L,"armor");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 8);
  
  /* self.old_y = self.object:getpos().y */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"y");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"old_y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.old_health = self.health */
  lua_pushliteral(L,"health");
  lua_gettable(L,1);
  lua_pushliteral(L,"old_health");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.object:setyaw((math.random(0, 360) - 180) / 180 * pi) */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"setyaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0);
  lua_pushnumber(L,360);
  lua_call(L,2,1);
  lua_pushnumber(L,180);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,180);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),7,11);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 8);
  
  /* self.sounds.distance = self.sounds.distance or 10 */
  lua_pushliteral(L,"sounds");
  lua_gettable(L,1);
  lua_pushliteral(L,"distance");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,10);
  }
  lua_pushliteral(L,"sounds");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"distance");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.textures = textures */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"textures");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.mesh = mesh */
  lua_pushvalue(L,6);
  lua_pushliteral(L,"mesh");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.collisionbox = colbox */
  lua_pushvalue(L,8);
  lua_pushliteral(L,"collisionbox");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.visual_size = vis_size */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"visual_size");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* self.standing_in = "" */
  lua_pushliteral(L,"");
  lua_pushliteral(L,"standing_in");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* -- set anything changed above
   * self.object:set_properties(self) */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"set_properties");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 8);
  
  /* update_tag(self) */
  lua_getfield(L,LUA_ENVIRONINDEX,"update_tag");
  lua_pushvalue(L,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 8);
  return 0;
}


/* function(self) */
static int lcf773 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* -- remove mob when out of range unless tamed
   * if remove_far
   * 		and self.remove_ok
   * 		and not self.tamed then */
  enum { lc761 = 1 };
  lc_getupvalue(L,lua_upvalueindex(1),12,6);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"remove_ok");
    lua_gettable(L,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"tamed");
    lua_gettable(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc762 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc762) {
    
    /* --print ("REMOVED " .. self.name)
     * self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 1);
    
    /* return nil */
    lua_pushnil(L);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc761);
  assert(lua_gettop(L) == 1);
  
  /* self.remove_ok = true */
  lua_pushboolean(L,1);
  lua_pushliteral(L,"remove_ok");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* self.attack = nil */
  lua_pushnil(L);
  lua_pushliteral(L,"attack");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* self.following = nil */
  lua_pushnil(L);
  lua_pushliteral(L,"following");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* self.state = "stand" */
  lua_pushliteral(L,"stand");
  lua_pushliteral(L,"state");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* -- used to rotate older nssm
   * if self.drawtype
   * 		and self.drawtype == "side" then */
  enum { lc763 = 1 };
  lua_pushliteral(L,"drawtype");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"drawtype");
    lua_gettable(L,1);
    lua_pushliteral(L,"side");
    const int lc764 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc764);
  }
  const int lc765 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc765) {
    
    /* self.rotate = math.rad(90) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"rad");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,90);
    lua_call(L,1,1);
    lua_pushliteral(L,"rotate");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc763);
  assert(lua_gettop(L) == 1);
  
  /* local tmp = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 2);
  
  /* for _,stat in pairs(self) do
   * internal: local f, s, var = explist */
  enum { lc766 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 6
     * internal: local stat with idx 7 */
    
    
    /* local t = type(stat) */
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,7);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 8);
    
    /* if  t ~= 'function'
     * 			and t ~= 'nil'
     * 			and t ~= 'userdata' then */
    enum { lc767 = 8 };
    lua_pushliteral(L,"function");
    const int lc768 = lua_equal(L,8,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc768);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"nil");
      const int lc769 = lua_equal(L,8,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc769);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"userdata");
      const int lc770 = lua_equal(L,8,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc770);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc771 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc771) {
      
      /* tmp[_] = self[_] */
      lua_pushvalue(L,6);
      lua_gettable(L,1);
      lua_pushvalue(L,6);
      lua_insert(L,-2);
      lua_settable(L,2);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc767);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc766);
  assert(lua_gettop(L) == 2);
  
  /* -- print('===== '..self.name..'\n'.. dump(tmp)..'\n=====\n')
   * return minetest.serialize(tmp) */
  const int lc772 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"serialize");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,LUA_MULTRET);
  return (lua_gettop(L) - lc772);
  assert(lua_gettop(L) == 2);
}


/* name: nssm:register_mob
 * function(name, def) */
static int lcf1_nssm_register_mob (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc295 = 4 };
  assert((lua_gettop(L) == lc295));
  lua_pushvalue(L,3);
  lua_rawseti(L,-2,20);
  
  /* minetest.register_entity(name, {
   * 
   * 	stepheight = def.stepheight or 0.6,
   * 	name = name,
   * 	type = def.type,
   * 	attack_type = def.attack_type,
   * 	fly = def.fly,
   * 	fly_in = def.fly_in or "air",
   * 	owner = def.owner or "",
   * 	order = def.order or "",
   * 	on_die = def.on_die,
   * 	do_custom = def.do_custom,
   * 	jump_height = def.jump_height or 6,
   * 	jump_chance = def.jump_chance or 0,
   * 	drawtype = def.drawtype, -- DEPRECATED, use rotate instead
   * 	rotate = math.rad(def.rotate or 0), --  0=front, 90=side, 180=back, 270=side2
   * 	lifetimer = def.lifetimer or 180, -- 3 minutes
   * 	hp_min = def.hp_min or 5,
   * 	hp_max = def.hp_max or 10,
   * 	physical = true,
   * 	collisionbox = def.collisionbox,
   * 	visual = def.visual,
   * 	visual_size = def.visual_size or {x = 1, y = 1},
   * 	mesh = def.mesh,
   * 	makes_footstep_sound = def.makes_footstep_sound or false,
   * 	view_range = def.view_range or 5,
   * 	walk_velocity = def.walk_velocity or 1,
   * 	run_velocity = def.run_velocity or 2,
   * 	damage = def.damage or 0,
   * 	light_damage = def.light_damage or 0,
   * 	water_damage = def.water_damage or 0,
   * 	lava_damage = def.lava_damage or 0,
   * 	fall_damage = def.fall_damage or 1,
   * 	fall_speed = def.fall_speed or -10, -- must be lower than -2 (default: -10)
   * 	drops = def.drops or {},
   * 	armor = def.armor,
   * 	on_rightclick = def.on_rightclick,
   * 	arrow = def.arrow,
   * 	shoot_interval = def.shoot_interval,
   * 	sounds = def.sounds or {},
   * 	animation = def.animation,
   * 	follow = def.follow,
   * 	jump = def.jump or true,
   * 	walk_chance = def.walk_chance or 50,
   * 	attacks_monsters = def.attacks_monsters or false,
   * 	group_attack = def.group_attack or false,
   * 	--fov = def.fov or 120,
   * 	passive = def.passive or false,
   * 	recovery_time = def.recovery_time or 0.5,
   * 	knock_back = def.knock_back or 3,
   * 	blood_amount = def.blood_amount or 5,
   * 	blood_texture = def.blood_texture or "nssm_blood.png",
   * 	shoot_offset = def.shoot_offset or 0,
   * 	floats = def.floats or 1, -- floats in water by default
   * 	replace_rate = def.replace_rate,
   * 	replace_what = def.replace_what,
   * 	replace_with = def.replace_with,
   * 	replace_offset = def.replace_offset or 0,
   * 	timer = 0,
   * 	env_damage_timer = 0, -- only used when state = "attack"
   * 	tamed = false,
   * 	pause_timer = 0,
   * 	horny = false,
   * 	hornytimer = 0,
   * 	child = false,
   * 	gotten = false,
   * 	health = 0,
   * 	reach = def.reach or 2,
   * 	htimer = 0,
   * 	child_texture = def.child_texture,
   * 	docile_by_day = def.docile_by_day or false,
   * 	time_of_day = 0.5,
   * 	fear_height = def.fear_height or 0,
   * 	runaway = def.runaway,
   * 	runaway_timer = 0,
   * 	pathfinding = def.pathfinding,
   * 	immune_to = def.immune_to or {},
   * 	explosion_radius = def.explosion_radius,
   * 
   * 	--NSSM parameters
   * 
   * 	on_dist_attack = def.on_dist_attack,
   * 	metamorphosis = def.metamorphosis or false,
   * 	metatimer = 0,
   * 	dogshoot_stop = def.dogshoot_stop or false,
   * 	hydra = def.hydra or false,
   * 	mele_number = def.mele_number or 1,
   * 	true_dist_attack = def.true_dist_attack or false,
   * 	explosion_radius = def.explosion_radius or 0,
   * 	direct_hit = false,
   * 	num_sons = 0,
   * 	num_mele_attacks = 0,
   * 	custom_attack = def.custom_attack or false,
   * 	attack_rip = 0,
   * 
   * 	--End of NSSM parameters
   * 
   * 	on_step = function(self, dtime)
   * 
   * 		local pos = self.object:getpos()
   * 		local yaw = self.object:getyaw() or 0
   * 
   * 		if self.metatimer == 0 then
   * 			self.metatimer = os.time()
   * 		end
   * 
   * 		-- when lifetimer expires remove mob (except npc and tamed)
   * 		if self.type ~= "npc"
   * 		and not self.tamed
   * 		and self.state ~= "attack" then
   * 
   * 			self.lifetimer = self.lifetimer - dtime
   * 
   * 			if self.lifetimer <= 0 then
   * 
   * 				-- only despawn away from player
   * 				local objs = minetest.get_objects_inside_radius(pos, 10)
   * 
   * 				for _,oir in pairs(objs) do
   * 
   * 					if oir:is_player() then
   * 
   * 						self.lifetimer = 20
   * 
   * 						return
   * 					end
   * 				end
   * 
   * 				minetest.log("action",
   * 					"lifetimer expired, removed " .. self.name)
   * 
   * 				effect(pos, 15, "tnt_smoke.png")
   * 
   * 				self.object:remove()
   * 
   * 				return
   * 			end
   * 		end
   * 
   * 		if not self.fly then
   * 
   * 			-- floating in water (or falling)
   * 			local v = self.object:getvelocity()
   * 
   * 			-- going up then apply gravity
   * 			if v.y > 0.1 then
   * 
   * 				self.object:setacceleration({
   * 					x = 0,
   * 					y = self.fall_speed,
   * 					z = 0
   * 				})
   * 			end
   * 
   * 			-- in water then float up
   * 			if minetest.registered_nodes[node_ok(pos).name].groups.liquid then -- water then
   * 
   * 				if self.floats == 1 then
   * 
   * 					self.object:setacceleration({
   * 						x = 0,
   * 						y = -self.fall_speed / (math.max(1, v.y) ^ 2),
   * 						z = 0
   * 					})
   * 				end
   * 			else
   * 				-- fall downwards
   * 				self.object:setacceleration({
   * 					x = 0,
   * 					y = self.fall_speed,
   * 					z = 0
   * 				})
   * 
   * 				-- fall damage
   * 				if self.fall_damage == 1
   * 				and self.object:getvelocity().y == 0 then
   * 
   * 					local d = self.old_y - self.object:getpos().y
   * 
   * 					if d > 5 then
   * 
   * 						--self.object:set_hp(self.object:get_hp() - math.floor(d - 5))
   * 						self.health = self.health - math.floor(d - 5)
   * 
   * 						effect(pos, 5, "tnt_smoke.png")
   * 
   * 						if check_for_death(self) then
   * 							return
   * 						end
   * 					end
   * 
   * 					self.old_y = self.object:getpos().y
   * 				end
   * 			end
   * 		end
   * 
   * 		-- knockback timer
   * 		if self.pause_timer > 0 then
   * 
   * 			self.pause_timer = self.pause_timer - dtime
   * 
   * 			if self.pause_timer < 1 then
   * 				self.pause_timer = 0
   * 			end
   * 
   * 			return
   * 		end
   * 
   * 		-- attack timer
   * 		self.timer = self.timer + dtime
   * 
   * 		if self.state ~= "attack" then
   * 
   * 			if self.timer < 1 then
   * 				return
   * 			end
   * 
   * 			self.timer = 0
   * 		end
   * 
   * 		-- never go over 100
   * 		if self.timer > 100 then
   * 			self.timer = 1
   * 		end
   * 
   * 		-- node replace check (cow eats grass etc.)
   * 		replace(self, pos)
   * 
   * 		-- mob plays random sound at times
   * 		if self.sounds.random
   * 		and math.random(1, 100) == 1 then
   * 
   * 			minetest.sound_play(self.sounds.random, {
   * 				object = self.object,
   * 				max_hear_distance = self.sounds.distance
   * 			})
   * 		end
   * 
   * 		-- environmental damage timer (every 1 second)
   * 		self.env_damage_timer = self.env_damage_timer + dtime
   * 
   * 		if (self.state == "attack" and self.env_damage_timer > 1)
   * 		or self.state ~= "attack" then
   * 
   * 			self.env_damage_timer = 0
   * 
   * 			do_env_damage(self)
   * 
   * 			-- custom function (defined in mob lua file)
   * 			if self.do_custom then
   * 				self.do_custom(self)
   * 			end
   * 		end
   * 
   * 		-- find someone to attack
   * 		if self.type == "monster"
   * 		and damage_enabled
   * 		and self.state ~= "attack"
   * 		and not day_docile(self) then
   * 
   * 			local s = self.object:getpos()
   * 			local p, sp, dist
   * 			local player = nil
   * 			local type = nil
   * 			local obj = nil
   * 			local min_dist = self.view_range + 1
   * 			local min_player = nil
   * 
   * 			for _,oir in pairs(minetest.get_objects_inside_radius(s, self.view_range)) do
   * 
   * 				if oir:is_player() then
   * 
   * 					player = oir
   * 					type = "player"
   * 				else
   * 					obj = oir:get_luaentity()
   * 
   * 					if obj then
   * 						player = obj.object
   * 						type = obj.type
   * 					end
   * 				end
   * 
   * 				if type == "player"
   * 				or type == "npc" then
   * 
   * 					s = self.object:getpos()
   * 					p = player:getpos()
   * 					sp = s
   * 
   * 					-- aim higher to make looking up hills more realistic
   * 					p.y = p.y + 1
   * 					sp.y = sp.y + 1
   * 
   * 					dist = get_distance(p, s)
   * 
   * 					if dist < self.view_range then
   * 					-- field of view check goes here
   * 
   * 						-- choose closest player to attack
   * 						--if minetest.line_of_sight(sp, p, 2) == true
   * 						if line_of_sight_water(self, sp, p, 2) == true
   * 						and dist < min_dist then
   * 							min_dist = dist
   * 							min_player = player
   * 						end
   * 					end
   * 				end
   * 			end
   * 
   * 			-- attack player
   * 			if min_player then
   * 				do_attack(self, min_player)
   * 			end
   * 		end
   * 
   * 		-- npc, find closest monster to attack
   * 		local min_dist = self.view_range + 1
   * 		local min_player = nil
   * 
   * 		if self.type == "npc"
   * 		and self.attacks_monsters
   * 		and self.state ~= "attack" then
   * 
   * 			local s = self.object:getpos()
   * 			local obj = nil
   * 
   * 			for _, oir in pairs(minetest.get_objects_inside_radius(s, self.view_range)) do
   * 
   * 				obj = oir:get_luaentity()
   * 
   * 				if obj
   * 				and obj.type == "monster" then
   * 
   * 					-- attack monster
   * 					p = obj.object:getpos()
   * 
   * 					dist = get_distance(p, s)
   * 
   * 					if dist < min_dist then
   * 						min_dist = dist
   * 						min_player = obj.object
   * 					end
   * 				end
   * 			end
   * 
   * 			if min_player then
   * 				do_attack(self, min_player)
   * 			end
   * 		end
   * 
   * 		-- breed and grow children
   * 		breed(self)
   * 
   * 		-- find player to follow
   * 		if (self.follow ~= ""
   * 		or self.order == "follow")
   * 		and not self.following
   * 		and self.state ~= "attack"
   * 		and self.state ~= "runaway" then
   * 
   * 			local s, p, dist
   * 
   * 			for _,player in pairs(minetest.get_connected_players()) do
   * 
   * 				s = self.object:getpos()
   * 				p = player:getpos()
   * 				dist = get_distance(p, s)
   * 
   * 				if dist < self.view_range then
   * 					self.following = player
   * 					break
   * 				end
   * 			end
   * 		end
   * 
   * 		if self.type == "npc"
   * 		and self.order == "follow"
   * 		and self.state ~= "attack"
   * 		and self.owner ~= "" then
   * 
   * 			-- npc stop following player if not owner
   * 			if self.following
   * 			and self.owner
   * 			and self.owner ~= self.following:get_player_name() then
   * 				self.following = nil
   * 			end
   * 		else
   * 			-- stop following player if not holding specific item
   * 			if self.following
   * 			and self.following:is_player()
   * 			and follow_holding(self, self.following) == false then
   * 				self.following = nil
   * 			end
   * 
   * 		end
   * 
   * 		-- follow that thing
   * 		if self.following then
   * 
   * 			local s = self.object:getpos()
   * 			local p
   * 
   * 			if self.following:is_player() then
   * 
   * 				p = self.following:getpos()
   * 
   * 			elseif self.following.object then
   * 
   * 				p = self.following.object:getpos()
   * 			end
   * 
   * 			if p then
   * 
   * 				local dist = get_distance(p, s)
   * 
   * 				-- dont follow if out of range
   * 				if dist > self.view_range then
   * 					self.following = nil
   * 				else
   * 					local vec = {
   * 						x = p.x - s.x,
   * 						y = p.y - s.y,
   * 						z = p.z - s.z
   * 					}
   * 
   * 					if vec.x ~= 0
   * 					and vec.z ~= 0 then
   * 
   * 						yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 						if p.x > s.x then
   * 							yaw = yaw + pi
   * 						end
   * 
   * 						self.object:setyaw(yaw)
   * 					end
   * 
   * 					-- anyone but standing npc's can move along
   * 					if dist > self.reach
   * 					and self.order ~= "stand" then
   * 
   * 						if (self.jump
   * 						and get_velocity(self) <= 0.5
   * 						and self.object:getvelocity().y == 0)
   * 						or (self.object:getvelocity().y == 0
   * 						and self.jump_chance > 0) then
   * 
   * 							do_jump(self)
   * 						end
   * 
   * 						set_velocity(self, self.walk_velocity)
   * 
   * 						if self.walk_chance ~= 0 then
   * 							set_animation(self, "walk")
   * 						end
   * 					else
   * 						set_velocity(self, 0)
   * 						set_animation(self, "stand")
   * 					end
   * 
   * 					return
   * 				end
   * 			end
   * 		end
   * 
   * 		-- water swimmers flop when on land
   * 		if self.fly
   * 		and self.fly_in == "default:water_source"
   * 		and self.standing_in ~= self.fly_in then
   * 
   * 			self.state = "flop"
   * 			self.object:setvelocity({x = 0, y = -5, z = 0})
   * 
   * 			set_animation(self, "stand")
   * 
   * 			return
   * 		end
   * 
   * 		if self.state == "stand" then
   * 
   * 			if math.random(1, 4) == 1 then
   * 
   * 				local lp = nil
   * 				local s = self.object:getpos()
   * 
   * 				if self.type == "npc" then
   * 
   * 					local o = minetest.get_objects_inside_radius(self.object:getpos(), 3)
   * 
   * 					for _,o in pairs(o) do
   * 
   * 						if o:is_player() then
   * 							lp = o:getpos()
   * 							break
   * 						end
   * 					end
   * 				end
   * 
   * 				-- look at any players nearby, otherwise turn randomly
   * 				if lp then
   * 
   * 					local vec = {
   * 						x = lp.x - s.x,
   * 						y = lp.y - s.y,
   * 						z = lp.z - s.z
   * 					}
   * 
   * 					if vec.x ~= 0
   * 					and vec.z ~= 0 then
   * 
   * 						yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 						if lp.x > s.x then
   * 							yaw = yaw + pi
   * 						end
   * 					end
   * 				else
   * 					yaw = (math.random(0, 360) - 180) / 180 * pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			set_velocity(self, 0)
   * 			set_animation(self, "stand")
   * 
   * 			-- npc's ordered to stand stay standing
   * 			if self.type ~= "npc"
   * 			or self.order ~= "stand" then
   * 
   * 				if self.walk_chance ~= 0
   * 				and math.random(1, 100) <= self.walk_chance
   * 				and is_at_cliff(self) == false then
   * 
   * 					set_velocity(self, self.walk_velocity)
   * 					self.state = "walk"
   * 					set_animation(self, "walk")
   * 				end
   * 			end
   * 
   * 		elseif self.state == "walk" then
   * 
   * 			local s = self.object:getpos()
   * 			local lp = minetest.find_node_near(s, 1, {"group:water"})
   * 
   * 			-- if water nearby then turn away
   * 			if lp then
   * 
   * 				local vec = {
   * 					x = lp.x - s.x,
   * 					y = lp.y - s.y,
   * 					z = lp.z - s.z
   * 				}
   * 
   * 				if vec.x ~= 0
   * 				and vec.z ~= 0 then
   * 
   * 					yaw = atan(vec.z / vec.x) + 3 * pi / 2 - self.rotate
   * 
   * 					if lp.x > s.x then
   * 						yaw = yaw + pi
   * 					end
   * 
   * 					self.object:setyaw(yaw)
   * 				end
   * 
   * 			-- otherwise randomly turn
   * 			elseif math.random(1, 100) <= 30 then
   * 
   * 				yaw = (math.random(0, 360) - 180) / 180 * pi
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			-- stand for great fall in front
   * 			local temp_is_cliff = is_at_cliff(self)
   * 
   * 			-- jump when walking comes to a halt
   * 			if temp_is_cliff == false
   * 			and self.jump
   * 			and get_velocity(self) <= 0.5
   * 			and self.object:getvelocity().y == 0 then
   * 
   * 				do_jump(self)
   * 			end
   * 
   * 			if temp_is_cliff
   * 			or math.random(1, 100) <= 30 then
   * 
   * 				set_velocity(self, 0)
   * 				self.state = "stand"
   * 				set_animation(self, "stand")
   * 			else
   * 				set_velocity(self, self.walk_velocity)
   * 				set_animation(self, "walk")
   * 			end
   * 
   * 		-- runaway when punched
   * 		elseif self.state == "runaway" then
   * 
   * 			self.runaway_timer = self.runaway_timer + 1
   * 
   * 			-- stop after 3 seconds or when at cliff
   * 			if self.runaway_timer > 3
   * 			or is_at_cliff(self) then
   * 				self.runaway_timer = 0
   * 				set_velocity(self, 0)
   * 				self.state = "stand"
   * 				set_animation(self, "stand")
   * 			else
   * 				set_velocity(self, self.run_velocity)
   * 				set_animation(self, "walk")
   * 			end
   * 
   * 			-- jump when walking comes to a halt
   * 			if self.jump
   * 			and get_velocity(self) <= 0.5
   * 			and self.object:getvelocity().y == 0 then
   * 
   * 				do_jump(self)
   * 			end
   * 
   * 		-- attack routines (explode, dogfight, shoot, dogshoot)
   * 		elseif self.state == "attack" then
   * 
   * 		-- calculate distance from mob and enemy
   * 		local s = self.object:getpos()
   * 		local p = self.attack:getpos() or s
   * 		local dist = get_distance(p, s)
   * 
   * 		-- stop attacking if player or out of range
   * 		if dist > self.view_range
   * 		or not self.attack
   * 		or not self.attack:getpos()
   * 		or self.attack:get_hp() <= 0 then
   * 
   * 			--print(" ** stop attacking **", dist, self.view_range)
   * 			self.state = "stand"
   * 			set_velocity(self, 0)
   * 			set_animation(self, "stand")
   * 			self.attack = nil
   * 			self.v_start = false
   * 			self.timer = 0
   * 			self.blinktimer = 0
   * 
   * 			return
   * 		end
   * 
   * 		if self.attack_type == "explode" then
   * 
   * 			local vec = {
   * 				x = p.x - s.x,
   * 				y = p.y - s.y,
   * 				z = p.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				yaw = atan(vec.z / vec.x) + pi / 2 - self.rotate
   * 
   * 				if p.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			if dist > self.reach then
   * 
   * 				if not self.v_start then
   * 
   * 					self.v_start = true
   * 					set_velocity(self, self.run_velocity)
   * 					self.timer = 0
   * 					self.blinktimer = 0
   * 				else
   * 					self.timer = 0
   * 					self.blinktimer = 0
   * 
   * 					if get_velocity(self) <= 0.5
   * 					and self.object:getvelocity().y == 0 then
   * 
   * 						local v = self.object:getvelocity()
   * 						v.y = 5
   * 						self.object:setvelocity(v)
   * 					end
   * 
   * 					set_velocity(self, self.run_velocity)
   * 				end
   * 
   * 				set_animation(self, "run")
   * 			else
   * 				set_velocity(self, 0)
   * 
   * 				--NSSM additions:
   * 				set_animation(self, "punch")
   * 				--end of NSSM additions
   * 
   * 				self.timer = self.timer + dtime
   * 				self.blinktimer = (self.blinktimer or 0) + dtime
   * 
   * 				if self.blinktimer > 0.2 then
   * 
   * 					self.blinktimer = 0
   * 
   * 					if self.blinkstatus then
   * 						self.object:settexturemod("")
   * 					else
   * 						self.object:settexturemod("^[brighten")
   * 					end
   * 
   * 					self.blinkstatus = not self.blinkstatus
   * 				end
   * 
   * 				if self.timer > 3 then
   * 
   * 					local pos = self.object:getpos()
   * 					local radius = self.explosion_radius or 1
   * 
   * 					-- hurt player/nssm caught in blast area
   * 					--entity_physics(pos, radius)		--NSSM modification (the damage function is part of the explosion one now)
   * 
   * 					-- dont damage anything if area protected or next to water
   * 					if minetest.find_node_near(pos, 1, {"group:water"})
   * 					or minetest.is_protected(pos, "") then
   * 
   * 						if self.sounds.explode then
   * 
   * 							minetest.sound_play(self.sounds.explode, {
   * 								object = self.object,
   * 								gain = 1.0,
   * 								max_hear_distance = 16
   * 							})
   * 						end
   * 
   * 						self.object:remove()
   * 
   * 						effect(pos, 15, "tnt_smoke.png", 5)
   * 
   * 						return
   * 					end
   * 
   * 					pos.y = pos.y - 1
   * 
   * 					--NSSM modifications:
   * 
   * 					if self.explosion_radius==0 then
   * 						nssm:explosion(pos, 5, 0, 1, self.sounds.explode)
   * 					else
   * 						nssm:explosion(pos, self.explosion_radius, 0, 1, self.sounds.explode)
   * 					end
   * 
   * 					--end of NSSM modifications
   * 
   * 					self.object:remove()
   * 
   * 					return
   * 				end
   * 			end
   * 
   * 		elseif self.attack_type == "dogfight"
   * 		or (self.attack_type == "dogshoot" and dist <= self.reach)
   * 		or (self.attack_type == "dogshoot" and self.dogshoot_stop and self.direct_hit)		--NSSM addition
   * 		then
   * 
   * 			if self.fly
   * 			and dist > self.reach then
   * 
   * 				local nod = node_ok(s)
   * 				local p1 = s
   * 				local me_y = math.floor(p1.y)
   * 				local p2 = p
   * 				local p_y = math.floor(p2.y + 1)
   * 				local v = self.object:getvelocity()
   * 
   * 				if nod.name == self.fly_in then
   * 
   * 					if me_y < p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = 1 * self.walk_velocity,
   * 							z = v.z
   * 						})
   * 
   * 					elseif me_y > p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = -1 * self.walk_velocity,
   * 							z = v.z
   * 						})
   * 					end
   * 				else
   * 					if me_y < p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = 0.01,
   * 							z = v.z
   * 						})
   * 
   * 					elseif me_y > p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = -0.01,
   * 							z = v.z
   * 						})
   * 					end
   * 				end
   * 
   * 			end
   * 
   * 			-- rnd: new movement direction
   * 			if self.path.following
   * 			and self.path.way
   * 			and self.attack_type ~= "dogshoot" then
   * 
   * 				-- no paths longer than 50
   * 				if #self.path.way > 50
   * 				or dist < self.reach then
   * 					self.path.following = false
   * 					return
   * 				end
   * 
   * 				local p1 = self.path.way[1]
   * 
   * 				if not p1 then
   * 					self.path.following = false
   * 					return
   * 				end
   * 
   * 				if math.abs(p1.x-s.x) + math.abs(p1.z - s.z) < 0.6 then
   * 					-- reached waypoint, remove it from queue
   * 					table.remove(self.path.way, 1)
   * 				end
   * 
   * 				-- set new temporary target
   * 				p = {x = p1.x, y = p1.y, z = p1.z}
   * 			end
   * 
   * 			local vec = {
   * 				x = p.x - s.x,
   * 				y = p.y - s.y,
   * 				z = p.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 				if p.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			-- move towards enemy if beyond mob reach
   * 			if dist > self.reach then
   * 
   * 				-- path finding by rnd
   * 				if self.pathfinding -- only if mob has pathfinding enabled
   * 				and enable_pathfinding then
   * 
   * 					smart_nssm(self, s, p, dist, dtime)
   * 				end
   * 
   * 				-- jump attack
   * 				if (self.jump
   * 				and get_velocity(self) <= 0.5
   * 				and self.object:getvelocity().y == 0)
   * 				or (self.object:getvelocity().y == 0
   * 				and self.jump_chance > 0) then
   * 
   * 					do_jump(self)
   * 				end
   * 
   * 				if is_at_cliff(self) then
   * 
   * 					set_velocity(self, 0)
   * 					set_animation(self, "stand")
   * 				else
   * 
   * 					if self.path.stuck then
   * 						set_velocity(self, self.walk_velocity)
   * 					else
   * 						set_velocity(self, self.run_velocity)
   * 					end
   * 
   * 					set_animation(self, "run")
   * 				end
   * 
   * 			else -- rnd: if inside reach range
   * 
   * 				self.path.stuck = false
   * 				self.path.stuck_timer = 0
   * 				self.path.following = false -- not stuck anymore
   * 
   * 				set_velocity(self, 0)
   * 
   * 				--NSSM modifications:
   * 				--modifications to add multiple melee attack animations
   * 				--ATTACK ANIMATIONS:
   * 				if self.mele_number>1 then
   *         			if randattack==1 then
   * 						set_animation(self, "punch")
   * 					else
   * 						local attack = "punch"..(randattack-1)
   *             			set_animation(self, attack)
   *           			end
   * 				else
   * 					set_animation(self, "punch")
   * 				end
   * 
   * 				--modifications to add special attacks to some monster:
   * 				if not def.custom_attack then
   * 
   * 					if self.timer > 1 then
   * 
   * 						self.timer = 0
   * 
   * 						local p2 = p
   * 						local s2 = s
   * 
   * 						p2.y = p2.y + 1.5
   * 						s2.y = s2.y + 1.5
   * 
   * 						if line_of_sight_water(self,p2,s2,1) then
   * 
   * 							-- play attack sound
   * 							if self.sounds.attack then
   * 
   * 								minetest.sound_play(self.sounds.attack, {
   * 									object = self.object,
   * 									max_hear_distance = self.sounds.distance
   * 								})
   * 							end
   * 
   * 							-- punch player
   * 							self.attack:punch(self.object, 1.0, {
   * 								full_punch_interval = 1.0,
   * 								damage_groups = {fleshy = self.damage}
   * 							}, nil)
   * 
   * 							--NSSM Modifications for dogshoot nssm
   * 							if (self.dogshoot_stop) then
   * 								self.num_mele_attacks=self.num_mele_attacks+1
   * 								--minetest.chat_send_all("num_mele_attacks= "..self.num_mele_attacks)
   * 								if (self.num_mele_attacks>3) then
   * 									self.num_sons=0
   * 									self.num_mele_attacks=0
   * 									self.direct_hit=false
   * 								end
   * 							end
   * 							--end of modifications for dogshoot nssm
   * 						end
   * 					end
   * 
   * 					--some additions: special melee attacks
   * 				else
   * 					if def.custom_attack then
   * 						def.custom_attack(self)
   * 					end
   * 				end
   * 			end
   * 
   * 		--end of NSSM modifications
   * 
   * 		elseif self.attack_type == "shoot"
   * 		or (self.attack_type == "dogshoot" and dist > self.reach and not self.dogshoot_stop)	--NSSM modification
   * 		or (self.attack_type == "dogshoot" and self.dogshoot_stop and not self.direct_hit)		--NSSM addition
   * 		then
   * 
   * 			p.y = p.y - .5
   * 			s.y = s.y + .5
   * 
   * 			local dist = get_distance(p, s)
   * 			local vec = {
   * 				x = p.x - s.x,
   * 				y = p.y - s.y,
   * 				z = p.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 				if p.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			set_velocity(self, 0)
   * 
   * 			if self.shoot_interval
   * 			and self.timer > self.shoot_interval
   * 			and math.random(1, 100) <= 60 then
   * 
   * 				self.timer = 0
   * 				set_animation(self, "dattack")					--NSSM modification
   * 
   * 				-- play shoot attack sound
   * 				if self.sounds.shoot_attack then
   * 
   * 					minetest.sound_play(self.sounds.shoot_attack, {
   * 						object = self.object,
   * 						max_hear_distance = self.sounds.distance
   * 					})
   * 				end
   * 
   * 				if not self.true_dist_attack then			--NSSM addition
   * 					local p = self.object:getpos()
   * 
   * 					p.y = p.y + (self.collisionbox[2] + self.collisionbox[5]) / 2
   * 
   * 					local obj = minetest.add_entity(p, self.arrow)
   * 					local ent = obj:get_luaentity()
   * 					local amount = (vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) ^ 0.5
   * 					local v = ent.velocity
   * 					ent.switch = 1
   * 
   * 					--NSSM additions:
   * 
   * 					if (self.dogshoot_stop) then
   * 						self.num_sons=self.num_sons+1
   * 						--minetest.chat_send_all("num_sons="..self.num_sons)
   * 						if (self.num_sons>2) then
   * 							self.direct_hit=true
   * 						end
   * 					end
   * 
   * 					--end of NSSM additions
   * 
   * 					 -- offset makes shoot aim accurate
   * 					vec.y = vec.y + self.shoot_offset
   * 					vec.x = vec.x * v / amount
   * 					vec.y = vec.y * v / amount
   * 					vec.z = vec.z * v / amount
   * 
   * 					obj:setvelocity(vec)
   * 
   * 					--NSSM additions:
   * 
   * 				else
   * 					if math.random(1,100)<=50 then
   * 						self.on_dist_attack(self, self.attack)
   * 						if (self.dogshoot_stop) then
   * 							self.num_sons=self.num_sons+1
   * 							--minetest.chat_send_all("num_sons="..self.num_sons)
   * 							if (self.num_sons>2) then
   * 								self.direct_hit=true
   * 							end
   * 						end
   * 					end
   * 				end
   * 
   * 				--end of NSSM additions
   * 
   * 			end
   * 		end
   * 
   * 		end -- END if self.state == "attack"
   * 
   * 		--NSSM additions:
   * 
   * 		--larva and mantis
   * 		if self.metamorphosis == true then
   * 			if os.time() - self.metatimer >20 then
   * 				minetest.log("action",
   * 					"metatimer expired, metamorphosis! ")
   * 				local pos=self.object:getpos()
   * 				self.object:remove()
   * 				minetest.add_particlespawner(
   * 					200, --amount
   * 					0.1, --time
   * 					{x=pos.x-1, y=pos.y-1, z=pos.z-1}, --minpos
   * 					{x=pos.x+1, y=pos.y+1, z=pos.z+1}, --maxpos
   * 					{x=-0, y=-0, z=-0}, --minvel
   * 					{x=1, y=1, z=1}, --maxvel
   * 					{x=-0.5,y=5,z=-0.5}, --minacc
   * 					{x=0.5,y=5,z=0.5}, --maxacc
   * 					0.1, --minexptime
   * 					1, --maxexptime
   * 					3, --minsize
   * 					4, --maxsize
   * 					false, --collisiondetection
   * 					"tnt_smoke.png" --texture
   * 				)
   * 				if math.random(1,2)==1 then
   * 					minetest.add_entity(pos, "nssm:mantis")
   * 				else
   * 					minetest.add_entity(pos, "nssm:mantis_beast")
   * 				end
   * 
   * 				return
   * 			end
   * 		end
   * 
   * 		--ens of NSSM additions
   * 
   * 	end,
   * 
   * 	on_punch = function(self, hitter, tflp, tool_capabilities, dir)
   * 
   * 		-- direction error check
   * 		dir = dir or {x = 0, y = 0, z = 0}
   * 
   * 		-- weapon wear
   * 		local weapon = hitter:get_wielded_item()
   * 		local punch_interval = 1.4
   * 
   * 		-- calculate mob damage
   * 		local damage = 0
   * 		local armor = self.object:get_armor_groups() or {}
   * 		local tmp
   * 
   *         -- added by MrCerealGuy 2016-04-14, if tool_capabilities is nil, then set default values (see default/tools.lua)
   *         if tool_capabilities == nil then
   *             tool_capabilities = {
   * 		        full_punch_interval = 0.9,
   * 		        max_drop_level = 0,
   * 		        groupcaps = {
   * 			        crumbly = {times={[2]=3.00, [3]=0.70}, uses=0, maxlevel=1},
   * 			        snappy = {times={[3]=0.40}, uses=0, maxlevel=1},
   * 			        oddly_breakable_by_hand = {times={[1]=3.50,[2]=2.00,[3]=0.70}, uses=0}
   * 		        },
   * 		        damage_groups = {fleshy=1},
   * 	        } 
   *         end
   * 
   *         if tflp == nil then
   *             tflp = 1
   *         end
   *         
   * 	    for group,_ in pairs(tool_capabilities.damage_groups) do
   * 
   * 		    tmp = tflp / tool_capabilities.full_punch_interval
   * 
   * 		    if tmp < 0 then
   * 			    tmp = 0.0
   * 		    elseif tmp > 1 then
   * 			        tmp = 1.0
   * 		    end
   * 
   * 		    damage = damage + (tool_capabilities.damage_groups[group] or 0)
   * 			    * tmp * ((armor[group] or 0) / 100.0)
   * 	    end
   * 
   * 
   * 		-- check for tool immunity or special damage
   * 		for _, no in pairs(self.immune_to) do
   * 
   * 			if no[1] == weapon:get_name() then
   * 				damage = no[2] or 0
   * 				break
   * 			end
   * 		end
   * 
   * 		-- print ("Mob Damage is", damage)
   * 
   * 		-- add weapon wear
   * 		if tool_capabilities then
   * 			punch_interval = tool_capabilities.full_punch_interval or 1.4
   * 		end
   * 
   * 		if weapon:get_definition()
   * 		and weapon:get_definition().tool_capabilities then
   * 
   * 			weapon:add_wear(math.floor((punch_interval / 75) * 9000))
   * 			hitter:set_wielded_item(weapon)
   * 		end
   * 
   * 		-- weapon sounds
   * 		if weapon:get_definition().sounds ~= nil then
   * 
   * 			local s = math.random(0, #weapon:get_definition().sounds)
   * 
   * 			minetest.sound_play(weapon:get_definition().sounds[s], {
   * 				object = hitter,
   * 				max_hear_distance = 8
   * 			})
   * 		else
   * 			minetest.sound_play("default_punch", {
   * 				object = hitter,
   * 				max_hear_distance = 5
   * 			})
   * 		end
   * 
   * 		-- do damage
   * 		self.health = self.health - math.floor(damage)
   * 
   * 		-- exit here if dead
   * 		if check_for_death(self) then
   * 			return
   * 		end
   * 
   * 		-- add healthy afterglow when hit
   * 		core.after(0.1, function()
   * 			self.object:settexturemod("^[colorize:#c9900070")
   * 
   * 			core.after(0.3, function()
   * 				self.object:settexturemod("")
   * 			end)
   * 		end)
   * 
   * 		-- blood_particles
   * 		if self.blood_amount > 0
   * 		and not disable_blood then
   * 
   * 			local pos = self.object:getpos()
   * 
   * 			pos.y = pos.y + (-self.collisionbox[2] + self.collisionbox[5]) / 2
   * 
   * 			effect(pos, self.blood_amount, self.blood_texture)
   * 		end
   * 
   * 		-- knock back effect (only on full punch)
   * 		if self.knock_back > 0
   * 		and tflp > punch_interval then
   * 
   * 			local v = self.object:getvelocity()
   * 			local r = 1.4 - math.min(punch_interval, 1.4)
   * 			local kb = r * 5
   * 			local up = 2
   * 
   * 			-- if already in air then dont go up anymore when hit
   * 			if v.y > 0
   * 			or self.fly then
   * 				up = 0
   * 			end
   * 
   * 			self.object:setvelocity({
   * 				x = dir.x * kb,
   * 				y = up,
   * 				z = dir.z * kb
   * 			})
   * 
   * 			self.pause_timer = r
   * 		end
   * 
   * 		-- if skittish then run away
   * 		if self.runaway == true then
   * 
   * 			local lp = hitter:getpos()
   * 			local s = self.object:getpos()
   * 
   * 			local vec = {
   * 				x = lp.x - s.x,
   * 				y = lp.y - s.y,
   * 				z = lp.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				local yaw = atan(vec.z / vec.x) + 3 * pi / 2 - self.rotate
   * 
   * 				if lp.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			self.state = "runaway"
   * 			self.runaway_timer = 0
   * 			self.following = nil
   * 		end
   * 
   * 		-- attack puncher and call other nssm for help
   * 		if self.passive == false
   * 		and self.state ~= "flop"
   * 		and self.child == false
   * 		and hitter:get_player_name() ~= self.owner then
   * 
   * 			-- attack whoever punched mob
   * 			self.state = ""
   * 			do_attack(self, hitter)
   * 
   * 			-- alert others to the attack
   * 			local obj = nil
   * 
   * 			for _, oir in pairs(minetest.get_objects_inside_radius(hitter:getpos(), 5)) do
   * 
   * 				obj = oir:get_luaentity()
   * 
   * 				if obj then
   * 
   * 					if obj.group_attack == true
   * 					and obj.state ~= "attack" then
   * 						do_attack(obj, hitter)
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end,
   * 
   * 	on_activate = function(self, staticdata, dtime_s)
   * 
   * 		-- remove monsters in peaceful mode, or when no data
   * 		if (self.type == "monster" and peaceful_only)
   * 		or not staticdata then
   * 
   * 			self.object:remove()
   * 
   * 			return
   * 		end
   * 
   * 		-- load entity variables
   * 		local tmp = minetest.deserialize(staticdata)
   * 
   * 		if tmp then
   * 
   * 			for _,stat in pairs(tmp) do
   * 				self[_] = stat
   * 			end
   * 		end
   * 
   * 		-- select random texture, set model and size
   * 		if not self.base_texture then
   * 
   * 			self.base_texture = def.textures[math.random(1, #def.textures)]
   * 			self.base_mesh = def.mesh
   * 			self.base_size = self.visual_size
   * 			self.base_colbox = self.collisionbox
   * 		end
   * 
   * 		--NSSM addition, random melee attack:
   * 		if self.mele_number>1 then
   *     	randattack=math.random(1,self.mele_number)
   *     end
   * 
   * 		--end of NSSM additions
   * 
   * 		-- set texture, model and size
   * 		local textures = self.base_texture
   * 		local mesh = self.base_mesh
   * 		local vis_size = self.base_size
   * 		local colbox = self.base_colbox
   * 
   * 		-- specific texture if gotten
   * 		if self.gotten == true
   * 		and def.gotten_texture then
   * 			textures = def.gotten_texture
   * 		end
   * 
   * 		-- specific mesh if gotten
   * 		if self.gotten == true
   * 		and def.gotten_mesh then
   * 			mesh = def.gotten_mesh
   * 		end
   * 
   * 		-- set child objects to half size
   * 		if self.child == true then
   * 
   * 			vis_size = {
   * 				x = self.base_size.x / 2,
   * 				y = self.base_size.y / 2
   * 			}
   * 
   * 			if def.child_texture then
   * 				textures = def.child_texture[1]
   * 			end
   * 
   * 			colbox = {
   * 				self.base_colbox[1] / 2,
   * 				self.base_colbox[2] / 2,
   * 				self.base_colbox[3] / 2,
   * 				self.base_colbox[4] / 2,
   * 				self.base_colbox[5] / 2,
   * 				self.base_colbox[6] / 2
   * 			}
   * 		end
   * 
   * 		if self.health == 0 then
   * 			self.health = math.random(self.hp_min, self.hp_max)
   * 		end
   * 
   * 		-- rnd: pathfinding init
   * 		self.path = {}
   * 		self.path.way = {} -- path to follow, table of positions
   * 		self.path.lastpos = {x = 0, y = 0, z = 0}
   * 		self.path.stuck = false
   * 		self.path.following = false -- currently following path?
   * 		self.path.stuck_timer = 0 -- if stuck for too long search for path
   * 		-- end init
   * 
   * 		self.object:set_armor_groups({immortal = 1, fleshy = self.armor})
   * 		self.old_y = self.object:getpos().y
   * 		self.old_health = self.health
   * 		self.object:setyaw((math.random(0, 360) - 180) / 180 * pi)
   * 		self.sounds.distance = self.sounds.distance or 10
   * 		self.textures = textures
   * 		self.mesh = mesh
   * 		self.collisionbox = colbox
   * 		self.visual_size = vis_size
   * 		self.standing_in = ""
   * 
   * 		-- set anything changed above
   * 		self.object:set_properties(self)
   * 		update_tag(self)
   * 	end,
   * 
   * 	get_staticdata = function(self)
   * 
   * 		-- remove mob when out of range unless tamed
   * 		if remove_far
   * 		and self.remove_ok
   * 		and not self.tamed then
   * 
   * 			--print ("REMOVED " .. self.name)
   * 
   * 			self.object:remove()
   * 
   * 			return nil
   * 		end
   * 
   * 		self.remove_ok = true
   * 		self.attack = nil
   * 		self.following = nil
   * 		self.state = "stand"
   * 
   * 		-- used to rotate older nssm
   * 		if self.drawtype
   * 		and self.drawtype == "side" then
   * 			self.rotate = math.rad(90)
   * 		end
   * 
   * 		local tmp = {}
   * 
   * 		for _,stat in pairs(self) do
   * 
   * 			local t = type(stat)
   * 
   * 			if  t ~= 'function'
   * 			and t ~= 'nil'
   * 			and t ~= 'userdata' then
   * 				tmp[_] = self[_]
   * 			end
   * 		end
   * 
   * 		-- print('===== '..self.name..'\n'.. dump(tmp)..'\n=====\n')
   * 		return minetest.serialize(tmp)
   * 	end,
   * 
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_entity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_createtable(L,0,92);
  lua_pushliteral(L,"stepheight");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"stepheight");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0.6);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"name");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"type");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"type");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"attack_type");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"attack_type");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"fly");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"fly");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"fly_in");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"fly_in");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"air");
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"owner");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"owner");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"");
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"order");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"order");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"");
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_die");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"on_die");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"do_custom");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"do_custom");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"jump_height");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"jump_height");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,6);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"jump_chance");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"jump_chance");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"drawtype");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rotate");
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"rad");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"rotate");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"lifetimer");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"lifetimer");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,180);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"hp_min");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"hp_min");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,5);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"hp_max");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"hp_max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,10);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"physical");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"collisionbox");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"collisionbox");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"visual");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual_size");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"visual_size");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"x");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"mesh");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"mesh");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"makes_footstep_sound");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"makes_footstep_sound");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"view_range");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"view_range");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,5);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"walk_velocity");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"walk_velocity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"run_velocity");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"run_velocity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,2);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"damage");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"damage");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"light_damage");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"light_damage");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"water_damage");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"water_damage");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"lava_damage");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"lava_damage");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"fall_damage");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"fall_damage");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"fall_speed");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"fall_speed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,-10);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"drops");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"drops");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_newtable(L);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"armor");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"armor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_rightclick");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"on_rightclick");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"arrow");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"arrow");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"shoot_interval");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"shoot_interval");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"sounds");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_newtable(L);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"animation");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"animation");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"follow");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"follow");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"jump");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"jump");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,1);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"walk_chance");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"walk_chance");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,50);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"attacks_monsters");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"attacks_monsters");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"group_attack");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"group_attack");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"passive");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"passive");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"recovery_time");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"recovery_time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0.5);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"knock_back");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"knock_back");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,3);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"blood_amount");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"blood_amount");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,5);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"blood_texture");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"blood_texture");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"nssm_blood.png");
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"shoot_offset");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"shoot_offset");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"floats");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"floats");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"replace_rate");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"replace_rate");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"replace_what");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"replace_what");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"replace_with");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"replace_with");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"replace_offset");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"replace_offset");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"timer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"env_damage_timer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tamed");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"pause_timer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"horny");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hornytimer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"child");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"gotten");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"health");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"reach");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"reach");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,2);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"htimer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"child_texture");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"child_texture");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"docile_by_day");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"docile_by_day");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"time_of_day");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"fear_height");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"fear_height");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"runaway");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"runaway");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"runaway_timer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"pathfinding");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"pathfinding");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"immune_to");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"immune_to");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_newtable(L);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"explosion_radius");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"explosion_radius");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_dist_attack");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"on_dist_attack");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"metamorphosis");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"metamorphosis");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"metatimer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dogshoot_stop");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"dogshoot_stop");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"hydra");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"hydra");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"mele_number");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"mele_number");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"true_dist_attack");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"true_dist_attack");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"explosion_radius");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"explosion_radius");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"direct_hit");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"num_sons");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"num_mele_attacks");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"custom_attack");
  lc_getupvalue(L,lc295,0,20);
  lua_pushliteral(L,"custom_attack");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"attack_rip");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushvalue(L,lc295);
  lua_pushcclosure(L,lcf670,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_punch");
  lua_pushvalue(L,lc295);
  lua_pushcclosure(L,lcf734,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_activate");
  lua_pushvalue(L,lc295);
  lua_pushcclosure(L,lcf760,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"get_staticdata");
  lua_pushvalue(L,lc295);
  lua_pushcclosure(L,lcf773,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* function(pos, node, _, active_object_count_wider) */
static int lcf818 (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* -- do not spawn if too many active entities in area
   * if active_object_count_wider > active_object_count
   * 			or not nssm.spawning_nssm[name] then */
  enum { lc782 = 4 };
  lc_getupvalue(L,lua_upvalueindex(1),0,25);
  const int lc783 = lua_lessthan(L,-1,4);
  lua_pop(L,1);
  lua_pushboolean(L,lc783);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
    lua_pushliteral(L,"spawning_nssm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lua_upvalueindex(1),0,22);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc784 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc784) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc782);
  assert(lua_gettop(L) == 4);
  
  /* -- if toggle set to nil then ignore day/night check
   * if day_toggle ~= nil then */
  enum { lc785 = 4 };
  lc_getupvalue(L,lua_upvalueindex(1),0,28);
  lua_pushnil(L);
  const int lc786 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc786);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc787 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc787) {
    
    /* local tod = (minetest.get_timeofday() or 0) * 24000 */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_timeofday");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    lua_pushnumber(L,24000);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 5);
    
    /* if tod > 4500 and tod < 19500 then */
    enum { lc788 = 5 };
    lua_pushnumber(L,4500);
    const int lc789 = lua_lessthan(L,-1,5);
    lua_pop(L,1);
    lua_pushboolean(L,lc789);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,19500);
      const int lc790 = lua_lessthan(L,5,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc790);
    }
    const int lc791 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc791) {
      
      /* -- daylight, but mob wants night
       * if day_toggle == false then */
      enum { lc792 = 5 };
      lc_getupvalue(L,lua_upvalueindex(1),0,28);
      lua_pushboolean(L,0);
      const int lc793 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc793);
      const int lc794 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc794) {
        
        /* return */
        return 0;
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc792);
      assert(lua_gettop(L) == 5);
    }
    else {
      
      /* else
       * -- night time but mob wants day
       * if day_toggle == true then */
      enum { lc795 = 5 };
      lc_getupvalue(L,lua_upvalueindex(1),0,28);
      lua_pushboolean(L,1);
      const int lc796 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc796);
      const int lc797 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc797) {
        
        /* return */
        return 0;
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc795);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc788);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc785);
  assert(lua_gettop(L) == 4);
  
  /* -- spawn above node
   * pos.y = pos.y + 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 4);
  
  /* -- only spawn away from player
   * local objs = minetest.get_objects_inside_radius(pos, 10) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,10);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 5);
  
  /* for _,oir in pairs(objs) do
   * internal: local f, s, var = explist */
  enum { lc798 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushvalue(L,5);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 9
     * internal: local oir with idx 10 */
    
    
    /* if oir:is_player() then */
    enum { lc799 = 10 };
    lua_pushvalue(L,10);
    lua_pushliteral(L,"is_player");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    const int lc800 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc800) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc799);
    assert(lua_gettop(L) == 10);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc798);
  assert(lua_gettop(L) == 5);
  
  /* -- nssm cannot spawn in protected areas when enabled
   * if spawn_protected == 1
   * 			and minetest.is_protected(pos, "") then */
  enum { lc801 = 5 };
  lc_getupvalue(L,lua_upvalueindex(1),13,5);
  lua_pushnumber(L,1);
  const int lc802 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc802);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"is_protected");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushliteral(L,"");
    lua_call(L,2,1);
  }
  const int lc803 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc803) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc801);
  assert(lua_gettop(L) == 5);
  
  /* -- check if light and height levels are ok to spawn
   * local light = minetest.get_node_light(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_light");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* if not light
   * 			or light > max_light
   * 			or light < min_light
   * 			or pos.y > max_height
   * 			or pos.y < min_height then */
  enum { lc804 = 6 };
  lua_pushboolean(L,!(lua_toboolean(L,6)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,24);
    const int lc805 = lua_lessthan(L,-1,6);
    lua_pop(L,1);
    lua_pushboolean(L,lc805);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,23);
    const int lc806 = lua_lessthan(L,6,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc806);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,27);
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    const int lc807 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc807);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,26);
    const int lc808 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc808);
  }
  const int lc809 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc809) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc804);
  assert(lua_gettop(L) == 6);
  
  /* -- are we spawning inside solid nodes?
   * if minetest.registered_nodes[node_ok(pos).name].walkable == true then */
  enum { lc810 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),3,15);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"walkable");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc811 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc811);
  const int lc812 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc812) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc810);
  assert(lua_gettop(L) == 6);
  
  /* pos.y = pos.y + 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 6);
  
  /* if minetest.registered_nodes[node_ok(pos).name].walkable == true then */
  enum { lc813 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),3,15);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"walkable");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc814 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc814);
  const int lc815 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc815) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc813);
  assert(lua_gettop(L) == 6);
  
  /* -- spawn mob half block higher than ground
   * pos.y = pos.y - 0.5 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,0.5);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 6);
  
  /* local mob = minetest.add_entity(pos, name) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"add_entity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),0,22);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 7);
  
  /* if mob and mob:get_luaentity() then */
  enum { lc816 = 7 };
  lua_pushvalue(L,7);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"get_luaentity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
  }
  const int lc817 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc817) {
  }
  else {
    
    /* else
     * print ("[nssm]" .. name .. " failed to spawn at "
     * 				.. minetest.pos_to_string(pos)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"[nssm]");
    lc_getupvalue(L,lua_upvalueindex(1),0,22);
    lua_pushliteral(L," failed to spawn at ");
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"pos_to_string");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc816);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: nssm:spawn_specific
 * function(name, nodes, neighbors, min_light, max_light,
 * 	interval, chance, active_object_count, min_height, max_height, day_toggle) */
static int lcf1_nssm_spawn_specific (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 12 };
  lua_settop(L,12);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc774 = 13 };
  assert((lua_gettop(L) == lc774));
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,22);
  lua_pushvalue(L,5);
  lua_rawseti(L,-2,23);
  lua_pushvalue(L,6);
  lua_rawseti(L,-2,24);
  lua_pushvalue(L,9);
  lua_rawseti(L,-2,25);
  lua_pushvalue(L,10);
  lua_rawseti(L,-2,26);
  lua_pushvalue(L,11);
  lua_rawseti(L,-2,27);
  lua_pushvalue(L,12);
  lua_rawseti(L,-2,28);
  
  /* nssm.spawning_nssm[name] = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"spawning_nssm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lc774,0,22);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 13);
  
  /* -- chance override in stonecraft.conf for registered mob
   * local new_chance = tonumber(minetest.setting_get(name .. "_chance")) */
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  const int lc775 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_get");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc774,0,22);
  lua_pushliteral(L,"_chance");
  lua_concat(L,2);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc775),1);
  assert(lua_gettop(L) == 14);
  
  /* if new_chance ~= nil then */
  enum { lc776 = 14 };
  lua_pushnil(L);
  const int lc777 = lua_equal(L,14,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc777);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc778 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc778) {
    
    /* if new_chance == 0 then */
    enum { lc779 = 14 };
    lua_pushnumber(L,0);
    const int lc780 = lua_equal(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc780);
    const int lc781 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc781) {
      
      /* print("[nssm Redo] " .. name .. " has spawning disabled") */
      lua_getfield(L,LUA_ENVIRONINDEX,"print");
      lua_pushliteral(L,"[nssm Redo] ");
      lc_getupvalue(L,lc774,0,22);
      lua_pushliteral(L," has spawning disabled");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 14);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc779);
    assert(lua_gettop(L) == 14);
    
    /* chance = new_chance */
    lua_pushvalue(L,14);
    lua_replace(L,8);
    assert(lua_gettop(L) == 14);
    
    /* print ("[nssm Redo] Chance setting for " .. name .. " is now " .. chance) */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"[nssm Redo] Chance setting for ");
    lc_getupvalue(L,lc774,0,22);
    lua_pushliteral(L," is now ");
    lua_pushvalue(L,8);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc776);
  assert(lua_gettop(L) == 14);
  
  /* minetest.register_abm({
   * 
   * 		nodenames = nodes,
   * 		neighbors = neighbors,
   * 		interval = interval,
   * 		chance = chance,
   * 
   * 		action = function(pos, node, _, active_object_count_wider)
   * 
   * 			-- do not spawn if too many active entities in area
   * 			if active_object_count_wider > active_object_count
   * 			or not nssm.spawning_nssm[name] then
   * 				return
   * 			end
   * 
   * 			-- if toggle set to nil then ignore day/night check
   * 			if day_toggle ~= nil then
   * 
   * 				local tod = (minetest.get_timeofday() or 0) * 24000
   * 
   * 				if tod > 4500 and tod < 19500 then
   * 					-- daylight, but mob wants night
   * 					if day_toggle == false then
   * 						return
   * 					end
   * 				else
   * 					-- night time but mob wants day
   * 					if day_toggle == true then
   * 						return
   * 					end
   * 				end
   * 			end
   * 
   * 			-- spawn above node
   * 			pos.y = pos.y + 1
   * 
   * 			-- only spawn away from player
   * 			local objs = minetest.get_objects_inside_radius(pos, 10)
   * 
   * 			for _,oir in pairs(objs) do
   * 
   * 				if oir:is_player() then
   * 					return
   * 				end
   * 			end
   * 
   * 			-- nssm cannot spawn in protected areas when enabled
   * 			if spawn_protected == 1
   * 			and minetest.is_protected(pos, "") then
   * 				return
   * 			end
   * 
   * 			-- check if light and height levels are ok to spawn
   * 			local light = minetest.get_node_light(pos)
   * 			if not light
   * 			or light > max_light
   * 			or light < min_light
   * 			or pos.y > max_height
   * 			or pos.y < min_height then
   * 				return
   * 			end
   * 
   * 			-- are we spawning inside solid nodes?
   * 			if minetest.registered_nodes[node_ok(pos).name].walkable == true then
   * 				return
   * 			end
   * 
   * 			pos.y = pos.y + 1
   * 
   * 			if minetest.registered_nodes[node_ok(pos).name].walkable == true then
   * 				return
   * 			end
   * 
   * 			-- spawn mob half block higher than ground
   * 			pos.y = pos.y - 0.5
   * 
   * 			local mob = minetest.add_entity(pos, name)
   * 
   * 			if mob and mob:get_luaentity() then
   * --				print ("[nssm] Spawned " .. name .. " at "
   * --				.. minetest.pos_to_string(pos) .. " on "
   * --				.. node.name .. " near " .. neighbors[1])
   * 			else
   * 				print ("[nssm]" .. name .. " failed to spawn at "
   * 				.. minetest.pos_to_string(pos))
   * 			end
   * 
   * 		end
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,5);
  lua_pushliteral(L,"nodenames");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"neighbors");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushvalue(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushvalue(L,lc774);
  lua_pushcclosure(L,lcf818,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 14);
  return 0;
}


/* name: nssm:register_spawn
 * function(name, nodes, max_light, min_light, chance, active_object_count, max_height, day_toggle) */
static int lcf1_nssm_register_spawn (lua_State * L) {
  enum { lc_nformalargs = 9 };
  lua_settop(L,9);
  
  /* nssm:spawn_specific(name, nodes, {"air"}, min_light, max_light, 30,
   * 		chance, active_object_count, -31000, max_height, day_toggle) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_pushliteral(L,"spawn_specific");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,5);
  lua_pushvalue(L,4);
  lua_pushnumber(L,30);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushnumber(L,-31000);
  lua_pushvalue(L,8);
  lua_pushvalue(L,9);
  lua_call(L,12,0);
  assert(lua_gettop(L) == 9);
  return 0;
}


/* name: nssm:explosion
 * function(pos, radius, fire, smoke, sound) */
static int lcf1_nssm_explosion (lua_State * L) {
  lua_checkstack(L,34);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* radius = radius or 0 */
  lua_pushvalue(L,3);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_replace(L,3);
  assert(lua_gettop(L) == 6);
  
  /* fire = fire or 0 */
  lua_pushvalue(L,4);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_replace(L,4);
  assert(lua_gettop(L) == 6);
  
  /* smoke = smoke or 0 */
  lua_pushvalue(L,5);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_replace(L,5);
  assert(lua_gettop(L) == 6);
  
  /* -- if area protected or near map limits then no blast damage
   * if minetest.is_protected(pos, "")
   * 	or not within_limits(pos, radius) then */
  enum { lc825 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"is_protected");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"");
  lua_call(L,2,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"within_limits");
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc826 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc826) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc825);
  assert(lua_gettop(L) == 6);
  
  /* -- explosion sound
   * if sound
   * 	and sound ~= "" then */
  enum { lc827 = 6 };
  lua_pushvalue(L,6);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"");
    const int lc828 = lua_equal(L,6,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc828);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc829 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc829) {
    
    /* minetest.sound_play(sound, {
     * 			pos = pos,
     * 			gain = 1.0,
     * 			max_hear_distance = 16
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"sound_play");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"pos");
    lua_pushvalue(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"gain");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max_hear_distance");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc827);
  assert(lua_gettop(L) == 6);
  
  /* pos = vector.round(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"vector");
  lua_pushliteral(L,"round");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_replace(L,2);
  assert(lua_gettop(L) == 6);
  
  /* -- voxelmanip doesn't work properly unless pos is rounded ?!?!
   * local vm = VoxelManip() */
  lua_getfield(L,LUA_ENVIRONINDEX,"VoxelManip");
  lua_call(L,0,1);
  assert(lua_gettop(L) == 7);
  
  /* local minp, maxp = vm:read_from_map(vector.subtract(pos, radius), vector.add(pos, radius)) */
  lua_pushvalue(L,7);
  const int lc830 = lua_gettop(L);
  lua_pushliteral(L,"read_from_map");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"vector");
  lua_pushliteral(L,"subtract");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,2,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"vector");
  lua_pushliteral(L,"add");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,2,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc830),2);
  assert(lua_gettop(L) == 9);
  
  /* local a = VoxelArea:new({MinEdge = minp, MaxEdge = maxp}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"VoxelArea");
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"MinEdge");
  lua_pushvalue(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"MaxEdge");
  lua_pushvalue(L,9);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 10);
  
  /* local data = vm:get_data(dbuf) */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get_data");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,34);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 11);
  
  /* -- buffer added by MrCerealGuy
   * local p = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 12);
  
  /* local pr = PseudoRandom(os.time()) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc831 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"os");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc831),1);
  assert(lua_gettop(L) == 13);
  
  /* for z = -radius, radius do */
  lc_unm(L,3);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,3)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc832_var = lua_tonumber(L,-1);
  const double lc833_limit = lua_tonumber(L,3);
  const double lc834_step = 1;
  lua_pop(L,1);
  enum { lc835 = 13 };
  while ((((lc834_step > 0) && (lc832_var <= lc833_limit)) || ((lc834_step <= 0) && (lc832_var >= lc833_limit)))) {
    
    /* internal: local z at index 14 */
    lua_pushnumber(L,lc832_var);
    
    /* for y = -radius, radius do */
    lc_unm(L,3);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,3)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc836_var = lua_tonumber(L,-1);
    const double lc837_limit = lua_tonumber(L,3);
    const double lc838_step = 1;
    lua_pop(L,1);
    enum { lc839 = 14 };
    while ((((lc838_step > 0) && (lc836_var <= lc837_limit)) || ((lc838_step <= 0) && (lc836_var >= lc837_limit)))) {
      
      /* internal: local y at index 15 */
      lua_pushnumber(L,lc836_var);
      
      /* local vi = a:index(pos.x + (-radius), pos.y + y, pos.z + z) */
      lua_pushvalue(L,10);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,2);
      lc_unm(L,3);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,2);
      lc_add(L,-1,15);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,2);
      lc_add(L,-1,14);
      lua_remove(L,-2);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 16);
      
      /* for x = -radius, radius do */
      lc_unm(L,3);
      if (!((lua_isnumber(L,-1) && lua_isnumber(L,3)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc840_var = lua_tonumber(L,-1);
      const double lc841_limit = lua_tonumber(L,3);
      const double lc842_step = 1;
      lua_pop(L,1);
      enum { lc843 = 16 };
      while ((((lc842_step > 0) && (lc840_var <= lc841_limit)) || ((lc842_step <= 0) && (lc840_var >= lc841_limit)))) {
        
        /* internal: local x at index 17 */
        lua_pushnumber(L,lc840_var);
        
        /* p.x = pos.x + x */
        lua_pushliteral(L,"x");
        lua_gettable(L,2);
        lc_add(L,-1,17);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_insert(L,-2);
        lua_settable(L,12);
        assert(lua_gettop(L) == 17);
        
        /* p.y = pos.y + y */
        lua_pushliteral(L,"y");
        lua_gettable(L,2);
        lc_add(L,-1,15);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,12);
        assert(lua_gettop(L) == 17);
        
        /* p.z = pos.z + z */
        lua_pushliteral(L,"z");
        lua_gettable(L,2);
        lc_add(L,-1,14);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_insert(L,-2);
        lua_settable(L,12);
        assert(lua_gettop(L) == 17);
        
        /* if (x * x) + (y * y) + (z * z) <= (radius * radius) + pr:next(-radius, radius)
         * 		and data[vi] ~= c_air
         * 		and data[vi] ~= c_ignore
         * 		and data[vi] ~= c_obsidian
         * 		and data[vi] ~= c_brick
         * 		and data[vi] ~= c_chest then */
        enum { lc844 = 17 };
        lc_mul(L,17,17);
        lc_mul(L,15,15);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_mul(L,14,14);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_mul(L,3,3);
        lua_pushvalue(L,13);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lc_unm(L,3);
        lua_pushvalue(L,3);
        lua_call(L,3,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc845 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc845);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),5,29);
          const int lc846 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc846);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),4,30);
          const int lc847 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc847);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),3,31);
          const int lc848 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc848);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),2,32);
          const int lc849 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc849);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_gettable(L,11);
          lc_getupvalue(L,lua_upvalueindex(1),1,33);
          const int lc850 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc850);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc851 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc851) {
          
          /* local n = node_ok(p).name */
          lc_getupvalue(L,lua_upvalueindex(1),8,15);
          lua_pushvalue(L,12);
          lua_call(L,1,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 18);
          
          /* local on_blast = minetest.registered_nodes[n].on_blast */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,18);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"on_blast");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 19);
          
          /* if on_blast then */
          enum { lc852 = 19 };
          if (lua_toboolean(L,19)) {
            
            /* return on_blast(p) */
            const int lc853 = lua_gettop(L);
            lua_pushvalue(L,19);
            lua_pushvalue(L,12);
            lua_call(L,1,LUA_MULTRET);
            return (lua_gettop(L) - lc853);
            assert(lua_gettop(L) == 19);
          }
          lua_settop(L,lc852);
          assert(lua_gettop(L) == 19);
          
          /* if minetest.get_item_group(n, "unbreakable") ~= 1 then */
          enum { lc854 = 19 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_item_group");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,18);
          lua_pushliteral(L,"unbreakable");
          lua_call(L,2,1);
          lua_pushnumber(L,1);
          const int lc855 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc855);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc856 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc856) {
            
            /* -- if chest then drop items inside
             * if n == "default:chest"
             * 				or n == "3dchest:chest"
             * 				or n == "bones:bones" then */
            enum { lc857 = 19 };
            lua_pushvalue(L,18);
            lua_pushliteral(L,"default:chest");
            const int lc858 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc858);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,18);
              lua_pushliteral(L,"3dchest:chest");
              const int lc859 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc859);
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,18);
              lua_pushliteral(L,"bones:bones");
              const int lc860 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc860);
            }
            const int lc861 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc861) {
              
              /* local meta = minetest.get_meta(p) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"get_meta");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_call(L,1,1);
              assert(lua_gettop(L) == 20);
              
              /* local inv  = meta:get_inventory() */
              lua_pushvalue(L,20);
              lua_pushliteral(L,"get_inventory");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_call(L,1,1);
              assert(lua_gettop(L) == 21);
              
              /* for i = 1, inv:get_size("main") do */
              lua_pushnumber(L,1);
              lua_pushvalue(L,21);
              lua_pushliteral(L,"get_size");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushliteral(L,"main");
              lua_call(L,2,1);
              if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
                luaL_error(L,"'for' limit must be a number");
              }
              double lc862_var = lua_tonumber(L,-2);
              const double lc863_limit = lua_tonumber(L,-1);
              const double lc864_step = 1;
              lua_pop(L,2);
              enum { lc865 = 21 };
              while ((((lc864_step > 0) && (lc862_var <= lc863_limit)) || ((lc864_step <= 0) && (lc862_var >= lc863_limit)))) {
                
                /* internal: local i at index 22 */
                lua_pushnumber(L,lc862_var);
                
                /* local m_stack = inv:get_stack("main", i) */
                lua_pushvalue(L,21);
                lua_pushliteral(L,"get_stack");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushliteral(L,"main");
                lua_pushvalue(L,22);
                lua_call(L,3,1);
                assert(lua_gettop(L) == 23);
                
                /* local obj = minetest.add_item(p, m_stack) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"add_item");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,12);
                lua_pushvalue(L,23);
                lua_call(L,2,1);
                assert(lua_gettop(L) == 24);
                
                /* if obj then */
                enum { lc866 = 24 };
                if (lua_toboolean(L,24)) {
                  
                  /* obj:setvelocity({
                   * 								x = math.random(-2, 2),
                   * 								y = 7,
                   * 								z = math.random(-2, 2)
                   * 							}) */
                  lua_pushvalue(L,24);
                  lua_pushliteral(L,"setvelocity");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_createtable(L,0,3);
                  lua_pushliteral(L,"x");
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,-2);
                  lua_pushnumber(L,2);
                  lua_call(L,2,1);
                  lua_rawset(L,-3);
                  lua_pushliteral(L,"y");
                  lua_pushnumber(L,7);
                  lua_rawset(L,-3);
                  lua_pushliteral(L,"z");
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,-2);
                  lua_pushnumber(L,2);
                  lua_call(L,2,1);
                  lua_rawset(L,-3);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 24);
                }
                lua_settop(L,lc866);
                assert(lua_gettop(L) == 24);
                
                /* internal: stack cleanup on scope exit */
                lua_pop(L,3);
                lc862_var += lc864_step;
              }
              lua_settop(L,lc865);
              assert(lua_gettop(L) == 21);
            }
            lua_settop(L,lc857);
            assert(lua_gettop(L) == 19);
            
            /* -- after effects
             * if fire > 0
             * 				and (minetest.registered_nodes[n].groups.flammable
             * 				or math.random(1, 100) <= 30) then */
            enum { lc867 = 19 };
            lua_pushnumber(L,0);
            const int lc868 = lua_lessthan(L,-1,4);
            lua_pop(L,1);
            lua_pushboolean(L,lc868);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"registered_nodes");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,18);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"groups");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"flammable");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"random");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,1);
                lua_pushnumber(L,100);
                lua_call(L,2,1);
                lua_pushnumber(L,30);
                const int lc869 = lc_le(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc869);
              }
            }
            const int lc870 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc870) {
              
              /* minetest.set_node(p, {name = "fire:basic_flame"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"fire:basic_flame");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 19);
            }
            else {
              
              /* else
               * minetest.set_node(p, {name = "air"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"air");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 19);
              
              /* if smoke > 0 then */
              enum { lc871 = 19 };
              lua_pushnumber(L,0);
              const int lc872 = lua_lessthan(L,-1,5);
              lua_pop(L,1);
              lua_pushboolean(L,lc872);
              const int lc873 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc873) {
                
                /* effect(p, 2, "tnt_smoke.png", 5) */
                lua_getfield(L,LUA_ENVIRONINDEX,"effect");
                lua_pushvalue(L,12);
                lua_pushnumber(L,2);
                lua_pushliteral(L,"tnt_smoke.png");
                lua_pushnumber(L,5);
                lua_call(L,4,0);
                assert(lua_gettop(L) == 19);
              }
              lua_settop(L,lc871);
              assert(lua_gettop(L) == 19);
            }
            lua_settop(L,lc867);
            assert(lua_gettop(L) == 19);
          }
          lua_settop(L,lc854);
          assert(lua_gettop(L) == 19);
        }
        lua_settop(L,lc844);
        assert(lua_gettop(L) == 17);
        
        /* vi = vi + 1 */
        lua_pushnumber(L,1);
        lc_add(L,16,-1);
        lua_remove(L,-2);
        lua_replace(L,16);
        assert(lua_gettop(L) == 17);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc840_var += lc842_step;
      }
      lua_settop(L,lc843);
      assert(lua_gettop(L) == 16);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc836_var += lc838_step;
    }
    lua_settop(L,lc839);
    assert(lua_gettop(L) == 14);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc832_var += lc834_step;
  }
  lua_settop(L,lc835);
  assert(lua_gettop(L) == 13);
  return 0;
}


/* function(self, dtime) */
static int lcf902 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* --nssm_modification
   * self.timer = self.timer + 1 */
  lua_pushliteral(L,"timer");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"timer");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 2);
  
  /* local pos = self.object:getpos() */
  lua_pushliteral(L,"object");
  lua_gettable(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if self.switch == 0
   * 			or self.timer > 150
   * 			or not within_limits(pos, 0) then */
  enum { lc876 = 3 };
  lua_pushliteral(L,"switch");
  lua_gettable(L,1);
  lua_pushnumber(L,0);
  const int lc877 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc877);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,150);
    lua_pushliteral(L,"timer");
    lua_gettable(L,1);
    const int lc878 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc878);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"within_limits");
    lua_pushvalue(L,3);
    lua_pushnumber(L,0);
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc879 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc879) {
    
    /* self.object:remove() */
    lua_pushliteral(L,"object");
    lua_gettable(L,1);
    lua_pushliteral(L,"remove");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* -- print ("removed arrow")
     * return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc876);
  assert(lua_gettop(L) == 3);
  
  /* if self.hit_node then */
  enum { lc880 = 3 };
  lua_pushliteral(L,"hit_node");
  lua_gettable(L,1);
  const int lc881 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc881) {
    
    /* local node = node_ok(pos).name */
    lc_getupvalue(L,lua_upvalueindex(1),8,15);
    lua_pushvalue(L,3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 4);
    
    /* --if minetest.registered_nodes[node].walkable then
     * if node ~= "air" then */
    enum { lc882 = 4 };
    lua_pushliteral(L,"air");
    const int lc883 = lua_equal(L,4,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc883);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc884 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc884) {
      
      /* self.hit_node(self, pos, node) */
      lua_pushliteral(L,"hit_node");
      lua_gettable(L,1);
      lua_pushvalue(L,1);
      lua_pushvalue(L,3);
      lua_pushvalue(L,4);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 4);
      
      /* if self.drop == true then */
      enum { lc885 = 4 };
      lua_pushliteral(L,"drop");
      lua_gettable(L,1);
      lua_pushboolean(L,1);
      const int lc886 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc886);
      const int lc887 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc887) {
        
        /* pos.y = pos.y + 1 */
        lua_pushliteral(L,"y");
        lua_gettable(L,3);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,3);
        assert(lua_gettop(L) == 4);
        
        /* self.lastpos = (self.lastpos or pos) */
        lua_pushliteral(L,"lastpos");
        lua_gettable(L,1);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,3);
        }
        lua_pushliteral(L,"lastpos");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 4);
        
        /* minetest.add_item(self.lastpos, self.object:get_luaentity().name) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"add_item");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"lastpos");
        lua_gettable(L,1);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc885);
      assert(lua_gettop(L) == 4);
      
      /* self.object:remove() */
      lua_pushliteral(L,"object");
      lua_gettable(L,1);
      lua_pushliteral(L,"remove");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 4);
      
      /* -- print ("hit node")
       * return */
      return 0;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc882);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc880);
  assert(lua_gettop(L) == 3);
  
  /* if (self.hit_player or self.hit_mob)
   * 			-- clear mob entity before arrow becomes active
   * 			and self.timer > (10 - (self.velocity / 2)) then */
  enum { lc888 = 3 };
  lua_pushliteral(L,"hit_player");
  lua_gettable(L,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"hit_mob");
    lua_gettable(L,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,10);
    lua_pushliteral(L,"velocity");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"timer");
    lua_gettable(L,1);
    const int lc889 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc889);
  }
  const int lc890 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc890) {
    
    /* for _,player in pairs(minetest.get_objects_inside_radius(pos, 1.0)) do
     * internal: local f, s, var = explist */
    enum { lc891 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    const int lc892 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_objects_inside_radius");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushnumber(L,1);
    lua_call(L,2,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc892),3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 7
       * internal: local player with idx 8 */
      
      
      /* if self.hit_player
       * 					and player:is_player() then */
      enum { lc893 = 8 };
      lua_pushliteral(L,"hit_player");
      lua_gettable(L,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"is_player");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
      }
      const int lc894 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc894) {
        
        /* self.hit_player(self, player) */
        lua_pushliteral(L,"hit_player");
        lua_gettable(L,1);
        lua_pushvalue(L,1);
        lua_pushvalue(L,8);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 8);
        
        /* self.object:remove() */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"remove");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 8);
        
        /* -- print ("hit player")
         * return */
        return 0;
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc893);
      assert(lua_gettop(L) == 8);
      
      /* if self.hit_mob
       * 					and player:get_luaentity()
       * 					and player:get_luaentity().name ~= self.object:get_luaentity().name
       * 					and player:get_luaentity().name ~= "__builtin:item"
       * 					and player:get_luaentity().name ~= "gauges:hp_bar"
       * 					and player:get_luaentity().name ~= "signs:text"
       * 					and player:get_luaentity().name ~= "itemframes:item" then */
      enum { lc895 = 8 };
      lua_pushliteral(L,"hit_mob");
      lua_gettable(L,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc896 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc896);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"__builtin:item");
        const int lc897 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc897);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"gauges:hp_bar");
        const int lc898 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc898);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"signs:text");
        const int lc899 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc899);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get_luaentity");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"itemframes:item");
        const int lc900 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc900);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc901 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc901) {
        
        /* self.hit_mob(self, player) */
        lua_pushliteral(L,"hit_mob");
        lua_gettable(L,1);
        lua_pushvalue(L,1);
        lua_pushvalue(L,8);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 8);
        
        /* self.object:remove() */
        lua_pushliteral(L,"object");
        lua_gettable(L,1);
        lua_pushliteral(L,"remove");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 8);
        
        /* -- print ("hit mob")
         * return */
        return 0;
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc895);
      assert(lua_gettop(L) == 8);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc891);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc888);
  assert(lua_gettop(L) == 3);
  
  /* self.lastpos = pos */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"lastpos");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: nssm:register_arrow
 * function(name, def) */
static int lcf1_nssm_register_arrow (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if not name or not def then */
  enum { lc874 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,3)));
  }
  const int lc875 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc875) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc874);
  assert(lua_gettop(L) == 3);
  
  /* -- errorcheck
   * minetest.register_entity(name, {
   * 
   * 		physical = false,
   * 		visual = def.visual,
   * 		visual_size = def.visual_size,
   * 		textures = def.textures,
   * 		velocity = def.velocity,
   * 		hit_player = def.hit_player,
   * 		hit_node = def.hit_node,
   * 		hit_mob = def.hit_mob,
   * 		drop = def.drop or false,
   * 		collisionbox = {0, 0, 0, 0, 0, 0}, -- remove box around arrows
   * 		timer = 0,
   * 		switch = 0,
   * 
   * 		on_step = def.on_step or function(self, dtime)		--nssm_modification
   * 
   * 			self.timer = self.timer + 1
   * 
   * 			local pos = self.object:getpos()
   * 
   * 			if self.switch == 0
   * 			or self.timer > 150
   * 			or not within_limits(pos, 0) then
   * 
   * 				self.object:remove() ; -- print ("removed arrow")
   * 
   * 				return
   * 			end
   * 
   * 			if self.hit_node then
   * 
   * 				local node = node_ok(pos).name
   * 
   * 				--if minetest.registered_nodes[node].walkable then
   * 				if node ~= "air" then
   * 
   * 					self.hit_node(self, pos, node)
   * 
   * 					if self.drop == true then
   * 
   * 						pos.y = pos.y + 1
   * 
   * 						self.lastpos = (self.lastpos or pos)
   * 
   * 						minetest.add_item(self.lastpos, self.object:get_luaentity().name)
   * 					end
   * 
   * 					self.object:remove() ; -- print ("hit node")
   * 
   * 					return
   * 				end
   * 			end
   * 
   * 			if (self.hit_player or self.hit_mob)
   * 			-- clear mob entity before arrow becomes active
   * 			and self.timer > (10 - (self.velocity / 2)) then
   * 
   * 				for _,player in pairs(minetest.get_objects_inside_radius(pos, 1.0)) do
   * 
   * 					if self.hit_player
   * 					and player:is_player() then
   * 
   * 						self.hit_player(self, player)
   * 						self.object:remove() ; -- print ("hit player")
   * 						return
   * 					end
   * 
   * 					if self.hit_mob
   * 					and player:get_luaentity()
   * 					and player:get_luaentity().name ~= self.object:get_luaentity().name
   * 					and player:get_luaentity().name ~= "__builtin:item"
   * 					and player:get_luaentity().name ~= "gauges:hp_bar"
   * 					and player:get_luaentity().name ~= "signs:text"
   * 					and player:get_luaentity().name ~= "itemframes:item" then
   * 
   * 						self.hit_mob(self, player)
   * 
   * 						self.object:remove() ; -- print ("hit mob")
   * 
   * 						return
   * 					end
   * 				end
   * 			end
   * 
   * 			self.lastpos = pos
   * 		end
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_entity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_createtable(L,0,13);
  lua_pushliteral(L,"physical");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual");
  lua_pushliteral(L,"visual");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual_size");
  lua_pushliteral(L,"visual_size");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"textures");
  lua_pushliteral(L,"textures");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"velocity");
  lua_pushliteral(L,"velocity");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_player");
  lua_pushliteral(L,"hit_player");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_node");
  lua_pushliteral(L,"hit_node");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"hit_mob");
  lua_pushliteral(L,"hit_mob");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"drop");
  lua_gettable(L,3);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,0);
  }
  lua_rawset(L,-3);
  lua_pushliteral(L,"collisionbox");
  lua_createtable(L,6,0);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"timer");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"switch");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_step");
  lua_pushliteral(L,"on_step");
  lua_gettable(L,3);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,lua_upvalueindex(1));
    lua_pushcclosure(L,lcf902,1);
  }
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(itemstack, placer, pointed_thing) */
static int lcf915 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local pos = pointed_thing.above */
  lua_pushliteral(L,"above");
  lua_gettable(L,3);
  assert(lua_gettop(L) == 4);
  
  /* if pos
   * 			and within_limits(pos, 0)
   * 			and not minetest.is_protected(pos, placer:get_player_name()) then */
  enum { lc907 = 4 };
  lua_pushvalue(L,4);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"within_limits");
    lua_pushvalue(L,4);
    lua_pushnumber(L,0);
    lua_call(L,2,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"is_protected");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc908 = lua_gettop(L);
    lua_pushvalue(L,4);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc908),1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc909 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc909) {
    
    /* pos.y = pos.y + 1 */
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,4);
    assert(lua_gettop(L) == 4);
    
    /* local mob = minetest.add_entity(pos, mob) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"add_entity");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lc_getupvalue(L,lua_upvalueindex(1),0,35);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 5);
    
    /* local ent = mob:get_luaentity() */
    lua_pushvalue(L,5);
    lua_pushliteral(L,"get_luaentity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 6);
    
    /* if ent.type ~= "monster" then */
    enum { lc910 = 6 };
    lua_pushliteral(L,"type");
    lua_gettable(L,6);
    lua_pushliteral(L,"monster");
    const int lc911 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc911);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc912 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc912) {
      
      /* -- set owner and tame if not monster
       * ent.owner = placer:get_player_name() */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"get_player_name");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"owner");
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 6);
      
      /* ent.tamed = true */
      lua_pushboolean(L,1);
      lua_pushliteral(L,"tamed");
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc910);
    assert(lua_gettop(L) == 6);
    
    /* -- if not in creative then take item
     * if not creative then */
    enum { lc913 = 6 };
    lc_getupvalue(L,lua_upvalueindex(1),20,4);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc914 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc914) {
      
      /* itemstack:take_item() */
      lua_pushvalue(L,1);
      lua_pushliteral(L,"take_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc913);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc907);
  assert(lua_gettop(L) == 4);
  
  /* return itemstack */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: nssm:register_egg
 * function(mob, desc, background, addegg) */
static int lcf1_nssm_register_egg (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc903 = 6 };
  assert((lua_gettop(L) == lc903));
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,35);
  
  /* local invimg = background */
  lua_pushvalue(L,4);
  assert(lua_gettop(L) == 7);
  
  /* if addegg == 1 then */
  enum { lc904 = 7 };
  lua_pushnumber(L,1);
  const int lc905 = lua_equal(L,5,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc905);
  const int lc906 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc906) {
    
    /* invimg = "nssm_chicken_egg.png^(" .. invimg .. "^[mask:nssm_chicken_egg_overlay.png)" */
    lua_pushliteral(L,"nssm_chicken_egg.png^(");
    lua_pushvalue(L,7);
    lua_pushliteral(L,"^[mask:nssm_chicken_egg_overlay.png)");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_replace(L,7);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc904);
  assert(lua_gettop(L) == 7);
  
  /* minetest.register_craftitem(mob, {
   * 
   * 		description = desc,
   * 		inventory_image = invimg,
   * 
   * 		on_place = function(itemstack, placer, pointed_thing)
   * 
   * 			local pos = pointed_thing.above
   * 
   * 			if pos
   * 			and within_limits(pos, 0)
   * 			and not minetest.is_protected(pos, placer:get_player_name()) then
   * 
   * 				pos.y = pos.y + 1
   * 
   * 				local mob = minetest.add_entity(pos, mob)
   * 				local ent = mob:get_luaentity()
   * 
   * 				if ent.type ~= "monster" then
   * 					-- set owner and tame if not monster
   * 					ent.owner = placer:get_player_name()
   * 					ent.tamed = true
   * 				end
   * 
   * 				-- if not in creative then take item
   * 				if not creative then
   * 					itemstack:take_item()
   * 				end
   * 			end
   * 
   * 			return itemstack
   * 		end,
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craftitem");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc903,0,35);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_place");
  lua_pushvalue(L,lc903);
  lua_pushcclosure(L,lcf915,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: nssm:capture_mob
 * function(self, clicker, chance_hand, chance_net, chance_lasso, force_take, replacewith) */
static int lcf1_nssm_capture_mob (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 8 };
  lua_settop(L,8);
  
  /* if not self.child
   * 	and clicker:is_player()
   * 	and clicker:get_inventory() then */
  enum { lc916 = 8 };
  lua_pushliteral(L,"child");
  lua_gettable(L,2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"is_player");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_inventory");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
  }
  const int lc917 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc917) {
    
    /* -- get name of clicked mob
     * local mobname = self.name */
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    assert(lua_gettop(L) == 9);
    
    /* -- if not nil change what will be added to inventory
     * if replacewith then */
    enum { lc918 = 9 };
    if (lua_toboolean(L,8)) {
      
      /* mobname = replacewith */
      lua_pushvalue(L,8);
      lua_replace(L,9);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc918);
    assert(lua_gettop(L) == 9);
    
    /* local name = clicker:get_player_name() */
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 10);
    
    /* -- is mob tamed?
     * if self.tamed == false
     * 		and force_take == false then */
    enum { lc919 = 10 };
    lua_pushliteral(L,"tamed");
    lua_gettable(L,2);
    lua_pushboolean(L,0);
    const int lc920 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc920);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,7);
      lua_pushboolean(L,0);
      const int lc921 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc921);
    }
    const int lc922 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc922) {
      
      /* minetest.chat_send_player(name, "Not tamed!") */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"chat_send_player");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,10);
      lua_pushliteral(L,"Not tamed!");
      lua_call(L,2,0);
      assert(lua_gettop(L) == 10);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc919);
    assert(lua_gettop(L) == 10);
    
    /* -- cannot pick up if not owner
     * if self.owner ~= name
     * 		and force_take == false then */
    enum { lc923 = 10 };
    lua_pushliteral(L,"owner");
    lua_gettable(L,2);
    const int lc924 = lua_equal(L,-1,10);
    lua_pop(L,1);
    lua_pushboolean(L,lc924);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,7);
      lua_pushboolean(L,0);
      const int lc925 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc925);
    }
    const int lc926 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc926) {
      
      /* minetest.chat_send_player(name, self.owner.." is owner!") */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"chat_send_player");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,10);
      lua_pushliteral(L,"owner");
      lua_gettable(L,2);
      lua_pushliteral(L," is owner!");
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 10);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc923);
    assert(lua_gettop(L) == 10);
    
    /* if clicker:get_inventory():room_for_item("main", mobname) then */
    enum { lc927 = 10 };
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_inventory");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"room_for_item");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"main");
    lua_pushvalue(L,9);
    lua_call(L,3,1);
    const int lc928 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc928) {
      
      /* -- was mob clicked with hand, net, or lasso?
       * local tool = clicker:get_wielded_item() */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"get_wielded_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 11);
      
      /* local chance = 0 */
      lua_pushnumber(L,0);
      assert(lua_gettop(L) == 12);
      
      /* if tool:is_empty() then */
      enum { lc929 = 12 };
      lua_pushvalue(L,11);
      lua_pushliteral(L,"is_empty");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      const int lc930 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc930) {
        
        /* chance = chance_hand */
        lua_pushvalue(L,4);
        lua_replace(L,12);
        assert(lua_gettop(L) == 12);
      }
      else {
        
        /* elseif tool:get_name() == "nssm:net" then */
        enum { lc931 = 12 };
        lua_pushvalue(L,11);
        lua_pushliteral(L,"get_name");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"nssm:net");
        const int lc932 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc932);
        const int lc933 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc933) {
          
          /* chance = chance_net */
          lua_pushvalue(L,5);
          lua_replace(L,12);
          assert(lua_gettop(L) == 12);
          
          /* tool:add_wear(4000) */
          lua_pushvalue(L,11);
          lua_pushliteral(L,"add_wear");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushnumber(L,4000);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 12);
          
          /* -- 17 uses
           * clicker:set_wielded_item(tool) */
          lua_pushvalue(L,3);
          lua_pushliteral(L,"set_wielded_item");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,11);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 12);
        }
        else {
          
          /* elseif tool:get_name() == "nssm:magic_lasso" then */
          enum { lc934 = 12 };
          lua_pushvalue(L,11);
          lua_pushliteral(L,"get_name");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"nssm:magic_lasso");
          const int lc935 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc935);
          const int lc936 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc936) {
            
            /* chance = chance_lasso */
            lua_pushvalue(L,6);
            lua_replace(L,12);
            assert(lua_gettop(L) == 12);
            
            /* tool:add_wear(650) */
            lua_pushvalue(L,11);
            lua_pushliteral(L,"add_wear");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushnumber(L,650);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 12);
            
            /* -- 100 uses
             * clicker:set_wielded_item(tool) */
            lua_pushvalue(L,3);
            lua_pushliteral(L,"set_wielded_item");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,11);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 12);
          }
          lua_settop(L,lc934);
        }
        lua_settop(L,lc931);
      }
      lua_settop(L,lc929);
      assert(lua_gettop(L) == 12);
      
      /* -- return if no chance
       * if chance == 0 then */
      enum { lc937 = 12 };
      lua_pushnumber(L,0);
      const int lc938 = lua_equal(L,12,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc938);
      const int lc939 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc939) {
        
        /* return */
        return 0;
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc937);
      assert(lua_gettop(L) == 12);
      
      /* -- calculate chance.. add to inventory if successful?
       * if math.random(1, 100) <= chance then */
      enum { lc940 = 12 };
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,100);
      lua_call(L,2,1);
      const int lc941 = lc_le(L,-1,12);
      lua_pop(L,1);
      lua_pushboolean(L,lc941);
      const int lc942 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc942) {
        
        /* clicker:get_inventory():add_item("main", mobname) */
        lua_pushvalue(L,3);
        lua_pushliteral(L,"get_inventory");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"add_item");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"main");
        lua_pushvalue(L,9);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 12);
        
        /* self.object:remove() */
        lua_pushliteral(L,"object");
        lua_gettable(L,2);
        lua_pushliteral(L,"remove");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 12);
      }
      else {
        
        /* else
         * minetest.chat_send_player(name, "Missed!") */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"chat_send_player");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_pushliteral(L,"Missed!");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc940);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc927);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc916);
  assert(lua_gettop(L) == 8);
  return 0;
}


/* name: nssm:feed_tame
 * function(self, clicker, feed_count, breed, tame) */
static int lcf1_nssm_feed_tame (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* if not self.follow then */
  enum { lc945 = 6 };
  lua_pushliteral(L,"follow");
  lua_gettable(L,2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc946 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc946) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc945);
  assert(lua_gettop(L) == 6);
  
  /* -- can eat/tame with item in hand
   * if follow_holding(self, clicker) then */
  enum { lc947 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"follow_holding");
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,2,1);
  const int lc948 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc948) {
    
    /* -- if not in creative then take item
     * if not creative then */
    enum { lc949 = 6 };
    lc_getupvalue(L,lua_upvalueindex(1),21,4);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc950 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc950) {
      
      /* local item = clicker:get_wielded_item() */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"get_wielded_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 7);
      
      /* item:take_item() */
      lua_pushvalue(L,7);
      lua_pushliteral(L,"take_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 7);
      
      /* clicker:set_wielded_item(item) */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"set_wielded_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,7);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc949);
    assert(lua_gettop(L) == 6);
    
    /* -- increase health
     * self.health = self.health + 4 */
    lua_pushliteral(L,"health");
    lua_gettable(L,2);
    lua_pushnumber(L,4);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"health");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 6);
    
    /* if self.health >= self.hp_max then */
    enum { lc951 = 6 };
    lua_pushliteral(L,"hp_max");
    lua_gettable(L,2);
    lua_pushliteral(L,"health");
    lua_gettable(L,2);
    const int lc952 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc952);
    const int lc953 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc953) {
      
      /* self.health = self.hp_max */
      lua_pushliteral(L,"hp_max");
      lua_gettable(L,2);
      lua_pushliteral(L,"health");
      lua_insert(L,-2);
      lua_settable(L,2);
      assert(lua_gettop(L) == 6);
      
      /* if self.htimer < 1 then */
      enum { lc954 = 6 };
      lua_pushliteral(L,"htimer");
      lua_gettable(L,2);
      lua_pushnumber(L,1);
      const int lc955 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc955);
      const int lc956 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc956) {
        
        /* minetest.chat_send_player(clicker:get_player_name(),
         * 					self.name:split(":")[2]
         * 					.. " at full health (" .. tostring(self.health) .. ")") */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"chat_send_player");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,3);
        lua_pushliteral(L,"get_player_name");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,2);
        lua_pushliteral(L,"split");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,":");
        lua_call(L,2,1);
        lua_pushnumber(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L," at full health (");
        lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
        lua_pushliteral(L,"health");
        lua_gettable(L,2);
        lua_call(L,1,1);
        lua_pushliteral(L,")");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 6);
        
        /* self.htimer = 5 */
        lua_pushnumber(L,5);
        lua_pushliteral(L,"htimer");
        lua_insert(L,-2);
        lua_settable(L,2);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc954);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc951);
    assert(lua_gettop(L) == 6);
    
    /* self.object:set_hp(self.health) */
    lua_pushliteral(L,"object");
    lua_gettable(L,2);
    lua_pushliteral(L,"set_hp");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"health");
    lua_gettable(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
    
    /* update_tag(self) */
    lua_getfield(L,LUA_ENVIRONINDEX,"update_tag");
    lua_pushvalue(L,2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 6);
    
    /* -- make children grow quicker
     * if self.child == true then */
    enum { lc957 = 6 };
    lua_pushliteral(L,"child");
    lua_gettable(L,2);
    lua_pushboolean(L,1);
    const int lc958 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc958);
    const int lc959 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc959) {
      
      /* self.hornytimer = self.hornytimer + 20 */
      lua_pushliteral(L,"hornytimer");
      lua_gettable(L,2);
      lua_pushnumber(L,20);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"hornytimer");
      lua_insert(L,-2);
      lua_settable(L,2);
      assert(lua_gettop(L) == 6);
      
      /* return true */
      lua_pushboolean(L,1);
      return 1;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc957);
    assert(lua_gettop(L) == 6);
    
    /* -- feed and tame
     * self.food = (self.food or 0) + 1 */
    lua_pushliteral(L,"food");
    lua_gettable(L,2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"food");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 6);
    
    /* if self.food >= feed_count then */
    enum { lc960 = 6 };
    lua_pushliteral(L,"food");
    lua_gettable(L,2);
    const int lc961 = lc_le(L,4,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc961);
    const int lc962 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc962) {
      
      /* self.food = 0 */
      lua_pushnumber(L,0);
      lua_pushliteral(L,"food");
      lua_insert(L,-2);
      lua_settable(L,2);
      assert(lua_gettop(L) == 6);
      
      /* if breed and self.hornytimer == 0 then */
      enum { lc963 = 6 };
      lua_pushvalue(L,5);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"hornytimer");
        lua_gettable(L,2);
        lua_pushnumber(L,0);
        const int lc964 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc964);
      }
      const int lc965 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc965) {
        
        /* self.horny = true */
        lua_pushboolean(L,1);
        lua_pushliteral(L,"horny");
        lua_insert(L,-2);
        lua_settable(L,2);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc963);
      assert(lua_gettop(L) == 6);
      
      /* self.gotten = false */
      lua_pushboolean(L,0);
      lua_pushliteral(L,"gotten");
      lua_insert(L,-2);
      lua_settable(L,2);
      assert(lua_gettop(L) == 6);
      
      /* if tame then */
      enum { lc966 = 6 };
      if (lua_toboolean(L,6)) {
        
        /* if self.tamed == false then */
        enum { lc967 = 6 };
        lua_pushliteral(L,"tamed");
        lua_gettable(L,2);
        lua_pushboolean(L,0);
        const int lc968 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc968);
        const int lc969 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc969) {
          
          /* minetest.chat_send_player(clicker:get_player_name(),
           * 						self.name:split(":")[2]
           * 						.. " has been tamed!") */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"chat_send_player");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,3);
          lua_pushliteral(L,"get_player_name");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,2);
          lua_pushliteral(L,"split");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,":");
          lua_call(L,2,1);
          lua_pushnumber(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L," has been tamed!");
          lua_concat(L,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc967);
        assert(lua_gettop(L) == 6);
        
        /* self.tamed = true */
        lua_pushboolean(L,1);
        lua_pushliteral(L,"tamed");
        lua_insert(L,-2);
        lua_settable(L,2);
        assert(lua_gettop(L) == 6);
        
        /* if not self.owner or self.owner == "" then */
        enum { lc970 = 6 };
        lua_pushliteral(L,"owner");
        lua_gettable(L,2);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushliteral(L,"owner");
          lua_gettable(L,2);
          lua_pushliteral(L,"");
          const int lc971 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc971);
        }
        const int lc972 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc972) {
          
          /* self.owner = clicker:get_player_name() */
          lua_pushvalue(L,3);
          lua_pushliteral(L,"get_player_name");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"owner");
          lua_insert(L,-2);
          lua_settable(L,2);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc970);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc966);
      assert(lua_gettop(L) == 6);
      
      /* -- make sound when fed so many times
       * if self.sounds.random then */
      enum { lc973 = 6 };
      lua_pushliteral(L,"sounds");
      lua_gettable(L,2);
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc974 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc974) {
        
        /* minetest.sound_play(self.sounds.random, {
         * 					object = self.object,
         * 					max_hear_distance = self.sounds.distance
         * 				}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"sound_play");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"sounds");
        lua_gettable(L,2);
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"object");
        lua_pushliteral(L,"object");
        lua_gettable(L,2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"max_hear_distance");
        lua_pushliteral(L,"sounds");
        lua_gettable(L,2);
        lua_pushliteral(L,"distance");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc973);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc960);
    assert(lua_gettop(L) == 6);
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc947);
  assert(lua_gettop(L) == 6);
  
  /* local item = clicker:get_wielded_item() */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"get_wielded_item");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* -- if mob has been tamed you can name it with a nametag
   * if item:get_name() == "nssm:nametag"
   * 	and clicker:get_player_name() == self.owner then */
  enum { lc975 = 7 };
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get_name");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"nssm:nametag");
  const int lc976 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc976);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"owner");
    lua_gettable(L,2);
    const int lc977 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc977);
  }
  const int lc978 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc978) {
    
    /* local name = clicker:get_player_name() */
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 8);
    
    /* -- store mob and nametag stack in external variables
     * mob_obj[name] = self */
    lua_pushvalue(L,2);
    lc_getupvalue(L,lua_upvalueindex(1),1,36);
    lua_insert(L,-2);
    lua_pushvalue(L,8);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* mob_sta[name] = item */
    lua_pushvalue(L,7);
    lc_getupvalue(L,lua_upvalueindex(1),0,37);
    lua_insert(L,-2);
    lua_pushvalue(L,8);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* local tag = self.nametag or "" */
    lua_pushliteral(L,"nametag");
    lua_gettable(L,2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
    }
    assert(lua_gettop(L) == 9);
    
    /* local formspec = "size[8,4]"
     * 			.. default.gui_bg
     * 			.. default.gui_bg_img
     * 			.. "field[0.5,1;7.5,0;name;Enter name:;" .. tag .. "]"
     * 			.. "button_exit[2.5,3.5;3,1;mob_rename;Rename]" */
    lua_pushliteral(L,"size[8,4]");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"gui_bg");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"gui_bg_img");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"field[0.5,1;7.5,0;name;Enter name:;");
    lua_pushvalue(L,9);
    lua_pushliteral(L,"]");
    lua_pushliteral(L,"button_exit[2.5,3.5;3,1;mob_rename;Rename]");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 10);
    
    /* minetest.show_formspec(name, "nssm_nametag", formspec) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"show_formspec");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,8);
    lua_pushliteral(L,"nssm_nametag");
    lua_pushvalue(L,10);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc975);
  assert(lua_gettop(L) == 7);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* function(player, formname, fields) */
static int lcf987 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- right-clicked with nametag and name entered?
   * if formname == "nssm_nametag"
   * 	and fields.name
   * 	and fields.name ~= "" then */
  enum { lc979 = 3 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"nssm_nametag");
  const int lc980 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc980);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lua_pushliteral(L,"");
    const int lc981 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc981);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc982 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc982) {
    
    /* local name = player:get_player_name() */
    lua_pushvalue(L,1);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 4);
    
    /* if not mob_obj[name]
     * 		or not mob_obj[name].object then */
    enum { lc983 = 4 };
    lc_getupvalue(L,lua_upvalueindex(1),1,36);
    lua_pushvalue(L,4);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),1,36);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"object");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc984 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc984) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc983);
    assert(lua_gettop(L) == 4);
    
    /* -- update nametag
     * mob_obj[name].nametag = fields.name */
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lc_getupvalue(L,lua_upvalueindex(1),1,36);
    lua_pushvalue(L,4);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"nametag");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 4);
    
    /* update_tag(mob_obj[name]) */
    lua_getfield(L,LUA_ENVIRONINDEX,"update_tag");
    lc_getupvalue(L,lua_upvalueindex(1),1,36);
    lua_pushvalue(L,4);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
    
    /* -- if not in creative then take item
     * if not creative then */
    enum { lc985 = 4 };
    lc_getupvalue(L,lua_upvalueindex(1),21,4);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc986 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc986) {
      
      /* mob_sta[name]:take_item() */
      lc_getupvalue(L,lua_upvalueindex(1),0,37);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"take_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 4);
      
      /* player:set_wielded_item(mob_sta[name]) */
      lua_pushvalue(L,1);
      lua_pushliteral(L,"set_wielded_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,37);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc985);
    assert(lua_gettop(L) == 4);
    
    /* -- reset external variables
     * mob_obj[name] = nil */
    lua_pushnil(L);
    lc_getupvalue(L,lua_upvalueindex(1),1,36);
    lua_insert(L,-2);
    lua_pushvalue(L,4);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 4);
    
    /* mob_sta[name] = nil */
    lua_pushnil(L);
    lc_getupvalue(L,lua_upvalueindex(1),0,37);
    lua_insert(L,-2);
    lua_pushvalue(L,4);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc979);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,35);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* --[[
   * 
   * nssm Api (19th March 2016) with NSSM modifications
   * 
   * 2016 modified by MrCerealGuy <mrcerealguy@gmx.de>
   * 
   * --]]
   * nssm = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"nssm");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* nssm.mod = "redo" */
  lua_pushliteral(L,"redo");
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"mod");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- Load settings
   * local damage_enabled = minetest.setting_getbool("enable_damage") */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_getbool");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"enable_damage");
  lua_call(L,1,1);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local peaceful_only = minetest.setting_getbool("only_peaceful_nssm") */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_getbool");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"only_peaceful_nssm");
  lua_call(L,1,1);
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local disable_blood = minetest.setting_getbool("nssm_disable_blood") */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc3 = 3 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_getbool");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nssm_disable_blood");
  lua_call(L,1,1);
  lua_rawseti(L,(lc3 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local creative = minetest.setting_getbool("creative_mode") */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 4 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_getbool");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"creative_mode");
  lua_call(L,1,1);
  lua_rawseti(L,(lc4 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local spawn_protected = tonumber(minetest.setting_get("nssm_spawn_protected")) or 1 */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc5 = 5 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  const int lc6 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_get");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nssm_spawn_protected");
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc6),1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_rawseti(L,(lc5 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local remove_far = minetest.setting_getbool("remove_far_nssm") */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc7 = 6 };
  assert((lua_gettop(L) == (lc7 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_getbool");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"remove_far_nssm");
  lua_call(L,1,1);
  lua_rawseti(L,(lc7 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* -- pathfinding settings
   * local enable_pathfinding = true */
  lc_newclosuretable(L,(lc7 + lc_nextra));
  enum { lc8 = 7 };
  assert((lua_gettop(L) == (lc8 + lc_nextra)));
  lua_pushboolean(L,1);
  lua_rawseti(L,(lc8 + lc_nextra),7);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* local enable_pathfind_digging = false */
  lc_newclosuretable(L,(lc8 + lc_nextra));
  enum { lc9 = 8 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_pushboolean(L,0);
  lua_rawseti(L,(lc9 + lc_nextra),8);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local stuck_timeout = 3 */
  lc_newclosuretable(L,(lc9 + lc_nextra));
  enum { lc10 = 9 };
  assert((lua_gettop(L) == (lc10 + lc_nextra)));
  lua_pushnumber(L,3);
  lua_rawseti(L,(lc10 + lc_nextra),9);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* -- how long before mob gets stuck in place and starts searching
   * local stuck_path_timeout = 10 */
  lc_newclosuretable(L,(lc10 + lc_nextra));
  enum { lc11 = 10 };
  assert((lua_gettop(L) == (lc11 + lc_nextra)));
  lua_pushnumber(L,10);
  lua_rawseti(L,(lc11 + lc_nextra),10);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* -- how long will mob follow path before giving up
   * -- internal functions
   * local pi = math.pi */
  lc_newclosuretable(L,(lc11 + lc_nextra));
  enum { lc12 = 11 };
  assert((lua_gettop(L) == (lc12 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"pi");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc12 + lc_nextra),11);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local square = math.sqrt */
  lc_newclosuretable(L,(lc12 + lc_nextra));
  enum { lc13 = 12 };
  assert((lua_gettop(L) == (lc13 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sqrt");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc13 + lc_nextra),12);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* local atan = function(x)
   * 
   * 	if x ~= x then
   * 		--error("atan bassed NaN")
   * 		print ("atan based NaN")
   * 		return 0
   * 	else
   * 		return math.atan(x)
   * 	end
   * end */
  lc_newclosuretable(L,(lc13 + lc_nextra));
  enum { lc14 = 13 };
  assert((lua_gettop(L) == (lc14 + lc_nextra)));
  lua_pushcfunction(L,lcf1_atan);
  lua_rawseti(L,(lc14 + lc_nextra),13);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* do_attack = function(self, player)
   * 
   * 	if self.state ~= "attack" then
   * 
   * 		if math.random(0,100) < 90
   * 		and self.sounds.war_cry then
   * 
   * 			minetest.sound_play(self.sounds.war_cry,{
   * 				object = self.object,
   * 				max_hear_distance = self.sounds.distance
   * 			})
   * 		end
   * 
   * 		self.state = "attack"
   * 		self.attack = player
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_do_attack);
  lua_setfield(L,LUA_ENVIRONINDEX,"do_attack");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* set_velocity = function(self, v)
   * 
   * 	v = v or 0
   * 
   * 	local yaw = (self.object:getyaw() + self.rotate) or 0
   * 
   * 	self.object:setvelocity({
   * 		x = math.sin(yaw) * -v,
   * 		y = self.object:getvelocity().y,
   * 		z = math.cos(yaw) * v
   * 	})
   * end */
  lua_pushcfunction(L,lcf1_set_velocity);
  lua_setfield(L,LUA_ENVIRONINDEX,"set_velocity");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* get_velocity = function(self)
   * 
   * 	local v = self.object:getvelocity()
   * 
   * 	return (v.x * v.x + v.z * v.z) ^ 0.5
   * end */
  lua_pushcfunction(L,lcf1_get_velocity);
  lua_setfield(L,LUA_ENVIRONINDEX,"get_velocity");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* set_animation = function(self, type)
   * 
   * 	if not self.animation then
   * 		return
   * 	end
   * 
   * 	self.animation.current = self.animation.current or ""
   * 
   * 	self.animation.speed_normal = self.animation.speed_normal or 15
   * 
   * 	if type == "stand"
   * 	and self.animation.current ~= "stand" then
   * 
   * 		if self.animation.stand_start
   * 		and self.animation.stand_end
   * 		and self.animation.speed_normal then
   * 
   * 			self.object:set_animation({
   * 				x = self.animation.stand_start,
   * 				y = self.animation.stand_end},
   * 				self.animation.speed_normal, 0)
   * 
   * 			self.animation.current = "stand"
   * 		end
   * 
   * 	elseif type == "walk"
   * 	and self.animation.current ~= "walk" then
   * 
   * 		if self.animation.walk_start
   * 		and self.animation.walk_end
   * 		and self.animation.speed_normal then
   * 
   * 			self.object:set_animation({
   * 				x = self.animation.walk_start,
   * 				y = self.animation.walk_end},
   * 				self.animation.speed_normal, 0)
   * 
   * 			self.animation.current = "walk"
   * 		end
   * 
   * 	elseif type == "run"
   * 	and self.animation.current ~= "run" then
   * 
   * 		if self.animation.run_start
   * 		and self.animation.run_end
   * 		and self.animation.speed_run then
   * 
   * 			self.object:set_animation({
   * 				x = self.animation.run_start,
   * 				y = self.animation.run_end},
   * 				(self.animation.speed_run or self.animation.speed_normal), 0)
   * 
   * 			self.animation.current = "run"
   * 		end
   * 
   * 	elseif type == "punch"
   * 	and self.animation.current ~= "punch" then
   * 
   * 		if self.animation.punch_start
   * 		and self.animation.punch_end
   * 		and self.animation.speed_normal then
   * 
   * 			self.object:set_animation({
   * 				x = self.animation.punch_start,
   * 				y = self.animation.punch_end},
   * 				(self.animation.speed_punch or self.animation.speed_normal), 0)
   * 
   * 			self.animation.current = "punch"
   * 		end
   * 
   * 		--NSSM additions:
   * 
   * 	elseif type == "punch1"
   * 		and self.animation.current ~= "punch1"  then
   * 			if self.animation.punch1_start
   * 			and self.animation.punch1_end
   * 			and self.animation.speed_normal then
   * 				self.object:set_animation({
   * 					x = self.animation.punch1_start,
   * 					y = self.animation.punch1_end},
   * 					self.animation.speed_normal, 0)
   * 				self.animation.current = "punch1"
   * 			end
   *     elseif type == "dattack"
   * 		and self.animation.current ~= "dattack"  then
   * 			if self.animation.dattack_start
   * 			and self.animation.dattack_end
   * 			and self.animation.speed_normal then
   * 				self.object:set_animation({
   * 					x = self.animation.dattack_start,
   * 					y = self.animation.dattack_end},
   * 					self.animation.speed_normal, 0)
   * 				self.animation.current = "dattack"
   * 			end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_set_animation);
  lua_setfield(L,LUA_ENVIRONINDEX,"set_animation");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- check line of sight for walkers and swimmers alike
   * function line_of_sight_water(self, pos1, pos2, stepsize)
   * 
   * 	local s, pos_w = minetest.line_of_sight(pos1, pos2, stepsize)
   * 
   * 	-- normal walking and flying nssm can see you through air
   * 	if s == true then
   * 		return true
   * 	end
   * 
   * 	-- swimming nssm can see you through water
   * 	if s == false
   * 	and self.fly
   * 	and self.fly_in == "default:water_source" then
   * 
   * 		local nod = minetest.get_node(pos_w).name
   * 
   * 		if nod == "default:water_source"
   * 		or nod == "default:water_flowing" then
   * 
   * 			return true
   * 		end
   * 	end
   * 
   * 	return false
   * 
   * end */
  lua_pushcfunction(L,lcf1_line_of_sight_water);
  lua_setfield(L,LUA_ENVIRONINDEX,"line_of_sight_water");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- particle effects
   * function effect(pos, amount, texture, max_size)
   * 
   * 	minetest.add_particlespawner({
   * 		amount = amount,
   * 		time = 0.25,
   * 		minpos = pos,
   * 		maxpos = pos,
   * 		minvel = {x = -0, y = -2, z = -0},
   * 		maxvel = {x = 2,  y = 2,  z = 2},
   * 		minacc = {x = -4, y = -4, z = -4},
   * 		maxacc = {x = 4, y = 4, z = 4},
   * 		minexptime = 0.1,
   * 		maxexptime = 1,
   * 		minsize = 0.5,
   * 		maxsize = (max_size or 1),
   * 		texture = texture,
   * 	})
   * end */
  lua_pushcfunction(L,lcf1_effect);
  lua_setfield(L,LUA_ENVIRONINDEX,"effect");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- update nametag colour
   * function update_tag(self)
   * 
   * 	local col = "#00FF00"
   * 	local qua = self.hp_max / 4
   * 
   * 	if self.health <= math.floor(qua * 3) then
   * 		col = "#FFFF00"
   * 	end
   * 
   * 	if self.health <= math.floor(qua * 2) then
   * 		col = "#FF6600"
   * 	end
   * 
   * 	if self.health <= math.floor(qua) then
   * 		col = "#FF0000"
   * 	end
   * 
   * 	self.object:set_properties({
   * 		nametag = self.nametag,
   * 		nametag_color = col
   * 	})
   * 
   * end */
  lua_pushcfunction(L,lcf1_update_tag);
  lua_setfield(L,LUA_ENVIRONINDEX,"update_tag");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- check if mob is dead or only hurt
   * function check_for_death(self)
   * 
   * 	-- has health actually changed?
   * 	if self.health == self.old_health then
   * 		return
   * 	end
   * 
   * 	self.old_health = self.health
   * 
   * 	-- still got some health? play hurt sound
   * 	if self.health > 0 then
   * 
   * 		if self.sounds.damage then
   * 
   * 			minetest.sound_play(self.sounds.damage,{
   * 				object = self.object,
   * 				gain = 1.0,
   * 				max_hear_distance = self.sounds.distance
   * 			})
   * 		end
   * 
   * 		-- make sure health isn't higher than max
   * 		if self.health > self.hp_max then
   * 			self.health = self.hp_max
   * 		end
   * 
   * 		update_tag(self)
   * 
   * 		return false
   * 	end
   * 
   * 	-- drop items when dead
   * 	local obj
   * 	local pos = self.object:getpos()
   * 
   * 	for _,drop in pairs(self.drops) do
   * 
   * 		if math.random(1, drop.chance) == 1 then
   * 
   * 			obj = minetest.add_item(pos,
   * 				ItemStack(drop.name .. " "
   * 					.. math.random(drop.min, drop.max)))
   * 
   * 			if obj then
   * 
   * 				obj:setvelocity({
   * 					x = math.random(-1, 1),
   * 					y = 6,
   * 					z = math.random(-1, 1)
   * 				})
   * 			end
   * 		end
   * 	end
   * 
   * 	-- play death sound
   * 	if self.sounds.death then
   * 
   * 		minetest.sound_play(self.sounds.death,{
   * 			object = self.object,
   * 			gain = 1.0,
   * 			max_hear_distance = self.sounds.distance
   * 		})
   * 	end
   * 
   * 	-- execute custom death function
   * 	if self.on_die then
   * 		self.on_die(self, pos)
   * 	end
   * 
   * 	self.object:remove()
   * 
   * 	return true
   * end */
  lua_pushcfunction(L,lcf1_check_for_death);
  lua_setfield(L,LUA_ENVIRONINDEX,"check_for_death");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- check if within map limits (-30911 to 30927)
   * function within_limits(pos, radius)
   * 
   * 	if  (pos.x - radius) > -30913
   * 	and (pos.x + radius) <  30928
   * 	and (pos.y - radius) > -30913
   * 	and (pos.y + radius) <  30928
   * 	and (pos.z - radius) > -30913
   * 	and (pos.z + radius) <  30928 then
   * 		return true -- within limits
   * 	end
   * 
   * 	return false -- beyond limits
   * end */
  lua_pushcfunction(L,lcf1_within_limits);
  lua_setfield(L,LUA_ENVIRONINDEX,"within_limits");
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- is mob facing a cliff
   * local function is_at_cliff(self)
   * 
   * 	if self.fear_height == 0 then -- if 0, no falling protection!
   * 		return false
   * 	end
   * 
   * 	local yaw = self.object:getyaw()
   * 	local dir_x = -math.sin(yaw) * (self.collisionbox[4] + 0.5)
   * 	local dir_z = math.cos(yaw) * (self.collisionbox[4] + 0.5)
   * 	local pos = self.object:getpos()
   * 	local ypos = pos.y + self.collisionbox[2] -- just above floor
   * 
   * 	if minetest.line_of_sight(
   * 		{x = pos.x + dir_x, y = ypos, z = pos.z + dir_z},
   * 		{x = pos.x + dir_x, y = ypos - self.fear_height, z = pos.z + dir_z}
   * 	, 1) then
   * 
   * 		return true
   * 	end
   * 
   * 	return false
   * end */
  lc_newclosuretable(L,(lc14 + lc_nextra));
  enum { lc112 = 14 };
  assert((lua_gettop(L) == (lc112 + lc_nextra)));
  lua_pushcfunction(L,lcf1_is_at_cliff);
  lua_rawseti(L,(lc112 + lc_nextra),14);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* -- get node but use fallback for nil or unknown
   * local function node_ok(pos, fallback)
   * 
   * 	fallback = fallback or "default:dirt"
   * 
   * 	local node = minetest.get_node_or_nil(pos)
   * 
   * 	if not node then
   * 		return minetest.registered_nodes[fallback]
   * 	end
   * 
   * 	if minetest.registered_nodes[node.name] then
   * 		return node
   * 	end
   * 
   * 	return minetest.registered_nodes[fallback]
   * end */
  lc_newclosuretable(L,(lc112 + lc_nextra));
  enum { lc118 = 15 };
  assert((lua_gettop(L) == (lc118 + lc_nextra)));
  lua_pushcfunction(L,lcf1_node_ok);
  lua_rawseti(L,(lc118 + lc_nextra),15);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* -- environmental damage (water, lava, fire, light)
   * do_env_damage = function(self)
   * 
   * 	-- feed/tame text timer (so mob 'full' messages dont spam chat)
   * 	if self.htimer > 0 then
   * 		self.htimer = self.htimer - 1
   * 	end
   * 
   * 	local pos = self.object:getpos()
   * 
   * 	self.time_of_day = minetest.get_timeofday()
   * 
   * 	-- remove mob if beyond map limits
   * 	if not within_limits(pos, 0) then
   * 		self.object:remove()
   * 		return
   * 	end
   * 
   * 	-- daylight above ground
   * 	if self.light_damage ~= 0
   * 	and pos.y > 0
   * 	and self.time_of_day > 0.2
   * 	and self.time_of_day < 0.8
   * 	and (minetest.get_node_light(pos) or 0) > 12 then
   * 
   * 		self.health = self.health - self.light_damage
   * 
   * 		effect(pos, 5, "tnt_smoke.png")
   * 	end
   * 
   * 	-- what is mob standing in?
   * 	pos.y = pos.y + self.collisionbox[2] + 0.1 -- foot level
   * 	self.standing_in = node_ok(pos, "air").name
   * 	--print ("standing in " .. self.standing_in)
   * 
   * 	if self.water_damage ~= 0
   * 	or self.lava_damage ~= 0 then
   * 
   * 		local nodef = minetest.registered_nodes[self.standing_in]
   * 
   * 		pos.y = pos.y + 1
   * 
   * 		-- water
   * 		if self.water_damage ~= 0
   * 		and nodef.groups.water then
   * 
   * 			self.health = self.health - self.water_damage
   * 
   * 			effect(pos, 5, "bubble.png")
   * 		end
   * 
   * 		-- lava or fire
   * 		if self.lava_damage ~= 0
   * 		and (nodef.groups.lava
   * 		or self.standing_in == "fire:basic_flame"
   * 		or self.standing_in == "fire:permanent_flame") then
   * 
   * 			self.health = self.health - self.lava_damage
   * 
   * 			effect(pos, 5, "fire_basic_flame.png")
   * 		end
   * 	end
   * 
   * 	--NSSM modifications:
   * 
   * 	if not self.hydra then
   * 		if check_for_death(self) then
   * 			return
   * 		end
   * 	else
   * 		if nssm:check_for_death_hydra(self) then
   * 			return
   * 		end
   * 	end
   * 
   * 	--end of NSSM modifications
   * 
   * 
   * end */
  lua_pushvalue(L,(lc118 + lc_nextra));
  lua_pushcclosure(L,lcf1_do_env_damage,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"do_env_damage");
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* -- jump if facing a solid node (not fences)
   * do_jump = function(self)
   * 
   * 	if self.fly
   * 	or self.child then
   * 		return
   * 	end
   * 
   * 	local pos = self.object:getpos()
   * 
   * 	-- what is mob standing on?
   * 	pos.y = pos.y + self.collisionbox[2] - 0.2
   * 
   * 	local nod = node_ok(pos)
   * 
   * --print ("standing on:", nod.name, pos.y)
   * 
   * 	if minetest.registered_nodes[nod.name].walkable == false then
   * 		return
   * 	end
   * 
   * 	-- where is front
   * 	local yaw = self.object:getyaw()
   * 	local dir_x = -math.sin(yaw) * (self.collisionbox[4] + 0.5)
   * 	local dir_z = math.cos(yaw) * (self.collisionbox[4] + 0.5)
   * 
   * 	-- what is in front of mob?
   * 	local nod = node_ok({
   * 		x = pos.x + dir_x,
   * 		y = pos.y + 0.5,
   * 		z = pos.z + dir_z
   * 	})
   * 
   * 	-- thin blocks that do not need to be jumped
   * 	if nod.name == "default:snow" then
   * 		return
   * 	end
   * 
   * --print ("in front:", nod.name, pos.y + 0.5)
   * 
   * 	if (minetest.registered_items[nod.name].walkable
   * 	and not nod.name:find("fence")
   * 	and not nod.name:find("gate"))
   * 	or self.walk_chance == 0 then
   * 
   * 		local v = self.object:getvelocity()
   * 
   * 		v.y = self.jump_height + 1
   * 		v.x = v.x * 2.2
   * 		v.z = v.z * 2.2
   * 
   * 		self.object:setvelocity(v)
   * 
   * 		if self.sounds.jump then
   * 
   * 			minetest.sound_play(self.sounds.jump, {
   * 				object = self.object,
   * 				gain = 1.0,
   * 				max_hear_distance = self.sounds.distance
   * 			})
   * 		end
   * 	else
   * 		if self.state ~= "attack" then
   * 			self.state = "stand"
   * 			set_animation(self, "stand")
   * 		end
   * 	end
   * end */
  lua_pushvalue(L,(lc118 + lc_nextra));
  lua_pushcclosure(L,lcf1_do_jump,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"do_jump");
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* -- this is a faster way to calculate distance
   * local get_distance = function(a, b)
   * 
   * 	local x, y, z = a.x - b.x, a.y - b.y, a.z - b.z
   * 
   * 	return square(x * x + y * y + z * z)
   * end */
  lc_newclosuretable(L,(lc118 + lc_nextra));
  enum { lc169 = 16 };
  assert((lua_gettop(L) == (lc169 + lc_nextra)));
  lua_pushvalue(L,(lc118 + lc_nextra));
  lua_pushcclosure(L,lcf1_get_distance,1);
  lua_rawseti(L,(lc169 + lc_nextra),16);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- blast damage to entities nearby (modified from TNT mod)
   * function entity_physics(pos, radius)
   * 
   * 	radius = radius * 2
   * 
   * 	local objs = minetest.get_objects_inside_radius(pos, radius)
   * 	local obj_pos, dist
   * 
   * 	for _, obj in pairs(objs) do
   * 
   * 		obj_pos = obj:getpos()
   * 
   * 		dist = math.max(1, get_distance(pos, obj_pos))
   * 
   * 		local damage = math.floor((4 / dist) * radius)
   * 		local ent = obj:get_luaentity()
   * 
   * 		if obj:is_player() then
   * 			obj:set_hp(obj:get_hp() - damage)
   * 
   * 		elseif ent.health then
   * 
   * 			obj:punch(obj, 1.0, {
   * 				full_punch_interval = 1.0,
   * 				damage_groups = {fleshy = damage},
   * 			}, nil)
   * 
   * 		end
   * 	end
   * end */
  lua_pushvalue(L,(lc169 + lc_nextra));
  lua_pushcclosure(L,lcf1_entity_physics,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"entity_physics");
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- should mob follow what I'm holding ?
   * function follow_holding(self, clicker)
   * 
   * 	local item = clicker:get_wielded_item()
   * 	local t = type(self.follow)
   * 
   * 	-- single item
   * 	if t == "string"
   * 	and item:get_name() == self.follow then
   * 		return true
   * 
   * 	-- multiple items
   * 	elseif t == "table" then
   * 
   * 		for no = 1, #self.follow do
   * 
   * 			if self.follow[no] == item:get_name() then
   * 				return true
   * 			end
   * 		end
   * 	end
   * 
   * 	return false
   * end */
  lua_pushcfunction(L,lcf1_follow_holding);
  lua_setfield(L,LUA_ENVIRONINDEX,"follow_holding");
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* local function breed(self)
   * 
   * 	-- child take 240 seconds before growing into adult
   * 	if self.child == true then
   * 
   * 		self.hornytimer = self.hornytimer + 1
   * 
   * 		if self.hornytimer > 240 then
   * 
   * 			self.child = false
   * 			self.hornytimer = 0
   * 
   * 			self.object:set_properties({
   * 				textures = self.base_texture,
   * 				mesh = self.base_mesh,
   * 				visual_size = self.base_size,
   * 				collisionbox = self.base_colbox,
   * 			})
   * 
   * 			-- jump when fully grown so not to fall into ground
   * 			self.object:setvelocity({
   * 				x = 0,
   * 				y = self.jump_height,
   * 				z = 0
   * 			})
   * 		end
   * 
   * 		return
   * 	end
   * 
   * 	-- horny animal can mate for 40 seconds,
   * 	-- afterwards horny animal cannot mate again for 200 seconds
   * 	if self.horny == true
   * 	and self.hornytimer < 240 then
   * 
   * 		self.hornytimer = self.hornytimer + 1
   * 
   * 		if self.hornytimer >= 240 then
   * 			self.hornytimer = 0
   * 			self.horny = false
   * 		end
   * 	end
   * 
   * 	-- find another same animal who is also horny and mate if close enough
   * 	if self.horny == true
   * 	and self.hornytimer <= 40 then
   * 
   * 		local pos = self.object:getpos()
   * 
   * 		effect({x = pos.x, y = pos.y + 1, z = pos.z}, 4, "heart.png")
   * 
   * 		local ents = minetest.get_objects_inside_radius(pos, 3)
   * 		local num = 0
   * 		local ent = nil
   * 
   * 		for i, obj in pairs(ents) do
   * 
   * 			ent = obj:get_luaentity()
   * 
   * 			-- check for same animal with different colour
   * 			local canmate = false
   * 
   * 			if ent then
   * 
   * 				if ent.name == self.name then
   * 					canmate = true
   * 				else
   * 					local entname = string.split(ent.name,":")
   * 					local selfname = string.split(self.name,":")
   * 
   * 					if entname[1] == selfname[1] then
   * 						entname = string.split(entname[2],"_")
   * 						selfname = string.split(selfname[2],"_")
   * 
   * 						if entname[1] == selfname[1] then
   * 							canmate = true
   * 						end
   * 					end
   * 				end
   * 			end
   * 
   * 			if ent
   * 			and canmate == true
   * 			and ent.horny == true
   * 			and ent.hornytimer <= 40 then
   * 				num = num + 1
   * 			end
   * 
   * 			-- found your mate? then have a baby
   * 			if num > 1 then
   * 
   * 				self.hornytimer = 41
   * 				ent.hornytimer = 41
   * 
   * 				-- spawn baby
   * 				minetest.after(5, function(dtime)
   * 
   * 					local mob = minetest.add_entity(pos, self.name)
   * 					local ent2 = mob:get_luaentity()
   * 					local textures = self.base_texture
   * 
   * 					if self.child_texture then
   * 						textures = self.child_texture[1]
   * 					end
   * 
   * 					mob:set_properties({
   * 						textures = textures,
   * 						visual_size = {
   * 							x = self.base_size.x / 2,
   * 							y = self.base_size.y / 2
   * 						},
   * 						collisionbox = {
   * 							self.base_colbox[1] / 2,
   * 							self.base_colbox[2] / 2,
   * 							self.base_colbox[3] / 2,
   * 							self.base_colbox[4] / 2,
   * 							self.base_colbox[5] / 2,
   * 							self.base_colbox[6] / 2
   * 						},
   * 					})
   * 					ent2.child = true
   * 					ent2.tamed = true
   * 					ent2.owner = self.owner
   * 				end)
   * 
   * 				num = 0
   * 
   * 				break
   * 			end
   * 		end
   * 	end
   * end */
  lc_newclosuretable(L,(lc169 + lc_nextra));
  enum { lc192 = 17 };
  assert((lua_gettop(L) == (lc192 + lc_nextra)));
  lua_pushcfunction(L,lcf1_breed);
  lua_rawseti(L,(lc192 + lc_nextra),17);
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* function replace(self, pos)
   * 
   * 	if self.replace_rate
   * 	and self.child == false
   * 	and math.random(1, self.replace_rate) == 1 then
   * 
   * 		local pos = self.object:getpos()
   * 
   * 		pos.y = pos.y + self.replace_offset
   * 
   * -- print ("replace node = ".. minetest.get_node(pos).name, pos.y)
   * 
   * 		if self.replace_what
   * 		and self.replace_with
   * 		and self.object:getvelocity().y == 0
   * 		and #minetest.find_nodes_in_area(pos, pos, self.replace_what) > 0 then
   * 
   * 			minetest.set_node(pos, {name = self.replace_with})
   * 
   * 			-- when cow/sheep eats grass, replace wool and milk
   * 			if self.gotten == true then
   * 				self.gotten = false
   * 				self.object:set_properties(self)
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_replace);
  lua_setfield(L,LUA_ENVIRONINDEX,"replace");
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- check if daytime and also if mob is docile during daylight hours
   * function day_docile(self)
   * 
   * 	if self.docile_by_day == false then
   * 
   * 		return false
   * 
   * 	elseif self.docile_by_day == true
   * 	and self.time_of_day > 0.2
   * 	and self.time_of_day < 0.8 then
   * 
   * 		return true
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_day_docile);
  lua_setfield(L,LUA_ENVIRONINDEX,"day_docile");
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- path finding and smart mob routine by rnd
   * function smart_nssm(self, s, p, dist, dtime)
   * 
   * 	local s1 = self.path.lastpos
   * 
   * 	-- is it becoming stuck?
   * 	if math.abs(s1.x - s.x) + math.abs(s1.z - s.z) < 1.5 then
   * 		self.path.stuck_timer = self.path.stuck_timer + dtime
   * 	else
   * 		self.path.stuck_timer = 0
   * 	end
   * 
   * 	self.path.lastpos = {x = s.x, y = s.y, z = s.z}
   * 
   * 	-- im stuck, search for path
   * 	if (self.path.stuck_timer > stuck_timeout and not self.path.following)
   * 	or (self.path.stuck_timer > stuck_path_timeout
   * 	and self.path.following) then
   * 
   * 		self.path.stuck_timer = 0
   * 
   * 		-- lets try find a path, first take care of positions
   * 		-- since pathfinder is very sensitive
   * 		local sheight = self.collisionbox[5] - self.collisionbox[2]
   * 
   * 		-- round position to center of node to avoid stuck in walls
   * 		-- also adjust height for player models!
   * 		s.x = math.floor(s.x + 0.5)
   * 		s.y = math.floor(s.y + 0.5) - sheight
   * 		s.z = math.floor(s.z + 0.5)
   * 
   * 		local ssight, sground
   * 		ssight, sground = minetest.line_of_sight(s, {
   * 			x = s.x, y = s.y - 4, z = s.z}, 1)
   * 
   * 		-- determine node above ground
   * 		if not ssight then
   * 			s.y = sground.y + 1
   * 		end
   * 
   * 		local p1 = self.attack:getpos()
   * 
   * 		p1.x = math.floor(p1.x + 0.5)
   * 		p1.y = math.floor(p1.y + 0.5)
   * 		p1.z = math.floor(p1.z + 0.5)
   * 
   * 		self.path.way = minetest.find_path(s, p1, 16, 2, 6, "Dijkstra") --"A*_noprefetch")
   * 
   * 		-- attempt to unstick mob that is "daydreaming"
   * 		self.object:setpos({
   * 			x = s.x + 0.1 * (math.random() * 2 - 1),
   * 			y = s.y + 1,
   * 			z = s.z + 0.1 * (math.random() * 2 - 1)
   * 		})
   * 
   * 		self.state = ""
   * 		do_attack(self, self.attack)
   * 
   * 		-- no path found, try something else
   * 		if not self.path.way then
   * 
   * 			self.path.following = false
   * --			self.path.stuck = true
   * 
   * 			 -- lets make way by digging/building if not accessible
   * 			if enable_pathfind_digging then
   * 
   * 				 -- add block and remove one block above so
   * 				 -- there is room to jump if needed
   * 				if s.y < p1.y then
   * 
   * 					if not minetest.is_protected(s, "") then
   * 						minetest.set_node(s, {name = "default:dirt"})
   * 					end
   * 
   * 					local sheight = math.ceil(self.collisionbox[5]) + 1
   * 
   * 					-- assume mob is 2 blocks high so it digs above its head
   * 					s.y = s.y + sheight
   * 
   * 					if not minetest.is_protected(s, "") then
   * 
   * 						local node1 = minetest.get_node(s).name
   * 
   * 						if node1 ~= "air"
   * 						and node1 ~= "ignore" then
   * 							minetest.set_node(s, {name = "air"})
   * 							minetest.add_item(s, ItemStack(node1))
   * 						end
   * 					end
   * 
   * 					s.y = s.y - sheight
   * 					self.object:setpos({x = s.x, y = s.y + 2, z = s.z})
   * 
   * 				else -- dig 2 blocks to make door toward player direction
   * 
   * 					local yaw1 = self.object:getyaw() + pi / 2
   * 
   * 					local p1 = {
   * 						x = s.x + math.cos(yaw1),
   * 						y = s.y,
   * 						z = s.z + math.sin(yaw1)
   * 					}
   * 
   * 					if not minetest.is_protected(p1, "") then
   * 
   * 						local node1 = minetest.get_node(p1).name
   * 
   * 						if node1 ~= "air"
   * 						and node1 ~= "ignore" then
   * 							minetest.add_item(p1, ItemStack(node1))
   * 							minetest.set_node(p1, {name = "air"})
   * 						end
   * 
   * 						p1.y = p1.y + 1
   * 						node1 = minetest.get_node(p1).name
   * 
   * 						if node1 ~= "air"
   * 						and node1 ~= "ignore" then
   * 							minetest.add_item(p1, ItemStack(node1))
   * 							minetest.set_node(p1, {name = "air"})
   * 						end
   * 
   * 					end
   * 				end
   * 			end
   * 
   * 			-- will try again in 2 second
   * 			self.path.stuck_timer = stuck_timeout - 2
   * 
   * 			-- frustration! cant find the damn path :(
   * 			if self.sounds.random then
   * 				minetest.sound_play(self.sounds.random, {
   * 					object = self.object,
   * 					max_hear_distance = self.sounds.distance
   * 				})
   * 			end
   * 
   * 		else
   * 
   * 			-- yay i found path
   * 			if self.sounds.attack then
   * 
   * 				set_velocity(self, self.walk_velocity)
   * 
   * 				minetest.sound_play(self.sounds.attack, {
   * 					object = self.object,
   * 					max_hear_distance = self.sounds.distance
   * 				})
   * 			end
   * 
   * 			-- follow path now that it has it
   * 			self.path.following = true
   * 		end
   * 	end
   * end */
  lua_pushvalue(L,(lc192 + lc_nextra));
  lua_pushcclosure(L,lcf1_smart_nssm,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"smart_nssm");
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- register mob function
   * function nssm:register_mob(name, def)
   * 
   * minetest.register_entity(name, {
   * 
   * 	stepheight = def.stepheight or 0.6,
   * 	name = name,
   * 	type = def.type,
   * 	attack_type = def.attack_type,
   * 	fly = def.fly,
   * 	fly_in = def.fly_in or "air",
   * 	owner = def.owner or "",
   * 	order = def.order or "",
   * 	on_die = def.on_die,
   * 	do_custom = def.do_custom,
   * 	jump_height = def.jump_height or 6,
   * 	jump_chance = def.jump_chance or 0,
   * 	drawtype = def.drawtype, -- DEPRECATED, use rotate instead
   * 	rotate = math.rad(def.rotate or 0), --  0=front, 90=side, 180=back, 270=side2
   * 	lifetimer = def.lifetimer or 180, -- 3 minutes
   * 	hp_min = def.hp_min or 5,
   * 	hp_max = def.hp_max or 10,
   * 	physical = true,
   * 	collisionbox = def.collisionbox,
   * 	visual = def.visual,
   * 	visual_size = def.visual_size or {x = 1, y = 1},
   * 	mesh = def.mesh,
   * 	makes_footstep_sound = def.makes_footstep_sound or false,
   * 	view_range = def.view_range or 5,
   * 	walk_velocity = def.walk_velocity or 1,
   * 	run_velocity = def.run_velocity or 2,
   * 	damage = def.damage or 0,
   * 	light_damage = def.light_damage or 0,
   * 	water_damage = def.water_damage or 0,
   * 	lava_damage = def.lava_damage or 0,
   * 	fall_damage = def.fall_damage or 1,
   * 	fall_speed = def.fall_speed or -10, -- must be lower than -2 (default: -10)
   * 	drops = def.drops or {},
   * 	armor = def.armor,
   * 	on_rightclick = def.on_rightclick,
   * 	arrow = def.arrow,
   * 	shoot_interval = def.shoot_interval,
   * 	sounds = def.sounds or {},
   * 	animation = def.animation,
   * 	follow = def.follow,
   * 	jump = def.jump or true,
   * 	walk_chance = def.walk_chance or 50,
   * 	attacks_monsters = def.attacks_monsters or false,
   * 	group_attack = def.group_attack or false,
   * 	--fov = def.fov or 120,
   * 	passive = def.passive or false,
   * 	recovery_time = def.recovery_time or 0.5,
   * 	knock_back = def.knock_back or 3,
   * 	blood_amount = def.blood_amount or 5,
   * 	blood_texture = def.blood_texture or "nssm_blood.png",
   * 	shoot_offset = def.shoot_offset or 0,
   * 	floats = def.floats or 1, -- floats in water by default
   * 	replace_rate = def.replace_rate,
   * 	replace_what = def.replace_what,
   * 	replace_with = def.replace_with,
   * 	replace_offset = def.replace_offset or 0,
   * 	timer = 0,
   * 	env_damage_timer = 0, -- only used when state = "attack"
   * 	tamed = false,
   * 	pause_timer = 0,
   * 	horny = false,
   * 	hornytimer = 0,
   * 	child = false,
   * 	gotten = false,
   * 	health = 0,
   * 	reach = def.reach or 2,
   * 	htimer = 0,
   * 	child_texture = def.child_texture,
   * 	docile_by_day = def.docile_by_day or false,
   * 	time_of_day = 0.5,
   * 	fear_height = def.fear_height or 0,
   * 	runaway = def.runaway,
   * 	runaway_timer = 0,
   * 	pathfinding = def.pathfinding,
   * 	immune_to = def.immune_to or {},
   * 	explosion_radius = def.explosion_radius,
   * 
   * 	--NSSM parameters
   * 
   * 	on_dist_attack = def.on_dist_attack,
   * 	metamorphosis = def.metamorphosis or false,
   * 	metatimer = 0,
   * 	dogshoot_stop = def.dogshoot_stop or false,
   * 	hydra = def.hydra or false,
   * 	mele_number = def.mele_number or 1,
   * 	true_dist_attack = def.true_dist_attack or false,
   * 	explosion_radius = def.explosion_radius or 0,
   * 	direct_hit = false,
   * 	num_sons = 0,
   * 	num_mele_attacks = 0,
   * 	custom_attack = def.custom_attack or false,
   * 	attack_rip = 0,
   * 
   * 	--End of NSSM parameters
   * 
   * 	on_step = function(self, dtime)
   * 
   * 		local pos = self.object:getpos()
   * 		local yaw = self.object:getyaw() or 0
   * 
   * 		if self.metatimer == 0 then
   * 			self.metatimer = os.time()
   * 		end
   * 
   * 		-- when lifetimer expires remove mob (except npc and tamed)
   * 		if self.type ~= "npc"
   * 		and not self.tamed
   * 		and self.state ~= "attack" then
   * 
   * 			self.lifetimer = self.lifetimer - dtime
   * 
   * 			if self.lifetimer <= 0 then
   * 
   * 				-- only despawn away from player
   * 				local objs = minetest.get_objects_inside_radius(pos, 10)
   * 
   * 				for _,oir in pairs(objs) do
   * 
   * 					if oir:is_player() then
   * 
   * 						self.lifetimer = 20
   * 
   * 						return
   * 					end
   * 				end
   * 
   * 				minetest.log("action",
   * 					"lifetimer expired, removed " .. self.name)
   * 
   * 				effect(pos, 15, "tnt_smoke.png")
   * 
   * 				self.object:remove()
   * 
   * 				return
   * 			end
   * 		end
   * 
   * 		if not self.fly then
   * 
   * 			-- floating in water (or falling)
   * 			local v = self.object:getvelocity()
   * 
   * 			-- going up then apply gravity
   * 			if v.y > 0.1 then
   * 
   * 				self.object:setacceleration({
   * 					x = 0,
   * 					y = self.fall_speed,
   * 					z = 0
   * 				})
   * 			end
   * 
   * 			-- in water then float up
   * 			if minetest.registered_nodes[node_ok(pos).name].groups.liquid then -- water then
   * 
   * 				if self.floats == 1 then
   * 
   * 					self.object:setacceleration({
   * 						x = 0,
   * 						y = -self.fall_speed / (math.max(1, v.y) ^ 2),
   * 						z = 0
   * 					})
   * 				end
   * 			else
   * 				-- fall downwards
   * 				self.object:setacceleration({
   * 					x = 0,
   * 					y = self.fall_speed,
   * 					z = 0
   * 				})
   * 
   * 				-- fall damage
   * 				if self.fall_damage == 1
   * 				and self.object:getvelocity().y == 0 then
   * 
   * 					local d = self.old_y - self.object:getpos().y
   * 
   * 					if d > 5 then
   * 
   * 						--self.object:set_hp(self.object:get_hp() - math.floor(d - 5))
   * 						self.health = self.health - math.floor(d - 5)
   * 
   * 						effect(pos, 5, "tnt_smoke.png")
   * 
   * 						if check_for_death(self) then
   * 							return
   * 						end
   * 					end
   * 
   * 					self.old_y = self.object:getpos().y
   * 				end
   * 			end
   * 		end
   * 
   * 		-- knockback timer
   * 		if self.pause_timer > 0 then
   * 
   * 			self.pause_timer = self.pause_timer - dtime
   * 
   * 			if self.pause_timer < 1 then
   * 				self.pause_timer = 0
   * 			end
   * 
   * 			return
   * 		end
   * 
   * 		-- attack timer
   * 		self.timer = self.timer + dtime
   * 
   * 		if self.state ~= "attack" then
   * 
   * 			if self.timer < 1 then
   * 				return
   * 			end
   * 
   * 			self.timer = 0
   * 		end
   * 
   * 		-- never go over 100
   * 		if self.timer > 100 then
   * 			self.timer = 1
   * 		end
   * 
   * 		-- node replace check (cow eats grass etc.)
   * 		replace(self, pos)
   * 
   * 		-- mob plays random sound at times
   * 		if self.sounds.random
   * 		and math.random(1, 100) == 1 then
   * 
   * 			minetest.sound_play(self.sounds.random, {
   * 				object = self.object,
   * 				max_hear_distance = self.sounds.distance
   * 			})
   * 		end
   * 
   * 		-- environmental damage timer (every 1 second)
   * 		self.env_damage_timer = self.env_damage_timer + dtime
   * 
   * 		if (self.state == "attack" and self.env_damage_timer > 1)
   * 		or self.state ~= "attack" then
   * 
   * 			self.env_damage_timer = 0
   * 
   * 			do_env_damage(self)
   * 
   * 			-- custom function (defined in mob lua file)
   * 			if self.do_custom then
   * 				self.do_custom(self)
   * 			end
   * 		end
   * 
   * 		-- find someone to attack
   * 		if self.type == "monster"
   * 		and damage_enabled
   * 		and self.state ~= "attack"
   * 		and not day_docile(self) then
   * 
   * 			local s = self.object:getpos()
   * 			local p, sp, dist
   * 			local player = nil
   * 			local type = nil
   * 			local obj = nil
   * 			local min_dist = self.view_range + 1
   * 			local min_player = nil
   * 
   * 			for _,oir in pairs(minetest.get_objects_inside_radius(s, self.view_range)) do
   * 
   * 				if oir:is_player() then
   * 
   * 					player = oir
   * 					type = "player"
   * 				else
   * 					obj = oir:get_luaentity()
   * 
   * 					if obj then
   * 						player = obj.object
   * 						type = obj.type
   * 					end
   * 				end
   * 
   * 				if type == "player"
   * 				or type == "npc" then
   * 
   * 					s = self.object:getpos()
   * 					p = player:getpos()
   * 					sp = s
   * 
   * 					-- aim higher to make looking up hills more realistic
   * 					p.y = p.y + 1
   * 					sp.y = sp.y + 1
   * 
   * 					dist = get_distance(p, s)
   * 
   * 					if dist < self.view_range then
   * 					-- field of view check goes here
   * 
   * 						-- choose closest player to attack
   * 						--if minetest.line_of_sight(sp, p, 2) == true
   * 						if line_of_sight_water(self, sp, p, 2) == true
   * 						and dist < min_dist then
   * 							min_dist = dist
   * 							min_player = player
   * 						end
   * 					end
   * 				end
   * 			end
   * 
   * 			-- attack player
   * 			if min_player then
   * 				do_attack(self, min_player)
   * 			end
   * 		end
   * 
   * 		-- npc, find closest monster to attack
   * 		local min_dist = self.view_range + 1
   * 		local min_player = nil
   * 
   * 		if self.type == "npc"
   * 		and self.attacks_monsters
   * 		and self.state ~= "attack" then
   * 
   * 			local s = self.object:getpos()
   * 			local obj = nil
   * 
   * 			for _, oir in pairs(minetest.get_objects_inside_radius(s, self.view_range)) do
   * 
   * 				obj = oir:get_luaentity()
   * 
   * 				if obj
   * 				and obj.type == "monster" then
   * 
   * 					-- attack monster
   * 					p = obj.object:getpos()
   * 
   * 					dist = get_distance(p, s)
   * 
   * 					if dist < min_dist then
   * 						min_dist = dist
   * 						min_player = obj.object
   * 					end
   * 				end
   * 			end
   * 
   * 			if min_player then
   * 				do_attack(self, min_player)
   * 			end
   * 		end
   * 
   * 		-- breed and grow children
   * 		breed(self)
   * 
   * 		-- find player to follow
   * 		if (self.follow ~= ""
   * 		or self.order == "follow")
   * 		and not self.following
   * 		and self.state ~= "attack"
   * 		and self.state ~= "runaway" then
   * 
   * 			local s, p, dist
   * 
   * 			for _,player in pairs(minetest.get_connected_players()) do
   * 
   * 				s = self.object:getpos()
   * 				p = player:getpos()
   * 				dist = get_distance(p, s)
   * 
   * 				if dist < self.view_range then
   * 					self.following = player
   * 					break
   * 				end
   * 			end
   * 		end
   * 
   * 		if self.type == "npc"
   * 		and self.order == "follow"
   * 		and self.state ~= "attack"
   * 		and self.owner ~= "" then
   * 
   * 			-- npc stop following player if not owner
   * 			if self.following
   * 			and self.owner
   * 			and self.owner ~= self.following:get_player_name() then
   * 				self.following = nil
   * 			end
   * 		else
   * 			-- stop following player if not holding specific item
   * 			if self.following
   * 			and self.following:is_player()
   * 			and follow_holding(self, self.following) == false then
   * 				self.following = nil
   * 			end
   * 
   * 		end
   * 
   * 		-- follow that thing
   * 		if self.following then
   * 
   * 			local s = self.object:getpos()
   * 			local p
   * 
   * 			if self.following:is_player() then
   * 
   * 				p = self.following:getpos()
   * 
   * 			elseif self.following.object then
   * 
   * 				p = self.following.object:getpos()
   * 			end
   * 
   * 			if p then
   * 
   * 				local dist = get_distance(p, s)
   * 
   * 				-- dont follow if out of range
   * 				if dist > self.view_range then
   * 					self.following = nil
   * 				else
   * 					local vec = {
   * 						x = p.x - s.x,
   * 						y = p.y - s.y,
   * 						z = p.z - s.z
   * 					}
   * 
   * 					if vec.x ~= 0
   * 					and vec.z ~= 0 then
   * 
   * 						yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 						if p.x > s.x then
   * 							yaw = yaw + pi
   * 						end
   * 
   * 						self.object:setyaw(yaw)
   * 					end
   * 
   * 					-- anyone but standing npc's can move along
   * 					if dist > self.reach
   * 					and self.order ~= "stand" then
   * 
   * 						if (self.jump
   * 						and get_velocity(self) <= 0.5
   * 						and self.object:getvelocity().y == 0)
   * 						or (self.object:getvelocity().y == 0
   * 						and self.jump_chance > 0) then
   * 
   * 							do_jump(self)
   * 						end
   * 
   * 						set_velocity(self, self.walk_velocity)
   * 
   * 						if self.walk_chance ~= 0 then
   * 							set_animation(self, "walk")
   * 						end
   * 					else
   * 						set_velocity(self, 0)
   * 						set_animation(self, "stand")
   * 					end
   * 
   * 					return
   * 				end
   * 			end
   * 		end
   * 
   * 		-- water swimmers flop when on land
   * 		if self.fly
   * 		and self.fly_in == "default:water_source"
   * 		and self.standing_in ~= self.fly_in then
   * 
   * 			self.state = "flop"
   * 			self.object:setvelocity({x = 0, y = -5, z = 0})
   * 
   * 			set_animation(self, "stand")
   * 
   * 			return
   * 		end
   * 
   * 		if self.state == "stand" then
   * 
   * 			if math.random(1, 4) == 1 then
   * 
   * 				local lp = nil
   * 				local s = self.object:getpos()
   * 
   * 				if self.type == "npc" then
   * 
   * 					local o = minetest.get_objects_inside_radius(self.object:getpos(), 3)
   * 
   * 					for _,o in pairs(o) do
   * 
   * 						if o:is_player() then
   * 							lp = o:getpos()
   * 							break
   * 						end
   * 					end
   * 				end
   * 
   * 				-- look at any players nearby, otherwise turn randomly
   * 				if lp then
   * 
   * 					local vec = {
   * 						x = lp.x - s.x,
   * 						y = lp.y - s.y,
   * 						z = lp.z - s.z
   * 					}
   * 
   * 					if vec.x ~= 0
   * 					and vec.z ~= 0 then
   * 
   * 						yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 						if lp.x > s.x then
   * 							yaw = yaw + pi
   * 						end
   * 					end
   * 				else
   * 					yaw = (math.random(0, 360) - 180) / 180 * pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			set_velocity(self, 0)
   * 			set_animation(self, "stand")
   * 
   * 			-- npc's ordered to stand stay standing
   * 			if self.type ~= "npc"
   * 			or self.order ~= "stand" then
   * 
   * 				if self.walk_chance ~= 0
   * 				and math.random(1, 100) <= self.walk_chance
   * 				and is_at_cliff(self) == false then
   * 
   * 					set_velocity(self, self.walk_velocity)
   * 					self.state = "walk"
   * 					set_animation(self, "walk")
   * 				end
   * 			end
   * 
   * 		elseif self.state == "walk" then
   * 
   * 			local s = self.object:getpos()
   * 			local lp = minetest.find_node_near(s, 1, {"group:water"})
   * 
   * 			-- if water nearby then turn away
   * 			if lp then
   * 
   * 				local vec = {
   * 					x = lp.x - s.x,
   * 					y = lp.y - s.y,
   * 					z = lp.z - s.z
   * 				}
   * 
   * 				if vec.x ~= 0
   * 				and vec.z ~= 0 then
   * 
   * 					yaw = atan(vec.z / vec.x) + 3 * pi / 2 - self.rotate
   * 
   * 					if lp.x > s.x then
   * 						yaw = yaw + pi
   * 					end
   * 
   * 					self.object:setyaw(yaw)
   * 				end
   * 
   * 			-- otherwise randomly turn
   * 			elseif math.random(1, 100) <= 30 then
   * 
   * 				yaw = (math.random(0, 360) - 180) / 180 * pi
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			-- stand for great fall in front
   * 			local temp_is_cliff = is_at_cliff(self)
   * 
   * 			-- jump when walking comes to a halt
   * 			if temp_is_cliff == false
   * 			and self.jump
   * 			and get_velocity(self) <= 0.5
   * 			and self.object:getvelocity().y == 0 then
   * 
   * 				do_jump(self)
   * 			end
   * 
   * 			if temp_is_cliff
   * 			or math.random(1, 100) <= 30 then
   * 
   * 				set_velocity(self, 0)
   * 				self.state = "stand"
   * 				set_animation(self, "stand")
   * 			else
   * 				set_velocity(self, self.walk_velocity)
   * 				set_animation(self, "walk")
   * 			end
   * 
   * 		-- runaway when punched
   * 		elseif self.state == "runaway" then
   * 
   * 			self.runaway_timer = self.runaway_timer + 1
   * 
   * 			-- stop after 3 seconds or when at cliff
   * 			if self.runaway_timer > 3
   * 			or is_at_cliff(self) then
   * 				self.runaway_timer = 0
   * 				set_velocity(self, 0)
   * 				self.state = "stand"
   * 				set_animation(self, "stand")
   * 			else
   * 				set_velocity(self, self.run_velocity)
   * 				set_animation(self, "walk")
   * 			end
   * 
   * 			-- jump when walking comes to a halt
   * 			if self.jump
   * 			and get_velocity(self) <= 0.5
   * 			and self.object:getvelocity().y == 0 then
   * 
   * 				do_jump(self)
   * 			end
   * 
   * 		-- attack routines (explode, dogfight, shoot, dogshoot)
   * 		elseif self.state == "attack" then
   * 
   * 		-- calculate distance from mob and enemy
   * 		local s = self.object:getpos()
   * 		local p = self.attack:getpos() or s
   * 		local dist = get_distance(p, s)
   * 
   * 		-- stop attacking if player or out of range
   * 		if dist > self.view_range
   * 		or not self.attack
   * 		or not self.attack:getpos()
   * 		or self.attack:get_hp() <= 0 then
   * 
   * 			--print(" ** stop attacking **", dist, self.view_range)
   * 			self.state = "stand"
   * 			set_velocity(self, 0)
   * 			set_animation(self, "stand")
   * 			self.attack = nil
   * 			self.v_start = false
   * 			self.timer = 0
   * 			self.blinktimer = 0
   * 
   * 			return
   * 		end
   * 
   * 		if self.attack_type == "explode" then
   * 
   * 			local vec = {
   * 				x = p.x - s.x,
   * 				y = p.y - s.y,
   * 				z = p.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				yaw = atan(vec.z / vec.x) + pi / 2 - self.rotate
   * 
   * 				if p.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			if dist > self.reach then
   * 
   * 				if not self.v_start then
   * 
   * 					self.v_start = true
   * 					set_velocity(self, self.run_velocity)
   * 					self.timer = 0
   * 					self.blinktimer = 0
   * 				else
   * 					self.timer = 0
   * 					self.blinktimer = 0
   * 
   * 					if get_velocity(self) <= 0.5
   * 					and self.object:getvelocity().y == 0 then
   * 
   * 						local v = self.object:getvelocity()
   * 						v.y = 5
   * 						self.object:setvelocity(v)
   * 					end
   * 
   * 					set_velocity(self, self.run_velocity)
   * 				end
   * 
   * 				set_animation(self, "run")
   * 			else
   * 				set_velocity(self, 0)
   * 
   * 				--NSSM additions:
   * 				set_animation(self, "punch")
   * 				--end of NSSM additions
   * 
   * 				self.timer = self.timer + dtime
   * 				self.blinktimer = (self.blinktimer or 0) + dtime
   * 
   * 				if self.blinktimer > 0.2 then
   * 
   * 					self.blinktimer = 0
   * 
   * 					if self.blinkstatus then
   * 						self.object:settexturemod("")
   * 					else
   * 						self.object:settexturemod("^[brighten")
   * 					end
   * 
   * 					self.blinkstatus = not self.blinkstatus
   * 				end
   * 
   * 				if self.timer > 3 then
   * 
   * 					local pos = self.object:getpos()
   * 					local radius = self.explosion_radius or 1
   * 
   * 					-- hurt player/nssm caught in blast area
   * 					--entity_physics(pos, radius)		--NSSM modification (the damage function is part of the explosion one now)
   * 
   * 					-- dont damage anything if area protected or next to water
   * 					if minetest.find_node_near(pos, 1, {"group:water"})
   * 					or minetest.is_protected(pos, "") then
   * 
   * 						if self.sounds.explode then
   * 
   * 							minetest.sound_play(self.sounds.explode, {
   * 								object = self.object,
   * 								gain = 1.0,
   * 								max_hear_distance = 16
   * 							})
   * 						end
   * 
   * 						self.object:remove()
   * 
   * 						effect(pos, 15, "tnt_smoke.png", 5)
   * 
   * 						return
   * 					end
   * 
   * 					pos.y = pos.y - 1
   * 
   * 					--NSSM modifications:
   * 
   * 					if self.explosion_radius==0 then
   * 						nssm:explosion(pos, 5, 0, 1, self.sounds.explode)
   * 					else
   * 						nssm:explosion(pos, self.explosion_radius, 0, 1, self.sounds.explode)
   * 					end
   * 
   * 					--end of NSSM modifications
   * 
   * 					self.object:remove()
   * 
   * 					return
   * 				end
   * 			end
   * 
   * 		elseif self.attack_type == "dogfight"
   * 		or (self.attack_type == "dogshoot" and dist <= self.reach)
   * 		or (self.attack_type == "dogshoot" and self.dogshoot_stop and self.direct_hit)		--NSSM addition
   * 		then
   * 
   * 			if self.fly
   * 			and dist > self.reach then
   * 
   * 				local nod = node_ok(s)
   * 				local p1 = s
   * 				local me_y = math.floor(p1.y)
   * 				local p2 = p
   * 				local p_y = math.floor(p2.y + 1)
   * 				local v = self.object:getvelocity()
   * 
   * 				if nod.name == self.fly_in then
   * 
   * 					if me_y < p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = 1 * self.walk_velocity,
   * 							z = v.z
   * 						})
   * 
   * 					elseif me_y > p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = -1 * self.walk_velocity,
   * 							z = v.z
   * 						})
   * 					end
   * 				else
   * 					if me_y < p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = 0.01,
   * 							z = v.z
   * 						})
   * 
   * 					elseif me_y > p_y then
   * 
   * 						self.object:setvelocity({
   * 							x = v.x,
   * 							y = -0.01,
   * 							z = v.z
   * 						})
   * 					end
   * 				end
   * 
   * 			end
   * 
   * 			-- rnd: new movement direction
   * 			if self.path.following
   * 			and self.path.way
   * 			and self.attack_type ~= "dogshoot" then
   * 
   * 				-- no paths longer than 50
   * 				if #self.path.way > 50
   * 				or dist < self.reach then
   * 					self.path.following = false
   * 					return
   * 				end
   * 
   * 				local p1 = self.path.way[1]
   * 
   * 				if not p1 then
   * 					self.path.following = false
   * 					return
   * 				end
   * 
   * 				if math.abs(p1.x-s.x) + math.abs(p1.z - s.z) < 0.6 then
   * 					-- reached waypoint, remove it from queue
   * 					table.remove(self.path.way, 1)
   * 				end
   * 
   * 				-- set new temporary target
   * 				p = {x = p1.x, y = p1.y, z = p1.z}
   * 			end
   * 
   * 			local vec = {
   * 				x = p.x - s.x,
   * 				y = p.y - s.y,
   * 				z = p.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 				if p.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			-- move towards enemy if beyond mob reach
   * 			if dist > self.reach then
   * 
   * 				-- path finding by rnd
   * 				if self.pathfinding -- only if mob has pathfinding enabled
   * 				and enable_pathfinding then
   * 
   * 					smart_nssm(self, s, p, dist, dtime)
   * 				end
   * 
   * 				-- jump attack
   * 				if (self.jump
   * 				and get_velocity(self) <= 0.5
   * 				and self.object:getvelocity().y == 0)
   * 				or (self.object:getvelocity().y == 0
   * 				and self.jump_chance > 0) then
   * 
   * 					do_jump(self)
   * 				end
   * 
   * 				if is_at_cliff(self) then
   * 
   * 					set_velocity(self, 0)
   * 					set_animation(self, "stand")
   * 				else
   * 
   * 					if self.path.stuck then
   * 						set_velocity(self, self.walk_velocity)
   * 					else
   * 						set_velocity(self, self.run_velocity)
   * 					end
   * 
   * 					set_animation(self, "run")
   * 				end
   * 
   * 			else -- rnd: if inside reach range
   * 
   * 				self.path.stuck = false
   * 				self.path.stuck_timer = 0
   * 				self.path.following = false -- not stuck anymore
   * 
   * 				set_velocity(self, 0)
   * 
   * 				--NSSM modifications:
   * 				--modifications to add multiple melee attack animations
   * 				--ATTACK ANIMATIONS:
   * 				if self.mele_number>1 then
   *         			if randattack==1 then
   * 						set_animation(self, "punch")
   * 					else
   * 						local attack = "punch"..(randattack-1)
   *             			set_animation(self, attack)
   *           			end
   * 				else
   * 					set_animation(self, "punch")
   * 				end
   * 
   * 				--modifications to add special attacks to some monster:
   * 				if not def.custom_attack then
   * 
   * 					if self.timer > 1 then
   * 
   * 						self.timer = 0
   * 
   * 						local p2 = p
   * 						local s2 = s
   * 
   * 						p2.y = p2.y + 1.5
   * 						s2.y = s2.y + 1.5
   * 
   * 						if line_of_sight_water(self,p2,s2,1) then
   * 
   * 							-- play attack sound
   * 							if self.sounds.attack then
   * 
   * 								minetest.sound_play(self.sounds.attack, {
   * 									object = self.object,
   * 									max_hear_distance = self.sounds.distance
   * 								})
   * 							end
   * 
   * 							-- punch player
   * 							self.attack:punch(self.object, 1.0, {
   * 								full_punch_interval = 1.0,
   * 								damage_groups = {fleshy = self.damage}
   * 							}, nil)
   * 
   * 							--NSSM Modifications for dogshoot nssm
   * 							if (self.dogshoot_stop) then
   * 								self.num_mele_attacks=self.num_mele_attacks+1
   * 								--minetest.chat_send_all("num_mele_attacks= "..self.num_mele_attacks)
   * 								if (self.num_mele_attacks>3) then
   * 									self.num_sons=0
   * 									self.num_mele_attacks=0
   * 									self.direct_hit=false
   * 								end
   * 							end
   * 							--end of modifications for dogshoot nssm
   * 						end
   * 					end
   * 
   * 					--some additions: special melee attacks
   * 				else
   * 					if def.custom_attack then
   * 						def.custom_attack(self)
   * 					end
   * 				end
   * 			end
   * 
   * 		--end of NSSM modifications
   * 
   * 		elseif self.attack_type == "shoot"
   * 		or (self.attack_type == "dogshoot" and dist > self.reach and not self.dogshoot_stop)	--NSSM modification
   * 		or (self.attack_type == "dogshoot" and self.dogshoot_stop and not self.direct_hit)		--NSSM addition
   * 		then
   * 
   * 			p.y = p.y - .5
   * 			s.y = s.y + .5
   * 
   * 			local dist = get_distance(p, s)
   * 			local vec = {
   * 				x = p.x - s.x,
   * 				y = p.y - s.y,
   * 				z = p.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				yaw = (atan(vec.z / vec.x) + pi / 2) - self.rotate
   * 
   * 				if p.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			set_velocity(self, 0)
   * 
   * 			if self.shoot_interval
   * 			and self.timer > self.shoot_interval
   * 			and math.random(1, 100) <= 60 then
   * 
   * 				self.timer = 0
   * 				set_animation(self, "dattack")					--NSSM modification
   * 
   * 				-- play shoot attack sound
   * 				if self.sounds.shoot_attack then
   * 
   * 					minetest.sound_play(self.sounds.shoot_attack, {
   * 						object = self.object,
   * 						max_hear_distance = self.sounds.distance
   * 					})
   * 				end
   * 
   * 				if not self.true_dist_attack then			--NSSM addition
   * 					local p = self.object:getpos()
   * 
   * 					p.y = p.y + (self.collisionbox[2] + self.collisionbox[5]) / 2
   * 
   * 					local obj = minetest.add_entity(p, self.arrow)
   * 					local ent = obj:get_luaentity()
   * 					local amount = (vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) ^ 0.5
   * 					local v = ent.velocity
   * 					ent.switch = 1
   * 
   * 					--NSSM additions:
   * 
   * 					if (self.dogshoot_stop) then
   * 						self.num_sons=self.num_sons+1
   * 						--minetest.chat_send_all("num_sons="..self.num_sons)
   * 						if (self.num_sons>2) then
   * 							self.direct_hit=true
   * 						end
   * 					end
   * 
   * 					--end of NSSM additions
   * 
   * 					 -- offset makes shoot aim accurate
   * 					vec.y = vec.y + self.shoot_offset
   * 					vec.x = vec.x * v / amount
   * 					vec.y = vec.y * v / amount
   * 					vec.z = vec.z * v / amount
   * 
   * 					obj:setvelocity(vec)
   * 
   * 					--NSSM additions:
   * 
   * 				else
   * 					if math.random(1,100)<=50 then
   * 						self.on_dist_attack(self, self.attack)
   * 						if (self.dogshoot_stop) then
   * 							self.num_sons=self.num_sons+1
   * 							--minetest.chat_send_all("num_sons="..self.num_sons)
   * 							if (self.num_sons>2) then
   * 								self.direct_hit=true
   * 							end
   * 						end
   * 					end
   * 				end
   * 
   * 				--end of NSSM additions
   * 
   * 			end
   * 		end
   * 
   * 		end -- END if self.state == "attack"
   * 
   * 		--NSSM additions:
   * 
   * 		--larva and mantis
   * 		if self.metamorphosis == true then
   * 			if os.time() - self.metatimer >20 then
   * 				minetest.log("action",
   * 					"metatimer expired, metamorphosis! ")
   * 				local pos=self.object:getpos()
   * 				self.object:remove()
   * 				minetest.add_particlespawner(
   * 					200, --amount
   * 					0.1, --time
   * 					{x=pos.x-1, y=pos.y-1, z=pos.z-1}, --minpos
   * 					{x=pos.x+1, y=pos.y+1, z=pos.z+1}, --maxpos
   * 					{x=-0, y=-0, z=-0}, --minvel
   * 					{x=1, y=1, z=1}, --maxvel
   * 					{x=-0.5,y=5,z=-0.5}, --minacc
   * 					{x=0.5,y=5,z=0.5}, --maxacc
   * 					0.1, --minexptime
   * 					1, --maxexptime
   * 					3, --minsize
   * 					4, --maxsize
   * 					false, --collisiondetection
   * 					"tnt_smoke.png" --texture
   * 				)
   * 				if math.random(1,2)==1 then
   * 					minetest.add_entity(pos, "nssm:mantis")
   * 				else
   * 					minetest.add_entity(pos, "nssm:mantis_beast")
   * 				end
   * 
   * 				return
   * 			end
   * 		end
   * 
   * 		--ens of NSSM additions
   * 
   * 	end,
   * 
   * 	on_punch = function(self, hitter, tflp, tool_capabilities, dir)
   * 
   * 		-- direction error check
   * 		dir = dir or {x = 0, y = 0, z = 0}
   * 
   * 		-- weapon wear
   * 		local weapon = hitter:get_wielded_item()
   * 		local punch_interval = 1.4
   * 
   * 		-- calculate mob damage
   * 		local damage = 0
   * 		local armor = self.object:get_armor_groups() or {}
   * 		local tmp
   * 
   *         -- added by MrCerealGuy 2016-04-14, if tool_capabilities is nil, then set default values (see default/tools.lua)
   *         if tool_capabilities == nil then
   *             tool_capabilities = {
   * 		        full_punch_interval = 0.9,
   * 		        max_drop_level = 0,
   * 		        groupcaps = {
   * 			        crumbly = {times={[2]=3.00, [3]=0.70}, uses=0, maxlevel=1},
   * 			        snappy = {times={[3]=0.40}, uses=0, maxlevel=1},
   * 			        oddly_breakable_by_hand = {times={[1]=3.50,[2]=2.00,[3]=0.70}, uses=0}
   * 		        },
   * 		        damage_groups = {fleshy=1},
   * 	        } 
   *         end
   * 
   *         if tflp == nil then
   *             tflp = 1
   *         end
   *         
   * 	    for group,_ in pairs(tool_capabilities.damage_groups) do
   * 
   * 		    tmp = tflp / tool_capabilities.full_punch_interval
   * 
   * 		    if tmp < 0 then
   * 			    tmp = 0.0
   * 		    elseif tmp > 1 then
   * 			        tmp = 1.0
   * 		    end
   * 
   * 		    damage = damage + (tool_capabilities.damage_groups[group] or 0)
   * 			    * tmp * ((armor[group] or 0) / 100.0)
   * 	    end
   * 
   * 
   * 		-- check for tool immunity or special damage
   * 		for _, no in pairs(self.immune_to) do
   * 
   * 			if no[1] == weapon:get_name() then
   * 				damage = no[2] or 0
   * 				break
   * 			end
   * 		end
   * 
   * 		-- print ("Mob Damage is", damage)
   * 
   * 		-- add weapon wear
   * 		if tool_capabilities then
   * 			punch_interval = tool_capabilities.full_punch_interval or 1.4
   * 		end
   * 
   * 		if weapon:get_definition()
   * 		and weapon:get_definition().tool_capabilities then
   * 
   * 			weapon:add_wear(math.floor((punch_interval / 75) * 9000))
   * 			hitter:set_wielded_item(weapon)
   * 		end
   * 
   * 		-- weapon sounds
   * 		if weapon:get_definition().sounds ~= nil then
   * 
   * 			local s = math.random(0, #weapon:get_definition().sounds)
   * 
   * 			minetest.sound_play(weapon:get_definition().sounds[s], {
   * 				object = hitter,
   * 				max_hear_distance = 8
   * 			})
   * 		else
   * 			minetest.sound_play("default_punch", {
   * 				object = hitter,
   * 				max_hear_distance = 5
   * 			})
   * 		end
   * 
   * 		-- do damage
   * 		self.health = self.health - math.floor(damage)
   * 
   * 		-- exit here if dead
   * 		if check_for_death(self) then
   * 			return
   * 		end
   * 
   * 		-- add healthy afterglow when hit
   * 		core.after(0.1, function()
   * 			self.object:settexturemod("^[colorize:#c9900070")
   * 
   * 			core.after(0.3, function()
   * 				self.object:settexturemod("")
   * 			end)
   * 		end)
   * 
   * 		-- blood_particles
   * 		if self.blood_amount > 0
   * 		and not disable_blood then
   * 
   * 			local pos = self.object:getpos()
   * 
   * 			pos.y = pos.y + (-self.collisionbox[2] + self.collisionbox[5]) / 2
   * 
   * 			effect(pos, self.blood_amount, self.blood_texture)
   * 		end
   * 
   * 		-- knock back effect (only on full punch)
   * 		if self.knock_back > 0
   * 		and tflp > punch_interval then
   * 
   * 			local v = self.object:getvelocity()
   * 			local r = 1.4 - math.min(punch_interval, 1.4)
   * 			local kb = r * 5
   * 			local up = 2
   * 
   * 			-- if already in air then dont go up anymore when hit
   * 			if v.y > 0
   * 			or self.fly then
   * 				up = 0
   * 			end
   * 
   * 			self.object:setvelocity({
   * 				x = dir.x * kb,
   * 				y = up,
   * 				z = dir.z * kb
   * 			})
   * 
   * 			self.pause_timer = r
   * 		end
   * 
   * 		-- if skittish then run away
   * 		if self.runaway == true then
   * 
   * 			local lp = hitter:getpos()
   * 			local s = self.object:getpos()
   * 
   * 			local vec = {
   * 				x = lp.x - s.x,
   * 				y = lp.y - s.y,
   * 				z = lp.z - s.z
   * 			}
   * 
   * 			if vec.x ~= 0
   * 			and vec.z ~= 0 then
   * 
   * 				local yaw = atan(vec.z / vec.x) + 3 * pi / 2 - self.rotate
   * 
   * 				if lp.x > s.x then
   * 					yaw = yaw + pi
   * 				end
   * 
   * 				self.object:setyaw(yaw)
   * 			end
   * 
   * 			self.state = "runaway"
   * 			self.runaway_timer = 0
   * 			self.following = nil
   * 		end
   * 
   * 		-- attack puncher and call other nssm for help
   * 		if self.passive == false
   * 		and self.state ~= "flop"
   * 		and self.child == false
   * 		and hitter:get_player_name() ~= self.owner then
   * 
   * 			-- attack whoever punched mob
   * 			self.state = ""
   * 			do_attack(self, hitter)
   * 
   * 			-- alert others to the attack
   * 			local obj = nil
   * 
   * 			for _, oir in pairs(minetest.get_objects_inside_radius(hitter:getpos(), 5)) do
   * 
   * 				obj = oir:get_luaentity()
   * 
   * 				if obj then
   * 
   * 					if obj.group_attack == true
   * 					and obj.state ~= "attack" then
   * 						do_attack(obj, hitter)
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end,
   * 
   * 	on_activate = function(self, staticdata, dtime_s)
   * 
   * 		-- remove monsters in peaceful mode, or when no data
   * 		if (self.type == "monster" and peaceful_only)
   * 		or not staticdata then
   * 
   * 			self.object:remove()
   * 
   * 			return
   * 		end
   * 
   * 		-- load entity variables
   * 		local tmp = minetest.deserialize(staticdata)
   * 
   * 		if tmp then
   * 
   * 			for _,stat in pairs(tmp) do
   * 				self[_] = stat
   * 			end
   * 		end
   * 
   * 		-- select random texture, set model and size
   * 		if not self.base_texture then
   * 
   * 			self.base_texture = def.textures[math.random(1, #def.textures)]
   * 			self.base_mesh = def.mesh
   * 			self.base_size = self.visual_size
   * 			self.base_colbox = self.collisionbox
   * 		end
   * 
   * 		--NSSM addition, random melee attack:
   * 		if self.mele_number>1 then
   *     	randattack=math.random(1,self.mele_number)
   *     end
   * 
   * 		--end of NSSM additions
   * 
   * 		-- set texture, model and size
   * 		local textures = self.base_texture
   * 		local mesh = self.base_mesh
   * 		local vis_size = self.base_size
   * 		local colbox = self.base_colbox
   * 
   * 		-- specific texture if gotten
   * 		if self.gotten == true
   * 		and def.gotten_texture then
   * 			textures = def.gotten_texture
   * 		end
   * 
   * 		-- specific mesh if gotten
   * 		if self.gotten == true
   * 		and def.gotten_mesh then
   * 			mesh = def.gotten_mesh
   * 		end
   * 
   * 		-- set child objects to half size
   * 		if self.child == true then
   * 
   * 			vis_size = {
   * 				x = self.base_size.x / 2,
   * 				y = self.base_size.y / 2
   * 			}
   * 
   * 			if def.child_texture then
   * 				textures = def.child_texture[1]
   * 			end
   * 
   * 			colbox = {
   * 				self.base_colbox[1] / 2,
   * 				self.base_colbox[2] / 2,
   * 				self.base_colbox[3] / 2,
   * 				self.base_colbox[4] / 2,
   * 				self.base_colbox[5] / 2,
   * 				self.base_colbox[6] / 2
   * 			}
   * 		end
   * 
   * 		if self.health == 0 then
   * 			self.health = math.random(self.hp_min, self.hp_max)
   * 		end
   * 
   * 		-- rnd: pathfinding init
   * 		self.path = {}
   * 		self.path.way = {} -- path to follow, table of positions
   * 		self.path.lastpos = {x = 0, y = 0, z = 0}
   * 		self.path.stuck = false
   * 		self.path.following = false -- currently following path?
   * 		self.path.stuck_timer = 0 -- if stuck for too long search for path
   * 		-- end init
   * 
   * 		self.object:set_armor_groups({immortal = 1, fleshy = self.armor})
   * 		self.old_y = self.object:getpos().y
   * 		self.old_health = self.health
   * 		self.object:setyaw((math.random(0, 360) - 180) / 180 * pi)
   * 		self.sounds.distance = self.sounds.distance or 10
   * 		self.textures = textures
   * 		self.mesh = mesh
   * 		self.collisionbox = colbox
   * 		self.visual_size = vis_size
   * 		self.standing_in = ""
   * 
   * 		-- set anything changed above
   * 		self.object:set_properties(self)
   * 		update_tag(self)
   * 	end,
   * 
   * 	get_staticdata = function(self)
   * 
   * 		-- remove mob when out of range unless tamed
   * 		if remove_far
   * 		and self.remove_ok
   * 		and not self.tamed then
   * 
   * 			--print ("REMOVED " .. self.name)
   * 
   * 			self.object:remove()
   * 
   * 			return nil
   * 		end
   * 
   * 		self.remove_ok = true
   * 		self.attack = nil
   * 		self.following = nil
   * 		self.state = "stand"
   * 
   * 		-- used to rotate older nssm
   * 		if self.drawtype
   * 		and self.drawtype == "side" then
   * 			self.rotate = math.rad(90)
   * 		end
   * 
   * 		local tmp = {}
   * 
   * 		for _,stat in pairs(self) do
   * 
   * 			local t = type(stat)
   * 
   * 			if  t ~= 'function'
   * 			and t ~= 'nil'
   * 			and t ~= 'userdata' then
   * 				tmp[_] = self[_]
   * 			end
   * 		end
   * 
   * 		-- print('===== '..self.name..'\n'.. dump(tmp)..'\n=====\n')
   * 		return minetest.serialize(tmp)
   * 	end,
   * 
   * })
   * 
   * end */
  lua_pushvalue(L,(lc192 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_register_mob,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_mob");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- END nssm:register_mob function
   * -- global functions
   * nssm.spawning_nssm = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"spawning_nssm");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* function nssm:spawn_specific(name, nodes, neighbors, min_light, max_light,
   * 	interval, chance, active_object_count, min_height, max_height, day_toggle)
   * 
   * 	nssm.spawning_nssm[name] = true
   * 
   * 	-- chance override in stonecraft.conf for registered mob
   * 	local new_chance = tonumber(minetest.setting_get(name .. "_chance"))
   * 
   * 	if new_chance ~= nil then
   * 
   * 		if new_chance == 0 then
   * 			print("[nssm Redo] " .. name .. " has spawning disabled")
   * 			return
   * 		end
   * 
   * 		chance = new_chance
   * 
   * 		print ("[nssm Redo] Chance setting for " .. name .. " is now " .. chance)
   * 
   * 	end
   * 
   * 	minetest.register_abm({
   * 
   * 		nodenames = nodes,
   * 		neighbors = neighbors,
   * 		interval = interval,
   * 		chance = chance,
   * 
   * 		action = function(pos, node, _, active_object_count_wider)
   * 
   * 			-- do not spawn if too many active entities in area
   * 			if active_object_count_wider > active_object_count
   * 			or not nssm.spawning_nssm[name] then
   * 				return
   * 			end
   * 
   * 			-- if toggle set to nil then ignore day/night check
   * 			if day_toggle ~= nil then
   * 
   * 				local tod = (minetest.get_timeofday() or 0) * 24000
   * 
   * 				if tod > 4500 and tod < 19500 then
   * 					-- daylight, but mob wants night
   * 					if day_toggle == false then
   * 						return
   * 					end
   * 				else
   * 					-- night time but mob wants day
   * 					if day_toggle == true then
   * 						return
   * 					end
   * 				end
   * 			end
   * 
   * 			-- spawn above node
   * 			pos.y = pos.y + 1
   * 
   * 			-- only spawn away from player
   * 			local objs = minetest.get_objects_inside_radius(pos, 10)
   * 
   * 			for _,oir in pairs(objs) do
   * 
   * 				if oir:is_player() then
   * 					return
   * 				end
   * 			end
   * 
   * 			-- nssm cannot spawn in protected areas when enabled
   * 			if spawn_protected == 1
   * 			and minetest.is_protected(pos, "") then
   * 				return
   * 			end
   * 
   * 			-- check if light and height levels are ok to spawn
   * 			local light = minetest.get_node_light(pos)
   * 			if not light
   * 			or light > max_light
   * 			or light < min_light
   * 			or pos.y > max_height
   * 			or pos.y < min_height then
   * 				return
   * 			end
   * 
   * 			-- are we spawning inside solid nodes?
   * 			if minetest.registered_nodes[node_ok(pos).name].walkable == true then
   * 				return
   * 			end
   * 
   * 			pos.y = pos.y + 1
   * 
   * 			if minetest.registered_nodes[node_ok(pos).name].walkable == true then
   * 				return
   * 			end
   * 
   * 			-- spawn mob half block higher than ground
   * 			pos.y = pos.y - 0.5
   * 
   * 			local mob = minetest.add_entity(pos, name)
   * 
   * 			if mob and mob:get_luaentity() then
   * --				print ("[nssm] Spawned " .. name .. " at "
   * --				.. minetest.pos_to_string(pos) .. " on "
   * --				.. node.name .. " near " .. neighbors[1])
   * 			else
   * 				print ("[nssm]" .. name .. " failed to spawn at "
   * 				.. minetest.pos_to_string(pos))
   * 			end
   * 
   * 		end
   * 	})
   * end */
  lua_pushvalue(L,(lc192 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_spawn_specific,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"spawn_specific");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- compatibility with older mob registration
   * function nssm:register_spawn(name, nodes, max_light, min_light, chance, active_object_count, max_height, day_toggle)
   * 
   * 	nssm:spawn_specific(name, nodes, {"air"}, min_light, max_light, 30,
   * 		chance, active_object_count, -31000, max_height, day_toggle)
   * end */
  lua_pushcfunction(L,lcf1_nssm_register_spawn);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_spawn");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- set content id's
   * local c_air = minetest.get_content_id("air") */
  lc_newclosuretable(L,(lc192 + lc_nextra));
  enum { lc819 = 18 };
  assert((lua_gettop(L) == (lc819 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  lua_rawseti(L,(lc819 + lc_nextra),29);
  assert(lua_gettop(L) - lc_nextra == 18);
  
  /* local c_ignore = minetest.get_content_id("ignore") */
  lc_newclosuretable(L,(lc819 + lc_nextra));
  enum { lc820 = 19 };
  assert((lua_gettop(L) == (lc820 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ignore");
  lua_call(L,1,1);
  lua_rawseti(L,(lc820 + lc_nextra),30);
  assert(lua_gettop(L) - lc_nextra == 19);
  
  /* local c_obsidian = minetest.get_content_id("default:obsidian") */
  lc_newclosuretable(L,(lc820 + lc_nextra));
  enum { lc821 = 20 };
  assert((lua_gettop(L) == (lc821 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:obsidian");
  lua_call(L,1,1);
  lua_rawseti(L,(lc821 + lc_nextra),31);
  assert(lua_gettop(L) - lc_nextra == 20);
  
  /* local c_brick = minetest.get_content_id("default:obsidianbrick") */
  lc_newclosuretable(L,(lc821 + lc_nextra));
  enum { lc822 = 21 };
  assert((lua_gettop(L) == (lc822 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:obsidianbrick");
  lua_call(L,1,1);
  lua_rawseti(L,(lc822 + lc_nextra),32);
  assert(lua_gettop(L) - lc_nextra == 21);
  
  /* local c_chest = minetest.get_content_id("default:chest_locked") */
  lc_newclosuretable(L,(lc822 + lc_nextra));
  enum { lc823 = 22 };
  assert((lua_gettop(L) == (lc823 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:chest_locked");
  lua_call(L,1,1);
  lua_rawseti(L,(lc823 + lc_nextra),33);
  assert(lua_gettop(L) - lc_nextra == 22);
  
  /* -- buffer for vm:get_data, added by MrCerealGuy
   * local dbuf = {} */
  lc_newclosuretable(L,(lc823 + lc_nextra));
  enum { lc824 = 23 };
  assert((lua_gettop(L) == (lc824 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc824 + lc_nextra),34);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* -- explosion (cannot break protected or unbreakable nodes)
   * function nssm:explosion(pos, radius, fire, smoke, sound)
   * 
   * 	radius = radius or 0
   * 	fire = fire or 0
   * 	smoke = smoke or 0
   * 
   * 	-- if area protected or near map limits then no blast damage
   * 	if minetest.is_protected(pos, "")
   * 	or not within_limits(pos, radius) then
   * 		return
   * 	end
   * 
   * 	-- explosion sound
   * 	if sound
   * 	and sound ~= "" then
   * 
   * 		minetest.sound_play(sound, {
   * 			pos = pos,
   * 			gain = 1.0,
   * 			max_hear_distance = 16
   * 		})
   * 	end
   * 
   * 	pos = vector.round(pos) -- voxelmanip doesn't work properly unless pos is rounded ?!?!
   * 
   * 	local vm = VoxelManip()
   * 	local minp, maxp = vm:read_from_map(vector.subtract(pos, radius), vector.add(pos, radius))
   * 	local a = VoxelArea:new({MinEdge = minp, MaxEdge = maxp})
   * 	local data = vm:get_data(dbuf)	-- buffer added by MrCerealGuy
   * 	local p = {}
   * 	local pr = PseudoRandom(os.time())
   * 
   * 	for z = -radius, radius do
   * 	for y = -radius, radius do
   * 	local vi = a:index(pos.x + (-radius), pos.y + y, pos.z + z)
   * 	for x = -radius, radius do
   * 
   * 		p.x = pos.x + x
   * 		p.y = pos.y + y
   * 		p.z = pos.z + z
   * 
   * 		if (x * x) + (y * y) + (z * z) <= (radius * radius) + pr:next(-radius, radius)
   * 		and data[vi] ~= c_air
   * 		and data[vi] ~= c_ignore
   * 		and data[vi] ~= c_obsidian
   * 		and data[vi] ~= c_brick
   * 		and data[vi] ~= c_chest then
   * 
   * 			local n = node_ok(p).name
   * 			local on_blast = minetest.registered_nodes[n].on_blast
   * 
   * 			if on_blast then
   * 				return on_blast(p)
   * 			end
   * 
   * 			if minetest.get_item_group(n, "unbreakable") ~= 1 then
   * 
   * 				-- if chest then drop items inside
   * 				if n == "default:chest"
   * 				or n == "3dchest:chest"
   * 				or n == "bones:bones" then
   * 
   * 					local meta = minetest.get_meta(p)
   * 					local inv  = meta:get_inventory()
   * 
   * 					for i = 1, inv:get_size("main") do
   * 
   * 						local m_stack = inv:get_stack("main", i)
   * 						local obj = minetest.add_item(p, m_stack)
   * 
   * 						if obj then
   * 
   * 							obj:setvelocity({
   * 								x = math.random(-2, 2),
   * 								y = 7,
   * 								z = math.random(-2, 2)
   * 							})
   * 						end
   * 					end
   * 				end
   * 
   * 				-- after effects
   * 				if fire > 0
   * 				and (minetest.registered_nodes[n].groups.flammable
   * 				or math.random(1, 100) <= 30) then
   * 
   * 					minetest.set_node(p, {name = "fire:basic_flame"})
   * 				else
   * 					minetest.set_node(p, {name = "air"})
   * 
   * 					if smoke > 0 then
   * 						effect(p, 2, "tnt_smoke.png", 5)
   * 					end
   * 				end
   * 			end
   * 		end
   * 
   * 		vi = vi + 1
   * 
   * 	end
   * 	end
   * 	end
   * end */
  lua_pushvalue(L,(lc824 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_explosion,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"explosion");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* -- register arrow for shoot attack
   * function nssm:register_arrow(name, def)
   * 
   * 	if not name or not def then return end -- errorcheck
   * 
   * 	minetest.register_entity(name, {
   * 
   * 		physical = false,
   * 		visual = def.visual,
   * 		visual_size = def.visual_size,
   * 		textures = def.textures,
   * 		velocity = def.velocity,
   * 		hit_player = def.hit_player,
   * 		hit_node = def.hit_node,
   * 		hit_mob = def.hit_mob,
   * 		drop = def.drop or false,
   * 		collisionbox = {0, 0, 0, 0, 0, 0}, -- remove box around arrows
   * 		timer = 0,
   * 		switch = 0,
   * 
   * 		on_step = def.on_step or function(self, dtime)		--nssm_modification
   * 
   * 			self.timer = self.timer + 1
   * 
   * 			local pos = self.object:getpos()
   * 
   * 			if self.switch == 0
   * 			or self.timer > 150
   * 			or not within_limits(pos, 0) then
   * 
   * 				self.object:remove() ; -- print ("removed arrow")
   * 
   * 				return
   * 			end
   * 
   * 			if self.hit_node then
   * 
   * 				local node = node_ok(pos).name
   * 
   * 				--if minetest.registered_nodes[node].walkable then
   * 				if node ~= "air" then
   * 
   * 					self.hit_node(self, pos, node)
   * 
   * 					if self.drop == true then
   * 
   * 						pos.y = pos.y + 1
   * 
   * 						self.lastpos = (self.lastpos or pos)
   * 
   * 						minetest.add_item(self.lastpos, self.object:get_luaentity().name)
   * 					end
   * 
   * 					self.object:remove() ; -- print ("hit node")
   * 
   * 					return
   * 				end
   * 			end
   * 
   * 			if (self.hit_player or self.hit_mob)
   * 			-- clear mob entity before arrow becomes active
   * 			and self.timer > (10 - (self.velocity / 2)) then
   * 
   * 				for _,player in pairs(minetest.get_objects_inside_radius(pos, 1.0)) do
   * 
   * 					if self.hit_player
   * 					and player:is_player() then
   * 
   * 						self.hit_player(self, player)
   * 						self.object:remove() ; -- print ("hit player")
   * 						return
   * 					end
   * 
   * 					if self.hit_mob
   * 					and player:get_luaentity()
   * 					and player:get_luaentity().name ~= self.object:get_luaentity().name
   * 					and player:get_luaentity().name ~= "__builtin:item"
   * 					and player:get_luaentity().name ~= "gauges:hp_bar"
   * 					and player:get_luaentity().name ~= "signs:text"
   * 					and player:get_luaentity().name ~= "itemframes:item" then
   * 
   * 						self.hit_mob(self, player)
   * 
   * 						self.object:remove() ; -- print ("hit mob")
   * 
   * 						return
   * 					end
   * 				end
   * 			end
   * 
   * 			self.lastpos = pos
   * 		end
   * 	})
   * end */
  lua_pushvalue(L,(lc824 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_register_arrow,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_arrow");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* -- Spawn Egg
   * function nssm:register_egg(mob, desc, background, addegg)
   * 
   * 	local invimg = background
   * 
   * 	if addegg == 1 then
   * 		invimg = "nssm_chicken_egg.png^(" .. invimg .. "^[mask:nssm_chicken_egg_overlay.png)"
   * 	end
   * 
   * 	minetest.register_craftitem(mob, {
   * 
   * 		description = desc,
   * 		inventory_image = invimg,
   * 
   * 		on_place = function(itemstack, placer, pointed_thing)
   * 
   * 			local pos = pointed_thing.above
   * 
   * 			if pos
   * 			and within_limits(pos, 0)
   * 			and not minetest.is_protected(pos, placer:get_player_name()) then
   * 
   * 				pos.y = pos.y + 1
   * 
   * 				local mob = minetest.add_entity(pos, mob)
   * 				local ent = mob:get_luaentity()
   * 
   * 				if ent.type ~= "monster" then
   * 					-- set owner and tame if not monster
   * 					ent.owner = placer:get_player_name()
   * 					ent.tamed = true
   * 				end
   * 
   * 				-- if not in creative then take item
   * 				if not creative then
   * 					itemstack:take_item()
   * 				end
   * 			end
   * 
   * 			return itemstack
   * 		end,
   * 	})
   * end */
  lua_pushvalue(L,(lc824 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_register_egg,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_egg");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* -- capture critter (thanks to blert2112 for idea)
   * function nssm:capture_mob(self, clicker, chance_hand, chance_net, chance_lasso, force_take, replacewith)
   * 
   * 	if not self.child
   * 	and clicker:is_player()
   * 	and clicker:get_inventory() then
   * 
   * 		-- get name of clicked mob
   * 		local mobname = self.name
   * 
   * 		-- if not nil change what will be added to inventory
   * 		if replacewith then
   * 			mobname = replacewith
   * 		end
   * 
   * 		local name = clicker:get_player_name()
   * 
   * 		-- is mob tamed?
   * 		if self.tamed == false
   * 		and force_take == false then
   * 
   * 			minetest.chat_send_player(name, "Not tamed!")
   * 
   * 			return
   * 		end
   * 
   * 		-- cannot pick up if not owner
   * 		if self.owner ~= name
   * 		and force_take == false then
   * 
   * 			minetest.chat_send_player(name, self.owner.." is owner!")
   * 
   * 			return
   * 		end
   * 
   * 		if clicker:get_inventory():room_for_item("main", mobname) then
   * 
   * 			-- was mob clicked with hand, net, or lasso?
   * 			local tool = clicker:get_wielded_item()
   * 			local chance = 0
   * 
   * 			if tool:is_empty() then
   * 				chance = chance_hand
   * 
   * 			elseif tool:get_name() == "nssm:net" then
   * 
   * 				chance = chance_net
   * 
   * 				tool:add_wear(4000) -- 17 uses
   * 
   * 				clicker:set_wielded_item(tool)
   * 
   * 			elseif tool:get_name() == "nssm:magic_lasso" then
   * 
   * 				chance = chance_lasso
   * 
   * 				tool:add_wear(650) -- 100 uses
   * 
   * 				clicker:set_wielded_item(tool)
   * 			end
   * 
   * 			-- return if no chance
   * 			if chance == 0 then return end
   * 
   * 			-- calculate chance.. add to inventory if successful?
   * 			if math.random(1, 100) <= chance then
   * 
   * 				clicker:get_inventory():add_item("main", mobname)
   * 
   * 				self.object:remove()
   * 			else
   * 				minetest.chat_send_player(name, "Missed!")
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_nssm_capture_mob);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"capture_mob");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* local mob_obj = {} */
  lc_newclosuretable(L,(lc824 + lc_nextra));
  enum { lc943 = 24 };
  assert((lua_gettop(L) == (lc943 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc943 + lc_nextra),36);
  assert(lua_gettop(L) - lc_nextra == 24);
  
  /* local mob_sta = {} */
  lc_newclosuretable(L,(lc943 + lc_nextra));
  enum { lc944 = 25 };
  assert((lua_gettop(L) == (lc944 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc944 + lc_nextra),37);
  assert(lua_gettop(L) - lc_nextra == 25);
  
  /* -- feeding, taming and breeding (thanks blert2112)
   * function nssm:feed_tame(self, clicker, feed_count, breed, tame)
   * 
   * 	if not self.follow then
   * 		return false
   * 	end
   * 
   * 	-- can eat/tame with item in hand
   * 	if follow_holding(self, clicker) then
   * 
   * 		-- if not in creative then take item
   * 		if not creative then
   * 
   * 			local item = clicker:get_wielded_item()
   * 
   * 			item:take_item()
   * 
   * 			clicker:set_wielded_item(item)
   * 		end
   * 
   * 		-- increase health
   * 		self.health = self.health + 4
   * 
   * 		if self.health >= self.hp_max then
   * 
   * 			self.health = self.hp_max
   * 
   * 			if self.htimer < 1 then
   * 
   * 				minetest.chat_send_player(clicker:get_player_name(),
   * 					self.name:split(":")[2]
   * 					.. " at full health (" .. tostring(self.health) .. ")")
   * 
   * 				self.htimer = 5
   * 			end
   * 		end
   * 
   * 		self.object:set_hp(self.health)
   * 
   * 		update_tag(self)
   * 
   * 		-- make children grow quicker
   * 		if self.child == true then
   * 
   * 			self.hornytimer = self.hornytimer + 20
   * 
   * 			return true
   * 		end
   * 
   * 		-- feed and tame
   * 		self.food = (self.food or 0) + 1
   * 		if self.food >= feed_count then
   * 
   * 			self.food = 0
   * 
   * 			if breed and self.hornytimer == 0 then
   * 				self.horny = true
   * 			end
   * 
   * 			self.gotten = false
   * 
   * 			if tame then
   * 
   * 				if self.tamed == false then
   * 					minetest.chat_send_player(clicker:get_player_name(),
   * 						self.name:split(":")[2]
   * 						.. " has been tamed!")
   * 				end
   * 
   * 				self.tamed = true
   * 
   * 				if not self.owner or self.owner == "" then
   * 					self.owner = clicker:get_player_name()
   * 				end
   * 			end
   * 
   * 			-- make sound when fed so many times
   * 			if self.sounds.random then
   * 
   * 				minetest.sound_play(self.sounds.random, {
   * 					object = self.object,
   * 					max_hear_distance = self.sounds.distance
   * 				})
   * 			end
   * 		end
   * 
   * 		return true
   * 	end
   * 
   * 	local item = clicker:get_wielded_item()
   * 
   * 	-- if mob has been tamed you can name it with a nametag
   * 	if item:get_name() == "nssm:nametag"
   * 	and clicker:get_player_name() == self.owner then
   * 
   * 		local name = clicker:get_player_name()
   * 
   * 		-- store mob and nametag stack in external variables
   * 		mob_obj[name] = self
   * 		mob_sta[name] = item
   * 
   * 		local tag = self.nametag or ""
   * 
   * 		local formspec = "size[8,4]"
   * 			.. default.gui_bg
   * 			.. default.gui_bg_img
   * 			.. "field[0.5,1;7.5,0;name;Enter name:;" .. tag .. "]"
   * 			.. "button_exit[2.5,3.5;3,1;mob_rename;Rename]"
   * 			minetest.show_formspec(name, "nssm_nametag", formspec)
   * 	end
   * 
   * 	return false
   * 
   * end */
  lua_pushvalue(L,(lc944 + lc_nextra));
  lua_pushcclosure(L,lcf1_nssm_feed_tame,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"nssm");
  lua_insert(L,-2);
  lua_pushliteral(L,"feed_tame");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 25);
  
  /* -- inspired by blockmen's nametag mod
   * minetest.register_on_player_receive_fields(function(player, formname, fields)
   * 
   * 	-- right-clicked with nametag and name entered?
   * 	if formname == "nssm_nametag"
   * 	and fields.name
   * 	and fields.name ~= "" then
   * 
   * 		local name = player:get_player_name()
   * 
   * 		if not mob_obj[name]
   * 		or not mob_obj[name].object then
   * 			return
   * 		end
   * 
   * 		-- update nametag
   * 		mob_obj[name].nametag = fields.name
   * 
   * 		update_tag(mob_obj[name])
   * 
   * 		-- if not in creative then take item
   * 		if not creative then
   * 
   * 			mob_sta[name]:take_item()
   * 
   * 			player:set_wielded_item(mob_sta[name])
   * 		end
   * 
   * 		-- reset external variables
   * 		mob_obj[name] = nil
   * 		mob_sta[name] = nil
   * 
   * 	end
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_player_receive_fields");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(lc944 + lc_nextra));
  lua_pushcclosure(L,lcf987,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 25);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_nssm_api(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


