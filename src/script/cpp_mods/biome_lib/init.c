/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

#include "cpp_mods/cpp_mods_init.h"

/* function(t,k) */
static int lcf1 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* print("Use of deprecated function:", k) */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"Use of deprecated function:");
  lua_pushvalue(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  
  /* return biome_lib[k] */
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* name: S
 * function(s) */
static int lcf1_S (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* return s */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: biome_lib:dbg
 * function(msg) */
static int lcf1_biome_lib_dbg (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if DEBUG then */
  enum { lc5 = 2 };
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  const int lc6 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc6) {
    
    /* print("[Plantlife] "..msg) */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"[Plantlife] ");
    lua_pushvalue(L,2);
    lua_concat(L,2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 2);
    
    /* minetest.log("verbose", "[Plantlife] "..msg) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"verbose");
    lua_pushliteral(L,"[Plantlife] ");
    lua_pushvalue(L,2);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc5);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* name: biome_lib:is_node_loaded
 * function(node_pos) */
static int lcf1_biome_lib_is_node_loaded (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local n = minetest.get_node_or_nil(node_pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_or_nil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if (not n) or (n.name == "ignore") then */
  enum { lc15 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lua_pushliteral(L,"ignore");
    const int lc16 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc16);
  }
  const int lc17 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc17) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc15);
  assert(lua_gettop(L) == 3);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: biome_lib:set_defaults
 * function(biome) */
static int lcf1_biome_lib_set_defaults (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* biome.seed_diff = biome.seed_diff or 0 */
  lua_pushliteral(L,"seed_diff");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushliteral(L,"seed_diff");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.min_elevation = biome.min_elevation or -31000 */
  lua_pushliteral(L,"min_elevation");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,-31000);
  }
  lua_pushliteral(L,"min_elevation");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.max_elevation = biome.max_elevation or 31000 */
  lua_pushliteral(L,"max_elevation");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,31000);
  }
  lua_pushliteral(L,"max_elevation");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.temp_min = biome.temp_min or 1 */
  lua_pushliteral(L,"temp_min");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_pushliteral(L,"temp_min");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.temp_max = biome.temp_max or -1 */
  lua_pushliteral(L,"temp_max");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,-1);
  }
  lua_pushliteral(L,"temp_max");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.humidity_min = biome.humidity_min or 1 */
  lua_pushliteral(L,"humidity_min");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_pushliteral(L,"humidity_min");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.humidity_max = biome.humidity_max or -1 */
  lua_pushliteral(L,"humidity_max");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,-1);
  }
  lua_pushliteral(L,"humidity_max");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.plantlife_limit = biome.plantlife_limit or 0.1 */
  lua_pushliteral(L,"plantlife_limit");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0.1);
  }
  lua_pushliteral(L,"plantlife_limit");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.near_nodes_vertical = biome.near_nodes_vertical or 1 */
  lua_pushliteral(L,"near_nodes_vertical");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_pushliteral(L,"near_nodes_vertical");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* -- specific to on-generate
   * biome.neighbors = biome.neighbors or biome.surface */
  lua_pushliteral(L,"neighbors");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"surface");
    lua_gettable(L,2);
  }
  lua_pushliteral(L,"neighbors");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.near_nodes_size = biome.near_nodes_size or 0 */
  lua_pushliteral(L,"near_nodes_size");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushliteral(L,"near_nodes_size");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.near_nodes_count = biome.near_nodes_count or 1 */
  lua_pushliteral(L,"near_nodes_count");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_pushliteral(L,"near_nodes_count");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.rarity = biome.rarity or 50 */
  lua_pushliteral(L,"rarity");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,50);
  }
  lua_pushliteral(L,"rarity");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.max_count = biome.max_count or 5 */
  lua_pushliteral(L,"max_count");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,5);
  }
  lua_pushliteral(L,"max_count");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* if biome.check_air ~= false then */
  enum { lc18 = 2 };
  lua_pushliteral(L,"check_air");
  lua_gettable(L,2);
  lua_pushboolean(L,0);
  const int lc19 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc19);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc20 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc20) {
    
    /* biome.check_air = true */
    lua_pushboolean(L,1);
    lua_pushliteral(L,"check_air");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc18);
  assert(lua_gettop(L) == 2);
  
  /* -- specific to abm spawner
   * biome.seed_diff = biome.seed_diff or 0 */
  lua_pushliteral(L,"seed_diff");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushliteral(L,"seed_diff");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.light_min = biome.light_min or 0 */
  lua_pushliteral(L,"light_min");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushliteral(L,"light_min");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.light_max = biome.light_max or 15 */
  lua_pushliteral(L,"light_max");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,15);
  }
  lua_pushliteral(L,"light_max");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.depth_max = biome.depth_max or 1 */
  lua_pushliteral(L,"depth_max");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
  }
  lua_pushliteral(L,"depth_max");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* biome.facedir = biome.facedir or 0 */
  lua_pushliteral(L,"facedir");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushliteral(L,"facedir");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: search_table
 * function(t, s) */
static int lcf1_search_table (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* for i = 1, #t do */
  lua_pushnumber(L,1);
  const double lc25 = lua_objlen(L,1);
  lua_pushnumber(L,lc25);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc22_var = lua_tonumber(L,-2);
  const double lc23_limit = lua_tonumber(L,-1);
  const double lc24_step = 1;
  lua_pop(L,2);
  enum { lc26 = 2 };
  while ((((lc24_step > 0) && (lc22_var <= lc23_limit)) || ((lc24_step <= 0) && (lc22_var >= lc23_limit)))) {
    
    /* internal: local i at index 3 */
    lua_pushnumber(L,lc22_var);
    
    /* if t[i] == s then */
    enum { lc27 = 3 };
    lua_pushvalue(L,3);
    lua_gettable(L,1);
    const int lc28 = lua_equal(L,-1,2);
    lua_pop(L,1);
    lua_pushboolean(L,lc28);
    const int lc29 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc29) {
      
      /* return true */
      lua_pushboolean(L,1);
      return 1;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc27);
    assert(lua_gettop(L) == 3);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc22_var += lc24_step;
  }
  lua_settop(L,lc26);
  assert(lua_gettop(L) == 2);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: biome_lib:register_generate_plant
 * function(biomedef, nodes_or_function_or_model) */
static int lcf1_biome_lib_register_generate_plant (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- if calling code passes an undefined node for a surface or 
   * -- as a node to be spawned, don't register an action for it.
   * if type(nodes_or_function_or_model) == "string"
   * 	  and string.find(nodes_or_function_or_model, ":")
   * 	  and not minetest.registered_nodes[nodes_or_function_or_model] then */
  enum { lc30 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"string");
  const int lc31 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc31);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushliteral(L,":");
    lua_call(L,2,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc32 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc32) {
    
    /* biome_lib:dbg("Warning: Ignored registration for undefined spawn node: "..dump(nodes_or_function_or_model)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"dbg");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"Warning: Ignored registration for undefined spawn node: ");
    lua_getfield(L,LUA_ENVIRONINDEX,"dump");
    lua_pushvalue(L,3);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc30);
  assert(lua_gettop(L) == 3);
  
  /* if type(nodes_or_function_or_model) == "string"
   * 	  and not string.find(nodes_or_function_or_model, ":") then */
  enum { lc33 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"string");
  const int lc34 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc34);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushliteral(L,":");
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc35 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc35) {
    
    /* biome_lib:dbg("Warning: Registered function call using deprecated string method: "..dump(nodes_or_function_or_model)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"dbg");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"Warning: Registered function call using deprecated string method: ");
    lua_getfield(L,LUA_ENVIRONINDEX,"dump");
    lua_pushvalue(L,3);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc33);
  assert(lua_gettop(L) == 3);
  
  /* if biomedef.check_air == false then */
  enum { lc36 = 3 };
  lua_pushliteral(L,"check_air");
  lua_gettable(L,2);
  lua_pushboolean(L,0);
  const int lc37 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc37);
  const int lc38 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc38) {
    
    /* biome_lib:dbg("Register no-air-check mapgen hook: "..dump(nodes_or_function_or_model)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"dbg");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"Register no-air-check mapgen hook: ");
    lua_getfield(L,LUA_ENVIRONINDEX,"dump");
    lua_pushvalue(L,3);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* biome_lib.actionslist_no_aircheck[#biome_lib.actionslist_no_aircheck + 1] = { biomedef, nodes_or_function_or_model } */
    lua_createtable(L,2,0);
    lua_pushvalue(L,2);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,3);
    lua_rawseti(L,-2,2);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"actionslist_no_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"actionslist_no_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc39 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc39);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* local s = biomedef.surface */
    lua_pushliteral(L,"surface");
    lua_gettable(L,2);
    assert(lua_gettop(L) == 4);
    
    /* if type(s) == "string" then */
    enum { lc40 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,4);
    lua_call(L,1,1);
    lua_pushliteral(L,"string");
    const int lc41 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc41);
    const int lc42 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc42) {
      
      /* if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then */
      enum { lc43 = 4 };
      lua_pushvalue(L,4);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"string");
        lua_pushliteral(L,"find");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,4);
        lua_pushliteral(L,"^group:");
        lua_call(L,2,1);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,4);
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
      }
      const int lc44 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc44) {
        
        /* if not search_table(biome_lib.surfaceslist_no_aircheck, s) then */
        enum { lc45 = 4 };
        lc_getupvalue(L,lua_upvalueindex(1),0,6);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surfaceslist_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,4);
        lua_call(L,2,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc46 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc46) {
          
          /* biome_lib.surfaceslist_no_aircheck[#biome_lib.surfaceslist_no_aircheck + 1] = s */
          lua_pushvalue(L,4);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surfaceslist_no_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surfaceslist_no_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const double lc47 = lua_objlen(L,-1);
          lua_pop(L,1);
          lua_pushnumber(L,lc47);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 4);
        }
        lua_settop(L,lc45);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* else
         * biome_lib:dbg("Warning: Ignored no-air-check registration for undefined surface node: "..dump(s)) */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"dbg");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"Warning: Ignored no-air-check registration for undefined surface node: ");
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushvalue(L,4);
        lua_call(L,1,1);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc43);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* else
       * for i = 1, #biomedef.surface do */
      lua_pushnumber(L,1);
      lua_pushliteral(L,"surface");
      lua_gettable(L,2);
      const double lc51 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc51);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc48_var = lua_tonumber(L,-2);
      const double lc49_limit = lua_tonumber(L,-1);
      const double lc50_step = 1;
      lua_pop(L,2);
      enum { lc52 = 4 };
      while ((((lc50_step > 0) && (lc48_var <= lc49_limit)) || ((lc50_step <= 0) && (lc48_var >= lc49_limit)))) {
        
        /* internal: local i at index 5 */
        lua_pushnumber(L,lc48_var);
        
        /* local s = biomedef.surface[i] */
        lua_pushliteral(L,"surface");
        lua_gettable(L,2);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 6);
        
        /* if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then */
        enum { lc53 = 6 };
        lua_pushvalue(L,6);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"string");
          lua_pushliteral(L,"find");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_pushliteral(L,"^group:");
          lua_call(L,2,1);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"registered_nodes");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,6);
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
        }
        const int lc54 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc54) {
          
          /* if not search_table(biome_lib.surfaceslist_no_aircheck, s) then */
          enum { lc55 = 6 };
          lc_getupvalue(L,lua_upvalueindex(1),0,6);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surfaceslist_no_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_call(L,2,1);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc56 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc56) {
            
            /* biome_lib.surfaceslist_no_aircheck[#biome_lib.surfaceslist_no_aircheck + 1] = s */
            lua_pushvalue(L,6);
            lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
            lua_pushliteral(L,"surfaceslist_no_aircheck");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
            lua_pushliteral(L,"surfaceslist_no_aircheck");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            const double lc57 = lua_objlen(L,-1);
            lua_pop(L,1);
            lua_pushnumber(L,lc57);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 6);
          }
          lua_settop(L,lc55);
          assert(lua_gettop(L) == 6);
        }
        else {
          
          /* else
           * biome_lib:dbg("Warning: Ignored no-air-check registration for undefined surface node: "..dump(s)) */
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"dbg");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"Warning: Ignored no-air-check registration for undefined surface node: ");
          lua_getfield(L,LUA_ENVIRONINDEX,"dump");
          lua_pushvalue(L,6);
          lua_call(L,1,1);
          lua_concat(L,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc53);
        assert(lua_gettop(L) == 6);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc48_var += lc50_step;
      }
      lua_settop(L,lc52);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc40);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* else
     * biome_lib:dbg("Register with-air-checking mapgen hook: "..dump(nodes_or_function_or_model)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"dbg");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"Register with-air-checking mapgen hook: ");
    lua_getfield(L,LUA_ENVIRONINDEX,"dump");
    lua_pushvalue(L,3);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* biome_lib.actionslist_aircheck[#biome_lib.actionslist_aircheck + 1] = { biomedef, nodes_or_function_or_model } */
    lua_createtable(L,2,0);
    lua_pushvalue(L,2);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,3);
    lua_rawseti(L,-2,2);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"actionslist_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"actionslist_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc58 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc58);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* local s = biomedef.surface */
    lua_pushliteral(L,"surface");
    lua_gettable(L,2);
    assert(lua_gettop(L) == 4);
    
    /* if type(s) == "string" then */
    enum { lc59 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,4);
    lua_call(L,1,1);
    lua_pushliteral(L,"string");
    const int lc60 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc60);
    const int lc61 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc61) {
      
      /* if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then */
      enum { lc62 = 4 };
      lua_pushvalue(L,4);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"string");
        lua_pushliteral(L,"find");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,4);
        lua_pushliteral(L,"^group:");
        lua_call(L,2,1);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,4);
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
      }
      const int lc63 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc63) {
        
        /* if not search_table(biome_lib.surfaceslist_aircheck, s) then */
        enum { lc64 = 4 };
        lc_getupvalue(L,lua_upvalueindex(1),0,6);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surfaceslist_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,4);
        lua_call(L,2,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc65 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc65) {
          
          /* biome_lib.surfaceslist_aircheck[#biome_lib.surfaceslist_aircheck + 1] = s */
          lua_pushvalue(L,4);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surfaceslist_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surfaceslist_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const double lc66 = lua_objlen(L,-1);
          lua_pop(L,1);
          lua_pushnumber(L,lc66);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 4);
        }
        lua_settop(L,lc64);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* else
         * biome_lib:dbg("Warning: Ignored with-air-checking registration for undefined surface node: "..dump(s)) */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"dbg");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"Warning: Ignored with-air-checking registration for undefined surface node: ");
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushvalue(L,4);
        lua_call(L,1,1);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc62);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* else
       * for i = 1, #biomedef.surface do */
      lua_pushnumber(L,1);
      lua_pushliteral(L,"surface");
      lua_gettable(L,2);
      const double lc70 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc70);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc67_var = lua_tonumber(L,-2);
      const double lc68_limit = lua_tonumber(L,-1);
      const double lc69_step = 1;
      lua_pop(L,2);
      enum { lc71 = 4 };
      while ((((lc69_step > 0) && (lc67_var <= lc68_limit)) || ((lc69_step <= 0) && (lc67_var >= lc68_limit)))) {
        
        /* internal: local i at index 5 */
        lua_pushnumber(L,lc67_var);
        
        /* local s = biomedef.surface[i] */
        lua_pushliteral(L,"surface");
        lua_gettable(L,2);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 6);
        
        /* if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then */
        enum { lc72 = 6 };
        lua_pushvalue(L,6);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"string");
          lua_pushliteral(L,"find");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_pushliteral(L,"^group:");
          lua_call(L,2,1);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"registered_nodes");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,6);
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
        }
        const int lc73 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc73) {
          
          /* if not search_table(biome_lib.surfaceslist_aircheck, s) then */
          enum { lc74 = 6 };
          lc_getupvalue(L,lua_upvalueindex(1),0,6);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surfaceslist_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_call(L,2,1);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          const int lc75 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc75) {
            
            /* biome_lib.surfaceslist_aircheck[#biome_lib.surfaceslist_aircheck + 1] = s */
            lua_pushvalue(L,6);
            lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
            lua_pushliteral(L,"surfaceslist_aircheck");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
            lua_pushliteral(L,"surfaceslist_aircheck");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            const double lc76 = lua_objlen(L,-1);
            lua_pop(L,1);
            lua_pushnumber(L,lc76);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 6);
          }
          lua_settop(L,lc74);
          assert(lua_gettop(L) == 6);
        }
        else {
          
          /* else
           * biome_lib:dbg("Warning: Ignored with-air-checking registration for undefined surface node: "..dump(s)) */
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"dbg");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"Warning: Ignored with-air-checking registration for undefined surface node: ");
          lua_getfield(L,LUA_ENVIRONINDEX,"dump");
          lua_pushvalue(L,6);
          lua_call(L,1,1);
          lua_concat(L,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc72);
        assert(lua_gettop(L) == 6);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc67_var += lc69_step;
      }
      lua_settop(L,lc71);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc59);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc36);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: biome_lib:populate_surfaces
 * function(biome, nodes_or_function_or_model, snodes, checkair) */
static int lcf1_biome_lib_populate_surfaces (lua_State * L) {
  lua_checkstack(L,27);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* biome_lib:set_defaults(biome) */
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"set_defaults");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 5);
  
  /* -- filter stage 1 - find nodes from the supplied surfaces that are within the current biome.
   * local in_biome_nodes = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 6);
  
  /* local perlin_fertile_area = minetest.get_perlin(biome.seed_diff, perlin_octaves, perlin_persistence, perlin_scale) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"seed_diff");
  lua_gettable(L,2);
  lc_getupvalue(L,lua_upvalueindex(1),4,2);
  lc_getupvalue(L,lua_upvalueindex(1),3,3);
  lc_getupvalue(L,lua_upvalueindex(1),2,4);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 7);
  
  /* for i = 1, #snodes do */
  lua_pushnumber(L,1);
  const double lc80 = lua_objlen(L,4);
  lua_pushnumber(L,lc80);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc77_var = lua_tonumber(L,-2);
  const double lc78_limit = lua_tonumber(L,-1);
  const double lc79_step = 1;
  lua_pop(L,2);
  enum { lc81 = 7 };
  while ((((lc79_step > 0) && (lc77_var <= lc78_limit)) || ((lc79_step <= 0) && (lc77_var >= lc78_limit)))) {
    
    /* internal: local i at index 8 */
    lua_pushnumber(L,lc77_var);
    
    /* local pos = snodes[i] */
    lua_pushvalue(L,8);
    lua_gettable(L,4);
    assert(lua_gettop(L) == 9);
    
    /* local p_top = { x = pos.x, y = pos.y + 1, z = pos.z } */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,9);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,9);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,9);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 10);
    
    /* local noise1 = perlin_fertile_area:get2d({x=pos.x, y=pos.z}) */
    lua_pushvalue(L,7);
    lua_pushliteral(L,"get2d");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,9);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"z");
    lua_gettable(L,9);
    lua_rawset(L,-3);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 11);
    
    /* local noise2 = biome_lib.perlin_temperature:get2d({x=pos.x, y=pos.z}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"perlin_temperature");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"get2d");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,9);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"z");
    lua_gettable(L,9);
    lua_rawset(L,-3);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 12);
    
    /* local noise3 = biome_lib.perlin_humidity:get2d({x=pos.x+150, y=pos.z+50}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"perlin_humidity");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"get2d");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,9);
    lua_pushnumber(L,150);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"z");
    lua_gettable(L,9);
    lua_pushnumber(L,50);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 13);
    
    /* local biome_surfaces_string = dump(biome.surface) */
    lua_getfield(L,LUA_ENVIRONINDEX,"dump");
    lua_pushliteral(L,"surface");
    lua_gettable(L,2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 14);
    
    /* local surface_ok = false */
    lua_pushboolean(L,0);
    assert(lua_gettop(L) == 15);
    
    /* if not biome.depth then */
    enum { lc82 = 15 };
    lua_pushliteral(L,"depth");
    lua_gettable(L,2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc83 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc83) {
      
      /* local dest_node = minetest.get_node(pos) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 16);
      
      /* if string.find(biome_surfaces_string, dest_node.name) then */
      enum { lc84 = 16 };
      lua_getfield(L,LUA_ENVIRONINDEX,"string");
      lua_pushliteral(L,"find");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,14);
      lua_pushliteral(L,"name");
      lua_gettable(L,16);
      lua_call(L,2,1);
      const int lc85 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc85) {
        
        /* surface_ok = true */
        lua_pushboolean(L,1);
        lua_replace(L,15);
        assert(lua_gettop(L) == 16);
      }
      else {
        
        /* else
         * if string.find(biome_surfaces_string, "group:") then */
        enum { lc86 = 16 };
        lua_getfield(L,LUA_ENVIRONINDEX,"string");
        lua_pushliteral(L,"find");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,14);
        lua_pushliteral(L,"group:");
        lua_call(L,2,1);
        const int lc87 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc87) {
          
          /* for j = 1, #biome.surface do */
          lua_pushnumber(L,1);
          lua_pushliteral(L,"surface");
          lua_gettable(L,2);
          const double lc91 = lua_objlen(L,-1);
          lua_pop(L,1);
          lua_pushnumber(L,lc91);
          if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc88_var = lua_tonumber(L,-2);
          const double lc89_limit = lua_tonumber(L,-1);
          const double lc90_step = 1;
          lua_pop(L,2);
          enum { lc92 = 16 };
          while ((((lc90_step > 0) && (lc88_var <= lc89_limit)) || ((lc90_step <= 0) && (lc88_var >= lc89_limit)))) {
            
            /* internal: local j at index 17 */
            lua_pushnumber(L,lc88_var);
            
            /* if string.find(biome.surface[j], "^group:") 
             * 						  and minetest.get_item_group(dest_node.name, biome.surface[j]) then */
            enum { lc93 = 17 };
            lua_getfield(L,LUA_ENVIRONINDEX,"string");
            lua_pushliteral(L,"find");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"surface");
            lua_gettable(L,2);
            lua_pushvalue(L,17);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"^group:");
            lua_call(L,2,1);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"get_item_group");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"name");
              lua_gettable(L,16);
              lua_pushliteral(L,"surface");
              lua_gettable(L,2);
              lua_pushvalue(L,17);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_call(L,2,1);
            }
            const int lc94 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc94) {
              
              /* surface_ok = true */
              lua_pushboolean(L,1);
              lua_replace(L,15);
              assert(lua_gettop(L) == 17);
              
              /* break */
              break;
              assert(lua_gettop(L) == 17);
            }
            lua_settop(L,lc93);
            assert(lua_gettop(L) == 17);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,1);
            lc88_var += lc90_step;
          }
          lua_settop(L,lc92);
          assert(lua_gettop(L) == 16);
        }
        lua_settop(L,lc86);
        assert(lua_gettop(L) == 16);
      }
      lua_settop(L,lc84);
      assert(lua_gettop(L) == 16);
    }
    else {
      
      /* elseif not string.find(biome_surfaces_string, minetest.get_node({ x = pos.x, y = pos.y-biome.depth-1, z = pos.z }).name) then */
      enum { lc95 = 15 };
      lua_getfield(L,LUA_ENVIRONINDEX,"string");
      lua_pushliteral(L,"find");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,14);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,9);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,9);
      lua_pushliteral(L,"depth");
      lua_gettable(L,2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,9);
      lua_rawset(L,-3);
      lua_call(L,1,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,2,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc96 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc96) {
        
        /* surface_ok = true */
        lua_pushboolean(L,1);
        lua_replace(L,15);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc95);
    }
    lua_settop(L,lc82);
    assert(lua_gettop(L) == 15);
    
    /* if surface_ok
     * 		  and (not checkair or minetest.get_node(p_top).name == "air")
     * 		  and pos.y >= biome.min_elevation
     * 		  and pos.y <= biome.max_elevation
     * 		  and noise1 > biome.plantlife_limit
     * 		  and noise2 <= biome.temp_min
     * 		  and noise2 >= biome.temp_max
     * 		  and noise3 <= biome.humidity_min
     * 		  and noise3 >= biome.humidity_max
     * 		  and (not biome.ncount or #(minetest.find_nodes_in_area({x=pos.x-1, y=pos.y, z=pos.z-1}, {x=pos.x+1, y=pos.y, z=pos.z+1}, biome.neighbors)) > biome.ncount)
     * 		  and (not biome.near_nodes or #(minetest.find_nodes_in_area({x=pos.x-biome.near_nodes_size, y=pos.y-biome.near_nodes_vertical, z=pos.z-biome.near_nodes_size}, {x=pos.x+biome.near_nodes_size, y=pos.y+biome.near_nodes_vertical, z=pos.z+biome.near_nodes_size}, biome.near_nodes)) >= biome.near_nodes_count)
     * 		  and math.random(1,100) > biome.rarity
     * 		  and (not biome.below_nodes or string.find(dump(biome.below_nodes), minetest.get_node({x=pos.x, y=pos.y-1, z=pos.z}).name) ) then */
    enum { lc97 = 15 };
    lua_pushvalue(L,15);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushboolean(L,!(lua_toboolean(L,5)));
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"air");
        const int lc98 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc98);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"min_elevation");
      lua_gettable(L,2);
      lua_pushliteral(L,"y");
      lua_gettable(L,9);
      const int lc99 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc99);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"y");
      lua_gettable(L,9);
      lua_pushliteral(L,"max_elevation");
      lua_gettable(L,2);
      const int lc100 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc100);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"plantlife_limit");
      lua_gettable(L,2);
      const int lc101 = lua_lessthan(L,-1,11);
      lua_pop(L,1);
      lua_pushboolean(L,lc101);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"temp_min");
      lua_gettable(L,2);
      const int lc102 = lc_le(L,12,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc102);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"temp_max");
      lua_gettable(L,2);
      const int lc103 = lc_le(L,-1,12);
      lua_pop(L,1);
      lua_pushboolean(L,lc103);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"humidity_min");
      lua_gettable(L,2);
      const int lc104 = lc_le(L,13,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc104);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"humidity_max");
      lua_gettable(L,2);
      const int lc105 = lc_le(L,-1,13);
      lua_pop(L,1);
      lua_pushboolean(L,lc105);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"ncount");
      lua_gettable(L,2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"ncount");
        lua_gettable(L,2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,9);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,9);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"neighbors");
        lua_gettable(L,2);
        lua_call(L,3,1);
        const double lc106 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc106);
        const int lc107 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc107);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"near_nodes");
      lua_gettable(L,2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"near_nodes_count");
        lua_gettable(L,2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,9);
        lua_pushliteral(L,"near_nodes_vertical");
        lua_gettable(L,2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,9);
        lua_pushliteral(L,"near_nodes_vertical");
        lua_gettable(L,2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"near_nodes");
        lua_gettable(L,2);
        lua_call(L,3,1);
        const double lc108 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc108);
        const int lc109 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc109);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"rarity");
      lua_gettable(L,2);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,100);
      lua_call(L,2,1);
      const int lc110 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc110);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"below_nodes");
      lua_gettable(L,2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"string");
        lua_pushliteral(L,"find");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushliteral(L,"below_nodes");
        lua_gettable(L,2);
        lua_call(L,1,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,9);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_rawset(L,-3);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,2,1);
      }
    }
    const int lc111 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc111) {
      
      /* in_biome_nodes[#in_biome_nodes + 1] = pos */
      lua_pushvalue(L,9);
      const double lc112 = lua_objlen(L,6);
      lua_pushnumber(L,lc112);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc97);
    assert(lua_gettop(L) == 15);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,8);
    lc77_var += lc79_step;
  }
  lua_settop(L,lc81);
  assert(lua_gettop(L) == 7);
  
  /* -- filter stage 2 - find places within that biome area to place the plants.
   * local num_in_biome_nodes = #in_biome_nodes */
  const double lc113 = lua_objlen(L,6);
  lua_pushnumber(L,lc113);
  assert(lua_gettop(L) == 8);
  
  /* if num_in_biome_nodes > 0 then */
  enum { lc114 = 8 };
  lua_pushnumber(L,0);
  const int lc115 = lua_lessthan(L,-1,8);
  lua_pop(L,1);
  lua_pushboolean(L,lc115);
  const int lc116 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc116) {
    
    /* for i = 1, math.min(biome.max_count, num_in_biome_nodes) do */
    lua_pushnumber(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"max_count");
    lua_gettable(L,2);
    lua_pushvalue(L,8);
    lua_call(L,2,1);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc117_var = lua_tonumber(L,-2);
    const double lc118_limit = lua_tonumber(L,-1);
    const double lc119_step = 1;
    lua_pop(L,2);
    enum { lc120 = 8 };
    while ((((lc119_step > 0) && (lc117_var <= lc118_limit)) || ((lc119_step <= 0) && (lc117_var >= lc118_limit)))) {
      
      /* internal: local i at index 9 */
      lua_pushnumber(L,lc117_var);
      
      /* local tries = 0 */
      lua_pushnumber(L,0);
      assert(lua_gettop(L) == 10);
      
      /* local spawned = false */
      lua_pushboolean(L,0);
      assert(lua_gettop(L) == 11);
      
      /* while tries < 2 and not spawned do */
      enum { lc121 = 11 };
      while (1) {
        lua_pushnumber(L,2);
        const int lc122 = lua_lessthan(L,10,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc122);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushboolean(L,!(lua_toboolean(L,11)));
        }
        if (!(lua_toboolean(L,-1))) {
          break;
        }
        lua_pop(L,1);
        
        /* local pos = in_biome_nodes[math.random(1, num_in_biome_nodes)] */
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushvalue(L,8);
        lua_call(L,2,1);
        lua_gettable(L,6);
        assert(lua_gettop(L) == 12);
        
        /* if biome.spawn_replace_node then */
        enum { lc123 = 12 };
        lua_pushliteral(L,"spawn_replace_node");
        lua_gettable(L,2);
        const int lc124 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc124) {
          
          /* pos.y = pos.y-1 */
          lua_pushliteral(L,"y");
          lua_gettable(L,12);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_insert(L,-2);
          lua_settable(L,12);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc123);
        assert(lua_gettop(L) == 12);
        
        /* local p_top = { x = pos.x, y = pos.y + 1, z = pos.z } */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,12);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,12);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,12);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 13);
        
        /* if not (biome.avoid_nodes and biome.avoid_radius and minetest.find_node_near(p_top, biome.avoid_radius + math.random(-1.5,2), biome.avoid_nodes)) then */
        enum { lc125 = 13 };
        lua_pushliteral(L,"avoid_nodes");
        lua_gettable(L,2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"avoid_radius");
          lua_gettable(L,2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"find_node_near");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,13);
          lua_pushliteral(L,"avoid_radius");
          lua_gettable(L,2);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,-1.5);
          lua_pushnumber(L,2);
          lua_call(L,2,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"avoid_nodes");
          lua_gettable(L,2);
          lua_call(L,3,1);
        }
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc126 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc126) {
          
          /* if biome.delete_above then */
          enum { lc127 = 13 };
          lua_pushliteral(L,"delete_above");
          lua_gettable(L,2);
          const int lc128 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc128) {
            
            /* minetest.remove_node(p_top) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,13);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x, y=p_top.y+1, z=p_top.z}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
          }
          lua_settop(L,lc127);
          assert(lua_gettop(L) == 13);
          
          /* if biome.delete_above_surround then */
          enum { lc129 = 13 };
          lua_pushliteral(L,"delete_above_surround");
          lua_gettable(L,2);
          const int lc130 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc130) {
            
            /* minetest.remove_node({x=p_top.x-1, y=p_top.y, z=p_top.z}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x+1, y=p_top.y, z=p_top.z}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x,   y=p_top.y, z=p_top.z-1}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x,   y=p_top.y, z=p_top.z+1}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x-1, y=p_top.y+1, z=p_top.z}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x+1, y=p_top.y+1, z=p_top.z}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x,   y=p_top.y+1, z=p_top.z-1}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
            
            /* minetest.remove_node({x=p_top.x,   y=p_top.y+1, z=p_top.z+1}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,13);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,13);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
          }
          lua_settop(L,lc129);
          assert(lua_gettop(L) == 13);
          
          /* if biome.spawn_replace_node then */
          enum { lc131 = 13 };
          lua_pushliteral(L,"spawn_replace_node");
          lua_gettable(L,2);
          const int lc132 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc132) {
            
            /* minetest.remove_node(pos) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"remove_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,12);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 13);
          }
          lua_settop(L,lc131);
          assert(lua_gettop(L) == 13);
          
          /* local objtype = type(nodes_or_function_or_model) */
          lua_getfield(L,LUA_ENVIRONINDEX,"type");
          lua_pushvalue(L,3);
          lua_call(L,1,1);
          assert(lua_gettop(L) == 14);
          
          /* if objtype == "table" then */
          enum { lc133 = 14 };
          lua_pushliteral(L,"table");
          const int lc134 = lua_equal(L,14,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc134);
          const int lc135 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc135) {
            
            /* if nodes_or_function_or_model.axiom then */
            enum { lc136 = 14 };
            lua_pushliteral(L,"axiom");
            lua_gettable(L,3);
            const int lc137 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc137) {
              
              /* biome_lib:generate_tree(p_top, nodes_or_function_or_model) */
              lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
              lua_pushliteral(L,"generate_tree");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,13);
              lua_pushvalue(L,3);
              lua_call(L,3,0);
              assert(lua_gettop(L) == 14);
              
              /* spawned = true */
              lua_pushboolean(L,1);
              lua_replace(L,11);
              assert(lua_gettop(L) == 14);
            }
            else {
              
              /* else
               * local fdir = nil */
              lua_pushnil(L);
              assert(lua_gettop(L) == 15);
              
              /* if biome.random_facedir then */
              enum { lc138 = 15 };
              lua_pushliteral(L,"random_facedir");
              lua_gettable(L,2);
              const int lc139 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc139) {
                
                /* fdir = math.random(biome.random_facedir[1], biome.random_facedir[2]) */
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"random");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"random_facedir");
                lua_gettable(L,2);
                lua_pushnumber(L,1);
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"random_facedir");
                lua_gettable(L,2);
                lua_pushnumber(L,2);
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_call(L,2,1);
                lua_replace(L,15);
                assert(lua_gettop(L) == 15);
              }
              lua_settop(L,lc138);
              assert(lua_gettop(L) == 15);
              
              /* minetest.set_node(p_top, { name = nodes_or_function_or_model[math.random(#nodes_or_function_or_model)], param2 = fdir }) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,13);
              lua_createtable(L,0,2);
              lua_pushliteral(L,"name");
              lua_getfield(L,LUA_ENVIRONINDEX,"math");
              lua_pushliteral(L,"random");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const double lc140 = lua_objlen(L,3);
              lua_pushnumber(L,lc140);
              lua_call(L,1,1);
              lua_gettable(L,3);
              lua_rawset(L,-3);
              lua_pushliteral(L,"param2");
              lua_pushvalue(L,15);
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 15);
              
              /* spawned = true */
              lua_pushboolean(L,1);
              lua_replace(L,11);
              assert(lua_gettop(L) == 15);
            }
            lua_settop(L,lc136);
            assert(lua_gettop(L) == 14);
          }
          else {
            
            /* elseif objtype == "string" and
             * 					  minetest.registered_nodes[nodes_or_function_or_model] then */
            enum { lc141 = 14 };
            lua_pushvalue(L,14);
            lua_pushliteral(L,"string");
            const int lc142 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc142);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"registered_nodes");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,3);
              lua_gettable(L,-2);
              lua_remove(L,-2);
            }
            const int lc143 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc143) {
              
              /* local fdir = nil */
              lua_pushnil(L);
              assert(lua_gettop(L) == 15);
              
              /* if biome.random_facedir then */
              enum { lc144 = 15 };
              lua_pushliteral(L,"random_facedir");
              lua_gettable(L,2);
              const int lc145 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc145) {
                
                /* fdir = math.random(biome.random_facedir[1], biome.random_facedir[2]) */
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"random");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"random_facedir");
                lua_gettable(L,2);
                lua_pushnumber(L,1);
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"random_facedir");
                lua_gettable(L,2);
                lua_pushnumber(L,2);
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_call(L,2,1);
                lua_replace(L,15);
                assert(lua_gettop(L) == 15);
              }
              lua_settop(L,lc144);
              assert(lua_gettop(L) == 15);
              
              /* minetest.set_node(p_top, { name = nodes_or_function_or_model, param2 = fdir }) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"set_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,13);
              lua_createtable(L,0,2);
              lua_pushliteral(L,"name");
              lua_pushvalue(L,3);
              lua_rawset(L,-3);
              lua_pushliteral(L,"param2");
              lua_pushvalue(L,15);
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 15);
              
              /* spawned = true */
              lua_pushboolean(L,1);
              lua_replace(L,11);
              assert(lua_gettop(L) == 15);
            }
            else {
              
              /* elseif objtype == "function" then */
              enum { lc146 = 14 };
              lua_pushliteral(L,"function");
              const int lc147 = lua_equal(L,14,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc147);
              const int lc148 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc148) {
                
                /* nodes_or_function_or_model(pos) */
                lua_pushvalue(L,3);
                lua_pushvalue(L,12);
                lua_call(L,1,0);
                assert(lua_gettop(L) == 14);
                
                /* spawned = true */
                lua_pushboolean(L,1);
                lua_replace(L,11);
                assert(lua_gettop(L) == 14);
              }
              else {
                
                /* elseif objtype == "string" and pcall(loadstring(("return %s(...)"):
                 * 						format(nodes_or_function_or_model)),pos) then */
                enum { lc149 = 14 };
                lua_pushvalue(L,14);
                lua_pushliteral(L,"string");
                const int lc150 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc150);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"pcall");
                  lua_getfield(L,LUA_ENVIRONINDEX,"loadstring");
                  const int lc151 = lua_gettop(L);
                  lua_pushliteral(L,"return %s(...)");
                  lua_pushliteral(L,"format");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,3);
                  lua_call(L,2,LUA_MULTRET);
                  lua_call(L,(lua_gettop(L) - lc151),1);
                  lua_pushvalue(L,12);
                  lua_call(L,2,1);
                }
                const int lc152 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc152) {
                  
                  /* spawned = true */
                  lua_pushboolean(L,1);
                  lua_replace(L,11);
                  assert(lua_gettop(L) == 14);
                }
                else {
                  
                  /* else
                   * biome_lib:dbg("Warning: Ignored invalid definition for object "..dump(nodes_or_function_or_model).." that was pointed at {"..dump(pos).."}") */
                  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
                  lua_pushliteral(L,"dbg");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushliteral(L,"Warning: Ignored invalid definition for object ");
                  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
                  lua_pushvalue(L,3);
                  lua_call(L,1,1);
                  lua_pushliteral(L," that was pointed at {");
                  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
                  lua_pushvalue(L,12);
                  lua_call(L,1,1);
                  lua_pushliteral(L,"}");
                  lua_concat(L,2);
                  lua_concat(L,2);
                  lua_concat(L,2);
                  lua_concat(L,2);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 14);
                }
                lua_settop(L,lc149);
              }
              lua_settop(L,lc146);
            }
            lua_settop(L,lc141);
          }
          lua_settop(L,lc133);
          assert(lua_gettop(L) == 14);
        }
        else {
          
          /* else
           * tries = tries + 1 */
          lua_pushnumber(L,1);
          lc_add(L,10,-1);
          lua_remove(L,-2);
          lua_replace(L,10);
          assert(lua_gettop(L) == 13);
        }
        lua_settop(L,lc125);
        assert(lua_gettop(L) == 13);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc121);
      assert(lua_gettop(L) == 11);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
      lc117_var += lc119_step;
    }
    lua_settop(L,lc120);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc114);
  assert(lua_gettop(L) == 8);
  return 0;
}


/* name: biome_lib:generate_block_with_air_checking
 * function() */
static int lcf1_biome_lib_generate_block_with_air_checking (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if #biome_lib.blocklist_aircheck > 0 then */
  enum { lc153 = 1 };
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc154 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc154);
  const int lc155 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc155);
  const int lc156 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc156) {
    
    /* local minp =		biome_lib.blocklist_aircheck[1][1] */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 2);
    
    /* local maxp =		biome_lib.blocklist_aircheck[1][2] */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 3);
    
    /* -- use the block hash as a unique key into the surface nodes
     * -- tables, so that we can write the tables thread-safely.
     * local blockhash =	minetest.hash_node_position(minp) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"hash_node_position");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 4);
    
    /* if not biome_lib.surface_nodes_aircheck.blockhash then */
    enum { lc157 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"surface_nodes_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"blockhash");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc158 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc158) {
      
      /* if type(minetest.find_nodes_in_area_under_air) == "function" then */
      enum { lc159 = 4 };
      lua_getfield(L,LUA_ENVIRONINDEX,"type");
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_nodes_in_area_under_air");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"function");
      const int lc160 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc160);
      const int lc161 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc161) {
        
        /* -- use newer API call
         * biome_lib.surface_nodes_aircheck.blockhash =
         * 					minetest.find_nodes_in_area_under_air(minp, maxp, biome_lib.surfaceslist_aircheck) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area_under_air");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,2);
        lua_pushvalue(L,3);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surfaceslist_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surface_nodes_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* else
         * local search_area = minetest.find_nodes_in_area(minp, maxp, biome_lib.surfaceslist_aircheck) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,2);
        lua_pushvalue(L,3);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surfaceslist_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,1);
        assert(lua_gettop(L) == 5);
        
        /* -- search the generated block for air-bounded surfaces the slow way.
         * biome_lib.surface_nodes_aircheck.blockhash = {} */
        lua_newtable(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surface_nodes_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 5);
        
        /* for i = 1, #search_area do */
        lua_pushnumber(L,1);
        const double lc165 = lua_objlen(L,5);
        lua_pushnumber(L,lc165);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc162_var = lua_tonumber(L,-2);
        const double lc163_limit = lua_tonumber(L,-1);
        const double lc164_step = 1;
        lua_pop(L,2);
        enum { lc166 = 5 };
        while ((((lc164_step > 0) && (lc162_var <= lc163_limit)) || ((lc164_step <= 0) && (lc162_var >= lc163_limit)))) {
          
          /* internal: local i at index 6 */
          lua_pushnumber(L,lc162_var);
          
          /* local pos = search_area[i] */
          lua_pushvalue(L,6);
          lua_gettable(L,5);
          assert(lua_gettop(L) == 7);
          
          /* local p_top = { x=pos.x, y=pos.y+1, z=pos.z } */
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,7);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_rawset(L,-3);
          assert(lua_gettop(L) == 8);
          
          /* if minetest.get_node(p_top).name == "air" then */
          enum { lc167 = 8 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,8);
          lua_call(L,1,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"air");
          const int lc168 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc168);
          const int lc169 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc169) {
            
            /* biome_lib.surface_nodes_aircheck.blockhash[#biome_lib.surface_nodes_aircheck.blockhash + 1] = pos */
            lua_pushvalue(L,7);
            lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
            lua_pushliteral(L,"surface_nodes_aircheck");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"blockhash");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
            lua_pushliteral(L,"surface_nodes_aircheck");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"blockhash");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            const double lc170 = lua_objlen(L,-1);
            lua_pop(L,1);
            lua_pushnumber(L,lc170);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 8);
          }
          lua_settop(L,lc167);
          assert(lua_gettop(L) == 8);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
          lc162_var += lc164_step;
        }
        lua_settop(L,lc166);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc159);
      assert(lua_gettop(L) == 4);
      
      /* biome_lib.actioncount_aircheck.blockhash = 1 */
      lua_pushnumber(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"actioncount_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"blockhash");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* else
       * if biome_lib.actioncount_aircheck.blockhash <= #biome_lib.actionslist_aircheck then */
      enum { lc171 = 4 };
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"actioncount_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"blockhash");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"actionslist_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc172 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc172);
      const int lc173 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc173);
      const int lc174 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc174) {
        
        /* -- [1] is biome, [2] is node/function/model
         * biome_lib:populate_surfaces(
         * 					biome_lib.actionslist_aircheck[biome_lib.actioncount_aircheck.blockhash][1],
         * 					biome_lib.actionslist_aircheck[biome_lib.actioncount_aircheck.blockhash][2],
         * 					biome_lib.surface_nodes_aircheck.blockhash, true) */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"populate_surfaces");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actionslist_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actionslist_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surface_nodes_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushboolean(L,1);
        lua_call(L,5,0);
        assert(lua_gettop(L) == 4);
        
        /* biome_lib.actioncount_aircheck.blockhash = biome_lib.actioncount_aircheck.blockhash + 1 */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* else
         * if biome_lib.surface_nodes_aircheck.blockhash then */
        enum { lc175 = 4 };
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surface_nodes_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc176 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc176) {
          
          /* table.remove(biome_lib.blocklist_aircheck, 1) */
          lua_getfield(L,LUA_ENVIRONINDEX,"table");
          lua_pushliteral(L,"remove");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"blocklist_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 4);
          
          /* biome_lib.surface_nodes_aircheck.blockhash = nil */
          lua_pushnil(L);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surface_nodes_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"blockhash");
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 4);
        }
        lua_settop(L,lc175);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc171);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc157);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc153);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: biome_lib:generate_block_no_aircheck
 * function() */
static int lcf1_biome_lib_generate_block_no_aircheck (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if #biome_lib.blocklist_no_aircheck > 0 then */
  enum { lc177 = 1 };
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_no_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc178 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc178);
  const int lc179 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc179);
  const int lc180 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc180) {
    
    /* local minp =		biome_lib.blocklist_no_aircheck[1][1] */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_no_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 2);
    
    /* local maxp =		biome_lib.blocklist_no_aircheck[1][2] */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_no_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 3);
    
    /* local blockhash =	minetest.hash_node_position(minp) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"hash_node_position");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 4);
    
    /* if not biome_lib.surface_nodes_no_aircheck.blockhash then */
    enum { lc181 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"surface_nodes_no_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"blockhash");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc182 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc182) {
      
      /* -- directly read the block to be searched into the chunk cache
       * biome_lib.surface_nodes_no_aircheck.blockhash =
       * 				minetest.find_nodes_in_area(minp, maxp, biome_lib.surfaceslist_no_aircheck) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_nodes_in_area");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_pushvalue(L,3);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"surfaceslist_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"surface_nodes_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"blockhash");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 4);
      
      /* biome_lib.actioncount_no_aircheck.blockhash = 1 */
      lua_pushnumber(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"actioncount_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"blockhash");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* else
       * if biome_lib.actioncount_no_aircheck.blockhash <= #biome_lib.actionslist_no_aircheck then */
      enum { lc183 = 4 };
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"actioncount_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"blockhash");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"actionslist_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc184 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc184);
      const int lc185 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc185);
      const int lc186 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc186) {
        
        /* biome_lib:populate_surfaces(
         * 					biome_lib.actionslist_no_aircheck[biome_lib.actioncount_no_aircheck.blockhash][1],
         * 					biome_lib.actionslist_no_aircheck[biome_lib.actioncount_no_aircheck.blockhash][2],
         * 					biome_lib.surface_nodes_no_aircheck.blockhash, false) */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"populate_surfaces");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actionslist_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actionslist_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surface_nodes_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushboolean(L,0);
        lua_call(L,5,0);
        assert(lua_gettop(L) == 4);
        
        /* biome_lib.actioncount_no_aircheck.blockhash = biome_lib.actioncount_no_aircheck.blockhash + 1 */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"actioncount_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* else
         * if biome_lib.surface_nodes_no_aircheck.blockhash then */
        enum { lc187 = 4 };
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"surface_nodes_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"blockhash");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc188 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc188) {
          
          /* table.remove(biome_lib.blocklist_no_aircheck, 1) */
          lua_getfield(L,LUA_ENVIRONINDEX,"table");
          lua_pushliteral(L,"remove");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"blocklist_no_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 4);
          
          /* biome_lib.surface_nodes_no_aircheck.blockhash = nil */
          lua_pushnil(L);
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"surface_nodes_no_aircheck");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"blockhash");
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 4);
        }
        lua_settop(L,lc187);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc183);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc181);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc177);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(minp, maxp, blockseed) */
static int lcf190 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* biome_lib.blocklist_aircheck[#biome_lib.blocklist_aircheck + 1] = { minp, maxp } */
  lua_createtable(L,2,0);
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,2);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc189 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc189);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(minp, maxp, blockseed) */
static int lcf192 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* biome_lib.blocklist_no_aircheck[#biome_lib.blocklist_no_aircheck + 1] = { minp, maxp } */
  lua_createtable(L,2,0);
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,2);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_no_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_no_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc191 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc191);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(dtime) */
static int lcf214 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if dtime < 0.2 and    -- don't attempt to populate if lag is already too high
   * 	  (#biome_lib.blocklist_aircheck > 0 or #biome_lib.blocklist_no_aircheck > 0) then */
  enum { lc193 = 1 };
  lua_pushnumber(L,0.2);
  const int lc194 = lua_lessthan(L,1,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc194);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc195 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc195);
    const int lc196 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc196);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"blocklist_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc197 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc197);
      const int lc198 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc198);
    }
  }
  const int lc199 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc199) {
    
    /* biome_lib.globalstep_start_time = minetest.get_us_time() */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_us_time");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_insert(L,-2);
    lua_pushliteral(L,"globalstep_start_time");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 1);
    
    /* biome_lib.globalstep_runtime = 0 */
    lua_pushnumber(L,0);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_insert(L,-2);
    lua_pushliteral(L,"globalstep_runtime");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 1);
    
    /* while (#biome_lib.blocklist_aircheck > 0 or #biome_lib.blocklist_no_aircheck > 0)
     * 		  and biome_lib.globalstep_runtime < 200000 do  -- 0.2 seconds, in uS. */
    enum { lc200 = 1 };
    while (1) {
      lua_pushnumber(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"blocklist_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc201 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc201);
      const int lc202 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc202);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushnumber(L,0);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"blocklist_no_aircheck");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const double lc203 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc203);
        const int lc204 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc204);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"globalstep_runtime");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,200000);
        const int lc205 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc205);
      }
      if (!(lua_toboolean(L,-1))) {
        break;
      }
      lua_pop(L,1);
      
      /* -- 0.2 seconds, in uS.
       * if #biome_lib.blocklist_aircheck > 0 then */
      enum { lc206 = 1 };
      lua_pushnumber(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"blocklist_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc207 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc207);
      const int lc208 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc208);
      const int lc209 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc209) {
        
        /* biome_lib:generate_block_with_air_checking() */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"generate_block_with_air_checking");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 1);
      }
      lua_settop(L,lc206);
      assert(lua_gettop(L) == 1);
      
      /* if #biome_lib.blocklist_no_aircheck > 0 then */
      enum { lc210 = 1 };
      lua_pushnumber(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"blocklist_no_aircheck");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc211 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc211);
      const int lc212 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc212);
      const int lc213 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc213) {
        
        /* biome_lib:generate_block_no_aircheck() */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"generate_block_no_aircheck");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 1);
      }
      lua_settop(L,lc210);
      assert(lua_gettop(L) == 1);
      
      /* biome_lib.globalstep_runtime = minetest.get_us_time() - biome_lib.globalstep_start_time */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_us_time");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"globalstep_start_time");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_insert(L,-2);
      lua_pushliteral(L,"globalstep_runtime");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 1);
    }
    lua_settop(L,lc200);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc193);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function() */
static int lcf221 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* print("[biome_lib] Stand by, playing out the rest of the aircheck mapblock log") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"[biome_lib] Stand by, playing out the rest of the aircheck mapblock log");
  lua_call(L,1,0);
  assert(lua_gettop(L) == 0);
  
  /* print("(there are "..#biome_lib.blocklist_aircheck.." entries)...") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"(there are ");
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc215 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc215);
  lua_pushliteral(L," entries)...");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 0);
  
  /* while true do */
  enum { lc216 = 0 };
  while (1) {
    lua_pushboolean(L,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* biome_lib:generate_block_with_air_checking(0.1) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"generate_block_with_air_checking");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,0.1);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 0);
    
    /* if #biome_lib.blocklist_aircheck == 0 then */
    enum { lc217 = 0 };
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc218 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc218);
    lua_pushnumber(L,0);
    const int lc219 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc219);
    const int lc220 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc220) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 0);
    }
    lua_settop(L,lc217);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc216);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* function() */
static int lcf228 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* print("[biome_lib] Stand by, playing out the rest of the no-aircheck mapblock log") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"[biome_lib] Stand by, playing out the rest of the no-aircheck mapblock log");
  lua_call(L,1,0);
  assert(lua_gettop(L) == 0);
  
  /* print("(there are "..#biome_lib.blocklist_no_aircheck.." entries)...") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"(there are ");
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"blocklist_no_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc222 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc222);
  lua_pushliteral(L," entries)...");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 0);
  
  /* while true do */
  enum { lc223 = 0 };
  while (1) {
    lua_pushboolean(L,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* biome_lib:generate_block_no_aircheck(0.1) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"generate_block_no_aircheck");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,0.1);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 0);
    
    /* if #biome_lib.blocklist_no_aircheck == 0 then */
    enum { lc224 = 0 };
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"blocklist_no_aircheck");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc225 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc225);
    lua_pushnumber(L,0);
    const int lc226 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc226);
    const int lc227 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc227) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 0);
    }
    lua_settop(L,lc224);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc223);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(pos, node, active_object_count, active_object_count_wider) */
static int lcf288 (lua_State * L) {
  lua_checkstack(L,27);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local p_top = { x = pos.x, y = pos.y + 1, z = pos.z } */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 5);
  
  /* local n_top = minetest.get_node(p_top) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* local perlin_fertile_area = minetest.get_perlin(biome.seed_diff, perlin_octaves, perlin_persistence, perlin_scale) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,7);
  lua_pushliteral(L,"seed_diff");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),5,2);
  lc_getupvalue(L,lua_upvalueindex(1),4,3);
  lc_getupvalue(L,lua_upvalueindex(1),3,4);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 7);
  
  /* local noise1 = perlin_fertile_area:get2d({x=p_top.x, y=p_top.z}) */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 8);
  
  /* local noise2 = biome_lib.perlin_temperature:get2d({x=p_top.x, y=p_top.z}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"perlin_temperature");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 9);
  
  /* local noise3 = biome_lib.perlin_humidity:get2d({x=p_top.x+150, y=p_top.z+50}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"perlin_humidity");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lua_pushnumber(L,150);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lua_pushnumber(L,50);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 10);
  
  /* if noise1 > biome.plantlife_limit 
   * 			  and noise2 <= biome.temp_min
   * 			  and noise2 >= biome.temp_max
   * 			  and noise3 <= biome.humidity_min
   * 			  and noise3 >= biome.humidity_max
   * 			  and biome_lib:is_node_loaded(p_top) then */
  enum { lc237 = 10 };
  lc_getupvalue(L,lua_upvalueindex(1),0,7);
  lua_pushliteral(L,"plantlife_limit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc238 = lua_lessthan(L,-1,8);
  lua_pop(L,1);
  lua_pushboolean(L,lc238);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,7);
    lua_pushliteral(L,"temp_min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc239 = lc_le(L,9,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc239);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,7);
    lua_pushliteral(L,"temp_max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc240 = lc_le(L,-1,9);
    lua_pop(L,1);
    lua_pushboolean(L,lc240);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,7);
    lua_pushliteral(L,"humidity_min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc241 = lc_le(L,10,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc241);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,7);
    lua_pushliteral(L,"humidity_max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc242 = lc_le(L,-1,10);
    lua_pop(L,1);
    lua_pushboolean(L,lc242);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"is_node_loaded");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,5);
    lua_call(L,2,1);
  }
  const int lc243 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc243) {
    
    /* local n_light = minetest.get_node_light(p_top, nil) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node_light");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_pushnil(L);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 11);
    
    /* if not (biome.avoid_nodes and biome.avoid_radius and minetest.find_node_near(p_top, biome.avoid_radius + math.random(-1.5,2), biome.avoid_nodes))
     * 				  and n_light >= biome.light_min
     * 				  and n_light <= biome.light_max
     * 				  and (not(biome.neighbors and biome.ncount) or #(minetest.find_nodes_in_area({x=pos.x-1, y=pos.y, z=pos.z-1}, {x=pos.x+1, y=pos.y, z=pos.z+1}, biome.neighbors)) > biome.ncount )
     * 				  and (not(biome.near_nodes and biome.near_nodes_count and biome.near_nodes_size) or #(minetest.find_nodes_in_area({x=pos.x-biome.near_nodes_size, y=pos.y-biome.near_nodes_vertical, z=pos.z-biome.near_nodes_size}, {x=pos.x+biome.near_nodes_size, y=pos.y+biome.near_nodes_vertical, z=pos.z+biome.near_nodes_size}, biome.near_nodes)) >= biome.near_nodes_count)
     * 				  and (not(biome.air_count and biome.air_size) or #(minetest.find_nodes_in_area({x=p_top.x-biome.air_size, y=p_top.y, z=p_top.z-biome.air_size}, {x=p_top.x+biome.air_size, y=p_top.y, z=p_top.z+biome.air_size}, "air")) >= biome.air_count)
     * 				  and pos.y >= biome.min_elevation
     * 				  and pos.y <= biome.max_elevation then */
    enum { lc244 = 11 };
    lc_getupvalue(L,lua_upvalueindex(1),0,7);
    lua_pushliteral(L,"avoid_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"avoid_radius");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_node_near");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"avoid_radius");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,-1.5);
      lua_pushnumber(L,2);
      lua_call(L,2,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"avoid_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,1);
    }
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"light_min");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc245 = lc_le(L,-1,11);
      lua_pop(L,1);
      lua_pushboolean(L,lc245);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"light_max");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc246 = lc_le(L,11,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc246);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"neighbors");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"ncount");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"ncount");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"neighbors");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,1);
        const double lc247 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc247);
        const int lc248 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc248);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"near_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_count");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_count");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_vertical");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_vertical");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"near_nodes");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,1);
        const double lc249 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc249);
        const int lc250 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc250);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"air_count");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"air_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"air_count");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_nodes_in_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,5);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"air_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,5);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,5);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"air_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,5);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"air_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,5);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,5);
        lc_getupvalue(L,lua_upvalueindex(1),0,7);
        lua_pushliteral(L,"air_size");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"air");
        lua_call(L,3,1);
        const double lc251 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc251);
        const int lc252 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc252);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"min_elevation");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      const int lc253 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc253);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"max_elevation");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc254 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc254);
    }
    const int lc255 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc255) {
      
      /* local walldir = biome_lib:find_adjacent_wall(p_top, biome.verticals_list, biome.choose_random_wall) */
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"find_adjacent_wall");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,5);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"verticals_list");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"choose_random_wall");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 12);
      
      /* if biome.alt_wallnode and walldir then */
      enum { lc256 = 12 };
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_pushliteral(L,"alt_wallnode");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,12);
      }
      const int lc257 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc257) {
        
        /* if n_top.name == "air" then */
        enum { lc258 = 12 };
        lua_pushliteral(L,"name");
        lua_gettable(L,6);
        lua_pushliteral(L,"air");
        const int lc259 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc259);
        const int lc260 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc260) {
          
          /* minetest.set_node(p_top, { name = biome.alt_wallnode, param2 = walldir }) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,5);
          lua_createtable(L,0,2);
          lua_pushliteral(L,"name");
          lc_getupvalue(L,lua_upvalueindex(1),0,7);
          lua_pushliteral(L,"alt_wallnode");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"param2");
          lua_pushvalue(L,12);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc258);
        assert(lua_gettop(L) == 12);
      }
      else {
        
        /* else
         * local currentsurface = minetest.get_node(pos).name */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 13);
        
        /* if currentsurface ~= "default:water_source"
         * 						  or (currentsurface == "default:water_source" and #(minetest.find_nodes_in_area({x=pos.x, y=pos.y-biome.depth_max-1, z=pos.z}, {x=pos.x, y=pos.y, z=pos.z}, {"default:dirt", "default:dirt_with_grass", "default:sand"})) > 0 ) then */
        enum { lc261 = 13 };
        lua_pushliteral(L,"default:water_source");
        const int lc262 = lua_equal(L,13,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc262);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,13);
          lua_pushliteral(L,"default:water_source");
          const int lc263 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc263);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushnumber(L,0);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"find_nodes_in_area");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,1);
            lc_getupvalue(L,lua_upvalueindex(1),0,7);
            lua_pushliteral(L,"depth_max");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_createtable(L,3,0);
            lua_pushliteral(L,"default:dirt");
            lua_rawseti(L,-2,1);
            lua_pushliteral(L,"default:dirt_with_grass");
            lua_rawseti(L,-2,2);
            lua_pushliteral(L,"default:sand");
            lua_rawseti(L,-2,3);
            lua_call(L,3,1);
            const double lc264 = lua_objlen(L,-1);
            lua_pop(L,1);
            lua_pushnumber(L,lc264);
            const int lc265 = lua_lessthan(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc265);
          }
        }
        const int lc266 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc266) {
          
          /* local rnd = math.random(1, biome.spawn_plants_count) */
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),0,7);
          lua_pushliteral(L,"spawn_plants_count");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,2,1);
          assert(lua_gettop(L) == 14);
          
          /* local plant_to_spawn = biome.spawn_plants[rnd] */
          lc_getupvalue(L,lua_upvalueindex(1),0,7);
          lua_pushliteral(L,"spawn_plants");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,14);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 15);
          
          /* local fdir = biome.facedir */
          lc_getupvalue(L,lua_upvalueindex(1),0,7);
          lua_pushliteral(L,"facedir");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 16);
          
          /* if biome.random_facedir then */
          enum { lc267 = 16 };
          lc_getupvalue(L,lua_upvalueindex(1),0,7);
          lua_pushliteral(L,"random_facedir");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc268 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc268) {
            
            /* fdir = math.random(biome.random_facedir[1],biome.random_facedir[2]) */
            lua_getfield(L,LUA_ENVIRONINDEX,"math");
            lua_pushliteral(L,"random");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lc_getupvalue(L,lua_upvalueindex(1),0,7);
            lua_pushliteral(L,"random_facedir");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lc_getupvalue(L,lua_upvalueindex(1),0,7);
            lua_pushliteral(L,"random_facedir");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,2);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_call(L,2,1);
            lua_replace(L,16);
            assert(lua_gettop(L) == 16);
          }
          lua_settop(L,lc267);
          assert(lua_gettop(L) == 16);
          
          /* if type(biome.spawn_plants) == "string" then */
          enum { lc269 = 16 };
          lua_getfield(L,LUA_ENVIRONINDEX,"type");
          lc_getupvalue(L,lua_upvalueindex(1),0,7);
          lua_pushliteral(L,"spawn_plants");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L,"string");
          const int lc270 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc270);
          const int lc271 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc271) {
            
            /* assert(loadstring(biome.spawn_plants.."(...)"))(pos) */
            lua_getfield(L,LUA_ENVIRONINDEX,"assert");
            const int lc272 = lua_gettop(L);
            lua_getfield(L,LUA_ENVIRONINDEX,"loadstring");
            lc_getupvalue(L,lua_upvalueindex(1),0,7);
            lua_pushliteral(L,"spawn_plants");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"(...)");
            lua_concat(L,2);
            lua_call(L,1,LUA_MULTRET);
            lua_call(L,(lua_gettop(L) - lc272),1);
            lua_pushvalue(L,1);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 16);
          }
          else {
            
            /* elseif not biome.spawn_on_side and not biome.spawn_on_bottom and not biome.spawn_replace_node then */
            enum { lc273 = 16 };
            lc_getupvalue(L,lua_upvalueindex(1),0,7);
            lua_pushliteral(L,"spawn_on_side");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lc_getupvalue(L,lua_upvalueindex(1),0,7);
              lua_pushliteral(L,"spawn_on_bottom");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lc_getupvalue(L,lua_upvalueindex(1),0,7);
              lua_pushliteral(L,"spawn_replace_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc274 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc274) {
              
              /* if n_top.name == "air" then */
              enum { lc275 = 16 };
              lua_pushliteral(L,"name");
              lua_gettable(L,6);
              lua_pushliteral(L,"air");
              const int lc276 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc276);
              const int lc277 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc277) {
                
                /* minetest.set_node(p_top, { name = plant_to_spawn, param2 = fdir }) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"set_node");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,5);
                lua_createtable(L,0,2);
                lua_pushliteral(L,"name");
                lua_pushvalue(L,15);
                lua_rawset(L,-3);
                lua_pushliteral(L,"param2");
                lua_pushvalue(L,16);
                lua_rawset(L,-3);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 16);
              }
              lua_settop(L,lc275);
              assert(lua_gettop(L) == 16);
            }
            else {
              
              /* elseif biome.spawn_replace_node then */
              enum { lc278 = 16 };
              lc_getupvalue(L,lua_upvalueindex(1),0,7);
              lua_pushliteral(L,"spawn_replace_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc279 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc279) {
                
                /* minetest.set_node(pos, { name = plant_to_spawn, param2 = fdir }) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"set_node");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,1);
                lua_createtable(L,0,2);
                lua_pushliteral(L,"name");
                lua_pushvalue(L,15);
                lua_rawset(L,-3);
                lua_pushliteral(L,"param2");
                lua_pushvalue(L,16);
                lua_rawset(L,-3);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 16);
              }
              else {
                
                /* elseif biome.spawn_on_side then */
                enum { lc280 = 16 };
                lc_getupvalue(L,lua_upvalueindex(1),0,7);
                lua_pushliteral(L,"spawn_on_side");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                const int lc281 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc281) {
                  
                  /* local onside = biome_lib:find_open_side(pos) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
                  lua_pushliteral(L,"find_open_side");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,1);
                  lua_call(L,2,1);
                  assert(lua_gettop(L) == 17);
                  
                  /* if onside then */
                  enum { lc282 = 17 };
                  if (lua_toboolean(L,17)) {
                    
                    /* minetest.set_node(onside.newpos, { name = plant_to_spawn, param2 = onside.facedir }) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"set_node");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"newpos");
                    lua_gettable(L,17);
                    lua_createtable(L,0,2);
                    lua_pushliteral(L,"name");
                    lua_pushvalue(L,15);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"param2");
                    lua_pushliteral(L,"facedir");
                    lua_gettable(L,17);
                    lua_rawset(L,-3);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 17);
                  }
                  lua_settop(L,lc282);
                  assert(lua_gettop(L) == 17);
                }
                else {
                  
                  /* elseif biome.spawn_on_bottom then */
                  enum { lc283 = 16 };
                  lc_getupvalue(L,lua_upvalueindex(1),0,7);
                  lua_pushliteral(L,"spawn_on_bottom");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc284 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc284) {
                    
                    /* if minetest.get_node({x=pos.x, y=pos.y-1, z=pos.z}).name == "air" then */
                    enum { lc285 = 16 };
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"get_node");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_createtable(L,0,3);
                    lua_pushliteral(L,"x");
                    lua_pushliteral(L,"x");
                    lua_gettable(L,1);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"y");
                    lua_pushliteral(L,"y");
                    lua_gettable(L,1);
                    lua_pushnumber(L,1);
                    lc_sub(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"z");
                    lua_pushliteral(L,"z");
                    lua_gettable(L,1);
                    lua_rawset(L,-3);
                    lua_call(L,1,1);
                    lua_pushliteral(L,"name");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"air");
                    const int lc286 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc286);
                    const int lc287 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc287) {
                      
                      /* minetest.set_node({x=pos.x, y=pos.y-1, z=pos.z}, { name = plant_to_spawn, param2 = fdir} ) */
                      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                      lua_pushliteral(L,"set_node");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_createtable(L,0,3);
                      lua_pushliteral(L,"x");
                      lua_pushliteral(L,"x");
                      lua_gettable(L,1);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"y");
                      lua_pushliteral(L,"y");
                      lua_gettable(L,1);
                      lua_pushnumber(L,1);
                      lc_sub(L,-2,-1);
                      lua_remove(L,-2);
                      lua_remove(L,-2);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"z");
                      lua_pushliteral(L,"z");
                      lua_gettable(L,1);
                      lua_rawset(L,-3);
                      lua_createtable(L,0,2);
                      lua_pushliteral(L,"name");
                      lua_pushvalue(L,15);
                      lua_rawset(L,-3);
                      lua_pushliteral(L,"param2");
                      lua_pushvalue(L,16);
                      lua_rawset(L,-3);
                      lua_call(L,2,0);
                      assert(lua_gettop(L) == 16);
                    }
                    lua_settop(L,lc285);
                    assert(lua_gettop(L) == 16);
                  }
                  lua_settop(L,lc283);
                }
                lua_settop(L,lc280);
              }
              lua_settop(L,lc278);
            }
            lua_settop(L,lc273);
          }
          lua_settop(L,lc269);
          assert(lua_gettop(L) == 16);
        }
        lua_settop(L,lc261);
        assert(lua_gettop(L) == 13);
      }
      lua_settop(L,lc256);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc244);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc237);
  assert(lua_gettop(L) == 10);
  return 0;
}


/* name: biome_lib:spawn_on_surfaces
 * function(sd,sp,sr,sc,ss,sa) */
static int lcf1_biome_lib_spawn_on_surfaces (lua_State * L) {
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* local biome = {} */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc229 = 8 };
  assert((lua_gettop(L) == lc229));
  lua_newtable(L);
  lua_rawseti(L,lc229,7);
  assert(lua_gettop(L) == 8);
  
  /* if type(sd) ~= "table" then */
  enum { lc230 = 8 };
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_pushliteral(L,"table");
  const int lc231 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc231);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc232 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc232) {
    
    /* biome.spawn_delay = sd */
    lua_pushvalue(L,2);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"spawn_delay");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* -- old api expects ABM interval param here.
     * biome.spawn_plants = {sp} */
    lua_createtable(L,1,0);
    lua_pushvalue(L,3);
    lua_rawseti(L,-2,1);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"spawn_plants");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* biome.avoid_radius = sr */
    lua_pushvalue(L,4);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"avoid_radius");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* biome.spawn_chance = sc */
    lua_pushvalue(L,5);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"spawn_chance");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* biome.spawn_surfaces = {ss} */
    lua_createtable(L,1,0);
    lua_pushvalue(L,6);
    lua_rawseti(L,-2,1);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"spawn_surfaces");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* biome.avoid_nodes = sa */
    lua_pushvalue(L,7);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"avoid_nodes");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
  }
  else {
    
    /* else
     * biome = sd */
    lua_pushvalue(L,2);
    lc_setupvalue(L,lc229,0,7);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc230);
  assert(lua_gettop(L) == 8);
  
  /* if biome.spawn_delay*time_scale >= 1 then */
  enum { lc233 = 8 };
  lua_pushnumber(L,1);
  lc_getupvalue(L,lc229,0,7);
  lua_pushliteral(L,"spawn_delay");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc229,2,5);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  const int lc234 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc234);
  const int lc235 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc235) {
    
    /* biome.interval = biome.spawn_delay*time_scale */
    lc_getupvalue(L,lc229,0,7);
    lua_pushliteral(L,"spawn_delay");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc229,2,5);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"interval");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
  }
  else {
    
    /* else
     * biome.interval = 1 */
    lua_pushnumber(L,1);
    lc_getupvalue(L,lc229,0,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"interval");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc233);
  assert(lua_gettop(L) == 8);
  
  /* biome_lib:set_defaults(biome) */
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"set_defaults");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lc229,0,7);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 8);
  
  /* biome.spawn_plants_count = #(biome.spawn_plants) */
  lc_getupvalue(L,lc229,0,7);
  lua_pushliteral(L,"spawn_plants");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc236 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc236);
  lc_getupvalue(L,lc229,0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"spawn_plants_count");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 8);
  
  /* minetest.register_abm({
   * 		nodenames = biome.spawn_surfaces,
   * 		interval = biome.interval,
   * 		chance = biome.spawn_chance,
   * 		neighbors = biome.neighbors,
   * 		action = function(pos, node, active_object_count, active_object_count_wider)
   * 			local p_top = { x = pos.x, y = pos.y + 1, z = pos.z }	
   * 			local n_top = minetest.get_node(p_top)
   * 			local perlin_fertile_area = minetest.get_perlin(biome.seed_diff, perlin_octaves, perlin_persistence, perlin_scale)
   * 			local noise1 = perlin_fertile_area:get2d({x=p_top.x, y=p_top.z})
   * 			local noise2 = biome_lib.perlin_temperature:get2d({x=p_top.x, y=p_top.z})
   * 			local noise3 = biome_lib.perlin_humidity:get2d({x=p_top.x+150, y=p_top.z+50})
   * 			if noise1 > biome.plantlife_limit 
   * 			  and noise2 <= biome.temp_min
   * 			  and noise2 >= biome.temp_max
   * 			  and noise3 <= biome.humidity_min
   * 			  and noise3 >= biome.humidity_max
   * 			  and biome_lib:is_node_loaded(p_top) then
   * 				local n_light = minetest.get_node_light(p_top, nil)
   * 				if not (biome.avoid_nodes and biome.avoid_radius and minetest.find_node_near(p_top, biome.avoid_radius + math.random(-1.5,2), biome.avoid_nodes))
   * 				  and n_light >= biome.light_min
   * 				  and n_light <= biome.light_max
   * 				  and (not(biome.neighbors and biome.ncount) or #(minetest.find_nodes_in_area({x=pos.x-1, y=pos.y, z=pos.z-1}, {x=pos.x+1, y=pos.y, z=pos.z+1}, biome.neighbors)) > biome.ncount )
   * 				  and (not(biome.near_nodes and biome.near_nodes_count and biome.near_nodes_size) or #(minetest.find_nodes_in_area({x=pos.x-biome.near_nodes_size, y=pos.y-biome.near_nodes_vertical, z=pos.z-biome.near_nodes_size}, {x=pos.x+biome.near_nodes_size, y=pos.y+biome.near_nodes_vertical, z=pos.z+biome.near_nodes_size}, biome.near_nodes)) >= biome.near_nodes_count)
   * 				  and (not(biome.air_count and biome.air_size) or #(minetest.find_nodes_in_area({x=p_top.x-biome.air_size, y=p_top.y, z=p_top.z-biome.air_size}, {x=p_top.x+biome.air_size, y=p_top.y, z=p_top.z+biome.air_size}, "air")) >= biome.air_count)
   * 				  and pos.y >= biome.min_elevation
   * 				  and pos.y <= biome.max_elevation
   * 				  then
   * 					local walldir = biome_lib:find_adjacent_wall(p_top, biome.verticals_list, biome.choose_random_wall)
   * 					if biome.alt_wallnode and walldir then
   * 						if n_top.name == "air" then
   * 							minetest.set_node(p_top, { name = biome.alt_wallnode, param2 = walldir })
   * 						end
   * 					else
   * 						local currentsurface = minetest.get_node(pos).name
   * 						if currentsurface ~= "default:water_source"
   * 						  or (currentsurface == "default:water_source" and #(minetest.find_nodes_in_area({x=pos.x, y=pos.y-biome.depth_max-1, z=pos.z}, {x=pos.x, y=pos.y, z=pos.z}, {"default:dirt", "default:dirt_with_grass", "default:sand"})) > 0 )
   * 						  then
   * 							local rnd = math.random(1, biome.spawn_plants_count)
   * 							local plant_to_spawn = biome.spawn_plants[rnd]
   * 							local fdir = biome.facedir
   * 							if biome.random_facedir then
   * 								fdir = math.random(biome.random_facedir[1],biome.random_facedir[2])
   * 							end
   * 							if type(biome.spawn_plants) == "string" then
   * 								assert(loadstring(biome.spawn_plants.."(...)"))(pos)
   * 							elseif not biome.spawn_on_side and not biome.spawn_on_bottom and not biome.spawn_replace_node then
   * 								if n_top.name == "air" then
   * 									minetest.set_node(p_top, { name = plant_to_spawn, param2 = fdir })
   * 								end
   * 							elseif biome.spawn_replace_node then
   * 								minetest.set_node(pos, { name = plant_to_spawn, param2 = fdir })
   * 
   * 							elseif biome.spawn_on_side then
   * 								local onside = biome_lib:find_open_side(pos)
   * 								if onside then 
   * 									minetest.set_node(onside.newpos, { name = plant_to_spawn, param2 = onside.facedir })
   * 								end
   * 							elseif biome.spawn_on_bottom then
   * 								if minetest.get_node({x=pos.x, y=pos.y-1, z=pos.z}).name == "air" then
   * 									minetest.set_node({x=pos.x, y=pos.y-1, z=pos.z}, { name = plant_to_spawn, param2 = fdir} )
   * 								end
   * 							end
   * 						end
   * 					end
   * 				end
   * 			end
   * 		end
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,5);
  lua_pushliteral(L,"nodenames");
  lc_getupvalue(L,lc229,0,7);
  lua_pushliteral(L,"spawn_surfaces");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lc_getupvalue(L,lc229,0,7);
  lua_pushliteral(L,"interval");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lc_getupvalue(L,lc229,0,7);
  lua_pushliteral(L,"spawn_chance");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"neighbors");
  lc_getupvalue(L,lc229,0,7);
  lua_pushliteral(L,"neighbors");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushvalue(L,lc229);
  lua_pushcclosure(L,lcf288,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 8);
  return 0;
}


/* function(pos, node, active_object_count, active_object_count_wider) */
static int lcf309 (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local p_top = {x=pos.x, y=pos.y+1, z=pos.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 5);
  
  /* local p_bot = {x=pos.x, y=pos.y-1, z=pos.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 6);
  
  /* local n_top = minetest.get_node(p_top) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local n_bot = minetest.get_node(p_bot) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,6);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* local root_node = minetest.get_node({x=pos.x, y=pos.y-options.height_limit, z=pos.z}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),0,8);
  lua_pushliteral(L,"height_limit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* local walldir = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 10);
  
  /* if options.need_wall and options.verticals_list then */
  enum { lc293 = 10 };
  lc_getupvalue(L,lua_upvalueindex(1),0,8);
  lua_pushliteral(L,"need_wall");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,8);
    lua_pushliteral(L,"verticals_list");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc294 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc294) {
    
    /* walldir = biome_lib:find_adjacent_wall(p_top, options.verticals_list, options.choose_random_wall) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"find_adjacent_wall");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,5);
    lc_getupvalue(L,lua_upvalueindex(1),0,8);
    lua_pushliteral(L,"verticals_list");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lua_upvalueindex(1),0,8);
    lua_pushliteral(L,"choose_random_wall");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,4,1);
    lua_replace(L,10);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc293);
  assert(lua_gettop(L) == 10);
  
  /* if (n_top.name == "air" or n_top.name == "default:snow")
   * 			  and (not options.need_wall or (options.need_wall and walldir)) then */
  enum { lc295 = 10 };
  lua_pushliteral(L,"name");
  lua_gettable(L,7);
  lua_pushliteral(L,"air");
  const int lc296 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc296);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,7);
    lua_pushliteral(L,"default:snow");
    const int lc297 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc297);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,8);
    lua_pushliteral(L,"need_wall");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,8);
      lua_pushliteral(L,"need_wall");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
      }
    }
  }
  const int lc298 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc298) {
    
    /* -- corner case for changing short junglegrass
     * -- to dry shrub in desert
     * if n_bot.name == options.dry_early_node and options.grow_plant == "junglegrass:short" then */
    enum { lc299 = 10 };
    lua_pushliteral(L,"name");
    lua_gettable(L,8);
    lc_getupvalue(L,lua_upvalueindex(1),0,8);
    lua_pushliteral(L,"dry_early_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc300 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc300);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,8);
      lua_pushliteral(L,"grow_plant");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"junglegrass:short");
      const int lc301 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc301);
    }
    const int lc302 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc302) {
      
      /* minetest.set_node(pos, { name = "default:dry_shrub" }) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lua_pushliteral(L,"default:dry_shrub");
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 10);
    }
    else {
      
      /* elseif options.grow_vertically and walldir then */
      enum { lc303 = 10 };
      lc_getupvalue(L,lua_upvalueindex(1),0,8);
      lua_pushliteral(L,"grow_vertically");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
      }
      const int lc304 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc304) {
        
        /* if biome_lib:search_downward(pos, options.height_limit, options.ground_nodes) then */
        enum { lc305 = 10 };
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"search_downward");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,8);
        lua_pushliteral(L,"height_limit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_getupvalue(L,lua_upvalueindex(1),0,8);
        lua_pushliteral(L,"ground_nodes");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,4,1);
        const int lc306 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc306) {
          
          /* minetest.set_node(p_top, { name = options.grow_plant, param2 = walldir}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,5);
          lua_createtable(L,0,2);
          lua_pushliteral(L,"name");
          lc_getupvalue(L,lua_upvalueindex(1),0,8);
          lua_pushliteral(L,"grow_plant");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"param2");
          lua_pushvalue(L,10);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 10);
        }
        lua_settop(L,lc305);
        assert(lua_gettop(L) == 10);
      }
      else {
        
        /* elseif not options.grow_result and not options.grow_function then */
        enum { lc307 = 10 };
        lc_getupvalue(L,lua_upvalueindex(1),0,8);
        lua_pushliteral(L,"grow_result");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),0,8);
          lua_pushliteral(L,"grow_function");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc308 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc308) {
          
          /* minetest.remove_node(pos) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"remove_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 10);
        }
        else {
          
          /* else
           * biome_lib:replace_object(pos, options.grow_result, options.grow_function, options.facedir, options.seed_diff) */
          lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
          lua_pushliteral(L,"replace_object");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),0,8);
          lua_pushliteral(L,"grow_result");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lc_getupvalue(L,lua_upvalueindex(1),0,8);
          lua_pushliteral(L,"grow_function");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lc_getupvalue(L,lua_upvalueindex(1),0,8);
          lua_pushliteral(L,"facedir");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lc_getupvalue(L,lua_upvalueindex(1),0,8);
          lua_pushliteral(L,"seed_diff");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,6,0);
          assert(lua_gettop(L) == 10);
        }
        lua_settop(L,lc307);
      }
      lua_settop(L,lc303);
    }
    lua_settop(L,lc299);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc295);
  assert(lua_gettop(L) == 10);
  return 0;
}


/* name: biome_lib:grow_plants
 * function(opts) */
static int lcf1_biome_lib_grow_plants (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local options = opts */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc289 = 3 };
  assert((lua_gettop(L) == lc289));
  lua_pushvalue(L,2);
  lua_rawseti(L,lc289,8);
  assert(lua_gettop(L) == 3);
  
  /* options.height_limit = options.height_limit or 5 */
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"height_limit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,5);
  }
  lc_getupvalue(L,lc289,0,8);
  lua_insert(L,-2);
  lua_pushliteral(L,"height_limit");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* options.ground_nodes = options.ground_nodes or { "default:dirt_with_grass" } */
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"ground_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_rawseti(L,-2,1);
  }
  lc_getupvalue(L,lc289,0,8);
  lua_insert(L,-2);
  lua_pushliteral(L,"ground_nodes");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* options.grow_nodes = options.grow_nodes or { "default:dirt_with_grass" } */
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"grow_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_rawseti(L,-2,1);
  }
  lc_getupvalue(L,lc289,0,8);
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_nodes");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* options.seed_diff = options.seed_diff or 0 */
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"seed_diff");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lc_getupvalue(L,lc289,0,8);
  lua_insert(L,-2);
  lua_pushliteral(L,"seed_diff");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* if options.grow_delay*time_scale >= 1 then */
  enum { lc290 = 3 };
  lua_pushnumber(L,1);
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"grow_delay");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc289,2,5);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  const int lc291 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc291);
  const int lc292 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc292) {
    
    /* options.interval = options.grow_delay*time_scale */
    lc_getupvalue(L,lc289,0,8);
    lua_pushliteral(L,"grow_delay");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc289,2,5);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc289,0,8);
    lua_insert(L,-2);
    lua_pushliteral(L,"interval");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * options.interval = 1 */
    lua_pushnumber(L,1);
    lc_getupvalue(L,lc289,0,8);
    lua_insert(L,-2);
    lua_pushliteral(L,"interval");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc290);
  assert(lua_gettop(L) == 3);
  
  /* minetest.register_abm({
   * 		nodenames = { options.grow_plant },
   * 		interval = options.interval,
   * 		chance = options.grow_chance,
   * 		action = function(pos, node, active_object_count, active_object_count_wider)
   * 			local p_top = {x=pos.x, y=pos.y+1, z=pos.z}
   * 			local p_bot = {x=pos.x, y=pos.y-1, z=pos.z}
   * 			local n_top = minetest.get_node(p_top)
   * 			local n_bot = minetest.get_node(p_bot)
   * 			local root_node = minetest.get_node({x=pos.x, y=pos.y-options.height_limit, z=pos.z})
   * 			local walldir = nil
   * 			if options.need_wall and options.verticals_list then
   * 				walldir = biome_lib:find_adjacent_wall(p_top, options.verticals_list, options.choose_random_wall)
   * 			end
   * 			if (n_top.name == "air" or n_top.name == "default:snow")
   * 			  and (not options.need_wall or (options.need_wall and walldir)) then
   * 				-- corner case for changing short junglegrass
   * 				-- to dry shrub in desert
   * 				if n_bot.name == options.dry_early_node and options.grow_plant == "junglegrass:short" then
   * 					minetest.set_node(pos, { name = "default:dry_shrub" })
   * 
   * 				elseif options.grow_vertically and walldir then
   * 					if biome_lib:search_downward(pos, options.height_limit, options.ground_nodes) then
   * 						minetest.set_node(p_top, { name = options.grow_plant, param2 = walldir})
   * 					end
   * 
   * 				elseif not options.grow_result and not options.grow_function then
   * 					minetest.remove_node(pos)
   * 
   * 				else
   * 					biome_lib:replace_object(pos, options.grow_result, options.grow_function, options.facedir, options.seed_diff)
   * 				end
   * 			end
   * 		end
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,4);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,1,0);
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"grow_plant");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"interval");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lc_getupvalue(L,lc289,0,8);
  lua_pushliteral(L,"grow_chance");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushvalue(L,lc289);
  lua_pushcclosure(L,lcf309,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: biome_lib:replace_object
 * function(pos, replacement, grow_function, walldir, seeddiff) */
static int lcf1_biome_lib_replace_object (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* local growtype = type(grow_function) */
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* if growtype == "table" then */
  enum { lc310 = 7 };
  lua_pushliteral(L,"table");
  const int lc311 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc311);
  const int lc312 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc312) {
    
    /* minetest.remove_node(pos) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"remove_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 7);
    
    /* biome_lib:grow_tree(pos, grow_function) */
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_pushliteral(L,"grow_tree");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,2);
    lua_pushvalue(L,4);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 7);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 7);
  }
  else {
    
    /* elseif growtype == "function" then */
    enum { lc313 = 7 };
    lua_pushliteral(L,"function");
    const int lc314 = lua_equal(L,7,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc314);
    const int lc315 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc315) {
      
      /* local perlin_fertile_area = minetest.get_perlin(seeddiff, perlin_octaves, perlin_persistence, perlin_scale) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_perlin");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,6);
      lc_getupvalue(L,lua_upvalueindex(1),4,2);
      lc_getupvalue(L,lua_upvalueindex(1),3,3);
      lc_getupvalue(L,lua_upvalueindex(1),2,4);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 8);
      
      /* local noise1 = perlin_fertile_area:get2d({x=pos.x, y=pos.z}) */
      lua_pushvalue(L,8);
      lua_pushliteral(L,"get2d");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"z");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 9);
      
      /* local noise2 = biome_lib.perlin_temperature:get2d({x=pos.x, y=pos.z}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
      lua_pushliteral(L,"perlin_temperature");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"get2d");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"z");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 10);
      
      /* grow_function(pos,noise1,noise2,walldir) */
      lua_pushvalue(L,4);
      lua_pushvalue(L,2);
      lua_pushvalue(L,9);
      lua_pushvalue(L,10);
      lua_pushvalue(L,5);
      lua_call(L,4,0);
      assert(lua_gettop(L) == 10);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 10);
    }
    else {
      
      /* elseif growtype == "string" then */
      enum { lc316 = 7 };
      lua_pushliteral(L,"string");
      const int lc317 = lua_equal(L,7,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc317);
      const int lc318 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc318) {
        
        /* local perlin_fertile_area = minetest.get_perlin(seeddiff, perlin_octaves, perlin_persistence, perlin_scale) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_perlin");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lc_getupvalue(L,lua_upvalueindex(1),4,2);
        lc_getupvalue(L,lua_upvalueindex(1),3,3);
        lc_getupvalue(L,lua_upvalueindex(1),2,4);
        lua_call(L,4,1);
        assert(lua_gettop(L) == 8);
        
        /* local noise1 = perlin_fertile_area:get2d({x=pos.x, y=pos.z}) */
        lua_pushvalue(L,8);
        lua_pushliteral(L,"get2d");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"z");
        lua_gettable(L,2);
        lua_rawset(L,-3);
        lua_call(L,2,1);
        assert(lua_gettop(L) == 9);
        
        /* local noise2 = biome_lib.perlin_temperature:get2d({x=pos.x, y=pos.z}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
        lua_pushliteral(L,"perlin_temperature");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"get2d");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"z");
        lua_gettable(L,2);
        lua_rawset(L,-3);
        lua_call(L,2,1);
        assert(lua_gettop(L) == 10);
        
        /* assert(loadstring(grow_function.."(...)"))(pos,noise1,noise2,walldir) */
        lua_getfield(L,LUA_ENVIRONINDEX,"assert");
        const int lc319 = lua_gettop(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"loadstring");
        lua_pushvalue(L,4);
        lua_pushliteral(L,"(...)");
        lua_concat(L,2);
        lua_call(L,1,LUA_MULTRET);
        lua_call(L,(lua_gettop(L) - lc319),1);
        lua_pushvalue(L,2);
        lua_pushvalue(L,9);
        lua_pushvalue(L,10);
        lua_pushvalue(L,5);
        lua_call(L,4,0);
        assert(lua_gettop(L) == 10);
        
        /* return */
        return 0;
        assert(lua_gettop(L) == 10);
      }
      else {
        
        /* elseif growtype == "nil" then */
        enum { lc320 = 7 };
        lua_pushliteral(L,"nil");
        const int lc321 = lua_equal(L,7,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc321);
        const int lc322 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc322) {
          
          /* minetest.set_node(pos, { name = replacement, param2 = walldir}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,2);
          lua_createtable(L,0,2);
          lua_pushliteral(L,"name");
          lua_pushvalue(L,3);
          lua_rawset(L,-3);
          lua_pushliteral(L,"param2");
          lua_pushvalue(L,5);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 7);
          
          /* return */
          return 0;
          assert(lua_gettop(L) == 7);
        }
        else {
          
          /* elseif growtype ~= "nil" and growtype ~= "string" and growtype ~= "table" then */
          enum { lc323 = 7 };
          lua_pushliteral(L,"nil");
          const int lc324 = lua_equal(L,7,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc324);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"string");
            const int lc325 = lua_equal(L,7,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc325);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"table");
            const int lc326 = lua_equal(L,7,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc326);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          const int lc327 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc327) {
            
            /* error("Invalid grow function "..dump(grow_function).." used on object at ("..dump(pos)..")") */
            lua_getfield(L,LUA_ENVIRONINDEX,"error");
            lua_pushliteral(L,"Invalid grow function ");
            lua_getfield(L,LUA_ENVIRONINDEX,"dump");
            lua_pushvalue(L,4);
            lua_call(L,1,1);
            lua_pushliteral(L," used on object at (");
            lua_getfield(L,LUA_ENVIRONINDEX,"dump");
            lua_pushvalue(L,2);
            lua_call(L,1,1);
            lua_pushliteral(L,")");
            lua_concat(L,2);
            lua_concat(L,2);
            lua_concat(L,2);
            lua_concat(L,2);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 7);
          }
          lua_settop(L,lc323);
        }
        lua_settop(L,lc320);
      }
      lua_settop(L,lc316);
    }
    lua_settop(L,lc313);
  }
  lua_settop(L,lc310);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: biome_lib:find_adjacent_wall
 * function(pos, verticals, randomflag) */
static int lcf1_biome_lib_find_adjacent_wall (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local verts = dump(verticals) */
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* if randomflag then */
  enum { lc328 = 5 };
  if (lua_toboolean(L,4)) {
    
    /* local walltab = {} */
    lua_newtable(L);
    assert(lua_gettop(L) == 6);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x-1, y=pos.y, z=pos.z   }).name) then */
    enum { lc329 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc330 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc330) {
      
      /* walltab[#walltab + 1] = 3 */
      lua_pushnumber(L,3);
      const double lc331 = lua_objlen(L,6);
      lua_pushnumber(L,lc331);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc329);
    assert(lua_gettop(L) == 6);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x+1, y=pos.y, z=pos.z   }).name) then */
    enum { lc332 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc333 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc333) {
      
      /* walltab[#walltab + 1] = 2 */
      lua_pushnumber(L,2);
      const double lc334 = lua_objlen(L,6);
      lua_pushnumber(L,lc334);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc332);
    assert(lua_gettop(L) == 6);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z-1 }).name) then */
    enum { lc335 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc336 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc336) {
      
      /* walltab[#walltab + 1] = 5 */
      lua_pushnumber(L,5);
      const double lc337 = lua_objlen(L,6);
      lua_pushnumber(L,lc337);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc335);
    assert(lua_gettop(L) == 6);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z+1 }).name) then */
    enum { lc338 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc339 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc339) {
      
      /* walltab[#walltab + 1] = 4 */
      lua_pushnumber(L,4);
      const double lc340 = lua_objlen(L,6);
      lua_pushnumber(L,lc340);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,6);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc338);
    assert(lua_gettop(L) == 6);
    
    /* if #walltab > 0 then */
    enum { lc341 = 6 };
    lua_pushnumber(L,0);
    const double lc342 = lua_objlen(L,6);
    lua_pushnumber(L,lc342);
    const int lc343 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc343);
    const int lc344 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc344) {
      
      /* return walltab[math.random(1, #walltab)] */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      const double lc345 = lua_objlen(L,6);
      lua_pushnumber(L,lc345);
      lua_call(L,2,1);
      lua_gettable(L,6);
      return 1;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc341);
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* else
     * if string.find(verts, minetest.get_node({ x=pos.x-1, y=pos.y, z=pos.z   }).name) then */
    enum { lc346 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc347 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc347) {
      
      /* return 3 */
      lua_pushnumber(L,3);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc346);
    assert(lua_gettop(L) == 5);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x+1, y=pos.y, z=pos.z   }).name) then */
    enum { lc348 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc349 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc349) {
      
      /* return 2 */
      lua_pushnumber(L,2);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc348);
    assert(lua_gettop(L) == 5);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z-1 }).name) then */
    enum { lc350 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc351 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc351) {
      
      /* return 5 */
      lua_pushnumber(L,5);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc350);
    assert(lua_gettop(L) == 5);
    
    /* if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z+1 }).name) then */
    enum { lc352 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc353 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc353) {
      
      /* return 4 */
      lua_pushnumber(L,4);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc352);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc328);
  assert(lua_gettop(L) == 5);
  
  /* return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: biome_lib:search_downward
 * function(pos, heightlimit, ground) */
static int lcf1_biome_lib_search_downward (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* for i = 0, heightlimit do */
  lua_pushnumber(L,0);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,3)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc354_var = lua_tonumber(L,-1);
  const double lc355_limit = lua_tonumber(L,3);
  const double lc356_step = 1;
  lua_pop(L,1);
  enum { lc357 = 4 };
  while ((((lc356_step > 0) && (lc354_var <= lc355_limit)) || ((lc356_step <= 0) && (lc354_var >= lc355_limit)))) {
    
    /* internal: local i at index 5 */
    lua_pushnumber(L,lc354_var);
    
    /* if string.find(dump(ground), minetest.get_node({x=pos.x, y=pos.y-i, z = pos.z}).name) then */
    enum { lc358 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"dump");
    lua_pushvalue(L,4);
    lua_call(L,1,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lc_sub(L,-1,5);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc359 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc359) {
      
      /* return {x=pos.x, y=pos.y-i, z = pos.z} */
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,2);
      lc_sub(L,-1,5);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc358);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc354_var += lc356_step;
  }
  lua_settop(L,lc357);
  assert(lua_gettop(L) == 4);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: biome_lib:find_open_side
 * function(pos) */
static int lcf1_biome_lib_find_open_side (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if minetest.get_node({ x=pos.x-1, y=pos.y, z=pos.z }).name == "air" then */
  enum { lc360 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  const int lc361 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc361);
  const int lc362 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc362) {
    
    /* return {newpos = { x=pos.x-1, y=pos.y, z=pos.z }, facedir = 2} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"newpos");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"facedir");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc360);
  assert(lua_gettop(L) == 2);
  
  /* if minetest.get_node({ x=pos.x+1, y=pos.y, z=pos.z }).name == "air" then */
  enum { lc363 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  const int lc364 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc364);
  const int lc365 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc365) {
    
    /* return {newpos = { x=pos.x+1, y=pos.y, z=pos.z }, facedir = 3} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"newpos");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"facedir");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc363);
  assert(lua_gettop(L) == 2);
  
  /* if minetest.get_node({ x=pos.x, y=pos.y, z=pos.z-1 }).name == "air" then */
  enum { lc366 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  const int lc367 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc367);
  const int lc368 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc368) {
    
    /* return {newpos = { x=pos.x, y=pos.y, z=pos.z-1 }, facedir = 4} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"newpos");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"facedir");
    lua_pushnumber(L,4);
    lua_rawset(L,-3);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc366);
  assert(lua_gettop(L) == 2);
  
  /* if minetest.get_node({ x=pos.x, y=pos.y, z=pos.z+1 }).name == "air" then */
  enum { lc369 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  const int lc370 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc370);
  const int lc371 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc371) {
    
    /* return {newpos = { x=pos.x, y=pos.y, z=pos.z+1 }, facedir = 5} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"newpos");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"facedir");
    lua_pushnumber(L,5);
    lua_rawset(L,-3);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc369);
  assert(lua_gettop(L) == 2);
  
  /* return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* name: biome_lib:generate_tree
 * function(pos, nodes_or_function_or_model) */
static int lcf1_biome_lib_generate_tree (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* minetest.spawn_tree(pos, nodes_or_function_or_model) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"spawn_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: biome_lib:grow_tree
 * function(pos, nodes_or_function_or_model) */
static int lcf1_biome_lib_grow_tree (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* minetest.spawn_tree(pos, nodes_or_function_or_model) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"spawn_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: biome_lib:get_nodedef_field
 * function(nodename, fieldname) */
static int lcf1_biome_lib_get_nodedef_field (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if not minetest.registered_nodes[nodename] then */
  enum { lc374 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc375 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc375) {
    
    /* return nil */
    lua_pushnil(L);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc374);
  assert(lua_gettop(L) == 3);
  
  /* return minetest.registered_nodes[nodename][fieldname] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* function() */
static int lcf380 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* print("[Biome Lib] Registered a total of "..(#biome_lib.surfaceslist_aircheck)+(#biome_lib.surfaceslist_no_aircheck).." surface types to be evaluated, spread") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"[Biome Lib] Registered a total of ");
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"surfaceslist_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc376 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc376);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"surfaceslist_no_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc377 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc377);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L," surface types to be evaluated, spread");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 0);
  
  /* print("[Biome Lib] across "..#biome_lib.actionslist_aircheck.." actions with air-checking and "..#biome_lib.actionslist_no_aircheck.." actions without.") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"[Biome Lib] across ");
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"actionslist_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc378 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc378);
  lua_pushliteral(L," actions with air-checking and ");
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_pushliteral(L,"actionslist_no_aircheck");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc379 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc379);
  lua_pushliteral(L," actions without.");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,26);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- Plantlife library mod by Vanessa Ezekowitz
   * --
   * -- License:  WTFPL
   * --
   * -- I got the temperature map idea from "hmmmm", values used for it came from
   * -- Splizard's snow mod.
   * --
   * -- Various settings - most of these probably won't need to be changed
   * biome_lib = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"biome_lib");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* plantslib = setmetatable({}, { __index=function(t,k) print("Use of deprecated function:", k) return biome_lib[k] end }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"setmetatable");
  lua_newtable(L);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"__index");
  lua_pushcfunction(L,lcf1);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_setfield(L,LUA_ENVIRONINDEX,"plantslib");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.blocklist_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"blocklist_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.blocklist_no_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"blocklist_no_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.surface_nodes_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"surface_nodes_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.surface_nodes_no_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"surface_nodes_no_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.surfaceslist_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"surfaceslist_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.surfaceslist_no_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"surfaceslist_no_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.actioncount_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"actioncount_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.actioncount_no_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"actioncount_no_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.actionslist_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"actionslist_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.actionslist_no_aircheck = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"actionslist_no_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.modpath = minetest.get_modpath("biome_lib") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"biome_lib");
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"modpath");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* biome_lib.total_no_aircheck_calls = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"total_no_aircheck_calls");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- Boilerplate to support localized strings if intllib mod is installed.
   * local S */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* if minetest.get_modpath("intllib") then */
  enum { lc2 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"intllib");
  lua_call(L,1,1);
  const int lc3 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc3) {
    
    /* S = intllib.Getter() */
    lua_getfield(L,LUA_ENVIRONINDEX,"intllib");
    lua_pushliteral(L,"Getter");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_replace(L,(1 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  else {
    
    /* else
     * S = function(s) return s end */
    lua_pushcfunction(L,lcf1_S);
    lua_replace(L,(1 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* biome_lib.intllib = S */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"intllib");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local DEBUG = false */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc4 = 2 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_pushboolean(L,0);
  lua_rawseti(L,(lc4 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* --... except if you want to spam the console with debugging info :-)
   * function biome_lib:dbg(msg)
   * 	if DEBUG then
   * 		print("[Plantlife] "..msg)
   * 		minetest.log("verbose", "[Plantlife] "..msg)
   * 	end
   * end */
  lua_pushvalue(L,(lc4 + lc_nextra));
  lua_pushcclosure(L,lcf1_biome_lib_dbg,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"dbg");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* biome_lib.plantlife_seed_diff = 329 */
  lua_pushnumber(L,329);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"plantlife_seed_diff");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- needs to be global so other mods can see it
   * local perlin_octaves = 3 */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc7 = 3 };
  assert((lua_gettop(L) == (lc7 + lc_nextra)));
  lua_pushnumber(L,3);
  lua_rawseti(L,(lc7 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local perlin_persistence = 0.6 */
  lc_newclosuretable(L,(lc7 + lc_nextra));
  enum { lc8 = 4 };
  assert((lua_gettop(L) == (lc8 + lc_nextra)));
  lua_pushnumber(L,0.6);
  lua_rawseti(L,(lc8 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local perlin_scale = 100 */
  lc_newclosuretable(L,(lc8 + lc_nextra));
  enum { lc9 = 5 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_pushnumber(L,100);
  lua_rawseti(L,(lc9 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local temperature_seeddiff = 112 */
  lua_pushnumber(L,112);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local temperature_octaves = 3 */
  lua_pushnumber(L,3);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* local temperature_persistence = 0.5 */
  lua_pushnumber(L,0.5);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local temperature_scale = 150 */
  lua_pushnumber(L,150);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* local humidity_seeddiff = 9130 */
  lua_pushnumber(L,9130);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* local humidity_octaves = 3 */
  lua_pushnumber(L,3);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local humidity_persistence = 0.5 */
  lua_pushnumber(L,0.5);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* local humidity_scale = 250 */
  lua_pushnumber(L,250);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* local time_scale = 1 */
  lc_newclosuretable(L,(lc9 + lc_nextra));
  enum { lc10 = 14 };
  assert((lua_gettop(L) == (lc10 + lc_nextra)));
  lua_pushnumber(L,1);
  lua_rawseti(L,(lc10 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* local time_speed = tonumber(minetest.setting_get("time_speed")) */
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  const int lc11 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_get");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"time_speed");
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc11),1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* if time_speed and time_speed > 0 then */
  enum { lc12 = 15 };
  lua_pushvalue(L,(15 + lc_nextra));
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
    const int lc13 = lua_lessthan(L,-1,(15 + lc_nextra));
    lua_pop(L,1);
    lua_pushboolean(L,lc13);
  }
  const int lc14 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc14) {
    
    /* time_scale = 72 / time_speed */
    lua_pushnumber(L,72);
    lc_div(L,-1,(15 + lc_nextra));
    lua_remove(L,-2);
    lc_setupvalue(L,(lc10 + lc_nextra),0,5);
    assert(lua_gettop(L) - lc_nextra == 15);
  }
  lua_settop(L,(lc12 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* --PerlinNoise(seed, octaves, persistence, scale)
   * biome_lib.perlin_temperature = PerlinNoise(temperature_seeddiff, temperature_octaves, temperature_persistence, temperature_scale) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PerlinNoise");
  lua_pushvalue(L,(6 + lc_nextra));
  lua_pushvalue(L,(7 + lc_nextra));
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushvalue(L,(9 + lc_nextra));
  lua_call(L,4,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"perlin_temperature");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* biome_lib.perlin_humidity = PerlinNoise(humidity_seeddiff, humidity_octaves, humidity_persistence, humidity_scale) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PerlinNoise");
  lua_pushvalue(L,(10 + lc_nextra));
  lua_pushvalue(L,(11 + lc_nextra));
  lua_pushvalue(L,(12 + lc_nextra));
  lua_pushvalue(L,(13 + lc_nextra));
  lua_call(L,4,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"perlin_humidity");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* -- Local functions
   * function biome_lib:is_node_loaded(node_pos)
   * 	local n = minetest.get_node_or_nil(node_pos)
   * 	if (not n) or (n.name == "ignore") then
   * 		return false
   * 	end
   * 	return true
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_is_node_loaded);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"is_node_loaded");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* function biome_lib:set_defaults(biome)
   * 	biome.seed_diff = biome.seed_diff or 0
   * 	biome.min_elevation = biome.min_elevation or -31000
   * 	biome.max_elevation = biome.max_elevation or 31000
   * 	biome.temp_min = biome.temp_min or 1
   * 	biome.temp_max = biome.temp_max or -1
   * 	biome.humidity_min = biome.humidity_min or 1
   * 	biome.humidity_max = biome.humidity_max or -1
   * 	biome.plantlife_limit = biome.plantlife_limit or 0.1
   * 	biome.near_nodes_vertical = biome.near_nodes_vertical or 1
   * 
   * -- specific to on-generate
   * 
   * 	biome.neighbors = biome.neighbors or biome.surface
   * 	biome.near_nodes_size = biome.near_nodes_size or 0
   * 	biome.near_nodes_count = biome.near_nodes_count or 1
   * 	biome.rarity = biome.rarity or 50
   * 	biome.max_count = biome.max_count or 5
   * 	if biome.check_air ~= false then biome.check_air = true end
   * 
   * -- specific to abm spawner
   * 	biome.seed_diff = biome.seed_diff or 0
   * 	biome.light_min = biome.light_min or 0
   * 	biome.light_max = biome.light_max or 15
   * 	biome.depth_max = biome.depth_max or 1
   * 	biome.facedir = biome.facedir or 0
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_set_defaults);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"set_defaults");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* local function search_table(t, s)
   * 	for i = 1, #t do
   * 		if t[i] == s then return true end
   * 	end
   * 	return false
   * end */
  lc_newclosuretable(L,(lc10 + lc_nextra));
  enum { lc21 = 16 };
  assert((lua_gettop(L) == (lc21 + lc_nextra)));
  lua_pushcfunction(L,lcf1_search_table);
  lua_rawseti(L,(lc21 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- register the list of surfaces to spawn stuff on, filtering out all duplicates.
   * -- separate the items by air-checking or non-air-checking map eval methods
   * function biome_lib:register_generate_plant(biomedef, nodes_or_function_or_model)
   * 
   * 	-- if calling code passes an undefined node for a surface or 
   * 	-- as a node to be spawned, don't register an action for it.
   * 
   * 	if type(nodes_or_function_or_model) == "string"
   * 	  and string.find(nodes_or_function_or_model, ":")
   * 	  and not minetest.registered_nodes[nodes_or_function_or_model] then
   * 		biome_lib:dbg("Warning: Ignored registration for undefined spawn node: "..dump(nodes_or_function_or_model))
   * 		return
   * 	end
   * 
   * 	if type(nodes_or_function_or_model) == "string"
   * 	  and not string.find(nodes_or_function_or_model, ":") then
   * 		biome_lib:dbg("Warning: Registered function call using deprecated string method: "..dump(nodes_or_function_or_model))
   * 	end
   * 
   * 	if biomedef.check_air == false then 
   * 		biome_lib:dbg("Register no-air-check mapgen hook: "..dump(nodes_or_function_or_model))
   * 		biome_lib.actionslist_no_aircheck[#biome_lib.actionslist_no_aircheck + 1] = { biomedef, nodes_or_function_or_model }
   * 		local s = biomedef.surface
   * 		if type(s) == "string" then
   * 			if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then
   * 				if not search_table(biome_lib.surfaceslist_no_aircheck, s) then
   * 					biome_lib.surfaceslist_no_aircheck[#biome_lib.surfaceslist_no_aircheck + 1] = s
   * 				end
   * 			else
   * 				biome_lib:dbg("Warning: Ignored no-air-check registration for undefined surface node: "..dump(s))
   * 			end
   * 		else
   * 			for i = 1, #biomedef.surface do
   * 				local s = biomedef.surface[i]
   * 				if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then
   * 					if not search_table(biome_lib.surfaceslist_no_aircheck, s) then
   * 						biome_lib.surfaceslist_no_aircheck[#biome_lib.surfaceslist_no_aircheck + 1] = s
   * 					end
   * 				else
   * 					biome_lib:dbg("Warning: Ignored no-air-check registration for undefined surface node: "..dump(s))
   * 				end
   * 			end
   * 		end
   * 	else
   * 		biome_lib:dbg("Register with-air-checking mapgen hook: "..dump(nodes_or_function_or_model))
   * 		biome_lib.actionslist_aircheck[#biome_lib.actionslist_aircheck + 1] = { biomedef, nodes_or_function_or_model }
   * 		local s = biomedef.surface
   * 		if type(s) == "string" then
   * 			if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then
   * 				if not search_table(biome_lib.surfaceslist_aircheck, s) then
   * 					biome_lib.surfaceslist_aircheck[#biome_lib.surfaceslist_aircheck + 1] = s
   * 				end
   * 			else
   * 				biome_lib:dbg("Warning: Ignored with-air-checking registration for undefined surface node: "..dump(s))
   * 			end
   * 		else
   * 			for i = 1, #biomedef.surface do
   * 				local s = biomedef.surface[i]
   * 				if s and (string.find(s, "^group:") or minetest.registered_nodes[s]) then
   * 					if not search_table(biome_lib.surfaceslist_aircheck, s) then
   * 						biome_lib.surfaceslist_aircheck[#biome_lib.surfaceslist_aircheck + 1] = s
   * 					end
   * 				else
   * 					biome_lib:dbg("Warning: Ignored with-air-checking registration for undefined surface node: "..dump(s))
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushvalue(L,(lc21 + lc_nextra));
  lua_pushcclosure(L,lcf1_biome_lib_register_generate_plant,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_generate_plant");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* function biome_lib:populate_surfaces(biome, nodes_or_function_or_model, snodes, checkair)
   * 
   * 	biome_lib:set_defaults(biome)
   * 
   * 	-- filter stage 1 - find nodes from the supplied surfaces that are within the current biome.
   * 
   * 	local in_biome_nodes = {}
   * 	local perlin_fertile_area = minetest.get_perlin(biome.seed_diff, perlin_octaves, perlin_persistence, perlin_scale)
   * 
   * 	for i = 1, #snodes do
   * 		local pos = snodes[i]
   * 		local p_top = { x = pos.x, y = pos.y + 1, z = pos.z }
   * 		local noise1 = perlin_fertile_area:get2d({x=pos.x, y=pos.z})
   * 		local noise2 = biome_lib.perlin_temperature:get2d({x=pos.x, y=pos.z})
   * 		local noise3 = biome_lib.perlin_humidity:get2d({x=pos.x+150, y=pos.z+50})
   * 		local biome_surfaces_string = dump(biome.surface)
   * 		local surface_ok = false
   * 
   * 		if not biome.depth then
   * 			local dest_node = minetest.get_node(pos)
   * 			if string.find(biome_surfaces_string, dest_node.name) then
   * 				surface_ok = true
   * 			else
   * 				if string.find(biome_surfaces_string, "group:") then
   * 					for j = 1, #biome.surface do
   * 						if string.find(biome.surface[j], "^group:") 
   * 						  and minetest.get_item_group(dest_node.name, biome.surface[j]) then
   * 							surface_ok = true
   * 							break
   * 						end
   * 					end
   * 				end
   * 			end
   * 		elseif not string.find(biome_surfaces_string, minetest.get_node({ x = pos.x, y = pos.y-biome.depth-1, z = pos.z }).name) then
   * 			surface_ok = true
   * 		end
   * 
   * 		if surface_ok
   * 		  and (not checkair or minetest.get_node(p_top).name == "air")
   * 		  and pos.y >= biome.min_elevation
   * 		  and pos.y <= biome.max_elevation
   * 		  and noise1 > biome.plantlife_limit
   * 		  and noise2 <= biome.temp_min
   * 		  and noise2 >= biome.temp_max
   * 		  and noise3 <= biome.humidity_min
   * 		  and noise3 >= biome.humidity_max
   * 		  and (not biome.ncount or #(minetest.find_nodes_in_area({x=pos.x-1, y=pos.y, z=pos.z-1}, {x=pos.x+1, y=pos.y, z=pos.z+1}, biome.neighbors)) > biome.ncount)
   * 		  and (not biome.near_nodes or #(minetest.find_nodes_in_area({x=pos.x-biome.near_nodes_size, y=pos.y-biome.near_nodes_vertical, z=pos.z-biome.near_nodes_size}, {x=pos.x+biome.near_nodes_size, y=pos.y+biome.near_nodes_vertical, z=pos.z+biome.near_nodes_size}, biome.near_nodes)) >= biome.near_nodes_count)
   * 		  and math.random(1,100) > biome.rarity
   * 		  and (not biome.below_nodes or string.find(dump(biome.below_nodes), minetest.get_node({x=pos.x, y=pos.y-1, z=pos.z}).name) )
   * 		  then
   * 			in_biome_nodes[#in_biome_nodes + 1] = pos
   * 		end
   * 	end
   * 
   * 	-- filter stage 2 - find places within that biome area to place the plants.
   * 
   * 	local num_in_biome_nodes = #in_biome_nodes
   * 
   * 	if num_in_biome_nodes > 0 then
   * 		for i = 1, math.min(biome.max_count, num_in_biome_nodes) do
   * 			local tries = 0
   * 			local spawned = false
   * 			while tries < 2 and not spawned do
   * 				local pos = in_biome_nodes[math.random(1, num_in_biome_nodes)]
   * 				if biome.spawn_replace_node then
   * 					pos.y = pos.y-1
   * 				end
   * 				local p_top = { x = pos.x, y = pos.y + 1, z = pos.z }
   * 
   * 				if not (biome.avoid_nodes and biome.avoid_radius and minetest.find_node_near(p_top, biome.avoid_radius + math.random(-1.5,2), biome.avoid_nodes)) then
   * 					if biome.delete_above then
   * 						minetest.remove_node(p_top)
   * 						minetest.remove_node({x=p_top.x, y=p_top.y+1, z=p_top.z})
   * 					end
   * 
   * 					if biome.delete_above_surround then
   * 						minetest.remove_node({x=p_top.x-1, y=p_top.y, z=p_top.z})
   * 						minetest.remove_node({x=p_top.x+1, y=p_top.y, z=p_top.z})
   * 						minetest.remove_node({x=p_top.x,   y=p_top.y, z=p_top.z-1})
   * 						minetest.remove_node({x=p_top.x,   y=p_top.y, z=p_top.z+1})
   * 
   * 						minetest.remove_node({x=p_top.x-1, y=p_top.y+1, z=p_top.z})
   * 						minetest.remove_node({x=p_top.x+1, y=p_top.y+1, z=p_top.z})
   * 						minetest.remove_node({x=p_top.x,   y=p_top.y+1, z=p_top.z-1})
   * 						minetest.remove_node({x=p_top.x,   y=p_top.y+1, z=p_top.z+1})
   * 					end
   * 
   * 					if biome.spawn_replace_node then
   * 						minetest.remove_node(pos)
   * 					end
   * 
   * 					local objtype = type(nodes_or_function_or_model)
   * 
   * 					if objtype == "table" then
   * 						if nodes_or_function_or_model.axiom then
   * 							biome_lib:generate_tree(p_top, nodes_or_function_or_model)
   * 							spawned = true
   * 						else
   * 							local fdir = nil
   * 							if biome.random_facedir then
   * 								fdir = math.random(biome.random_facedir[1], biome.random_facedir[2])
   * 							end
   * 							minetest.set_node(p_top, { name = nodes_or_function_or_model[math.random(#nodes_or_function_or_model)], param2 = fdir })
   * 							spawned = true
   * 						end
   * 					elseif objtype == "string" and
   * 					  minetest.registered_nodes[nodes_or_function_or_model] then
   * 						local fdir = nil
   * 						if biome.random_facedir then
   * 							fdir = math.random(biome.random_facedir[1], biome.random_facedir[2])
   * 						end
   * 						minetest.set_node(p_top, { name = nodes_or_function_or_model, param2 = fdir })
   * 						spawned = true
   * 					elseif objtype == "function" then
   * 						nodes_or_function_or_model(pos)
   * 						spawned = true
   * 					elseif objtype == "string" and pcall(loadstring(("return %s(...)"):
   * 						format(nodes_or_function_or_model)),pos) then
   * 						spawned = true
   * 					else
   * 						biome_lib:dbg("Warning: Ignored invalid definition for object "..dump(nodes_or_function_or_model).." that was pointed at {"..dump(pos).."}")
   * 					end
   * 				else
   * 					tries = tries + 1
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushvalue(L,(lc21 + lc_nextra));
  lua_pushcclosure(L,lcf1_biome_lib_populate_surfaces,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"populate_surfaces");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- Primary mapgen spawner, for mods that can work with air checking enabled on
   * -- a surface during the initial map read stage.
   * function biome_lib:generate_block_with_air_checking()
   * 	if #biome_lib.blocklist_aircheck > 0 then
   * 
   * 		local minp =		biome_lib.blocklist_aircheck[1][1]
   * 		local maxp =		biome_lib.blocklist_aircheck[1][2]
   * 
   * 		-- use the block hash as a unique key into the surface nodes
   * 		-- tables, so that we can write the tables thread-safely.
   * 
   * 		local blockhash =	minetest.hash_node_position(minp)
   * 
   * 		if not biome_lib.surface_nodes_aircheck.blockhash then
   * 
   * 			if type(minetest.find_nodes_in_area_under_air) == "function" then -- use newer API call
   * 				biome_lib.surface_nodes_aircheck.blockhash =
   * 					minetest.find_nodes_in_area_under_air(minp, maxp, biome_lib.surfaceslist_aircheck)
   * 			else
   * 				local search_area = minetest.find_nodes_in_area(minp, maxp, biome_lib.surfaceslist_aircheck)
   * 
   * 				-- search the generated block for air-bounded surfaces the slow way.
   * 
   * 				biome_lib.surface_nodes_aircheck.blockhash = {}
   * 
   * 				for i = 1, #search_area do
   * 				local pos = search_area[i]
   * 					local p_top = { x=pos.x, y=pos.y+1, z=pos.z }
   * 					if minetest.get_node(p_top).name == "air" then
   * 						biome_lib.surface_nodes_aircheck.blockhash[#biome_lib.surface_nodes_aircheck.blockhash + 1] = pos
   * 					end
   * 				end
   * 			end
   * 			biome_lib.actioncount_aircheck.blockhash = 1
   * 
   * 		else
   * 			if biome_lib.actioncount_aircheck.blockhash <= #biome_lib.actionslist_aircheck then
   * 				-- [1] is biome, [2] is node/function/model
   * 				biome_lib:populate_surfaces(
   * 					biome_lib.actionslist_aircheck[biome_lib.actioncount_aircheck.blockhash][1],
   * 					biome_lib.actionslist_aircheck[biome_lib.actioncount_aircheck.blockhash][2],
   * 					biome_lib.surface_nodes_aircheck.blockhash, true)
   * 				biome_lib.actioncount_aircheck.blockhash = biome_lib.actioncount_aircheck.blockhash + 1
   * 			else
   * 				if biome_lib.surface_nodes_aircheck.blockhash then
   * 					table.remove(biome_lib.blocklist_aircheck, 1)
   * 					biome_lib.surface_nodes_aircheck.blockhash = nil
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_generate_block_with_air_checking);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"generate_block_with_air_checking");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- Secondary mapgen spawner, for mods that require disabling of
   * -- checking for air during the initial map read stage.
   * function biome_lib:generate_block_no_aircheck()
   * 	if #biome_lib.blocklist_no_aircheck > 0 then
   * 
   * 		local minp =		biome_lib.blocklist_no_aircheck[1][1]
   * 		local maxp =		biome_lib.blocklist_no_aircheck[1][2]
   * 
   * 		local blockhash =	minetest.hash_node_position(minp)
   * 
   * 		if not biome_lib.surface_nodes_no_aircheck.blockhash then
   * 
   * 			-- directly read the block to be searched into the chunk cache
   * 
   * 			biome_lib.surface_nodes_no_aircheck.blockhash =
   * 				minetest.find_nodes_in_area(minp, maxp, biome_lib.surfaceslist_no_aircheck)
   * 			biome_lib.actioncount_no_aircheck.blockhash = 1
   * 
   * 		else
   * 			if biome_lib.actioncount_no_aircheck.blockhash <= #biome_lib.actionslist_no_aircheck then
   * 				biome_lib:populate_surfaces(
   * 					biome_lib.actionslist_no_aircheck[biome_lib.actioncount_no_aircheck.blockhash][1],
   * 					biome_lib.actionslist_no_aircheck[biome_lib.actioncount_no_aircheck.blockhash][2],
   * 					biome_lib.surface_nodes_no_aircheck.blockhash, false)
   * 				biome_lib.actioncount_no_aircheck.blockhash = biome_lib.actioncount_no_aircheck.blockhash + 1
   * 			else
   * 				if biome_lib.surface_nodes_no_aircheck.blockhash then
   * 					table.remove(biome_lib.blocklist_no_aircheck, 1)
   * 					biome_lib.surface_nodes_no_aircheck.blockhash = nil
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_generate_block_no_aircheck);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"generate_block_no_aircheck");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- "Record" the chunks being generated by the core mapgen
   * minetest.register_on_generated(function(minp, maxp, blockseed)
   * 	biome_lib.blocklist_aircheck[#biome_lib.blocklist_aircheck + 1] = { minp, maxp }
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_generated");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf190);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* minetest.register_on_generated(function(minp, maxp, blockseed)
   * 	biome_lib.blocklist_no_aircheck[#biome_lib.blocklist_no_aircheck + 1] = { minp, maxp }
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_generated");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf192);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- "Play" them back, populating them with new stuff in the process
   * minetest.register_globalstep(function(dtime)
   * 	if dtime < 0.2 and    -- don't attempt to populate if lag is already too high
   * 	  (#biome_lib.blocklist_aircheck > 0 or #biome_lib.blocklist_no_aircheck > 0) then
   * 		biome_lib.globalstep_start_time = minetest.get_us_time()
   * 		biome_lib.globalstep_runtime = 0
   * 		while (#biome_lib.blocklist_aircheck > 0 or #biome_lib.blocklist_no_aircheck > 0)
   * 		  and biome_lib.globalstep_runtime < 200000 do  -- 0.2 seconds, in uS.
   * 			if #biome_lib.blocklist_aircheck > 0 then
   * 				biome_lib:generate_block_with_air_checking()
   * 			end
   * 			if #biome_lib.blocklist_no_aircheck > 0 then
   * 				biome_lib:generate_block_no_aircheck()
   * 			end
   * 			biome_lib.globalstep_runtime = minetest.get_us_time() - biome_lib.globalstep_start_time
   * 		end
   * 	end
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_globalstep");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf214);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- Play out the entire log all at once on shutdown
   * -- to prevent unpopulated map areas
   * minetest.register_on_shutdown(function()
   * 	print("[biome_lib] Stand by, playing out the rest of the aircheck mapblock log")
   * 	print("(there are "..#biome_lib.blocklist_aircheck.." entries)...")
   * 	while true do
   * 		biome_lib:generate_block_with_air_checking(0.1)
   * 		if #biome_lib.blocklist_aircheck == 0 then return end
   * 	end
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_shutdown");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf221);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* minetest.register_on_shutdown(function()
   * 	print("[biome_lib] Stand by, playing out the rest of the no-aircheck mapblock log")
   * 	print("(there are "..#biome_lib.blocklist_no_aircheck.." entries)...")
   * 	while true do
   * 		biome_lib:generate_block_no_aircheck(0.1)
   * 		if #biome_lib.blocklist_no_aircheck == 0 then return end
   * 	end
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_shutdown");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf228);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- The spawning ABM
   * function biome_lib:spawn_on_surfaces(sd,sp,sr,sc,ss,sa)
   * 
   * 	local biome = {}
   * 
   * 	if type(sd) ~= "table" then
   * 		biome.spawn_delay = sd	-- old api expects ABM interval param here.
   * 		biome.spawn_plants = {sp}
   * 		biome.avoid_radius = sr
   * 		biome.spawn_chance = sc
   * 		biome.spawn_surfaces = {ss}
   * 		biome.avoid_nodes = sa
   * 	else
   * 		biome = sd
   * 	end
   * 
   * 	if biome.spawn_delay*time_scale >= 1 then
   * 		biome.interval = biome.spawn_delay*time_scale
   * 	else
   * 		biome.interval = 1
   * 	end
   * 
   * 	biome_lib:set_defaults(biome)
   * 	biome.spawn_plants_count = #(biome.spawn_plants)
   * 
   * 	minetest.register_abm({
   * 		nodenames = biome.spawn_surfaces,
   * 		interval = biome.interval,
   * 		chance = biome.spawn_chance,
   * 		neighbors = biome.neighbors,
   * 		action = function(pos, node, active_object_count, active_object_count_wider)
   * 			local p_top = { x = pos.x, y = pos.y + 1, z = pos.z }	
   * 			local n_top = minetest.get_node(p_top)
   * 			local perlin_fertile_area = minetest.get_perlin(biome.seed_diff, perlin_octaves, perlin_persistence, perlin_scale)
   * 			local noise1 = perlin_fertile_area:get2d({x=p_top.x, y=p_top.z})
   * 			local noise2 = biome_lib.perlin_temperature:get2d({x=p_top.x, y=p_top.z})
   * 			local noise3 = biome_lib.perlin_humidity:get2d({x=p_top.x+150, y=p_top.z+50})
   * 			if noise1 > biome.plantlife_limit 
   * 			  and noise2 <= biome.temp_min
   * 			  and noise2 >= biome.temp_max
   * 			  and noise3 <= biome.humidity_min
   * 			  and noise3 >= biome.humidity_max
   * 			  and biome_lib:is_node_loaded(p_top) then
   * 				local n_light = minetest.get_node_light(p_top, nil)
   * 				if not (biome.avoid_nodes and biome.avoid_radius and minetest.find_node_near(p_top, biome.avoid_radius + math.random(-1.5,2), biome.avoid_nodes))
   * 				  and n_light >= biome.light_min
   * 				  and n_light <= biome.light_max
   * 				  and (not(biome.neighbors and biome.ncount) or #(minetest.find_nodes_in_area({x=pos.x-1, y=pos.y, z=pos.z-1}, {x=pos.x+1, y=pos.y, z=pos.z+1}, biome.neighbors)) > biome.ncount )
   * 				  and (not(biome.near_nodes and biome.near_nodes_count and biome.near_nodes_size) or #(minetest.find_nodes_in_area({x=pos.x-biome.near_nodes_size, y=pos.y-biome.near_nodes_vertical, z=pos.z-biome.near_nodes_size}, {x=pos.x+biome.near_nodes_size, y=pos.y+biome.near_nodes_vertical, z=pos.z+biome.near_nodes_size}, biome.near_nodes)) >= biome.near_nodes_count)
   * 				  and (not(biome.air_count and biome.air_size) or #(minetest.find_nodes_in_area({x=p_top.x-biome.air_size, y=p_top.y, z=p_top.z-biome.air_size}, {x=p_top.x+biome.air_size, y=p_top.y, z=p_top.z+biome.air_size}, "air")) >= biome.air_count)
   * 				  and pos.y >= biome.min_elevation
   * 				  and pos.y <= biome.max_elevation
   * 				  then
   * 					local walldir = biome_lib:find_adjacent_wall(p_top, biome.verticals_list, biome.choose_random_wall)
   * 					if biome.alt_wallnode and walldir then
   * 						if n_top.name == "air" then
   * 							minetest.set_node(p_top, { name = biome.alt_wallnode, param2 = walldir })
   * 						end
   * 					else
   * 						local currentsurface = minetest.get_node(pos).name
   * 						if currentsurface ~= "default:water_source"
   * 						  or (currentsurface == "default:water_source" and #(minetest.find_nodes_in_area({x=pos.x, y=pos.y-biome.depth_max-1, z=pos.z}, {x=pos.x, y=pos.y, z=pos.z}, {"default:dirt", "default:dirt_with_grass", "default:sand"})) > 0 )
   * 						  then
   * 							local rnd = math.random(1, biome.spawn_plants_count)
   * 							local plant_to_spawn = biome.spawn_plants[rnd]
   * 							local fdir = biome.facedir
   * 							if biome.random_facedir then
   * 								fdir = math.random(biome.random_facedir[1],biome.random_facedir[2])
   * 							end
   * 							if type(biome.spawn_plants) == "string" then
   * 								assert(loadstring(biome.spawn_plants.."(...)"))(pos)
   * 							elseif not biome.spawn_on_side and not biome.spawn_on_bottom and not biome.spawn_replace_node then
   * 								if n_top.name == "air" then
   * 									minetest.set_node(p_top, { name = plant_to_spawn, param2 = fdir })
   * 								end
   * 							elseif biome.spawn_replace_node then
   * 								minetest.set_node(pos, { name = plant_to_spawn, param2 = fdir })
   * 
   * 							elseif biome.spawn_on_side then
   * 								local onside = biome_lib:find_open_side(pos)
   * 								if onside then 
   * 									minetest.set_node(onside.newpos, { name = plant_to_spawn, param2 = onside.facedir })
   * 								end
   * 							elseif biome.spawn_on_bottom then
   * 								if minetest.get_node({x=pos.x, y=pos.y-1, z=pos.z}).name == "air" then
   * 									minetest.set_node({x=pos.x, y=pos.y-1, z=pos.z}, { name = plant_to_spawn, param2 = fdir} )
   * 								end
   * 							end
   * 						end
   * 					end
   * 				end
   * 			end
   * 		end
   * 	})
   * end */
  lua_pushvalue(L,(lc21 + lc_nextra));
  lua_pushcclosure(L,lcf1_biome_lib_spawn_on_surfaces,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"spawn_on_surfaces");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- The growing ABM
   * function biome_lib:grow_plants(opts)
   * 
   * 	local options = opts
   * 
   * 	options.height_limit = options.height_limit or 5
   * 	options.ground_nodes = options.ground_nodes or { "default:dirt_with_grass" }
   * 	options.grow_nodes = options.grow_nodes or { "default:dirt_with_grass" }
   * 	options.seed_diff = options.seed_diff or 0
   * 
   * 	if options.grow_delay*time_scale >= 1 then
   * 		options.interval = options.grow_delay*time_scale
   * 	else
   * 		options.interval = 1
   * 	end
   * 
   * 	minetest.register_abm({
   * 		nodenames = { options.grow_plant },
   * 		interval = options.interval,
   * 		chance = options.grow_chance,
   * 		action = function(pos, node, active_object_count, active_object_count_wider)
   * 			local p_top = {x=pos.x, y=pos.y+1, z=pos.z}
   * 			local p_bot = {x=pos.x, y=pos.y-1, z=pos.z}
   * 			local n_top = minetest.get_node(p_top)
   * 			local n_bot = minetest.get_node(p_bot)
   * 			local root_node = minetest.get_node({x=pos.x, y=pos.y-options.height_limit, z=pos.z})
   * 			local walldir = nil
   * 			if options.need_wall and options.verticals_list then
   * 				walldir = biome_lib:find_adjacent_wall(p_top, options.verticals_list, options.choose_random_wall)
   * 			end
   * 			if (n_top.name == "air" or n_top.name == "default:snow")
   * 			  and (not options.need_wall or (options.need_wall and walldir)) then
   * 				-- corner case for changing short junglegrass
   * 				-- to dry shrub in desert
   * 				if n_bot.name == options.dry_early_node and options.grow_plant == "junglegrass:short" then
   * 					minetest.set_node(pos, { name = "default:dry_shrub" })
   * 
   * 				elseif options.grow_vertically and walldir then
   * 					if biome_lib:search_downward(pos, options.height_limit, options.ground_nodes) then
   * 						minetest.set_node(p_top, { name = options.grow_plant, param2 = walldir})
   * 					end
   * 
   * 				elseif not options.grow_result and not options.grow_function then
   * 					minetest.remove_node(pos)
   * 
   * 				else
   * 					biome_lib:replace_object(pos, options.grow_result, options.grow_function, options.facedir, options.seed_diff)
   * 				end
   * 			end
   * 		end
   * 	})
   * end */
  lua_pushvalue(L,(lc21 + lc_nextra));
  lua_pushcclosure(L,lcf1_biome_lib_grow_plants,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_plants");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- Function to decide how to replace a plant - either grow it, replace it with
   * -- a tree, run a function, or die with an error.
   * function biome_lib:replace_object(pos, replacement, grow_function, walldir, seeddiff)
   * 	local growtype = type(grow_function)
   * 	if growtype == "table" then
   * 		minetest.remove_node(pos)
   * 		biome_lib:grow_tree(pos, grow_function)
   * 		return
   * 	elseif growtype == "function" then
   * 		local perlin_fertile_area = minetest.get_perlin(seeddiff, perlin_octaves, perlin_persistence, perlin_scale)
   * 		local noise1 = perlin_fertile_area:get2d({x=pos.x, y=pos.z})
   * 		local noise2 = biome_lib.perlin_temperature:get2d({x=pos.x, y=pos.z})
   * 		grow_function(pos,noise1,noise2,walldir)
   * 		return
   * 	elseif growtype == "string" then
   * 		local perlin_fertile_area = minetest.get_perlin(seeddiff, perlin_octaves, perlin_persistence, perlin_scale)
   * 		local noise1 = perlin_fertile_area:get2d({x=pos.x, y=pos.z})
   * 		local noise2 = biome_lib.perlin_temperature:get2d({x=pos.x, y=pos.z})
   * 		assert(loadstring(grow_function.."(...)"))(pos,noise1,noise2,walldir)
   * 		return
   * 	elseif growtype == "nil" then
   * 		minetest.set_node(pos, { name = replacement, param2 = walldir})
   * 		return
   * 	elseif growtype ~= "nil" and growtype ~= "string" and growtype ~= "table" then
   * 		error("Invalid grow function "..dump(grow_function).." used on object at ("..dump(pos)..")")
   * 	end
   * end */
  lua_pushvalue(L,(lc21 + lc_nextra));
  lua_pushcclosure(L,lcf1_biome_lib_replace_object,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"replace_object");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- function to decide if a node has a wall that's in verticals_list{}
   * -- returns wall direction of valid node, or nil if invalid.
   * function biome_lib:find_adjacent_wall(pos, verticals, randomflag)
   * 	local verts = dump(verticals)
   * 	if randomflag then
   * 		local walltab = {}
   * 		
   * 		if string.find(verts, minetest.get_node({ x=pos.x-1, y=pos.y, z=pos.z   }).name) then walltab[#walltab + 1] = 3 end
   * 		if string.find(verts, minetest.get_node({ x=pos.x+1, y=pos.y, z=pos.z   }).name) then walltab[#walltab + 1] = 2 end
   * 		if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z-1 }).name) then walltab[#walltab + 1] = 5 end
   * 		if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z+1 }).name) then walltab[#walltab + 1] = 4 end
   * 
   * 		if #walltab > 0 then return walltab[math.random(1, #walltab)] end
   * 
   * 	else
   * 		if string.find(verts, minetest.get_node({ x=pos.x-1, y=pos.y, z=pos.z   }).name) then return 3 end
   * 		if string.find(verts, minetest.get_node({ x=pos.x+1, y=pos.y, z=pos.z   }).name) then return 2 end
   * 		if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z-1 }).name) then return 5 end
   * 		if string.find(verts, minetest.get_node({ x=pos.x  , y=pos.y, z=pos.z+1 }).name) then return 4 end
   * 	end
   * 	return nil
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_find_adjacent_wall);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"find_adjacent_wall");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- Function to search downward from the given position, looking for the first
   * -- node that matches the ground table.  Returns the new position, or nil if
   * -- height limit is exceeded before finding it.
   * function biome_lib:search_downward(pos, heightlimit, ground)
   * 	for i = 0, heightlimit do
   * 		if string.find(dump(ground), minetest.get_node({x=pos.x, y=pos.y-i, z = pos.z}).name) then
   * 			return {x=pos.x, y=pos.y-i, z = pos.z}
   * 		end
   * 	end
   * 	return false
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_search_downward);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"search_downward");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* function biome_lib:find_open_side(pos)
   * 	if minetest.get_node({ x=pos.x-1, y=pos.y, z=pos.z }).name == "air" then
   * 		return {newpos = { x=pos.x-1, y=pos.y, z=pos.z }, facedir = 2}
   * 	end
   * 	if minetest.get_node({ x=pos.x+1, y=pos.y, z=pos.z }).name == "air" then
   * 		return {newpos = { x=pos.x+1, y=pos.y, z=pos.z }, facedir = 3}
   * 	end
   * 	if minetest.get_node({ x=pos.x, y=pos.y, z=pos.z-1 }).name == "air" then
   * 		return {newpos = { x=pos.x, y=pos.y, z=pos.z-1 }, facedir = 4}
   * 	end
   * 	if minetest.get_node({ x=pos.x, y=pos.y, z=pos.z+1 }).name == "air" then
   * 		return {newpos = { x=pos.x, y=pos.y, z=pos.z+1 }, facedir = 5}
   * 	end
   * 	return nil
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_find_open_side);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"find_open_side");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- spawn_tree() on generate is routed through here so that other mods can hook
   * -- into it.
   * function biome_lib:generate_tree(pos, nodes_or_function_or_model)
   * 	minetest.spawn_tree(pos, nodes_or_function_or_model)
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_generate_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"generate_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- and this one's for the call used in the growing code
   * function biome_lib:grow_tree(pos, nodes_or_function_or_model)
   * 	minetest.spawn_tree(pos, nodes_or_function_or_model)
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_grow_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- Check for infinite stacks
   * if minetest.get_modpath("unified_inventory") or not minetest.setting_getbool("creative_mode") then */
  enum { lc372 = 16 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"unified_inventory");
  lua_call(L,1,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"setting_getbool");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"creative_mode");
    lua_call(L,1,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc373 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc373) {
    
    /* biome_lib.expect_infinite_stacks = false */
    lua_pushboolean(L,0);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_insert(L,-2);
    lua_pushliteral(L,"expect_infinite_stacks");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 16);
  }
  else {
    
    /* else
     * biome_lib.expect_infinite_stacks = true */
    lua_pushboolean(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
    lua_insert(L,-2);
    lua_pushliteral(L,"expect_infinite_stacks");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 16);
  }
  lua_settop(L,(lc372 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* -- read a field from a node's definition
   * function biome_lib:get_nodedef_field(nodename, fieldname)
   * 	if not minetest.registered_nodes[nodename] then
   * 		return nil
   * 	end
   * 	return minetest.registered_nodes[nodename][fieldname]
   * end */
  lua_pushcfunction(L,lcf1_biome_lib_get_nodedef_field);
  lua_getfield(L,LUA_ENVIRONINDEX,"biome_lib");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_nodedef_field");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* print("[Biome Lib] Loaded") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"[Biome Lib] Loaded");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* minetest.after(0, function()
   * 	print("[Biome Lib] Registered a total of "..(#biome_lib.surfaceslist_aircheck)+(#biome_lib.surfaceslist_no_aircheck).." surface types to be evaluated, spread")
   * 	print("[Biome Lib] across "..#biome_lib.actionslist_aircheck.." actions with air-checking and "..#biome_lib.actionslist_no_aircheck.." actions without.")
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"after");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0);
  lua_pushcfunction(L,lcf380);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 16);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_biome_lib_init(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}

