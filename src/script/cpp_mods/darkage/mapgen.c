/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: generate_stratus
 * function(name, wherein, ceilin, ceil, minp, maxp, seed, stratus_chance, radius, radius_y, deep, height_min, height_max) */
static int lcf1_generate_stratus (lua_State * L) {
  lua_checkstack(L,54);
  enum { lc_nformalargs = 13 };
  lua_settop(L,13);
  
  /* if maxp.y < height_min or minp.y > height_max then */
  enum { lc2 = 13 };
  lua_pushliteral(L,"y");
  lua_gettable(L,6);
  const int lc3 = lua_lessthan(L,-1,12);
  lua_pop(L,1);
  lua_pushboolean(L,lc3);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    const int lc4 = lua_lessthan(L,13,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc4);
  }
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc2);
  assert(lua_gettop(L) == 13);
  
  /* -- it will be only generate a stratus for every 100 m of area
   * local stratus_per_volume=1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 14);
  
  /* local area=45 */
  lua_pushnumber(L,45);
  assert(lua_gettop(L) == 15);
  
  /* local y_min = math.max(minp.y, height_min) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  lua_pushvalue(L,12);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 16);
  
  /* local y_max = math.min(maxp.y, height_max) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"min");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,6);
  lua_pushvalue(L,13);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 17);
  
  /* local volume = ((maxp.x-minp.x+1)/area)*((y_max-y_min+1)/area)*((maxp.z-minp.z+1)/area) */
  lua_pushliteral(L,"x");
  lua_gettable(L,6);
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_div(L,-1,15);
  lua_remove(L,-2);
  lc_sub(L,17,16);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_div(L,-1,15);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,6);
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_div(L,-1,15);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 18);
  
  /* local pr = PseudoRandom(seed) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  lua_pushvalue(L,7);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 19);
  
  /* local blocks = math.floor(stratus_per_volume*volume) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_mul(L,14,18);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 20);
  
  /* print("  <<"..dump(name)..">>") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"  <<");
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,">>");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 20);
  
  /* if blocks == 0 then */
  enum { lc6 = 20 };
  lua_pushnumber(L,0);
  const int lc7 = lua_equal(L,20,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc7);
  const int lc8 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc8) {
    
    /* blocks = 1 */
    lua_pushnumber(L,1);
    lua_replace(L,20);
    assert(lua_gettop(L) == 20);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 20);
  
  /* print("    blocks: "..dump(blocks).." in vol: "..dump(volume).." ("..dump(maxp.x-minp.x+1)..","..dump(y_max-y_min+1)..","..dump(maxp.z-minp.z+1)..")") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"    blocks: ");
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lua_pushvalue(L,20);
  lua_call(L,1,1);
  lua_pushliteral(L," in vol: ");
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lua_pushvalue(L,18);
  lua_call(L,1,1);
  lua_pushliteral(L," (");
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lua_pushliteral(L,"x");
  lua_gettable(L,6);
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,",");
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lc_sub(L,17,16);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,",");
  lua_getfield(L,LUA_ENVIRONINDEX,"dump");
  lua_pushliteral(L,"z");
  lua_gettable(L,6);
  lua_pushliteral(L,"z");
  lua_gettable(L,5);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,")");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 20);
  
  /* for i=1,blocks do */
  lua_pushnumber(L,1);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,20)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc9_var = lua_tonumber(L,-1);
  const double lc10_limit = lua_tonumber(L,20);
  const double lc11_step = 1;
  lua_pop(L,1);
  enum { lc12 = 20 };
  while ((((lc11_step > 0) && (lc9_var <= lc10_limit)) || ((lc11_step <= 0) && (lc9_var >= lc10_limit)))) {
    
    /* internal: local i at index 21 */
    lua_pushnumber(L,lc9_var);
    
    /* local x = pr:next(1,stratus_chance) */
    lua_pushvalue(L,19);
    lua_pushliteral(L,"next");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,1);
    lua_pushvalue(L,8);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 22);
    
    /* if x == 1 then */
    enum { lc13 = 22 };
    lua_pushnumber(L,1);
    const int lc14 = lua_equal(L,22,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc14);
    const int lc15 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc15) {
      
      /* -- TODO deep
       * local y0=y_max-radius_y+1 */
      lc_sub(L,17,10);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 23);
      
      /* if y0 < y_min then */
      enum { lc16 = 23 };
      const int lc17 = lua_lessthan(L,23,16);
      lua_pushboolean(L,lc17);
      const int lc18 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc18) {
        
        /* y0=y_min */
        lua_pushvalue(L,16);
        lua_replace(L,23);
        assert(lua_gettop(L) == 23);
      }
      else {
        
        /* else
         * y0=pr:next(y_min, y0) */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,16);
        lua_pushvalue(L,23);
        lua_call(L,3,1);
        lua_replace(L,23);
        assert(lua_gettop(L) == 23);
      }
      lua_settop(L,lc16);
      assert(lua_gettop(L) == 23);
      
      /* local x0 = maxp.x-radius+1 */
      lua_pushliteral(L,"x");
      lua_gettable(L,6);
      lc_sub(L,-1,9);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 24);
      
      /* if x0 < minp.x then */
      enum { lc19 = 24 };
      lua_pushliteral(L,"x");
      lua_gettable(L,5);
      const int lc20 = lua_lessthan(L,24,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc20);
      const int lc21 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc21) {
        
        /* x0 = minp.x */
        lua_pushliteral(L,"x");
        lua_gettable(L,5);
        lua_replace(L,24);
        assert(lua_gettop(L) == 24);
      }
      else {
        
        /* else
         * x0 = pr:next(minp.x, x0) */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"x");
        lua_gettable(L,5);
        lua_pushvalue(L,24);
        lua_call(L,3,1);
        lua_replace(L,24);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc19);
      assert(lua_gettop(L) == 24);
      
      /* local z0 = maxp.z-radius+1 */
      lua_pushliteral(L,"z");
      lua_gettable(L,6);
      lc_sub(L,-1,9);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 25);
      
      /* if z0 < minp.z then */
      enum { lc22 = 25 };
      lua_pushliteral(L,"z");
      lua_gettable(L,5);
      const int lc23 = lua_lessthan(L,25,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc23);
      const int lc24 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc24) {
        
        /* x0 = minp.z */
        lua_pushliteral(L,"z");
        lua_gettable(L,5);
        lua_replace(L,24);
        assert(lua_gettop(L) == 25);
      }
      else {
        
        /* else
         * z0 = pr:next(minp.z, z0) */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,5);
        lua_pushvalue(L,25);
        lua_call(L,3,1);
        lua_replace(L,25);
        assert(lua_gettop(L) == 25);
      }
      lua_settop(L,lc22);
      assert(lua_gettop(L) == 25);
      
      /* local p0 = {x=x0, y=y0, z=z0} */
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,24);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushvalue(L,23);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,25);
      lua_rawset(L,-3);
      assert(lua_gettop(L) == 26);
      
      /* local n = minetest.env:get_node(p0).name */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"env");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"get_node");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,26);
      lua_call(L,2,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 27);
      
      /* local i = 0 */
      lua_pushnumber(L,0);
      assert(lua_gettop(L) == 28);
      
      /* --print("    upper node "..n)
       * x = 0 */
      lua_pushnumber(L,0);
      lua_replace(L,22);
      assert(lua_gettop(L) == 28);
      
      /* for k, v in ipairs(ceilin) do
       * internal: local f, s, var = explist */
      enum { lc25 = 28 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
      lua_pushvalue(L,3);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local k with idx 32
         * internal: local v with idx 33 */
        
        
        /* if n == v then */
        enum { lc26 = 33 };
        const int lc27 = lua_equal(L,27,33);
        lua_pushboolean(L,lc27);
        const int lc28 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc28) {
          
          /* x = 1 */
          lua_pushnumber(L,1);
          lua_replace(L,22);
          assert(lua_gettop(L) == 33);
          
          /* break */
          break;
          assert(lua_gettop(L) == 33);
        }
        lua_settop(L,lc26);
        assert(lua_gettop(L) == 33);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc25);
      assert(lua_gettop(L) == 28);
      
      /* if x == 1 then */
      enum { lc29 = 28 };
      lua_pushnumber(L,1);
      const int lc30 = lua_equal(L,22,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc30);
      const int lc31 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc31) {
        
        /* -- search for the node to replace
         * --print("    Searching nodes to replace from "..dump(y0-1).." to "..dump(y_min))
         * for y1=y0-1,y_min,-1 do */
        lua_pushnumber(L,1);
        lc_sub(L,23,-1);
        lua_remove(L,-2);
        lua_pushnumber(L,-1);
        if (!(((lua_isnumber(L,-2) && lua_isnumber(L,16)) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc32_var = lua_tonumber(L,-2);
        const double lc33_limit = lua_tonumber(L,16);
        const double lc34_step = lua_tonumber(L,-1);
        lua_pop(L,2);
        enum { lc35 = 28 };
        while ((((lc34_step > 0) && (lc32_var <= lc33_limit)) || ((lc34_step <= 0) && (lc32_var >= lc33_limit)))) {
          
          /* internal: local y1 at index 29 */
          lua_pushnumber(L,lc32_var);
          
          /* p0.y=y1 */
          lua_pushvalue(L,29);
          lua_pushliteral(L,"y");
          lua_insert(L,-2);
          lua_settable(L,26);
          assert(lua_gettop(L) == 29);
          
          /* n = minetest.env:get_node(p0).name */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"env");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"get_node");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,26);
          lua_call(L,2,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_replace(L,27);
          assert(lua_gettop(L) == 29);
          
          /* x = 0 */
          lua_pushnumber(L,0);
          lua_replace(L,22);
          assert(lua_gettop(L) == 29);
          
          /* for k, v in ipairs(wherein) do
           * internal: local f, s, var = explist */
          enum { lc36 = 29 };
          lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
          lua_pushvalue(L,2);
          lua_call(L,1,3);
          while (1) {
            
            /* internal: local var_1, ..., var_n = f(s, var)
             *           if var_1 == nil then break end
             *           var = var_1 */
            lua_pushvalue(L,-3);
            lua_pushvalue(L,-3);
            lua_pushvalue(L,-3);
            lua_call(L,2,2);
            if (lua_isnil(L,-2)) {
              break;
            }
            lua_pushvalue(L,-2);
            lua_replace(L,-4);
            
            /* internal: local k with idx 33
             * internal: local v with idx 34 */
            
            
            /* if n == v then */
            enum { lc37 = 34 };
            const int lc38 = lua_equal(L,27,34);
            lua_pushboolean(L,lc38);
            const int lc39 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc39) {
              
              /* x = 1 */
              lua_pushnumber(L,1);
              lua_replace(L,22);
              assert(lua_gettop(L) == 34);
              
              /* break */
              break;
              assert(lua_gettop(L) == 34);
            }
            lua_settop(L,lc37);
            assert(lua_gettop(L) == 34);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,2);
          }
          lua_settop(L,lc36);
          assert(lua_gettop(L) == 29);
          
          /* if x == 1 then */
          enum { lc40 = 29 };
          lua_pushnumber(L,1);
          const int lc41 = lua_equal(L,22,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc41);
          const int lc42 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc42) {
            
            /* y0=y1-deep */
            lc_sub(L,29,11);
            lua_replace(L,23);
            assert(lua_gettop(L) == 29);
            
            /* if y0 < y_min then */
            enum { lc43 = 29 };
            const int lc44 = lua_lessthan(L,23,16);
            lua_pushboolean(L,lc44);
            const int lc45 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc45) {
              
              /* y0 = y_min */
              lua_pushvalue(L,16);
              lua_replace(L,23);
              assert(lua_gettop(L) == 29);
            }
            lua_settop(L,lc43);
            assert(lua_gettop(L) == 29);
            
            /* break */
            break;
            assert(lua_gettop(L) == 29);
          }
          lua_settop(L,lc40);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
          lc32_var += lc34_step;
        }
        lua_settop(L,lc35);
        assert(lua_gettop(L) == 28);
        
        /* local rx=pr:next(radius/2,radius)+1 */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushnumber(L,2);
        lc_div(L,9,-1);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_call(L,3,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 29);
        
        /* local rz=pr:next(radius/2,radius)+1 */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushnumber(L,2);
        lc_div(L,9,-1);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_call(L,3,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 30);
        
        /* local ry=pr:next(radius_y/2,radius_y)+1 */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushnumber(L,2);
        lc_div(L,10,-1);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_call(L,3,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 31);
        
        /* --print("    area of generation ("..dump(rx)..","..dump(rz)..","..dump(ry)..")")
         * for x1=0,rx do */
        lua_pushnumber(L,0);
        if (!((lua_isnumber(L,-1) && lua_isnumber(L,29)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc46_var = lua_tonumber(L,-1);
        const double lc47_limit = lua_tonumber(L,29);
        const double lc48_step = 1;
        lua_pop(L,1);
        enum { lc49 = 31 };
        while ((((lc48_step > 0) && (lc46_var <= lc47_limit)) || ((lc48_step <= 0) && (lc46_var >= lc47_limit)))) {
          
          /* internal: local x1 at index 32 */
          lua_pushnumber(L,lc46_var);
          
          /* rz = rz + 3 - pr:next(1,6) */
          lua_pushnumber(L,3);
          lc_add(L,30,-1);
          lua_remove(L,-2);
          lua_pushvalue(L,19);
          lua_pushliteral(L,"next");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushnumber(L,1);
          lua_pushnumber(L,6);
          lua_call(L,3,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,30);
          assert(lua_gettop(L) == 32);
          
          /* if rz < 1 then */
          enum { lc50 = 32 };
          lua_pushnumber(L,1);
          const int lc51 = lua_lessthan(L,30,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc51);
          const int lc52 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc52) {
            
            /* rz = 1 */
            lua_pushnumber(L,1);
            lua_replace(L,30);
            assert(lua_gettop(L) == 32);
          }
          lua_settop(L,lc50);
          assert(lua_gettop(L) == 32);
          
          /* for z1=pr:next(1,3),rz do */
          lua_pushvalue(L,19);
          lua_pushliteral(L,"next");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushnumber(L,1);
          lua_pushnumber(L,3);
          lua_call(L,3,1);
          if (!((lua_isnumber(L,-1) && lua_isnumber(L,30)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc53_var = lua_tonumber(L,-1);
          const double lc54_limit = lua_tonumber(L,30);
          const double lc55_step = 1;
          lua_pop(L,1);
          enum { lc56 = 32 };
          while ((((lc55_step > 0) && (lc53_var <= lc54_limit)) || ((lc55_step <= 0) && (lc53_var >= lc54_limit)))) {
            
            /* internal: local z1 at index 33 */
            lua_pushnumber(L,lc53_var);
            
            /* local ry0=ry+ pr:next(1,3) */
            lua_pushvalue(L,19);
            lua_pushliteral(L,"next");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushnumber(L,1);
            lua_pushnumber(L,3);
            lua_call(L,3,1);
            lc_add(L,31,-1);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 34);
            
            /* for y1=pr:next(1,3),ry0 do */
            lua_pushvalue(L,19);
            lua_pushliteral(L,"next");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushnumber(L,1);
            lua_pushnumber(L,3);
            lua_call(L,3,1);
            if (!((lua_isnumber(L,-1) && lua_isnumber(L,34)))) {
              luaL_error(L,"'for' limit must be a number");
            }
            double lc57_var = lua_tonumber(L,-1);
            const double lc58_limit = lua_tonumber(L,34);
            const double lc59_step = 1;
            lua_pop(L,1);
            enum { lc60 = 34 };
            while ((((lc59_step > 0) && (lc57_var <= lc58_limit)) || ((lc59_step <= 0) && (lc57_var >= lc58_limit)))) {
              
              /* internal: local y1 at index 35 */
              lua_pushnumber(L,lc57_var);
              
              /* local x2 = x0+x1 */
              lc_add(L,24,32);
              assert(lua_gettop(L) == 36);
              
              /* local y2 = y0+y1 */
              lc_add(L,23,35);
              assert(lua_gettop(L) == 37);
              
              /* local z2 = z0+z1 */
              lc_add(L,25,33);
              assert(lua_gettop(L) == 38);
              
              /* local p2 = {x=x2, y=y2, z=z2} */
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushvalue(L,36);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushvalue(L,37);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushvalue(L,38);
              lua_rawset(L,-3);
              assert(lua_gettop(L) == 39);
              
              /* n = minetest.env:get_node(p2).name */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"env");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"get_node");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,39);
              lua_call(L,2,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_replace(L,27);
              assert(lua_gettop(L) == 39);
              
              /* x = 0 */
              lua_pushnumber(L,0);
              lua_replace(L,22);
              assert(lua_gettop(L) == 39);
              
              /* for k, v in ipairs(wherein) do
               * internal: local f, s, var = explist */
              enum { lc61 = 39 };
              lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
              lua_pushvalue(L,2);
              lua_call(L,1,3);
              while (1) {
                
                /* internal: local var_1, ..., var_n = f(s, var)
                 *           if var_1 == nil then break end
                 *           var = var_1 */
                lua_pushvalue(L,-3);
                lua_pushvalue(L,-3);
                lua_pushvalue(L,-3);
                lua_call(L,2,2);
                if (lua_isnil(L,-2)) {
                  break;
                }
                lua_pushvalue(L,-2);
                lua_replace(L,-4);
                
                /* internal: local k with idx 43
                 * internal: local v with idx 44 */
                
                
                /* if n == v then */
                enum { lc62 = 44 };
                const int lc63 = lua_equal(L,27,44);
                lua_pushboolean(L,lc63);
                const int lc64 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc64) {
                  
                  /* x = 1 */
                  lua_pushnumber(L,1);
                  lua_replace(L,22);
                  assert(lua_gettop(L) == 44);
                  
                  /* break */
                  break;
                  assert(lua_gettop(L) == 44);
                }
                lua_settop(L,lc62);
                assert(lua_gettop(L) == 44);
                
                /* internal: stack cleanup on scope exit */
                lua_pop(L,2);
              }
              lua_settop(L,lc61);
              assert(lua_gettop(L) == 39);
              
              /* if x == 1 then */
              enum { lc65 = 39 };
              lua_pushnumber(L,1);
              const int lc66 = lua_equal(L,22,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc66);
              const int lc67 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc67) {
                
                /* if ceil == nil then */
                enum { lc68 = 39 };
                lua_pushnil(L);
                const int lc69 = lua_equal(L,4,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc69);
                const int lc70 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc70) {
                  
                  /* minetest.env:set_node(p2, {name=name}) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                  lua_pushliteral(L,"env");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushliteral(L,"set_node");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,39);
                  lua_createtable(L,0,1);
                  lua_pushliteral(L,"name");
                  lua_pushvalue(L,1);
                  lua_rawset(L,-3);
                  lua_call(L,3,0);
                  assert(lua_gettop(L) == 39);
                  
                  /* i = i +1 */
                  lua_pushnumber(L,1);
                  lc_add(L,28,-1);
                  lua_remove(L,-2);
                  lua_replace(L,28);
                  assert(lua_gettop(L) == 39);
                }
                else {
                  
                  /* else
                   * local p3 = {p2.x,p2.y+1,p2} */
                  lua_createtable(L,3,0);
                  lua_pushliteral(L,"x");
                  lua_gettable(L,39);
                  lua_rawseti(L,-2,1);
                  lua_pushliteral(L,"y");
                  lua_gettable(L,39);
                  lua_pushnumber(L,1);
                  lc_add(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lua_rawseti(L,-2,2);
                  lua_pushvalue(L,39);
                  lua_rawseti(L,-2,3);
                  assert(lua_gettop(L) == 40);
                  
                  /* if minetest.env:get_node(p3).name == ceil then */
                  enum { lc71 = 40 };
                  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                  lua_pushliteral(L,"env");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushliteral(L,"get_node");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,40);
                  lua_call(L,2,1);
                  lua_pushliteral(L,"name");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc72 = lua_equal(L,-1,4);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc72);
                  const int lc73 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc73) {
                    
                    /* minetest.env:set_node(p2, {name=name}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"env");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"set_node");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_pushvalue(L,39);
                    lua_createtable(L,0,1);
                    lua_pushliteral(L,"name");
                    lua_pushvalue(L,1);
                    lua_rawset(L,-3);
                    lua_call(L,3,0);
                    assert(lua_gettop(L) == 40);
                    
                    /* i = i +1 */
                    lua_pushnumber(L,1);
                    lc_add(L,28,-1);
                    lua_remove(L,-2);
                    lua_replace(L,28);
                    assert(lua_gettop(L) == 40);
                  }
                  lua_settop(L,lc71);
                  assert(lua_gettop(L) == 40);
                }
                lua_settop(L,lc68);
                assert(lua_gettop(L) == 39);
              }
              lua_settop(L,lc65);
              assert(lua_gettop(L) == 39);
              
              /* internal: stack cleanup on scope exit */
              lua_pop(L,5);
              lc57_var += lc59_step;
            }
            lua_settop(L,lc60);
            assert(lua_gettop(L) == 34);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,2);
            lc53_var += lc55_step;
          }
          lua_settop(L,lc56);
          assert(lua_gettop(L) == 32);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
          lc46_var += lc48_step;
        }
        lua_settop(L,lc49);
        assert(lua_gettop(L) == 31);
        
        /* print("    generated "..dump(i).." blocks in ("..dump(x0)..","..dump(y0)..","..dump(z0)..")") */
        lua_getfield(L,LUA_ENVIRONINDEX,"print");
        lua_pushliteral(L,"    generated ");
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushvalue(L,28);
        lua_call(L,1,1);
        lua_pushliteral(L," blocks in (");
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushvalue(L,24);
        lua_call(L,1,1);
        lua_pushliteral(L,",");
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushvalue(L,23);
        lua_call(L,1,1);
        lua_pushliteral(L,",");
        lua_getfield(L,LUA_ENVIRONINDEX,"dump");
        lua_pushvalue(L,25);
        lua_call(L,1,1);
        lua_pushliteral(L,")");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 31);
      }
      lua_settop(L,lc29);
      assert(lua_gettop(L) == 28);
    }
    lua_settop(L,lc13);
    assert(lua_gettop(L) == 22);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc9_var += lc11_step;
  }
  lua_settop(L,lc12);
  assert(lua_gettop(L) == 20);
  return 0;
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: generate_claylike
 * function(name, minp, maxp, seed, chance, minh, maxh, dirt) */
static int lcf1_generate_claylike (lua_State * L) {
  lua_checkstack(L,34);
  enum { lc_nformalargs = 8 };
  lua_settop(L,8);
  
  /* if maxp.y >= maxh+1 and minp.y <= minh-1 then */
  enum { lc75 = 8 };
  lua_pushnumber(L,1);
  lc_add(L,7,-1);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,3);
  const int lc76 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc76);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,6,-1);
    lua_remove(L,-2);
    const int lc77 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc77);
  }
  const int lc78 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc78) {
    
    /* local pr = PseudoRandom(seed) */
    lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
    lua_pushvalue(L,4);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 9);
    
    /* local divlen = 4 */
    lua_pushnumber(L,4);
    assert(lua_gettop(L) == 10);
    
    /* local divs = (maxp.x-minp.x)/divlen+1 */
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_div(L,-1,10);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 11);
    
    /* for yy=minh,maxh do */
    if (!((lua_isnumber(L,6) && lua_isnumber(L,7)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc79_var = lua_tonumber(L,6);
    const double lc80_limit = lua_tonumber(L,7);
    const double lc81_step = 1;
    lua_pop(L,0);
    enum { lc82 = 11 };
    while ((((lc81_step > 0) && (lc79_var <= lc80_limit)) || ((lc81_step <= 0) && (lc79_var >= lc80_limit)))) {
      
      /* internal: local yy at index 12 */
      lua_pushnumber(L,lc79_var);
      
      /* local x = pr:next(1,chance) */
      lua_pushvalue(L,9);
      lua_pushliteral(L,"next");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushnumber(L,1);
      lua_pushvalue(L,5);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 13);
      
      /* if x == 1 then */
      enum { lc83 = 13 };
      lua_pushnumber(L,1);
      const int lc84 = lua_equal(L,13,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc84);
      const int lc85 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc85) {
        
        /* for divx=0+1,divs-1-1 do */
        lua_pushnumber(L,1);
        lua_pushnumber(L,1);
        lc_sub(L,11,-1);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc86_var = lua_tonumber(L,-2);
        const double lc87_limit = lua_tonumber(L,-1);
        const double lc88_step = 1;
        lua_pop(L,2);
        enum { lc89 = 13 };
        while ((((lc88_step > 0) && (lc86_var <= lc87_limit)) || ((lc88_step <= 0) && (lc86_var >= lc87_limit)))) {
          
          /* internal: local divx at index 14 */
          lua_pushnumber(L,lc86_var);
          
          /* for divz=0+1,divs-1-1 do */
          lua_pushnumber(L,1);
          lua_pushnumber(L,1);
          lc_sub(L,11,-1);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc90_var = lua_tonumber(L,-2);
          const double lc91_limit = lua_tonumber(L,-1);
          const double lc92_step = 1;
          lua_pop(L,2);
          enum { lc93 = 14 };
          while ((((lc92_step > 0) && (lc90_var <= lc91_limit)) || ((lc92_step <= 0) && (lc90_var >= lc91_limit)))) {
            
            /* internal: local divz at index 15 */
            lua_pushnumber(L,lc90_var);
            
            /* local cx = minp.x + math.floor((divx+0.5)*divlen) */
            lua_pushliteral(L,"x");
            lua_gettable(L,2);
            lua_getfield(L,LUA_ENVIRONINDEX,"math");
            lua_pushliteral(L,"floor");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,0.5);
            lc_add(L,14,-1);
            lua_remove(L,-2);
            lc_mul(L,-1,10);
            lua_remove(L,-2);
            lua_call(L,1,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 16);
            
            /* local cz = minp.z + math.floor((divz+0.5)*divlen) */
            lua_pushliteral(L,"z");
            lua_gettable(L,2);
            lua_getfield(L,LUA_ENVIRONINDEX,"math");
            lua_pushliteral(L,"floor");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,0.5);
            lc_add(L,15,-1);
            lua_remove(L,-2);
            lc_mul(L,-1,10);
            lua_remove(L,-2);
            lua_call(L,1,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 17);
            
            /* local up = minetest.env:get_node({x=cx,y=yy,z=cz}).name */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"env");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"get_node");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushvalue(L,16);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushvalue(L,12);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushvalue(L,17);
            lua_rawset(L,-3);
            lua_call(L,2,1);
            lua_pushliteral(L,"name");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 18);
            
            /* local down = minetest.env:get_node({x=cx,y=yy-1,z=cz}).name */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"env");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"get_node");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushvalue(L,16);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushnumber(L,1);
            lc_sub(L,12,-1);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushvalue(L,17);
            lua_rawset(L,-3);
            lua_call(L,2,1);
            lua_pushliteral(L,"name");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 19);
            
            /* if ( up == "default:water_source" or up == "air" ) and
             * 				       ( down == "default:sand" or (dirt == 1 and (down == "default:dirt" or down == "default:dirt_with_grass" ))) then */
            enum { lc94 = 19 };
            lua_pushvalue(L,18);
            lua_pushliteral(L,"default:water_source");
            const int lc95 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc95);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,18);
              lua_pushliteral(L,"air");
              const int lc96 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc96);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,19);
              lua_pushliteral(L,"default:sand");
              const int lc97 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc97);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,8);
                lua_pushnumber(L,1);
                const int lc98 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc98);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushvalue(L,19);
                  lua_pushliteral(L,"default:dirt");
                  const int lc99 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc99);
                  if (!(lua_toboolean(L,-1))) {
                    lua_pop(L,1);
                    lua_pushvalue(L,19);
                    lua_pushliteral(L,"default:dirt_with_grass");
                    const int lc100 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc100);
                  }
                }
              }
            }
            const int lc101 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc101) {
              
              /* local is_shallow = true */
              lua_pushboolean(L,1);
              assert(lua_gettop(L) == 20);
              
              /* local num_water_around = 0 */
              lua_pushnumber(L,0);
              assert(lua_gettop(L) == 21);
              
              /* if minetest.env:get_node({x=cx-divlen*2,y=yy,z=cz}).name == "default:water_source" then */
              enum { lc102 = 21 };
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"env");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"get_node");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushnumber(L,2);
              lc_mul(L,10,-1);
              lua_remove(L,-2);
              lc_sub(L,16,-1);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushvalue(L,12);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushvalue(L,17);
              lua_rawset(L,-3);
              lua_call(L,2,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"default:water_source");
              const int lc103 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc103);
              const int lc104 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc104) {
                
                /* num_water_around = num_water_around + 1 */
                lua_pushnumber(L,1);
                lc_add(L,21,-1);
                lua_remove(L,-2);
                lua_replace(L,21);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc102);
              assert(lua_gettop(L) == 21);
              
              /* if minetest.env:get_node({x=cx+divlen*2,y=yy,z=cz}).name == "default:water_source" then */
              enum { lc105 = 21 };
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"env");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"get_node");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushnumber(L,2);
              lc_mul(L,10,-1);
              lua_remove(L,-2);
              lc_add(L,16,-1);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushvalue(L,12);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushvalue(L,17);
              lua_rawset(L,-3);
              lua_call(L,2,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"default:water_source");
              const int lc106 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc106);
              const int lc107 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc107) {
                
                /* num_water_around = num_water_around + 1 */
                lua_pushnumber(L,1);
                lc_add(L,21,-1);
                lua_remove(L,-2);
                lua_replace(L,21);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc105);
              assert(lua_gettop(L) == 21);
              
              /* if minetest.env:get_node({x=cx,y=yy,z=cz-divlen*2}).name == "default:water_source" then */
              enum { lc108 = 21 };
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"env");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"get_node");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushvalue(L,16);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushvalue(L,12);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushnumber(L,2);
              lc_mul(L,10,-1);
              lua_remove(L,-2);
              lc_sub(L,17,-1);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_call(L,2,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"default:water_source");
              const int lc109 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc109);
              const int lc110 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc110) {
                
                /* num_water_around = num_water_around + 1 */
                lua_pushnumber(L,1);
                lc_add(L,21,-1);
                lua_remove(L,-2);
                lua_replace(L,21);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc108);
              assert(lua_gettop(L) == 21);
              
              /* if minetest.env:get_node({x=cx,y=yy,z=cz+divlen*2}).name == "default:water_source" then */
              enum { lc111 = 21 };
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"env");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"get_node");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushvalue(L,16);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushvalue(L,12);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushnumber(L,2);
              lc_mul(L,10,-1);
              lua_remove(L,-2);
              lc_add(L,17,-1);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_call(L,2,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"default:water_source");
              const int lc112 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc112);
              const int lc113 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc113) {
                
                /* num_water_around = num_water_around + 1 */
                lua_pushnumber(L,1);
                lc_add(L,21,-1);
                lua_remove(L,-2);
                lua_replace(L,21);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc111);
              assert(lua_gettop(L) == 21);
              
              /* if num_water_around >= 3 then */
              enum { lc114 = 21 };
              lua_pushnumber(L,3);
              const int lc115 = lc_le(L,-1,21);
              lua_pop(L,1);
              lua_pushboolean(L,lc115);
              const int lc116 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc116) {
                
                /* is_shallow = false */
                lua_pushboolean(L,0);
                lua_replace(L,20);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc114);
              assert(lua_gettop(L) == 21);
              
              /* if is_shallow then */
              enum { lc117 = 21 };
              if (lua_toboolean(L,20)) {
                
                /* for x1=-divlen,divlen do */
                lc_unm(L,10);
                if (!((lua_isnumber(L,-1) && lua_isnumber(L,10)))) {
                  luaL_error(L,"'for' limit must be a number");
                }
                double lc118_var = lua_tonumber(L,-1);
                const double lc119_limit = lua_tonumber(L,10);
                const double lc120_step = 1;
                lua_pop(L,1);
                enum { lc121 = 21 };
                while ((((lc120_step > 0) && (lc118_var <= lc119_limit)) || ((lc120_step <= 0) && (lc118_var >= lc119_limit)))) {
                  
                  /* internal: local x1 at index 22 */
                  lua_pushnumber(L,lc118_var);
                  
                  /* for z1=-divlen,divlen do */
                  lc_unm(L,10);
                  if (!((lua_isnumber(L,-1) && lua_isnumber(L,10)))) {
                    luaL_error(L,"'for' limit must be a number");
                  }
                  double lc122_var = lua_tonumber(L,-1);
                  const double lc123_limit = lua_tonumber(L,10);
                  const double lc124_step = 1;
                  lua_pop(L,1);
                  enum { lc125 = 22 };
                  while ((((lc124_step > 0) && (lc122_var <= lc123_limit)) || ((lc124_step <= 0) && (lc122_var >= lc123_limit)))) {
                    
                    /* internal: local z1 at index 23 */
                    lua_pushnumber(L,lc122_var);
                    
                    /* local p={x=cx+x1,y=yy-1,z=cz+z1} */
                    lua_createtable(L,0,3);
                    lua_pushliteral(L,"x");
                    lc_add(L,16,22);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"y");
                    lua_pushnumber(L,1);
                    lc_sub(L,12,-1);
                    lua_remove(L,-2);
                    lua_rawset(L,-3);
                    lua_pushliteral(L,"z");
                    lc_add(L,17,23);
                    lua_rawset(L,-3);
                    assert(lua_gettop(L) == 24);
                    
                    /* down = minetest.env:get_node(p).name */
                    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                    lua_pushliteral(L,"env");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushliteral(L,"get_node");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_pushvalue(L,24);
                    lua_call(L,2,1);
                    lua_pushliteral(L,"name");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_replace(L,19);
                    assert(lua_gettop(L) == 24);
                    
                    /* if down == "default:sand" or (dirt == 1 and (down == "default:dirt" or down == "default:dirt_with_grass")) then */
                    enum { lc126 = 24 };
                    lua_pushvalue(L,19);
                    lua_pushliteral(L,"default:sand");
                    const int lc127 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc127);
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,8);
                      lua_pushnumber(L,1);
                      const int lc128 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc128);
                      if (lua_toboolean(L,-1)) {
                        lua_pop(L,1);
                        lua_pushvalue(L,19);
                        lua_pushliteral(L,"default:dirt");
                        const int lc129 = lua_equal(L,-2,-1);
                        lua_pop(L,2);
                        lua_pushboolean(L,lc129);
                        if (!(lua_toboolean(L,-1))) {
                          lua_pop(L,1);
                          lua_pushvalue(L,19);
                          lua_pushliteral(L,"default:dirt_with_grass");
                          const int lc130 = lua_equal(L,-2,-1);
                          lua_pop(L,2);
                          lua_pushboolean(L,lc130);
                        }
                      }
                    }
                    const int lc131 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc131) {
                      
                      /* minetest.env:set_node(p, {name=name}) */
                      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                      lua_pushliteral(L,"env");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_pushliteral(L,"set_node");
                      lua_gettable(L,-2);
                      lua_insert(L,-2);
                      lua_pushvalue(L,24);
                      lua_createtable(L,0,1);
                      lua_pushliteral(L,"name");
                      lua_pushvalue(L,1);
                      lua_rawset(L,-3);
                      lua_call(L,3,0);
                      assert(lua_gettop(L) == 24);
                    }
                    lua_settop(L,lc126);
                    assert(lua_gettop(L) == 24);
                    
                    /* internal: stack cleanup on scope exit */
                    lua_pop(L,2);
                    lc122_var += lc124_step;
                  }
                  lua_settop(L,lc125);
                  assert(lua_gettop(L) == 22);
                  
                  /* internal: stack cleanup on scope exit */
                  lua_pop(L,1);
                  lc118_var += lc120_step;
                }
                lua_settop(L,lc121);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc117);
              assert(lua_gettop(L) == 21);
            }
            lua_settop(L,lc94);
            assert(lua_gettop(L) == 19);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,5);
            lc90_var += lc92_step;
          }
          lua_settop(L,lc93);
          assert(lua_gettop(L) == 14);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
          lc86_var += lc88_step;
        }
        lua_settop(L,lc89);
        assert(lua_gettop(L) == 13);
      }
      lua_settop(L,lc83);
      assert(lua_gettop(L) == 13);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc79_var += lc81_step;
    }
    lua_settop(L,lc82);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc75);
  assert(lua_gettop(L) == 8);
  return 0;
}


/* name: generate_ore
 * function(name, wherein, minp, maxp, seed, chunks_per_volume, chunk_size, ore_per_chunk, height_min, height_max) */
static int lcf1_generate_ore (lua_State * L) {
  lua_checkstack(L,38);
  enum { lc_nformalargs = 10 };
  lua_settop(L,10);
  
  /* if maxp.y < height_min or minp.y > height_max then */
  enum { lc133 = 10 };
  lua_pushliteral(L,"y");
  lua_gettable(L,4);
  const int lc134 = lua_lessthan(L,-1,9);
  lua_pop(L,1);
  lua_pushboolean(L,lc134);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    const int lc135 = lua_lessthan(L,10,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc135);
  }
  const int lc136 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc136) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc133);
  assert(lua_gettop(L) == 10);
  
  /* local y_min = math.max(minp.y, height_min) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,3);
  lua_pushvalue(L,9);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 11);
  
  /* local y_max = math.min(maxp.y, height_max) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"min");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,4);
  lua_pushvalue(L,10);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 12);
  
  /* local volume = (maxp.x-minp.x+1)*(y_max-y_min+1)*(maxp.z-minp.z+1) */
  lua_pushliteral(L,"x");
  lua_gettable(L,4);
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,12,11);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,4);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 13);
  
  /* local pr = PseudoRandom(seed) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  lua_pushvalue(L,5);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 14);
  
  /* local num_chunks = math.floor(chunks_per_volume * volume) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_mul(L,6,13);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 15);
  
  /* local inverse_chance = math.floor(chunk_size*chunk_size*chunk_size / ore_per_chunk) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_mul(L,7,7);
  lc_mul(L,-1,7);
  lua_remove(L,-2);
  lc_div(L,-1,8);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 16);
  
  /* --print("generate_ore num_chunks: "..dump(num_chunks))
   * for i=1,num_chunks do */
  lua_pushnumber(L,1);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,15)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc137_var = lua_tonumber(L,-1);
  const double lc138_limit = lua_tonumber(L,15);
  const double lc139_step = 1;
  lua_pop(L,1);
  enum { lc140 = 16 };
  while ((((lc139_step > 0) && (lc137_var <= lc138_limit)) || ((lc139_step <= 0) && (lc137_var >= lc138_limit)))) {
    
    /* internal: local i at index 17 */
    lua_pushnumber(L,lc137_var);
    
    /* local y0 = pr:next(y_min, y_max-chunk_size+1) */
    lua_pushvalue(L,14);
    lua_pushliteral(L,"next");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,11);
    lc_sub(L,12,7);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 18);
    
    /* if y0 >= height_min and y0 <= height_max then */
    enum { lc141 = 18 };
    lua_pushboolean(L,lc_le(L,9,18));
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushboolean(L,lc_le(L,18,10));
    }
    const int lc142 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc142) {
      
      /* local x0 = pr:next(minp.x, maxp.x-chunk_size+1) */
      lua_pushvalue(L,14);
      lua_pushliteral(L,"next");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,3);
      lua_pushliteral(L,"x");
      lua_gettable(L,4);
      lc_sub(L,-1,7);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 19);
      
      /* local z0 = pr:next(minp.z, maxp.z-chunk_size+1) */
      lua_pushvalue(L,14);
      lua_pushliteral(L,"next");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,3);
      lua_pushliteral(L,"z");
      lua_gettable(L,4);
      lc_sub(L,-1,7);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 20);
      
      /* local p0 = {x=x0, y=y0, z=z0} */
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,19);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushvalue(L,18);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,20);
      lua_rawset(L,-3);
      assert(lua_gettop(L) == 21);
      
      /* for x1=0,chunk_size-1 do */
      lua_pushnumber(L,0);
      lua_pushnumber(L,1);
      lc_sub(L,7,-1);
      lua_remove(L,-2);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc143_var = lua_tonumber(L,-2);
      const double lc144_limit = lua_tonumber(L,-1);
      const double lc145_step = 1;
      lua_pop(L,2);
      enum { lc146 = 21 };
      while ((((lc145_step > 0) && (lc143_var <= lc144_limit)) || ((lc145_step <= 0) && (lc143_var >= lc144_limit)))) {
        
        /* internal: local x1 at index 22 */
        lua_pushnumber(L,lc143_var);
        
        /* for y1=0,chunk_size-1 do */
        lua_pushnumber(L,0);
        lua_pushnumber(L,1);
        lc_sub(L,7,-1);
        lua_remove(L,-2);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc147_var = lua_tonumber(L,-2);
        const double lc148_limit = lua_tonumber(L,-1);
        const double lc149_step = 1;
        lua_pop(L,2);
        enum { lc150 = 22 };
        while ((((lc149_step > 0) && (lc147_var <= lc148_limit)) || ((lc149_step <= 0) && (lc147_var >= lc148_limit)))) {
          
          /* internal: local y1 at index 23 */
          lua_pushnumber(L,lc147_var);
          
          /* for z1=0,chunk_size-1 do */
          lua_pushnumber(L,0);
          lua_pushnumber(L,1);
          lc_sub(L,7,-1);
          lua_remove(L,-2);
          if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc151_var = lua_tonumber(L,-2);
          const double lc152_limit = lua_tonumber(L,-1);
          const double lc153_step = 1;
          lua_pop(L,2);
          enum { lc154 = 23 };
          while ((((lc153_step > 0) && (lc151_var <= lc152_limit)) || ((lc153_step <= 0) && (lc151_var >= lc152_limit)))) {
            
            /* internal: local z1 at index 24 */
            lua_pushnumber(L,lc151_var);
            
            /* if pr:next(1,inverse_chance) == 1 then */
            enum { lc155 = 24 };
            lua_pushvalue(L,14);
            lua_pushliteral(L,"next");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushnumber(L,1);
            lua_pushvalue(L,16);
            lua_call(L,3,1);
            lua_pushnumber(L,1);
            const int lc156 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc156);
            const int lc157 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc157) {
              
              /* local x2 = x0+x1 */
              lc_add(L,19,22);
              assert(lua_gettop(L) == 25);
              
              /* local y2 = y0+y1 */
              lc_add(L,18,23);
              assert(lua_gettop(L) == 26);
              
              /* local z2 = z0+z1 */
              lc_add(L,20,24);
              assert(lua_gettop(L) == 27);
              
              /* local p2 = {x=x2, y=y2, z=z2} */
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushvalue(L,25);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushvalue(L,26);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushvalue(L,27);
              lua_rawset(L,-3);
              assert(lua_gettop(L) == 28);
              
              /* if minetest.env:get_node(p2).name == wherein then */
              enum { lc158 = 28 };
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"env");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"get_node");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,28);
              lua_call(L,2,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc159 = lua_equal(L,-1,2);
              lua_pop(L,1);
              lua_pushboolean(L,lc159);
              const int lc160 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc160) {
                
                /* minetest.env:set_node(p2, {name=name}) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"env");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"set_node");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,28);
                lua_createtable(L,0,1);
                lua_pushliteral(L,"name");
                lua_pushvalue(L,1);
                lua_rawset(L,-3);
                lua_call(L,3,0);
                assert(lua_gettop(L) == 28);
              }
              lua_settop(L,lc158);
              assert(lua_gettop(L) == 28);
            }
            lua_settop(L,lc155);
            assert(lua_gettop(L) == 24);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,1);
            lc151_var += lc153_step;
          }
          lua_settop(L,lc154);
          assert(lua_gettop(L) == 23);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
          lc147_var += lc149_step;
        }
        lua_settop(L,lc150);
        assert(lua_gettop(L) == 22);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc143_var += lc145_step;
      }
      lua_settop(L,lc146);
      assert(lua_gettop(L) == 21);
    }
    lua_settop(L,lc141);
    assert(lua_gettop(L) == 18);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc137_var += lc139_step;
  }
  lua_settop(L,lc140);
  assert(lua_gettop(L) == 16);
  return 0;
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* function(minp, maxp, seed) */
static int lcf161 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- Generate stratus
   * print("DARKAGE: Generate stratus") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"DARKAGE: Generate stratus");
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_ore("darkage:desert_stone_with_iron", "default:desert_stone", minp, maxp, seed+0, 1/7/7/7, 3, 5, -15, 40) */
  lc_getupvalue(L,lua_upvalueindex(1),0,3);
  lua_pushliteral(L,"darkage:desert_stone_with_iron");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,0);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,0.0029154518950437);
  lua_pushnumber(L,3);
  lua_pushnumber(L,5);
  lua_pushnumber(L,-15);
  lua_pushnumber(L,40);
  lua_call(L,10,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_claylike("darkage:mud", minp, maxp, seed+1, 4, 0, 2, 0) */
  lc_getupvalue(L,lua_upvalueindex(1),1,2);
  lua_pushliteral(L,"darkage:mud");
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,1);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_pushnumber(L,2);
  lua_pushnumber(L,0);
  lua_call(L,8,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_claylike("darkage:silt", minp, maxp, seed+2, 4, -1, 1, 1) */
  lc_getupvalue(L,lua_upvalueindex(1),1,2);
  lua_pushliteral(L,"darkage:silt");
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,2);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,-1);
  lua_pushnumber(L,1);
  lua_pushnumber(L,1);
  lua_call(L,8,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:chalk", 
   *                    {"default:stone"},
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+3, 4, 25, 8, 0, -20,  50) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:chalk");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,3);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,25);
  lua_pushnumber(L,8);
  lua_pushnumber(L,0);
  lua_pushnumber(L,-20);
  lua_pushnumber(L,50);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:ors", 
   *                    {"default:stone"},
   *                    {"default:stone","air","default:water_source"}, nil,
   *                    minp, maxp, seed+4, 4, 25, 7, 50, -200,  500) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:ors");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:water_source");
  lua_rawseti(L,-2,3);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,4);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,25);
  lua_pushnumber(L,7);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-200);
  lua_pushnumber(L,500);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:shale", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+5, 4, 23, 7, 50, -50,  20) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:shale");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,5);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,23);
  lua_pushnumber(L,7);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-50);
  lua_pushnumber(L,20);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:slate", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+6, 6, 23, 5, 50, -500, 0) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:slate");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,6);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,6);
  lua_pushnumber(L,23);
  lua_pushnumber(L,5);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-500);
  lua_pushnumber(L,0);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:schist", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+7, 6, 19, 6, 50, -31000, -10) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:schist");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,7);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,6);
  lua_pushnumber(L,19);
  lua_pushnumber(L,6);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-10);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:basalt", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+8, 5, 20, 5, 20, -31000, -50) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:basalt");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,8);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,5);
  lua_pushnumber(L,20);
  lua_pushnumber(L,5);
  lua_pushnumber(L,20);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-50);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:marble", 
   *                    {"default:stone"},
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+9, 4, 25, 6, 50, -31000,  -75) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:marble");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,9);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,25);
  lua_pushnumber(L,6);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-75);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:serpentine", 
   *                    {"default:stone"},
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+10, 4, 28, 8, 50, -31000,  -350) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:serpentine");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,10);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,28);
  lua_pushnumber(L,8);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-350);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  
  /* generate_stratus("darkage:gneiss", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+11, 4, 15, 5, 50, -31000, -250) */
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushliteral(L,"darkage:gneiss");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_pushnil(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushnumber(L,11);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,15);
  lua_pushnumber(L,5);
  lua_pushnumber(L,50);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-250);
  lua_call(L,13,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* --Makes a stratus of rocks
   * --name of the rock to generate
   * --wherein kind of node to replace, for example default:stone
   * --minp, maxp the corners of the map to be generated
   * --seed random seed
   * --stratus_chance inverse probability in a given radius 1:2, 1:3 etc
   * --radius horizontal radius of the stratus
   * --radius_y vertical radius of the stratus
   * --deep how deep can be from the ground
   * local function generate_stratus(name, wherein, ceilin, ceil, minp, maxp, seed, stratus_chance, radius, radius_y, deep, height_min, height_max)
   *   if maxp.y < height_min or minp.y > height_max then
   *     return
   *   end
   *   -- it will be only generate a stratus for every 100 m of area
   *   local stratus_per_volume=1
   *   local area=45
   *   local y_min = math.max(minp.y, height_min)
   *   local y_max = math.min(maxp.y, height_max)
   *   local volume = ((maxp.x-minp.x+1)/area)*((y_max-y_min+1)/area)*((maxp.z-minp.z+1)/area)
   *   local pr = PseudoRandom(seed)
   *   local blocks = math.floor(stratus_per_volume*volume)
   *   print("  <<"..dump(name)..">>");
   *   if blocks == 0 then
   *     blocks = 1
   *   end
   *   print("    blocks: "..dump(blocks).." in vol: "..dump(volume).." ("..dump(maxp.x-minp.x+1)..","..dump(y_max-y_min+1)..","..dump(maxp.z-minp.z+1)..")")
   *   for i=1,blocks do
   *     local x = pr:next(1,stratus_chance)
   *     if x == 1 then
   *       -- TODO deep
   *       local y0=y_max-radius_y+1
   *       if y0 < y_min then
   *         y0=y_min
   *       else
   *         y0=pr:next(y_min, y0)
   *       end
   *       local x0 = maxp.x-radius+1
   *       if x0 < minp.x then
   *         x0 = minp.x
   *       else
   *         x0 = pr:next(minp.x, x0)
   *       end
   *       local z0 = maxp.z-radius+1
   *       if z0 < minp.z then
   *         x0 = minp.z
   *       else
   *         z0 = pr:next(minp.z, z0)
   *       end
   *       local p0 = {x=x0, y=y0, z=z0}
   *       local n = minetest.env:get_node(p0).name
   *       local i = 0
   *       --print("    upper node "..n)
   *       x = 0
   *       for k, v in ipairs(ceilin) do
   *         if n == v then
   *           x = 1
   *           break
   *         end
   *       end
   *       if x == 1 then
   *         -- search for the node to replace
   *         --print("    Searching nodes to replace from "..dump(y0-1).." to "..dump(y_min))
   *         for y1=y0-1,y_min,-1 do
   *           p0.y=y1
   *           n = minetest.env:get_node(p0).name
   *           x = 0
   *           for k, v in ipairs(wherein) do
   *             if n == v then
   *               x = 1
   *               break
   *             end
   *           end
   *           if x == 1 then
   *             y0=y1-deep
   *             if y0 < y_min then
   *               y0 = y_min
   *             end
   *             break
   *           end
   *         end
   *         local rx=pr:next(radius/2,radius)+1
   *         local rz=pr:next(radius/2,radius)+1
   *         local ry=pr:next(radius_y/2,radius_y)+1
   *         --print("    area of generation ("..dump(rx)..","..dump(rz)..","..dump(ry)..")")
   *         for x1=0,rx do
   *           rz = rz + 3 - pr:next(1,6)
   *           if rz < 1 then 
   *             rz = 1
   *           end
   *           for z1=pr:next(1,3),rz do
   *             local ry0=ry+ pr:next(1,3)
   *             for y1=pr:next(1,3),ry0 do
   *               local x2 = x0+x1
   *               local y2 = y0+y1
   *               local z2 = z0+z1
   *               local p2 = {x=x2, y=y2, z=z2}
   *               n = minetest.env:get_node(p2).name
   *               x = 0
   *               for k, v in ipairs(wherein) do
   *                 if n == v then
   *                   x = 1
   *                   break
   *                 end
   *               end
   *               if x == 1 then
   *                 if ceil == nil then
   *                   minetest.env:set_node(p2, {name=name})
   *                   i = i +1
   *                 else
   *                   local p3 = {p2.x,p2.y+1,p2}
   *                   if minetest.env:get_node(p3).name == ceil then
   *                      minetest.env:set_node(p2, {name=name})
   *                      i = i +1
   *                   end
   *                 end
   *               end
   *             end
   *           end
   *         end
   *         print("    generated "..dump(i).." blocks in ("..dump(x0)..","..dump(y0)..","..dump(z0)..")")
   *       end
   * 
   *     end
   *   end
   *   --print("generate_ore done")
   * end */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_pushcfunction(L,lcf1_generate_stratus);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local function generate_claylike(name, minp, maxp, seed, chance, minh, maxh, dirt)
   * 	if maxp.y >= maxh+1 and minp.y <= minh-1 then
   *     local pr = PseudoRandom(seed)
   *     local divlen = 4
   *     local divs = (maxp.x-minp.x)/divlen+1;
   *     for yy=minh,maxh do
   *       local x = pr:next(1,chance)
   *       if x == 1 then
   * 		    for divx=0+1,divs-1-1 do
   * 		      for divz=0+1,divs-1-1 do
   * 			      local cx = minp.x + math.floor((divx+0.5)*divlen)
   * 			      local cz = minp.z + math.floor((divz+0.5)*divlen)
   *             local up = minetest.env:get_node({x=cx,y=yy,z=cz}).name
   *             local down = minetest.env:get_node({x=cx,y=yy-1,z=cz}).name
   * 			      if ( up == "default:water_source" or up == "air" ) and
   * 				       ( down == "default:sand" or (dirt == 1 and (down == "default:dirt" or down == "default:dirt_with_grass" ))) then
   * 				      local is_shallow = true
   * 				      local num_water_around = 0
   * 				      if minetest.env:get_node({x=cx-divlen*2,y=yy,z=cz}).name == "default:water_source" then
   * 					      num_water_around = num_water_around + 1 end
   * 				      if minetest.env:get_node({x=cx+divlen*2,y=yy,z=cz}).name == "default:water_source" then
   * 					      num_water_around = num_water_around + 1 end
   * 				      if minetest.env:get_node({x=cx,y=yy,z=cz-divlen*2}).name == "default:water_source" then
   * 					      num_water_around = num_water_around + 1 end
   * 				      if minetest.env:get_node({x=cx,y=yy,z=cz+divlen*2}).name == "default:water_source" then
   * 					      num_water_around = num_water_around + 1 end
   * 				      if num_water_around >= 3 then
   * 					      is_shallow = false
   * 				      end	
   * 				      if is_shallow then
   * 					      for x1=-divlen,divlen do
   * 					        for z1=-divlen,divlen do
   *                     local p={x=cx+x1,y=yy-1,z=cz+z1}
   *                     down = minetest.env:get_node(p).name
   * 						        if down == "default:sand" or (dirt == 1 and (down == "default:dirt" or down == "default:dirt_with_grass")) then
   * 							        minetest.env:set_node(p, {name=name})
   * 						        end
   * 					        end
   * 					      end
   * 				      end
   * 			      end
   * 		      end
   *         end
   *       end
   *     end
   *   end
   * end */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc74 = 2 };
  assert((lua_gettop(L) == (lc74 + lc_nextra)));
  lua_pushcfunction(L,lcf1_generate_claylike);
  lua_rawseti(L,(lc74 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local function generate_ore(name, wherein, minp, maxp, seed, chunks_per_volume, chunk_size, ore_per_chunk, height_min, height_max)
   * 	if maxp.y < height_min or minp.y > height_max then
   * 		return
   * 	end
   * 	local y_min = math.max(minp.y, height_min)
   * 	local y_max = math.min(maxp.y, height_max)
   * 	local volume = (maxp.x-minp.x+1)*(y_max-y_min+1)*(maxp.z-minp.z+1)
   * 	local pr = PseudoRandom(seed)
   * 	local num_chunks = math.floor(chunks_per_volume * volume)
   * 	local inverse_chance = math.floor(chunk_size*chunk_size*chunk_size / ore_per_chunk)
   * 	--print("generate_ore num_chunks: "..dump(num_chunks))
   * 	for i=1,num_chunks do
   * 		local y0 = pr:next(y_min, y_max-chunk_size+1)
   * 		if y0 >= height_min and y0 <= height_max then
   * 			local x0 = pr:next(minp.x, maxp.x-chunk_size+1)
   * 			local z0 = pr:next(minp.z, maxp.z-chunk_size+1)
   * 			local p0 = {x=x0, y=y0, z=z0}
   * 			for x1=0,chunk_size-1 do
   * 			for y1=0,chunk_size-1 do
   * 			for z1=0,chunk_size-1 do
   * 				if pr:next(1,inverse_chance) == 1 then
   * 					local x2 = x0+x1
   * 					local y2 = y0+y1
   * 					local z2 = z0+z1
   * 					local p2 = {x=x2, y=y2, z=z2}
   * 					if minetest.env:get_node(p2).name == wherein then
   * 						minetest.env:set_node(p2, {name=name})
   * 					end
   * 				end
   * 			end
   * 			end
   * 			end
   * 		end
   * 	end
   * 	--print("generate_ore done")
   * end */
  lc_newclosuretable(L,(lc74 + lc_nextra));
  enum { lc132 = 3 };
  assert((lua_gettop(L) == (lc132 + lc_nextra)));
  lua_pushcfunction(L,lcf1_generate_ore);
  lua_rawseti(L,(lc132 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* minetest.register_on_generated(function(minp, maxp, seed)
   *   -- Generate stratus
   *   print("DARKAGE: Generate stratus");
   *   generate_ore("darkage:desert_stone_with_iron", "default:desert_stone", minp, maxp, seed+0, 1/7/7/7, 3, 5, -15, 40)
   *   generate_claylike("darkage:mud", minp, maxp, seed+1, 4, 0, 2, 0)
   *   generate_claylike("darkage:silt", minp, maxp, seed+2, 4, -1, 1, 1)
   *   generate_stratus("darkage:chalk", 
   *                    {"default:stone"},
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+3, 4, 25, 8, 0, -20,  50)
   *   generate_stratus("darkage:ors", 
   *                    {"default:stone"},
   *                    {"default:stone","air","default:water_source"}, nil,
   *                    minp, maxp, seed+4, 4, 25, 7, 50, -200,  500)
   *   generate_stratus("darkage:shale", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+5, 4, 23, 7, 50, -50,  20)
   *   generate_stratus("darkage:slate", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+6, 6, 23, 5, 50, -500, 0)
   *   generate_stratus("darkage:schist", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+7, 6, 19, 6, 50, -31000, -10)
   *   generate_stratus("darkage:basalt", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+8, 5, 20, 5, 20, -31000, -50)
   *   generate_stratus("darkage:marble", 
   *                    {"default:stone"},
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+9, 4, 25, 6, 50, -31000,  -75)
   *   generate_stratus("darkage:serpentine", 
   *                    {"default:stone"},
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+10, 4, 28, 8, 50, -31000,  -350)
   *   generate_stratus("darkage:gneiss", 
   *                    {"default:stone"}, 
   *                    {"default:stone","air"}, nil,
   *                    minp, maxp, seed+11, 4, 15, 5, 50, -31000, -250)
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_generated");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(lc132 + lc_nextra));
  lua_pushcclosure(L,lcf161,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 3);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_darkage_mapgen(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
	const char * msg = lua_tostring(L,-1);
	if (msg == NULL) msg = "(error object is not a string)";
	fputs(msg, stderr);
  }
  return 0;
}



