/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* function(itemstack, placer, pointed_thing) */
static int lcf16 (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if pointed_thing.type ~= "node" then */
  enum { lc3 = 3 };
  lua_pushliteral(L,"type");
  lua_gettable(L,3);
  lua_pushliteral(L,"node");
  const int lc4 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc4);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* return itemstack */
    lua_pushvalue(L,1);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc3);
  assert(lua_gettop(L) == 3);
  
  /* -- If it's being placed on an another similar one, replace it with
   * -- a full block
   * local slabpos = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 4);
  
  /* local slabnode = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 5);
  
  /* local p0 = pointed_thing.under */
  lua_pushliteral(L,"under");
  lua_gettable(L,3);
  assert(lua_gettop(L) == 6);
  
  /* local p1 = pointed_thing.above */
  lua_pushliteral(L,"above");
  lua_gettable(L,3);
  assert(lua_gettop(L) == 7);
  
  /* local n0 = minetest.env:get_node(p0) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,6);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 8);
  
  /* local n1 = minetest.env:get_node(p1) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"env");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,7);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 9);
  
  /* if n0.name == itemname then */
  enum { lc6 = 9 };
  lua_pushliteral(L,"name");
  lua_gettable(L,8);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  const int lc7 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc7);
  const int lc8 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc8) {
    
    /* slabpos = p0 */
    lua_pushvalue(L,6);
    lua_replace(L,4);
    assert(lua_gettop(L) == 9);
    
    /* slabnode = n0 */
    lua_pushvalue(L,8);
    lua_replace(L,5);
    assert(lua_gettop(L) == 9);
  }
  else {
    
    /* elseif n1.name == itemname then */
    enum { lc9 = 9 };
    lua_pushliteral(L,"name");
    lua_gettable(L,9);
    lc_getupvalue(L,lua_upvalueindex(1),0,2);
    const int lc10 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc10);
    const int lc11 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc11) {
      
      /* slabpos = p1 */
      lua_pushvalue(L,7);
      lua_replace(L,4);
      assert(lua_gettop(L) == 9);
      
      /* slabnode = n1 */
      lua_pushvalue(L,9);
      lua_replace(L,5);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc9);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 9);
  
  /* if slabpos then */
  enum { lc12 = 9 };
  if (lua_toboolean(L,4)) {
    
    /* -- Remove the slab at slabpos
     * minetest.env:remove_node(slabpos) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"env");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"remove_node");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 9);
    
    /* -- Make a fake stack of a single item and try to place it
     * local fakestack = ItemStack(recipeitem) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ItemStack");
    lc_getupvalue(L,lua_upvalueindex(1),1,1);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 10);
    
    /* pointed_thing.above = slabpos */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"above");
    lua_insert(L,-2);
    lua_settable(L,3);
    assert(lua_gettop(L) == 10);
    
    /* fakestack = minetest.item_place(fakestack, placer, pointed_thing) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"item_place");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,10);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_call(L,3,1);
    lua_replace(L,10);
    assert(lua_gettop(L) == 10);
    
    /* -- If the item was taken from the fake stack, decrement original
     * if not fakestack or fakestack:is_empty() then */
    enum { lc13 = 10 };
    lua_pushboolean(L,!(lua_toboolean(L,10)));
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_pushliteral(L,"is_empty");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
    }
    const int lc14 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc14) {
      
      /* itemstack:take_item(1) */
      lua_pushvalue(L,1);
      lua_pushliteral(L,"take_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushnumber(L,1);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 10);
    }
    else {
      
      /* else
       * minetest.env:set_node(slabpos, slabnode) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"env");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,4);
      lua_pushvalue(L,5);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc13);
    assert(lua_gettop(L) == 10);
    
    /* return itemstack */
    lua_pushvalue(L,1);
    return 1;
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc12);
  assert(lua_gettop(L) == 9);
  
  /* -- Otherwise place regularly
   * return minetest.item_place(itemstack, placer, pointed_thing) */
  const int lc15 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"item_place");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_call(L,3,LUA_MULTRET);
  return (lua_gettop(L) - lc15);
  assert(lua_gettop(L) == 9);
}


/* name: darkage.register_stairs
 * function(modname, item, groups, images, description) */
static int lcf1_darkage_register_stairs (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* local recipeitem = modname..":"..item */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 6 };
  assert((lua_gettop(L) == lc1));
  lua_pushvalue(L,1);
  lua_pushliteral(L,":");
  lua_pushvalue(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_rawseti(L,lc1,1);
  assert(lua_gettop(L) == 6);
  
  /* local itemname = modname..":stair_"..item */
  lc_newclosuretable(L,lc1);
  enum { lc2 = 7 };
  assert((lua_gettop(L) == lc2));
  lua_pushvalue(L,1);
  lua_pushliteral(L,":stair_");
  lua_pushvalue(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_rawseti(L,lc2,2);
  assert(lua_gettop(L) == 7);
  
  /* minetest.register_node(itemname, {
   * 		description = description.." stair",
   * 		drawtype = "nodebox",
   * 		tiles = images,
   * 		paramtype = "light",
   * 		paramtype2 = "facedir",
   * 		is_ground_content = true,
   * 		groups = groups,
   * 		node_box = {
   * 			type = "fixed",
   * 			fixed = {
   * 				{-0.5, -0.5, -0.5, 0.5, 0, 0.5},
   * 				{-0.5, 0, 0, 0.5, 0.5, 0.5},
   * 			},
   * 		},
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc2,0,2);
  lua_createtable(L,0,8);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,5);
  lua_pushliteral(L," stair");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"nodebox");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype2");
  lua_pushliteral(L,"facedir");
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"node_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,2,0);
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawseti(L,-2,1);
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 7);
  
  /* minetest.register_craft({
   * 		output = itemname .. ' 4',
   * 		recipe = {
   * 			{recipeitem, "", ""},
   * 			{recipeitem, recipeitem, ""},
   * 			{recipeitem, recipeitem, recipeitem},
   * 		},
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"output");
  lc_getupvalue(L,lc2,0,2);
  lua_pushliteral(L," 4");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,3,0);
  lua_createtable(L,3,0);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,3,0);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,2);
  lua_createtable(L,3,0);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,2);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 7);
  
  /* -- Flipped recipe for the silly minecrafters
   * minetest.register_craft({
   * 		output = itemname .. ' 4',
   * 		recipe = {
   * 			{"", "", recipeitem},
   * 			{"", recipeitem, recipeitem},
   * 			{recipeitem, recipeitem, recipeitem},
   * 		},
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"output");
  lc_getupvalue(L,lc2,0,2);
  lua_pushliteral(L," 4");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,3,0);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,2);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,2);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,2);
  lua_createtable(L,3,0);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,2);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 7);
  
  /* itemname=modname..":slab_" .. item */
  lua_pushvalue(L,1);
  lua_pushliteral(L,":slab_");
  lua_pushvalue(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lc_setupvalue(L,lc2,0,2);
  assert(lua_gettop(L) == 7);
  
  /* minetest.register_node(itemname, {
   * 		description = description.." slab",
   * 		drawtype = "nodebox",
   * 		tiles = images,
   * 		paramtype = "light",
   * 		is_ground_content = true,
   * 		groups = groups,
   * 		node_box = {
   * 			type = "fixed",
   * 			fixed = {-0.5, -0.5, -0.5, 0.5, 0, 0.5},
   * 		},
   * 		selection_box = {
   * 			type = "fixed",
   * 			fixed = {-0.5, -0.5, -0.5, 0.5, 0, 0.5},
   * 		},
   * 		on_place = function(itemstack, placer, pointed_thing)
   * 			if pointed_thing.type ~= "node" then
   * 				return itemstack
   * 			end
   * 
   * 			-- If it's being placed on an another similar one, replace it with
   * 			-- a full block
   * 			local slabpos = nil
   * 			local slabnode = nil
   * 			local p0 = pointed_thing.under
   * 			local p1 = pointed_thing.above
   * 			local n0 = minetest.env:get_node(p0)
   * 			local n1 = minetest.env:get_node(p1)
   * 			if n0.name == itemname then
   * 				slabpos = p0
   * 				slabnode = n0
   * 			elseif n1.name == itemname then
   * 				slabpos = p1
   * 				slabnode = n1
   * 			end
   * 			if slabpos then
   * 				-- Remove the slab at slabpos
   * 				minetest.env:remove_node(slabpos)
   * 				-- Make a fake stack of a single item and try to place it
   * 				local fakestack = ItemStack(recipeitem)
   * 				pointed_thing.above = slabpos
   * 				fakestack = minetest.item_place(fakestack, placer, pointed_thing)
   * 				-- If the item was taken from the fake stack, decrement original
   * 				if not fakestack or fakestack:is_empty() then
   * 					itemstack:take_item(1)
   * 				-- Else put old node back
   * 				else
   * 					minetest.env:set_node(slabpos, slabnode)
   * 				end
   * 				return itemstack
   * 			end
   * 			
   * 			-- Otherwise place regularly
   * 			return minetest.item_place(itemstack, placer, pointed_thing)
   * 		end,
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc2,0,2);
  lua_createtable(L,0,9);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,5);
  lua_pushliteral(L," slab");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"nodebox");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"node_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"selection_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_place");
  lua_pushvalue(L,lc2);
  lua_pushcclosure(L,lcf16,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 7);
  
  /* minetest.register_craft({
   * 		output = itemname .. ' 3',
   * 		recipe = {
   * 			{recipeitem, recipeitem, recipeitem},
   * 		},
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"output");
  lc_getupvalue(L,lc2,0,2);
  lua_pushliteral(L," 3");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,1,0);
  lua_createtable(L,3,0);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,1);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,2);
  lc_getupvalue(L,lc2,1,1);
  lua_rawseti(L,-2,3);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* darkage = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"darkage");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function darkage.register_stairs(modname, item, groups, images, description)
   *   local recipeitem = modname..":"..item
   *   local itemname = modname..":stair_"..item
   * 	minetest.register_node(itemname, {
   * 		description = description.." stair",
   * 		drawtype = "nodebox",
   * 		tiles = images,
   * 		paramtype = "light",
   * 		paramtype2 = "facedir",
   * 		is_ground_content = true,
   * 		groups = groups,
   * 		node_box = {
   * 			type = "fixed",
   * 			fixed = {
   * 				{-0.5, -0.5, -0.5, 0.5, 0, 0.5},
   * 				{-0.5, 0, 0, 0.5, 0.5, 0.5},
   * 			},
   * 		},
   * 	})
   * 
   * 	minetest.register_craft({
   * 		output = itemname .. ' 4',
   * 		recipe = {
   * 			{recipeitem, "", ""},
   * 			{recipeitem, recipeitem, ""},
   * 			{recipeitem, recipeitem, recipeitem},
   * 		},
   * 	})
   * 
   * 	-- Flipped recipe for the silly minecrafters
   * 	minetest.register_craft({
   * 		output = itemname .. ' 4',
   * 		recipe = {
   * 			{"", "", recipeitem},
   * 			{"", recipeitem, recipeitem},
   * 			{recipeitem, recipeitem, recipeitem},
   * 		},
   * 	})
   * 
   *   itemname=modname..":slab_" .. item
   * 
   * 	minetest.register_node(itemname, {
   * 		description = description.." slab",
   * 		drawtype = "nodebox",
   * 		tiles = images,
   * 		paramtype = "light",
   * 		is_ground_content = true,
   * 		groups = groups,
   * 		node_box = {
   * 			type = "fixed",
   * 			fixed = {-0.5, -0.5, -0.5, 0.5, 0, 0.5},
   * 		},
   * 		selection_box = {
   * 			type = "fixed",
   * 			fixed = {-0.5, -0.5, -0.5, 0.5, 0, 0.5},
   * 		},
   * 		on_place = function(itemstack, placer, pointed_thing)
   * 			if pointed_thing.type ~= "node" then
   * 				return itemstack
   * 			end
   * 
   * 			-- If it's being placed on an another similar one, replace it with
   * 			-- a full block
   * 			local slabpos = nil
   * 			local slabnode = nil
   * 			local p0 = pointed_thing.under
   * 			local p1 = pointed_thing.above
   * 			local n0 = minetest.env:get_node(p0)
   * 			local n1 = minetest.env:get_node(p1)
   * 			if n0.name == itemname then
   * 				slabpos = p0
   * 				slabnode = n0
   * 			elseif n1.name == itemname then
   * 				slabpos = p1
   * 				slabnode = n1
   * 			end
   * 			if slabpos then
   * 				-- Remove the slab at slabpos
   * 				minetest.env:remove_node(slabpos)
   * 				-- Make a fake stack of a single item and try to place it
   * 				local fakestack = ItemStack(recipeitem)
   * 				pointed_thing.above = slabpos
   * 				fakestack = minetest.item_place(fakestack, placer, pointed_thing)
   * 				-- If the item was taken from the fake stack, decrement original
   * 				if not fakestack or fakestack:is_empty() then
   * 					itemstack:take_item(1)
   * 				-- Else put old node back
   * 				else
   * 					minetest.env:set_node(slabpos, slabnode)
   * 				end
   * 				return itemstack
   * 			end
   * 			
   * 			-- Otherwise place regularly
   * 			return minetest.item_place(itemstack, placer, pointed_thing)
   * 		end,
   * 	})
   * 
   * 	minetest.register_craft({
   * 		output = itemname .. ' 3',
   * 		recipe = {
   * 			{recipeitem, recipeitem, recipeitem},
   * 		},
   * 	})
   * end */
  lua_pushcfunction(L,lcf1_darkage_register_stairs);
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_stairs");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* darkage.register_stairs("darkage","basalt_cobble",
   * 	{cracky=3},
   * 	{"darkage_basalt_cobble.png"},
   * 	"Basalt Cobble"
   * ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_pushliteral(L,"register_stairs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"darkage");
  lua_pushliteral(L,"basalt_cobble");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"darkage_basalt_cobble.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Basalt Cobble");
  lua_call(L,5,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* darkage.register_stairs("darkage","slate_tale",
   * 	{cracky=3},
   * 	{"darkage_slate_tale.png"},
   * 	"Slate Tale"
   * ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_pushliteral(L,"register_stairs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"darkage");
  lua_pushliteral(L,"slate_tale");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"darkage_slate_tale.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Slate Tale");
  lua_call(L,5,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* darkage.register_stairs("darkage","straw",
   * 	 {snappy=3, flammable=2},
   * 	{"darkage_straw.png"},
   * 	"Straw"
   * ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_pushliteral(L,"register_stairs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"darkage");
  lua_pushliteral(L,"straw");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"snappy");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"flammable");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"darkage_straw.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Straw");
  lua_call(L,5,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* darkage.register_stairs("darkage","stone_brick",
   * 	{cracky=3},
   * 	{"darkage_stone_brick.png"},
   * 	"Stone Brick"
   * ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_pushliteral(L,"register_stairs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"darkage");
  lua_pushliteral(L,"stone_brick");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"darkage_stone_brick.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Stone Brick");
  lua_call(L,5,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* darkage.register_stairs("darkage","ors_cobble",
   * 	{cracky=3},
   * 	{"darkage_ors_cobble.png"},
   * 	"Old Red Sandtone"
   * ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_pushliteral(L,"register_stairs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"darkage");
  lua_pushliteral(L,"ors_cobble");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"darkage_ors_cobble.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Old Red Sandtone");
  lua_call(L,5,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* darkage.register_stairs("darkage","desert_stone_cobble",
   * 	{cracky=3},
   * 	{"darkage_desert_stone_cobble.png"},
   * 	"Desert Stone Cobble"
   * ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"darkage");
  lua_pushliteral(L,"register_stairs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"darkage");
  lua_pushliteral(L,"desert_stone_cobble");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"darkage_desert_stone_cobble.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Desert Stone Cobble");
  lua_call(L,5,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_darkage_stairs(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
	const char * msg = lua_tostring(L,-1);
	if (msg == NULL) msg = "(error object is not a string)";
	fputs(msg, stderr);
  }
  return 0;
}
