/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

#include "cpp_mods/cpp_mods_init.h"

/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* function() */
static int lcf27 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* local n = minetest.get_node(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,7);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 1);
  
  /* if n ~= nil then */
  enum { lc21 = 1 };
  lua_pushnil(L);
  const int lc22 = lua_equal(L,1,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc22);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc23 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc23) {
    
    /* if n.name == "mines:dummy" then */
    enum { lc24 = 1 };
    lua_pushliteral(L,"name");
    lua_gettable(L,1);
    lua_pushliteral(L,"mines:dummy");
    const int lc25 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc25);
    const int lc26 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc26) {
      
      /* minetest.set_node(pos, {name="default:torch",param2=1}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,7);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"name");
      lua_pushliteral(L,"default:torch");
      lua_rawset(L,-3);
      lua_pushliteral(L,"param2");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 1);
    }
    lua_settop(L,lc24);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc21);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: rotate_torch
 * function(pos) */
static int lcf1_rotate_torch (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc20 = 2 };
  assert((lua_gettop(L) == lc20));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,7);
  
  /* minetest.after(8, function()
   * 		local n = minetest.get_node(pos)
   * 		if n ~= nil then
   * 			if n.name == "mines:dummy" then
   * 				minetest.set_node(pos, {name="default:torch",param2=1})
   * 			end
   * 		end
   * 	end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"after");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  lua_pushvalue(L,lc20);
  lua_pushcclosure(L,lcf27,1);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function() */
static int lcf43 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* local n = minetest.get_node(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),0,9);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 1);
  
  /* if n ~= nil then */
  enum { lc30 = 1 };
  lua_pushnil(L);
  const int lc31 = lua_equal(L,1,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc31);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc32 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc32) {
    
    /* if n.name == "mines:dummy" then */
    enum { lc33 = 1 };
    lua_pushliteral(L,"name");
    lua_gettable(L,1);
    lua_pushliteral(L,"mines:dummy");
    const int lc34 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc34);
    const int lc35 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc35) {
      
      /* minetest.set_node(pos, {name="default:chest"}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,9);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lua_pushliteral(L,"default:chest");
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 1);
      
      /* local meta = minetest.get_meta(pos) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_meta");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,9);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 2);
      
      /* --meta:set_string("formspec",default.chest_formspec)
       * --meta:set_string("infotext", "Chest")
       * local inv = meta:get_inventory() */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"get_inventory");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 3);
      
      /* inv:set_size("main", 8*4) */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"set_size");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"main");
      lua_pushnumber(L,32);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 3);
      
      /* for i=0,2,1 do */
      lua_pushnumber(L,0);
      lua_pushnumber(L,2);
      lua_pushnumber(L,1);
      if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc36_var = lua_tonumber(L,-3);
      const double lc37_limit = lua_tonumber(L,-2);
      const double lc38_step = lua_tonumber(L,-1);
      lua_pop(L,3);
      enum { lc39 = 3 };
      while ((((lc38_step > 0) && (lc36_var <= lc37_limit)) || ((lc38_step <= 0) && (lc36_var >= lc37_limit)))) {
        
        /* internal: local i at index 4 */
        lua_pushnumber(L,lc36_var);
        
        /* local stuff = chest_stuff[math.random(1,#chest_stuff)] */
        lc_getupvalue(L,lua_upvalueindex(1),3,5);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),3,5);
        const double lc40 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc40);
        lua_call(L,2,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 5);
        
        /* local stack = {name=stuff.name, count = math.random(1,stuff.max)} */
        lua_createtable(L,0,2);
        lua_pushliteral(L,"name");
        lua_pushliteral(L,"name");
        lua_gettable(L,5);
        lua_rawset(L,-3);
        lua_pushliteral(L,"count");
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushliteral(L,"max");
        lua_gettable(L,5);
        lua_call(L,2,1);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 6);
        
        /* if not inv:contains_item("main", stack) then */
        enum { lc41 = 6 };
        lua_pushvalue(L,3);
        lua_pushliteral(L,"contains_item");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"main");
        lua_pushvalue(L,6);
        lua_call(L,3,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc42 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc42) {
          
          /* inv:set_stack("main", math.random(1,32), stack) */
          lua_pushvalue(L,3);
          lua_pushliteral(L,"set_stack");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"main");
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_pushnumber(L,32);
          lua_call(L,2,1);
          lua_pushvalue(L,6);
          lua_call(L,4,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc41);
        assert(lua_gettop(L) == 6);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,3);
        lc36_var += lc38_step;
      }
      lua_settop(L,lc39);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc33);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc30);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: fill_chest
 * function(pos) */
static int lcf1_fill_chest (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc29 = 2 };
  assert((lua_gettop(L) == lc29));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,9);
  
  /* minetest.after(5, function()
   * 		local n = minetest.get_node(pos)
   * 		if n ~= nil then
   * 			if n.name == "mines:dummy" then
   * 				minetest.set_node(pos, {name="default:chest"})
   * 				local meta = minetest.get_meta(pos)
   * 				--meta:set_string("formspec",default.chest_formspec)
   * 				--meta:set_string("infotext", "Chest")
   * 				local inv = meta:get_inventory()
   * 				inv:set_size("main", 8*4)
   * 				for i=0,2,1 do
   * 					local stuff = chest_stuff[math.random(1,#chest_stuff)]
   * 					local stack = {name=stuff.name, count = math.random(1,stuff.max)}
   * 					if not inv:contains_item("main", stack) then
   * 						inv:set_stack("main", math.random(1,32), stack)
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"after");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,5);
  lua_pushvalue(L,lc29);
  lua_pushcclosure(L,lcf43,1);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: check_dir
 * function(dir,old_dir) */
static int lcf1_check_dir (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if old_dir == 1 and dir == 3 then */
  enum { lc45 = 2 };
  lua_pushvalue(L,2);
  lua_pushnumber(L,1);
  const int lc46 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc46);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,1);
    lua_pushnumber(L,3);
    const int lc47 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc47);
  }
  const int lc48 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc48) {
    
    /* --n_switch = 2
     * return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* elseif old_dir == 3 and dir == 1 then */
    enum { lc49 = 2 };
    lua_pushvalue(L,2);
    lua_pushnumber(L,3);
    const int lc50 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc50);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,1);
      lua_pushnumber(L,1);
      const int lc51 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc51);
    }
    const int lc52 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc52) {
      
      /* --n_switch = 4
       * return true */
      lua_pushboolean(L,1);
      return 1;
      assert(lua_gettop(L) == 2);
    }
    else {
      
      /* elseif old_dir == 2 and dir == 4 then */
      enum { lc53 = 2 };
      lua_pushvalue(L,2);
      lua_pushnumber(L,2);
      const int lc54 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc54);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,1);
        lua_pushnumber(L,4);
        const int lc55 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc55);
      }
      const int lc56 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc56) {
        
        /* --n_switch = 1
         * return true */
        lua_pushboolean(L,1);
        return 1;
        assert(lua_gettop(L) == 2);
      }
      else {
        
        /* elseif old_dir == 4 and dir == 2 then */
        enum { lc57 = 2 };
        lua_pushvalue(L,2);
        lua_pushnumber(L,4);
        const int lc58 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc58);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,1);
          lua_pushnumber(L,2);
          const int lc59 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc59);
        }
        const int lc60 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc60) {
          
          /* --n_switch = 3
           * return true */
          lua_pushboolean(L,1);
          return 1;
          assert(lua_gettop(L) == 2);
        }
        lua_settop(L,lc57);
      }
      lua_settop(L,lc53);
    }
    lua_settop(L,lc49);
  }
  lua_settop(L,lc45);
  assert(lua_gettop(L) == 2);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: make_mine
 * function(mpos,p2,p3, vm_data, vx_area,cnt) */
static int lcf1_make_mine (lua_State * L) {
  lua_checkstack(L,31);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* local pos = {x=mpos.x,y=mpos.y,z=mpos.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 7);
  
  /* for j=0,12,1 do */
  lua_pushnumber(L,0);
  lua_pushnumber(L,12);
  lua_pushnumber(L,1);
  if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc62_var = lua_tonumber(L,-3);
  const double lc63_limit = lua_tonumber(L,-2);
  const double lc64_step = lua_tonumber(L,-1);
  lua_pop(L,3);
  enum { lc65 = 7 };
  while ((((lc64_step > 0) && (lc62_var <= lc63_limit)) || ((lc64_step <= 0) && (lc62_var >= lc63_limit)))) {
    
    /* internal: local j at index 8 */
    lua_pushnumber(L,lc62_var);
    
    /* local switch = cnt+1 */
    lua_pushnumber(L,1);
    lc_add(L,6,-1);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 9);
    
    /* n_switch = math.random(1,4) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,4);
    lua_call(L,2,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"n_switch");
    assert(lua_gettop(L) == 9);
    
    /* while check_dir(n_switch,switch) == true do */
    enum { lc66 = 9 };
    while (1) {
      lc_getupvalue(L,lua_upvalueindex(1),1,10);
      lua_getfield(L,LUA_ENVIRONINDEX,"n_switch");
      lua_pushvalue(L,9);
      lua_call(L,2,1);
      lua_pushboolean(L,1);
      const int lc67 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc67);
      if (!(lua_toboolean(L,-1))) {
        break;
      }
      lua_pop(L,1);
      
      /* n_switch = math.random(1,4) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,4);
      lua_call(L,2,1);
      lua_setfield(L,LUA_ENVIRONINDEX,"n_switch");
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc66);
    assert(lua_gettop(L) == 9);
    
    /* switch = n_switch */
    lua_getfield(L,LUA_ENVIRONINDEX,"n_switch");
    lua_replace(L,9);
    assert(lua_gettop(L) == 9);
    
    /* for i=0,20,1 do */
    lua_pushnumber(L,0);
    lua_pushnumber(L,20);
    lua_pushnumber(L,1);
    if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc68_var = lua_tonumber(L,-3);
    const double lc69_limit = lua_tonumber(L,-2);
    const double lc70_step = lua_tonumber(L,-1);
    lua_pop(L,3);
    enum { lc71 = 9 };
    while ((((lc70_step > 0) && (lc68_var <= lc69_limit)) || ((lc70_step <= 0) && (lc68_var >= lc69_limit)))) {
      
      /* internal: local i at index 10 */
      lua_pushnumber(L,lc68_var);
      
      /* local pillar = ids.air */
      lc_getupvalue(L,lua_upvalueindex(1),5,4);
      lua_pushliteral(L,"air");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 11);
      
      /* local pillar_top = ids.air */
      lc_getupvalue(L,lua_upvalueindex(1),5,4);
      lua_pushliteral(L,"air");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 12);
      
      /* if i==0 or i == 5 or i == 10 or i == 15 or i == 20 then */
      enum { lc72 = 12 };
      lua_pushvalue(L,10);
      lua_pushnumber(L,0);
      const int lc73 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc73);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
        lua_pushnumber(L,5);
        const int lc74 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc74);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
        lua_pushnumber(L,10);
        const int lc75 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc75);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
        lua_pushnumber(L,15);
        const int lc76 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc76);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,10);
        lua_pushnumber(L,20);
        const int lc77 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc77);
      }
      const int lc78 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc78) {
        
        /* pillar = ids.fence */
        lc_getupvalue(L,lua_upvalueindex(1),5,4);
        lua_pushliteral(L,"fence");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_replace(L,11);
        assert(lua_gettop(L) == 12);
        
        /* pillar_top = ids.wood */
        lc_getupvalue(L,lua_upvalueindex(1),5,4);
        lua_pushliteral(L,"wood");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_replace(L,12);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc72);
      assert(lua_gettop(L) == 12);
      
      /* local x1 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 13);
      
      /* local x2 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 14);
      
      /* local x3 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 15);
      
      /* local x4 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 16);
      
      /* local z1 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 17);
      
      /* local z2 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 18);
      
      /* local z3 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 19);
      
      /* local z4 */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 20);
      
      /* if switch == 1 then */
      enum { lc79 = 20 };
      lua_pushnumber(L,1);
      const int lc80 = lua_equal(L,9,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc80);
      const int lc81 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc81) {
        
        /* x1 = pos.x+1 */
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,13);
        assert(lua_gettop(L) == 20);
        
        /* x2 = pos.x */
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_replace(L,14);
        assert(lua_gettop(L) == 20);
        
        /* x3 = pos.x-1 */
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 20);
        
        /* x4 = pos.x */
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_replace(L,16);
        assert(lua_gettop(L) == 20);
        
        /* x5 = pos.x+1 */
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_setfield(L,LUA_ENVIRONINDEX,"x5");
        assert(lua_gettop(L) == 20);
        
        /* z1 = pos.z+i */
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_replace(L,17);
        assert(lua_gettop(L) == 20);
        
        /* z2 = pos.z+i */
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_replace(L,18);
        assert(lua_gettop(L) == 20);
        
        /* z3 = pos.z+i */
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_replace(L,19);
        assert(lua_gettop(L) == 20);
        
        /* z4 = pos.z+i-1 */
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,20);
        assert(lua_gettop(L) == 20);
        
        /* z5 = pos.z+i */
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_setfield(L,LUA_ENVIRONINDEX,"z5");
        assert(lua_gettop(L) == 20);
      }
      else {
        
        /* elseif switch == 2 then */
        enum { lc82 = 20 };
        lua_pushnumber(L,2);
        const int lc83 = lua_equal(L,9,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc83);
        const int lc84 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc84) {
          
          /* x1 = pos.x+i */
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_replace(L,13);
          assert(lua_gettop(L) == 20);
          
          /* x2 = pos.x+i */
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_replace(L,14);
          assert(lua_gettop(L) == 20);
          
          /* x3 = pos.x+i */
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_replace(L,15);
          assert(lua_gettop(L) == 20);
          
          /* x4 = pos.x+i-1 */
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,16);
          assert(lua_gettop(L) == 20);
          
          /* x5 = pos.x+i */
          lua_pushliteral(L,"x");
          lua_gettable(L,7);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_setfield(L,LUA_ENVIRONINDEX,"x5");
          assert(lua_gettop(L) == 20);
          
          /* z1 = pos.z+1 */
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,17);
          assert(lua_gettop(L) == 20);
          
          /* z2 = pos.z */
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_replace(L,18);
          assert(lua_gettop(L) == 20);
          
          /* z3 = pos.z-1 */
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,19);
          assert(lua_gettop(L) == 20);
          
          /* z4 = pos.z */
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_replace(L,20);
          assert(lua_gettop(L) == 20);
          
          /* z5 = pos.z+1 */
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_setfield(L,LUA_ENVIRONINDEX,"z5");
          assert(lua_gettop(L) == 20);
        }
        else {
          
          /* elseif switch == 3 then */
          enum { lc85 = 20 };
          lua_pushnumber(L,3);
          const int lc86 = lua_equal(L,9,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc86);
          const int lc87 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc87) {
            
            /* x1 = pos.x+1 */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,13);
            assert(lua_gettop(L) == 20);
            
            /* x2 = pos.x */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lua_replace(L,14);
            assert(lua_gettop(L) == 20);
            
            /* x3 = pos.x-1 */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,15);
            assert(lua_gettop(L) == 20);
            
            /* x4 = pos.x */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lua_replace(L,16);
            assert(lua_gettop(L) == 20);
            
            /* x5 = pos.x+1 */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_setfield(L,LUA_ENVIRONINDEX,"x5");
            assert(lua_gettop(L) == 20);
            
            /* z1 = pos.z-i */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_replace(L,17);
            assert(lua_gettop(L) == 20);
            
            /* z2 = pos.z-i */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_replace(L,18);
            assert(lua_gettop(L) == 20);
            
            /* z3 = pos.z-i */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_replace(L,19);
            assert(lua_gettop(L) == 20);
            
            /* z4 = pos.z-i-1 */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,20);
            assert(lua_gettop(L) == 20);
            
            /* z5 = pos.z-i */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_setfield(L,LUA_ENVIRONINDEX,"z5");
            assert(lua_gettop(L) == 20);
          }
          else {
            
            /* else
             * x1 = pos.x-i */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_replace(L,13);
            assert(lua_gettop(L) == 20);
            
            /* x2 = pos.x-i */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_replace(L,14);
            assert(lua_gettop(L) == 20);
            
            /* x3 = pos.x-i */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_replace(L,15);
            assert(lua_gettop(L) == 20);
            
            /* x4 = pos.x-i-1 */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,16);
            assert(lua_gettop(L) == 20);
            
            /* x5 = pos.x-i */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lc_sub(L,-1,10);
            lua_remove(L,-2);
            lua_setfield(L,LUA_ENVIRONINDEX,"x5");
            assert(lua_gettop(L) == 20);
            
            /* z1 = pos.z+1 */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,17);
            assert(lua_gettop(L) == 20);
            
            /* z2 = pos.z */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lua_replace(L,18);
            assert(lua_gettop(L) == 20);
            
            /* z3 = pos.z-1 */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,19);
            assert(lua_gettop(L) == 20);
            
            /* z4 = pos.z */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lua_replace(L,20);
            assert(lua_gettop(L) == 20);
            
            /* z5 = pos.z+1 */
            lua_pushliteral(L,"z");
            lua_gettable(L,7);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_setfield(L,LUA_ENVIRONINDEX,"z5");
            assert(lua_gettop(L) == 20);
          }
          lua_settop(L,lc85);
        }
        lua_settop(L,lc82);
      }
      lua_settop(L,lc79);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x1, y=pos.y-1, z=z1})] = pillar */
      lua_pushvalue(L,11);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,13);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,17);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x2, y=pos.y-1, z=z2})] = ids.air */
      lc_getupvalue(L,lua_upvalueindex(1),5,4);
      lua_pushliteral(L,"air");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,14);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,18);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x3, y=pos.y-1, z=z3})] = pillar */
      lua_pushvalue(L,11);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,15);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,19);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x1, y=pos.y, z=z1})] = pillar */
      lua_pushvalue(L,11);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,13);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,17);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x2, y=pos.y, z=z2})] = ids.air */
      lc_getupvalue(L,lua_upvalueindex(1),5,4);
      lua_pushliteral(L,"air");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,14);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,18);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x3, y=pos.y, z=z3})] = pillar */
      lua_pushvalue(L,11);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,15);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,19);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x1, y=pos.y+1, z=z1})] = pillar_top */
      lua_pushvalue(L,12);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,13);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,17);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x2, y=pos.y+1, z=z2})] = pillar_top */
      lua_pushvalue(L,12);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,14);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,18);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* vm_data[vx_area:indexp({x=x3, y=pos.y+1, z=z3})] = pillar_top */
      lua_pushvalue(L,12);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"indexp");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,15);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,19);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 20);
      
      /* if math.random(0,6) == 3 then */
      enum { lc88 = 20 };
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_pushnumber(L,6);
      lua_call(L,2,1);
      lua_pushnumber(L,3);
      const int lc89 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc89);
      const int lc90 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc90) {
        
        /* vm_data[vx_area:indexp({x=x4, y=pos.y-1, z=z4})] = ids.dummy */
        lc_getupvalue(L,lua_upvalueindex(1),5,4);
        lua_pushliteral(L,"dummy");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,5);
        lua_pushliteral(L,"indexp");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushvalue(L,16);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushvalue(L,20);
        lua_rawset(L,-3);
        lua_call(L,2,1);
        lua_insert(L,-2);
        lua_settable(L,4);
        assert(lua_gettop(L) == 20);
        
        /* rotate_torch({x=x4, y=pos.y-1, z=z4}) */
        lc_getupvalue(L,lua_upvalueindex(1),3,6);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushvalue(L,16);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushvalue(L,20);
        lua_rawset(L,-3);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 20);
      }
      lua_settop(L,lc88);
      assert(lua_gettop(L) == 20);
      
      /* if math.random(0,60) == 13 then */
      enum { lc91 = 20 };
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_pushnumber(L,60);
      lua_call(L,2,1);
      lua_pushnumber(L,13);
      const int lc92 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc92);
      const int lc93 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc93) {
        
        /* local p = {x=x5, y=pos.y-1, z=z5} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_getfield(L,LUA_ENVIRONINDEX,"x5");
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,7);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_getfield(L,LUA_ENVIRONINDEX,"z5");
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 21);
        
        /* if vm_data[vx_area:indexp(p)] ~= ids.fence then */
        enum { lc94 = 21 };
        lua_pushvalue(L,5);
        lua_pushliteral(L,"indexp");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,21);
        lua_call(L,2,1);
        lua_gettable(L,4);
        lc_getupvalue(L,lua_upvalueindex(1),5,4);
        lua_pushliteral(L,"fence");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc95 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc95);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc96 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc96) {
          
          /* vm_data[vx_area:indexp(p)] = ids.dummy */
          lc_getupvalue(L,lua_upvalueindex(1),5,4);
          lua_pushliteral(L,"dummy");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,5);
          lua_pushliteral(L,"indexp");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,21);
          lua_call(L,2,1);
          lua_insert(L,-2);
          lua_settable(L,4);
          assert(lua_gettop(L) == 21);
          
          /* fill_chest(p) */
          lc_getupvalue(L,lua_upvalueindex(1),2,8);
          lua_pushvalue(L,21);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 21);
        }
        lua_settop(L,lc94);
        assert(lua_gettop(L) == 21);
      }
      lua_settop(L,lc91);
      assert(lua_gettop(L) == 20);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,11);
      lc68_var += lc70_step;
    }
    lua_settop(L,lc71);
    assert(lua_gettop(L) == 9);
    
    /* if switch == 1 then */
    enum { lc97 = 9 };
    lua_pushnumber(L,1);
    const int lc98 = lua_equal(L,9,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc98);
    const int lc99 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc99) {
      
      /* pos.z = pos.z+20 */
      lua_pushliteral(L,"z");
      lua_gettable(L,7);
      lua_pushnumber(L,20);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_insert(L,-2);
      lua_settable(L,7);
      assert(lua_gettop(L) == 9);
    }
    else {
      
      /* --pos.x = pos.x+step
       * 		elseif switch == 2 then */
      enum { lc100 = 9 };
      lua_pushnumber(L,2);
      const int lc101 = lua_equal(L,9,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc101);
      const int lc102 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc102) {
        
        /* pos.x = pos.x+20 */
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushnumber(L,20);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* --pos.z = pos.z+step
         * 		elseif switch == 3 then */
        enum { lc103 = 9 };
        lua_pushnumber(L,3);
        const int lc104 = lua_equal(L,9,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc104);
        const int lc105 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc105) {
          
          /* pos.z = pos.z-20 */
          lua_pushliteral(L,"z");
          lua_gettable(L,7);
          lua_pushnumber(L,20);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"z");
          lua_insert(L,-2);
          lua_settable(L,7);
          assert(lua_gettop(L) == 9);
        }
        else {
          
          /* --pos.x = pos.x+step
           * 		elseif switch == 4 then */
          enum { lc106 = 9 };
          lua_pushnumber(L,4);
          const int lc107 = lua_equal(L,9,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc107);
          const int lc108 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc108) {
            
            /* pos.x = pos.x-20 */
            lua_pushliteral(L,"x");
            lua_gettable(L,7);
            lua_pushnumber(L,20);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"x");
            lua_insert(L,-2);
            lua_settable(L,7);
            assert(lua_gettop(L) == 9);
          }
          lua_settop(L,lc106);
        }
        lua_settop(L,lc103);
      }
      lua_settop(L,lc100);
    }
    lua_settop(L,lc97);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc62_var += lc64_step;
  }
  lua_settop(L,lc65);
  assert(lua_gettop(L) == 7);
  
  /* if cnt == 0 then */
  enum { lc109 = 7 };
  lua_pushnumber(L,0);
  const int lc110 = lua_equal(L,6,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc110);
  const int lc111 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc111) {
    
    /* minetest.log("action", "Created mine at ("..mpos.x..","..mpos.y..","..mpos.z..")") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"action");
    lua_pushliteral(L,"Created mine at (");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_pushliteral(L,",");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushliteral(L,",");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_pushliteral(L,")");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 7);
    
    /* local out2 = make_mine(p2,p3,mpos,vm_data,vx_area,1) */
    lc_getupvalue(L,lua_upvalueindex(1),0,11);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,1);
    lua_pushvalue(L,4);
    lua_pushvalue(L,5);
    lua_pushnumber(L,1);
    lua_call(L,6,1);
    assert(lua_gettop(L) == 8);
    
    /* local out3 = make_mine(p3,p2,mpos,out2,vx_area,2) */
    lc_getupvalue(L,lua_upvalueindex(1),0,11);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,8);
    lua_pushvalue(L,5);
    lua_pushnumber(L,2);
    lua_call(L,6,1);
    assert(lua_gettop(L) == 9);
    
    /* return out3 */
    lua_pushvalue(L,9);
    return 1;
    assert(lua_gettop(L) == 9);
  }
  else {
    
    /* else
     * return vm_data */
    lua_pushvalue(L,4);
    return 1;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc109);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: find_cave
 * function(min,max,vm_data, vx_area) */
static int lcf1_find_cave (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local out = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 5);
  
  /* for i in vx_area:iterp(min, max) do
   * internal: local f, s, var = explist */
  enum { lc113 = 5 };
  lua_pushvalue(L,4);
  lua_pushliteral(L,"iterp");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,3,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,1);
    if (lua_isnil(L,-1)) {
      break;
    }
    lua_pushvalue(L,-1);
    lua_replace(L,-3);
    
    /* internal: local i with idx 9 */
    
    
    /* if vm_data[i] == ids.air then */
    enum { lc114 = 9 };
    lua_pushvalue(L,9);
    lua_gettable(L,3);
    lc_getupvalue(L,lua_upvalueindex(1),6,4);
    lua_pushliteral(L,"air");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc115 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc115);
    const int lc116 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc116) {
      
      /* local p = vx_area:position(i) */
      lua_pushvalue(L,4);
      lua_pushliteral(L,"position");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,9);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 10);
      
      /* if p.y <= MINE_DEEP_MIN then */
      enum { lc117 = 10 };
      lua_pushliteral(L,"y");
      lua_gettable(L,10);
      lc_getupvalue(L,lua_upvalueindex(1),9,1);
      const int lc118 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc118);
      const int lc119 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc119) {
        
        /* out = p */
        lua_pushvalue(L,10);
        lua_replace(L,5);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc117);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc114);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
  }
  lua_settop(L,lc113);
  assert(lua_gettop(L) == 5);
  
  /* return out */
  lua_pushvalue(L,5);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(minp, maxp, seed) */
static int lcf131 (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if minp.y > MINE_DEEP_MIN or minp.y < MINE_DEEP_MAX then */
  enum { lc121 = 3 };
  lc_getupvalue(L,lua_upvalueindex(1),10,1);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  const int lc122 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc122);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),9,2);
    const int lc123 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc123);
  }
  const int lc124 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc124) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc121);
  assert(lua_gettop(L) == 3);
  
  /* cnt = cnt+1 */
  lc_getupvalue(L,lua_upvalueindex(1),0,13);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_setupvalue(L,lua_upvalueindex(1),0,13);
  assert(lua_gettop(L) == 3);
  
  /* if cnt < 8/MINE_FACTOR then */
  enum { lc125 = 3 };
  lc_getupvalue(L,lua_upvalueindex(1),0,13);
  lua_pushnumber(L,8);
  lc_getupvalue(L,lua_upvalueindex(1),8,3);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  const int lc126 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc126);
  const int lc127 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc127) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc125);
  assert(lua_gettop(L) == 3);
  
  /* cnt = 0 */
  lua_pushnumber(L,0);
  lc_setupvalue(L,lua_upvalueindex(1),0,13);
  assert(lua_gettop(L) == 3);
  
  /* --if math.random(0,100) > 85 then return end
   * local vm, emin, emax = minetest.get_mapgen_object("voxelmanip") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_mapgen_object");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"voxelmanip");
  lua_call(L,1,3);
  assert(lua_gettop(L) == 6);
  
  /* local data = vm:get_data() */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get_data");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local va = VoxelArea:new{ MinEdge = emin, MaxEdge = emax } */
  lua_getfield(L,LUA_ENVIRONINDEX,"VoxelArea");
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"MinEdge");
  lua_pushvalue(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"MaxEdge");
  lua_pushvalue(L,6);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 8);
  
  /* local mpos = find_cave(emin,emax,data,va) */
  lc_getupvalue(L,lua_upvalueindex(1),1,12);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,8);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 9);
  
  /* if mpos == nil then */
  enum { lc128 = 9 };
  lua_pushnil(L);
  const int lc129 = lua_equal(L,9,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc129);
  const int lc130 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc130) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc128);
  assert(lua_gettop(L) == 9);
  
  /* local mpos2 = {x=mpos.x+math.random(0,3),y=mpos.y-1,z=mpos.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,9);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0);
  lua_pushnumber(L,3);
  lua_call(L,2,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,9);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,9);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 10);
  
  /* local mpos3 = {x=mpos.x,y=mpos.y-2,z=mpos.z+math.random(0,3)} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,9);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,9);
  lua_pushnumber(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,9);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0);
  lua_pushnumber(L,3);
  lua_call(L,2,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 11);
  
  /* data = make_mine(mpos,mpos2,mpos3, data, va, 0) */
  lc_getupvalue(L,lua_upvalueindex(1),2,11);
  lua_pushvalue(L,9);
  lua_pushvalue(L,10);
  lua_pushvalue(L,11);
  lua_pushvalue(L,7);
  lua_pushvalue(L,8);
  lua_pushnumber(L,0);
  lua_call(L,6,1);
  lua_replace(L,7);
  assert(lua_gettop(L) == 11);
  
  /* vm:set_data(data) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"set_data");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,7);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 11);
  
  /* vm:calc_lighting(emin,emax) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"calc_lighting");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 11);
  
  /* vm:update_liquids() */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"update_liquids");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 11);
  
  /* vm:write_to_map() */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"write_to_map");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 11);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,25);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* --[[
   * 
   * 2017-02-05 modified by MrCerealGuy <mrcerealguy@gmx.de>
   * 	exit if mod is deactivated
   * 
   * --]]
   * local DIR_DELIM = DIR_DELIM or "/" */
  lua_getfield(L,LUA_ENVIRONINDEX,"DIR_DELIM");
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"/");
  }
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local world_file = minetest.get_worldpath()..DIR_DELIM.."world.mt" */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_worldpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"world.mt");
  lua_concat(L,2);
  lua_concat(L,2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local world_conf = Settings(world_file) */
  lua_getfield(L,LUA_ENVIRONINDEX,"Settings");
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local enable_mines = world_conf:get("enable_mines") */
  lua_pushvalue(L,(3 + lc_nextra));
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"enable_mines");
  lua_call(L,2,1);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* if enable_mines ~= nil and enable_mines == "false" then */
  enum { lc1 = 4 };
  lua_pushnil(L);
  const int lc2 = lua_equal(L,(4 + lc_nextra),-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,(4 + lc_nextra));
    lua_pushliteral(L,"false");
    const int lc3 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc3);
  }
  const int lc4 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc4) {
    
    /* minetest.log("info", "[mines] skip loading mod.") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"info");
    lua_pushliteral(L,"[mines] skip loading mod.");
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 4);
    
    /* return */
    return 0;
    assert(lua_gettop(L) - lc_nextra == 4);
  }
  lua_settop(L,(lc1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* -- --------------------------------------------------------------------------------------------------------
   * local MINE_DEEP_MIN = tonumber(minetest.setting_get("mines_deep_min")) */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc5 = 5 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  const int lc6 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_get");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mines_deep_min");
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc6),1);
  lua_rawseti(L,(lc5 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local MINE_DEEP_MAX = tonumber(minetest.setting_get("mines_deep_max")) */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc7 = 6 };
  assert((lua_gettop(L) == (lc7 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  const int lc8 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_get");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mines_deep_max");
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc8),1);
  lua_rawseti(L,(lc7 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local MINE_FACTOR = tonumber(minetest.setting_get("mines_spawnfactor")) */
  lc_newclosuretable(L,(lc7 + lc_nextra));
  enum { lc9 = 7 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  const int lc10 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"setting_get");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mines_spawnfactor");
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc10),1);
  lua_rawseti(L,(lc9 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* if not MINE_DEEP_MIN then */
  enum { lc11 = 7 };
  lc_getupvalue(L,(lc9 + lc_nextra),2,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc12 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc12) {
    
    /* MINE_DEEP_MIN = -64 */
    lua_pushnumber(L,-64);
    lc_setupvalue(L,(lc9 + lc_nextra),2,1);
    assert(lua_gettop(L) - lc_nextra == 7);
  }
  lua_settop(L,(lc11 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* if not MINE_DEEP_MAX then */
  enum { lc13 = 7 };
  lc_getupvalue(L,(lc9 + lc_nextra),1,2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc14 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc14) {
    
    /* MINE_DEEP_MAX = -380 */
    lua_pushnumber(L,-380);
    lc_setupvalue(L,(lc9 + lc_nextra),1,2);
    assert(lua_gettop(L) - lc_nextra == 7);
  }
  lua_settop(L,(lc13 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* if not MINE_FACTOR then */
  enum { lc15 = 7 };
  lc_getupvalue(L,(lc9 + lc_nextra),0,3);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc16 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc16) {
    
    /* MINE_FACTOR = 1.5 */
    lua_pushnumber(L,1.5);
    lc_setupvalue(L,(lc9 + lc_nextra),0,3);
    assert(lua_gettop(L) - lc_nextra == 7);
  }
  lua_settop(L,(lc15 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* minetest.register_node("mines:dummy", {
   * 	description = "Air (you hacker you!)",
   * 	inventory_image = "unknown_node.png",
   * 	wield_image = "unknown_node.png",
   * 	drawtype = "airlike",
   * 	paramtype = "light",
   * 	sunlight_propagates = true,
   * 	walkable = false,
   * 	pointable = false,
   * 	diggable = false,
   * 	buildable_to = true,
   * 	air_equivalent = true,
   * 	drop = "",
   * 	groups = {not_in_creative_inventory=1},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mines:dummy");
  lua_createtable(L,0,13);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Air (you hacker you!)");
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushliteral(L,"unknown_node.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wield_image");
  lua_pushliteral(L,"unknown_node.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"airlike");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sunlight_propagates");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"pointable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"diggable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"buildable_to");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"air_equivalent");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"not_in_creative_inventory");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* local ids = {
   * 	air = minetest.get_content_id("air"),
   * 	fence = minetest.get_content_id("default:fence_wood"),
   * 	wood = minetest.get_content_id("default:wood"),
   * 	dummy = minetest.get_content_id("mines:dummy")
   * } */
  lc_newclosuretable(L,(lc9 + lc_nextra));
  enum { lc17 = 8 };
  assert((lua_gettop(L) == (lc17 + lc_nextra)));
  lua_createtable(L,0,4);
  lua_pushliteral(L,"air");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"fence");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:fence_wood");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"wood");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:wood");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dummy");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mines:dummy");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_rawseti(L,(lc17 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local chest_stuff = {
   * 	{name="default:apple", max = 3},
   * 	{name="farming:bread", max = 3},
   * 	{name="default:steel_ingot", max = 2},
   * 	{name="default:gold_ingot", max = 2},
   * 	{name="default:diamond", max = 1},
   * 	{name="default:pick_steel", max = 1},
   * 	{name="default:pick_diamond", max = 1}
   * 
   * } */
  lc_newclosuretable(L,(lc17 + lc_nextra));
  enum { lc18 = 9 };
  assert((lua_gettop(L) == (lc18 + lc_nextra)));
  lua_createtable(L,7,0);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default:apple");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"farming:bread");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default:steel_ingot");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,3);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default:gold_ingot");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,4);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default:diamond");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,5);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default:pick_steel");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,6);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default:pick_diamond");
  lua_rawset(L,-3);
  lua_pushliteral(L,"max");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,7);
  lua_rawseti(L,(lc18 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* local function rotate_torch(pos)
   * 	minetest.after(8, function()
   * 		local n = minetest.get_node(pos)
   * 		if n ~= nil then
   * 			if n.name == "mines:dummy" then
   * 				minetest.set_node(pos, {name="default:torch",param2=1})
   * 			end
   * 		end
   * 	end)
   * end */
  lc_newclosuretable(L,(lc18 + lc_nextra));
  enum { lc19 = 10 };
  assert((lua_gettop(L) == (lc19 + lc_nextra)));
  lua_pushcfunction(L,lcf1_rotate_torch);
  lua_rawseti(L,(lc19 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* local function fill_chest(pos)
   * 	minetest.after(5, function()
   * 		local n = minetest.get_node(pos)
   * 		if n ~= nil then
   * 			if n.name == "mines:dummy" then
   * 				minetest.set_node(pos, {name="default:chest"})
   * 				local meta = minetest.get_meta(pos)
   * 				--meta:set_string("formspec",default.chest_formspec)
   * 				--meta:set_string("infotext", "Chest")
   * 				local inv = meta:get_inventory()
   * 				inv:set_size("main", 8*4)
   * 				for i=0,2,1 do
   * 					local stuff = chest_stuff[math.random(1,#chest_stuff)]
   * 					local stack = {name=stuff.name, count = math.random(1,stuff.max)}
   * 					if not inv:contains_item("main", stack) then
   * 						inv:set_stack("main", math.random(1,32), stack)
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end)
   * end */
  lc_newclosuretable(L,(lc19 + lc_nextra));
  enum { lc28 = 11 };
  assert((lua_gettop(L) == (lc28 + lc_nextra)));
  lua_pushvalue(L,(lc28 + lc_nextra));
  lua_pushcclosure(L,lcf1_fill_chest,1);
  lua_rawseti(L,(lc28 + lc_nextra),8);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local function check_dir(dir,old_dir)
   * 	if old_dir == 1 and dir == 3 then
   * 		--n_switch = 2
   * 		return true
   * 	elseif old_dir == 3 and dir == 1 then
   * 		--n_switch = 4
   * 		return true
   * 	elseif old_dir == 2 and dir == 4 then
   * 		--n_switch = 1
   * 		return true
   * 	elseif old_dir == 4 and dir == 2 then
   * 		--n_switch = 3
   * 		return true
   * 	end
   * 	return false
   * end */
  lc_newclosuretable(L,(lc28 + lc_nextra));
  enum { lc44 = 12 };
  assert((lua_gettop(L) == (lc44 + lc_nextra)));
  lua_pushcfunction(L,lcf1_check_dir);
  lua_rawseti(L,(lc44 + lc_nextra),10);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* local function make_mine(mpos,p2,p3, vm_data, vx_area,cnt)
   * 	local pos = {x=mpos.x,y=mpos.y,z=mpos.z}
   * 	for j=0,12,1 do
   * 	local switch = cnt+1
   * 	n_switch = math.random(1,4)
   * 	while check_dir(n_switch,switch) == true do
   * 		n_switch = math.random(1,4)
   * 	end
   * 	switch = n_switch
   * 
   * 		for i=0,20,1 do
   * 			local pillar = ids.air
   * 			local pillar_top = ids.air
   * 			if i==0 or i == 5 or i == 10 or i == 15 or i == 20 then
   * 				pillar = ids.fence
   * 				pillar_top = ids.wood
   * 			end
   * 			local x1
   * 			local x2
   * 			local x3
   * 			local x4
   * 			local z1
   * 			local z2
   * 			local z3
   * 			local z4
   * 			if switch == 1 then
   * 				x1 = pos.x+1
   * 				x2 = pos.x
   * 				x3 = pos.x-1
   * 				x4 = pos.x
   * 				x5 = pos.x+1
   * 
   * 				z1 = pos.z+i
   * 				z2 = pos.z+i
   * 				z3 = pos.z+i
   * 				z4 = pos.z+i-1
   * 				z5 = pos.z+i
   * 			elseif switch == 2 then
   * 				x1 = pos.x+i
   * 				x2 = pos.x+i
   * 				x3 = pos.x+i
   * 				x4 = pos.x+i-1
   * 				x5 = pos.x+i
   * 
   * 				z1 = pos.z+1
   * 				z2 = pos.z
   * 				z3 = pos.z-1
   * 				z4 = pos.z
   * 				z5 = pos.z+1
   * 			elseif switch == 3 then
   * 				x1 = pos.x+1
   * 				x2 = pos.x
   * 				x3 = pos.x-1
   * 				x4 = pos.x
   * 				x5 = pos.x+1
   * 
   * 				z1 = pos.z-i
   * 				z2 = pos.z-i
   * 				z3 = pos.z-i
   * 				z4 = pos.z-i-1
   * 				z5 = pos.z-i
   * 			else
   * 				x1 = pos.x-i
   * 				x2 = pos.x-i
   * 				x3 = pos.x-i
   * 				x4 = pos.x-i-1
   * 				x5 = pos.x-i
   * 
   * 				z1 = pos.z+1
   * 				z2 = pos.z
   * 				z3 = pos.z-1
   * 				z4 = pos.z
   * 				z5 = pos.z+1
   * 			end
   * 			vm_data[vx_area:indexp({x=x1, y=pos.y-1, z=z1})] = pillar
   * 			vm_data[vx_area:indexp({x=x2, y=pos.y-1, z=z2})] = ids.air
   * 			vm_data[vx_area:indexp({x=x3, y=pos.y-1, z=z3})] = pillar
   * 
   * 			vm_data[vx_area:indexp({x=x1, y=pos.y, z=z1})] = pillar
   * 			vm_data[vx_area:indexp({x=x2, y=pos.y, z=z2})] = ids.air
   * 			vm_data[vx_area:indexp({x=x3, y=pos.y, z=z3})] = pillar
   * 
   * 			vm_data[vx_area:indexp({x=x1, y=pos.y+1, z=z1})] = pillar_top
   * 			vm_data[vx_area:indexp({x=x2, y=pos.y+1, z=z2})] = pillar_top
   * 			vm_data[vx_area:indexp({x=x3, y=pos.y+1, z=z3})] = pillar_top
   * 
   * 			if math.random(0,6) == 3 then 
   * 				vm_data[vx_area:indexp({x=x4, y=pos.y-1, z=z4})] = ids.dummy
   * 				rotate_torch({x=x4, y=pos.y-1, z=z4})
   * 			end
   * 			if math.random(0,60) == 13 then
   * 				local p = {x=x5, y=pos.y-1, z=z5}
   * 				if vm_data[vx_area:indexp(p)] ~= ids.fence then
   * 					vm_data[vx_area:indexp(p)] = ids.dummy
   * 					fill_chest(p)
   * 				end
   * 			end
   * 		end
   * 		if switch == 1 then			
   * 			pos.z = pos.z+20
   * 			--pos.x = pos.x+step
   * 		elseif switch == 2 then
   * 			pos.x = pos.x+20
   * 			--pos.z = pos.z+step
   * 		elseif switch == 3 then			
   * 			pos.z = pos.z-20
   * 			--pos.x = pos.x+step
   * 		elseif switch == 4 then	
   * 			pos.x = pos.x-20
   * 			--pos.z = pos.z+step
   * 		end
   * 	end
   * 	if cnt == 0 then
   * 		minetest.log("action", "Created mine at ("..mpos.x..","..mpos.y..","..mpos.z..")")
   * 		local out2 = make_mine(p2,p3,mpos,vm_data,vx_area,1)
   * 		local out3 = make_mine(p3,p2,mpos,out2,vx_area,2)
   * 		return out3
   * 	else
   * 		return vm_data
   * 	end
   * end */
  lc_newclosuretable(L,(lc44 + lc_nextra));
  enum { lc61 = 13 };
  assert((lua_gettop(L) == (lc61 + lc_nextra)));
  lua_pushvalue(L,(lc61 + lc_nextra));
  lua_pushcclosure(L,lcf1_make_mine,1);
  lua_rawseti(L,(lc61 + lc_nextra),11);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* local function find_cave(min,max,vm_data, vx_area)
   * 	local out = nil
   * 	for i in vx_area:iterp(min, max) do
   * 		if vm_data[i] == ids.air then
   * 			local p = vx_area:position(i)
   * 			if p.y <= MINE_DEEP_MIN then out = p end
   * 		end		
   * 	end
   * 	return out
   * end */
  lc_newclosuretable(L,(lc61 + lc_nextra));
  enum { lc112 = 14 };
  assert((lua_gettop(L) == (lc112 + lc_nextra)));
  lua_pushvalue(L,(lc112 + lc_nextra));
  lua_pushcclosure(L,lcf1_find_cave,1);
  lua_rawseti(L,(lc112 + lc_nextra),12);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* local cnt = 0 */
  lc_newclosuretable(L,(lc112 + lc_nextra));
  enum { lc120 = 15 };
  assert((lua_gettop(L) == (lc120 + lc_nextra)));
  lua_pushnumber(L,0);
  lua_rawseti(L,(lc120 + lc_nextra),13);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* minetest.register_on_generated(function(minp, maxp, seed)
   * 	if minp.y > MINE_DEEP_MIN or minp.y < MINE_DEEP_MAX then
   * 		return
   * 	end
   * 	cnt = cnt+1
   * 	if cnt < 8/MINE_FACTOR then return end
   * 	cnt = 0
   * 
   * 	--if math.random(0,100) > 85 then return end
   * 	local vm, emin, emax = minetest.get_mapgen_object("voxelmanip")
   * 	local data = vm:get_data()
   * 	local va = VoxelArea:new{ MinEdge = emin, MaxEdge = emax }
   * 	local mpos = find_cave(emin,emax,data,va)
   * 	if mpos == nil then return end
   * 	local mpos2 = {x=mpos.x+math.random(0,3),y=mpos.y-1,z=mpos.z}
   * 	local mpos3 = {x=mpos.x,y=mpos.y-2,z=mpos.z+math.random(0,3)}
   * 	data = make_mine(mpos,mpos2,mpos3, data, va, 0)
   * 	vm:set_data(data)
   * 	vm:calc_lighting(emin,emax)
   * 	vm:update_liquids()
   * 	vm:write_to_map()
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_generated");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(lc120 + lc_nextra));
  lua_pushcclosure(L,lcf131,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 15);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mines_init(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


