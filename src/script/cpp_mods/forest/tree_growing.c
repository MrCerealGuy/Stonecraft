/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: tree_growing
 * function(pos, specie) */
static int lcf1_tree_growing (lua_State * L) {
  lua_checkstack(L,28);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local tree = trees[specie] */
  lua_getfield(L,LUA_ENVIRONINDEX,"trees");
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local height = math.random(tree.trunk_height.min, tree.trunk_height.max) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"trunk_height");
  lua_gettable(L,3);
  lua_pushliteral(L,"min");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"trunk_height");
  lua_gettable(L,3);
  lua_pushliteral(L,"max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 4);
  
  /* for dy = 0, height - 1 do */
  lua_pushnumber(L,0);
  lua_pushnumber(L,1);
  lc_sub(L,4,-1);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc1_var = lua_tonumber(L,-2);
  const double lc2_limit = lua_tonumber(L,-1);
  const double lc3_step = 1;
  lua_pop(L,2);
  enum { lc4 = 4 };
  while ((((lc3_step > 0) && (lc1_var <= lc2_limit)) || ((lc3_step <= 0) && (lc1_var >= lc2_limit)))) {
    
    /* internal: local dy at index 5 */
    lua_pushnumber(L,lc1_var);
    
    /* minetest.env:set_node({x = pos.x, y = pos.y + dy, z = pos.z}, {name = tree.nodes.tree}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"env");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_add(L,-1,5);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"nodes");
    lua_gettable(L,3);
    lua_pushliteral(L,"tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc1_var += lc3_step;
  }
  lua_settop(L,lc4);
  assert(lua_gettop(L) == 4);
  
  /* local steps = math.floor((height + tree.height_above_trunk) * tree.percent_size / 100) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"height_above_trunk");
  lua_gettable(L,3);
  lc_add(L,4,-1);
  lua_remove(L,-2);
  lua_pushliteral(L,"percent_size");
  lua_gettable(L,3);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,100);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* local corner_leaf */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 6);
  
  /* for dy = 1, steps do */
  lua_pushnumber(L,1);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,5)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc5_var = lua_tonumber(L,-1);
  const double lc6_limit = lua_tonumber(L,5);
  const double lc7_step = 1;
  lua_pop(L,1);
  enum { lc8 = 6 };
  while ((((lc7_step > 0) && (lc5_var <= lc6_limit)) || ((lc7_step <= 0) && (lc5_var >= lc6_limit)))) {
    
    /* internal: local dy at index 7 */
    lua_pushnumber(L,lc5_var);
    
    /* for dx = - tree.radius, tree.radius do */
    lua_pushliteral(L,"radius");
    lua_gettable(L,3);
    lc_unm(L,-1);
    lua_remove(L,-2);
    lua_pushliteral(L,"radius");
    lua_gettable(L,3);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc9_var = lua_tonumber(L,-2);
    const double lc10_limit = lua_tonumber(L,-1);
    const double lc11_step = 1;
    lua_pop(L,2);
    enum { lc12 = 7 };
    while ((((lc11_step > 0) && (lc9_var <= lc10_limit)) || ((lc11_step <= 0) && (lc9_var >= lc10_limit)))) {
      
      /* internal: local dx at index 8 */
      lua_pushnumber(L,lc9_var);
      
      /* for dz = - tree.radius, tree.radius do */
      lua_pushliteral(L,"radius");
      lua_gettable(L,3);
      lc_unm(L,-1);
      lua_remove(L,-2);
      lua_pushliteral(L,"radius");
      lua_gettable(L,3);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc13_var = lua_tonumber(L,-2);
      const double lc14_limit = lua_tonumber(L,-1);
      const double lc15_step = 1;
      lua_pop(L,2);
      enum { lc16 = 8 };
      while ((((lc15_step > 0) && (lc13_var <= lc14_limit)) || ((lc15_step <= 0) && (lc13_var >= lc14_limit)))) {
        
        /* internal: local dz at index 9 */
        lua_pushnumber(L,lc13_var);
        
        /* pos.x = pos.x + dx */
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_add(L,-1,8);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* pos.y = pos.y + height + tree.height_above_trunk - dy */
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_add(L,-1,4);
        lua_remove(L,-2);
        lua_pushliteral(L,"height_above_trunk");
        lua_gettable(L,3);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-1,7);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* pos.z = pos.z + dz */
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_add(L,-1,9);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* if dy == 1 or dy == steps then */
        enum { lc17 = 9 };
        lua_pushvalue(L,7);
        lua_pushnumber(L,1);
        const int lc18 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc18);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,7);
          lua_pushvalue(L,5);
          const int lc19 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc19);
        }
        const int lc20 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc20) {
          
          /* corner_leaf = 1 */
          lua_pushnumber(L,1);
          lua_replace(L,6);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc17);
        assert(lua_gettop(L) == 9);
        
        /* if math.abs(dx) == tree.radius then */
        enum { lc21 = 9 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,8);
        lua_call(L,1,1);
        lua_pushliteral(L,"radius");
        lua_gettable(L,3);
        const int lc22 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc22);
        const int lc23 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc23) {
          
          /* corner_leaf = corner_leaf + 1 */
          lua_pushnumber(L,1);
          lc_add(L,6,-1);
          lua_remove(L,-2);
          lua_replace(L,6);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc21);
        assert(lua_gettop(L) == 9);
        
        /* if math.abs(dz) == tree.radius then */
        enum { lc24 = 9 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_call(L,1,1);
        lua_pushliteral(L,"radius");
        lua_gettable(L,3);
        const int lc25 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc25);
        const int lc26 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc26) {
          
          /* corner_leaf = corner_leaf + 1 */
          lua_pushnumber(L,1);
          lc_add(L,6,-1);
          lua_remove(L,-2);
          lua_replace(L,6);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc24);
        assert(lua_gettop(L) == 9);
        
        /* if (minetest.env:get_node(pos).name == "air" or minetest.env:get_node(pos).name == "ignore") and math.random(100) <= tree.percent_leaves and corner_leaf <= tree.corners then */
        enum { lc27 = 9 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"env");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,2,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"air");
        const int lc28 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc28);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"env");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"get_node");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,2,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"ignore");
          const int lc29 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc29);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,100);
          lua_call(L,1,1);
          lua_pushliteral(L,"percent_leaves");
          lua_gettable(L,3);
          const int lc30 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc30);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"corners");
          lua_gettable(L,3);
          const int lc31 = lc_le(L,6,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc31);
        }
        const int lc32 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc32) {
          
          /* minetest.env:set_node(pos, {name = tree.nodes.leaves}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"env");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"nodes");
          lua_gettable(L,3);
          lua_pushliteral(L,"leaves");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_call(L,3,0);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc27);
        assert(lua_gettop(L) == 9);
        
        /* pos.x = pos.x - dx */
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_sub(L,-1,8);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* pos.y = pos.y - height - tree.height_above_trunk + dy */
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_sub(L,-1,4);
        lua_remove(L,-2);
        lua_pushliteral(L,"height_above_trunk");
        lua_gettable(L,3);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-1,7);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* pos.z = pos.z - dz */
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_sub(L,-1,9);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 9);
        
        /* corner_leaf = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,6);
        assert(lua_gettop(L) == 9);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc13_var += lc15_step;
      }
      lua_settop(L,lc16);
      assert(lua_gettop(L) == 8);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc9_var += lc11_step;
    }
    lua_settop(L,lc12);
    assert(lua_gettop(L) == 7);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc5_var += lc7_step;
  }
  lua_settop(L,lc8);
  assert(lua_gettop(L) == 6);
  
  /* if tree.base then */
  enum { lc33 = 6 };
  lua_pushliteral(L,"base");
  lua_gettable(L,3);
  const int lc34 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc34) {
    
    /* for dx = -1, 1 do */
    lua_pushnumber(L,-1);
    lua_pushnumber(L,1);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc35_var = lua_tonumber(L,-2);
    const double lc36_limit = lua_tonumber(L,-1);
    const double lc37_step = 1;
    lua_pop(L,2);
    enum { lc38 = 6 };
    while ((((lc37_step > 0) && (lc35_var <= lc36_limit)) || ((lc37_step <= 0) && (lc35_var >= lc36_limit)))) {
      
      /* internal: local dx at index 7 */
      lua_pushnumber(L,lc35_var);
      
      /* for dz = -1, 1 do */
      lua_pushnumber(L,-1);
      lua_pushnumber(L,1);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc39_var = lua_tonumber(L,-2);
      const double lc40_limit = lua_tonumber(L,-1);
      const double lc41_step = 1;
      lua_pop(L,2);
      enum { lc42 = 7 };
      while ((((lc41_step > 0) && (lc39_var <= lc40_limit)) || ((lc41_step <= 0) && (lc39_var >= lc40_limit)))) {
        
        /* internal: local dz at index 8 */
        lua_pushnumber(L,lc39_var);
        
        /* if math.random() * 100 <= tree.base then */
        enum { lc43 = 8 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,1);
        lua_pushnumber(L,100);
        lc_mul(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"base");
        lua_gettable(L,3);
        const int lc44 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc44);
        const int lc45 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc45) {
          
          /* local basepos = {x = pos.x + dx, y = pos.y, z = pos.z + dz} */
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,1);
          lc_add(L,-1,7);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,1);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,1);
          lc_add(L,-1,8);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          assert(lua_gettop(L) == 9);
          
          /* minetest.set_node(basepos, {name = tree.nodes.tree}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,9);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"nodes");
          lua_gettable(L,3);
          lua_pushliteral(L,"tree");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 9);
          
          /* if tree.associated then */
          enum { lc46 = 9 };
          lua_pushliteral(L,"associated");
          lua_gettable(L,3);
          const int lc47 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc47) {
            
            /* local chance = 100 */
            lua_pushnumber(L,100);
            assert(lua_gettop(L) == 10);
            
            /* local above = {x = basepos.x, y = basepos.y + 1, z = basepos.z} */
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,9);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,9);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,9);
            lua_rawset(L,-3);
            assert(lua_gettop(L) == 11);
            
            /* for plant, def in pairs(tree.associated) do
             * internal: local f, s, var = explist */
            enum { lc48 = 11 };
            lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
            lua_pushliteral(L,"associated");
            lua_gettable(L,3);
            lua_call(L,1,3);
            while (1) {
              
              /* internal: local var_1, ..., var_n = f(s, var)
               *           if var_1 == nil then break end
               *           var = var_1 */
              lua_pushvalue(L,-3);
              lua_pushvalue(L,-3);
              lua_pushvalue(L,-3);
              lua_call(L,2,2);
              if (lua_isnil(L,-2)) {
                break;
              }
              lua_pushvalue(L,-2);
              lua_replace(L,-4);
              
              /* internal: local plant with idx 15
               * internal: local def with idx 16 */
              
              
              /* if math.random() * chance < def and minetest.get_node(above).name == "air" then */
              enum { lc49 = 16 };
              lua_getfield(L,LUA_ENVIRONINDEX,"math");
              lua_pushliteral(L,"random");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_call(L,0,1);
              lc_mul(L,-1,10);
              lua_remove(L,-2);
              const int lc50 = lua_lessthan(L,-1,16);
              lua_pop(L,1);
              lua_pushboolean(L,lc50);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"get_node");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,11);
                lua_call(L,1,1);
                lua_pushliteral(L,"name");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushliteral(L,"air");
                const int lc51 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc51);
              }
              const int lc52 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc52) {
                
                /* minetest.set_node(above, {name = plant}) */
                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                lua_pushliteral(L,"set_node");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,11);
                lua_createtable(L,0,1);
                lua_pushliteral(L,"name");
                lua_pushvalue(L,15);
                lua_rawset(L,-3);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 16);
                
                /* break */
                break;
                assert(lua_gettop(L) == 16);
              }
              else {
                
                /* else
                 * chance = chance - def */
                lc_sub(L,10,16);
                lua_replace(L,10);
                assert(lua_gettop(L) == 16);
              }
              lua_settop(L,lc49);
              assert(lua_gettop(L) == 16);
              
              /* internal: stack cleanup on scope exit */
              lua_pop(L,2);
            }
            lua_settop(L,lc48);
            assert(lua_gettop(L) == 11);
          }
          lua_settop(L,lc46);
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc43);
        assert(lua_gettop(L) == 8);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc39_var += lc41_step;
      }
      lua_settop(L,lc42);
      assert(lua_gettop(L) == 7);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc35_var += lc37_step;
    }
    lua_settop(L,lc38);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc33);
  assert(lua_gettop(L) == 6);
  
  /* if tree.associated then */
  enum { lc53 = 6 };
  lua_pushliteral(L,"associated");
  lua_gettable(L,3);
  const int lc54 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc54) {
    
    /* local grass_area = minetest.find_nodes_in_area({x = pos.x - 2, y = pos.y - 2, z = pos.z - 2}, {x = pos.x + 2, y = pos.y + 2, z = pos.z + 2}, "default:dirt_with_grass") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"find_nodes_in_area");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_pushnumber(L,2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_call(L,3,1);
    assert(lua_gettop(L) == 7);
    
    /* for grass, pos in pairs(grass_area) do
     * internal: local f, s, var = explist */
    enum { lc55 = 7 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    lua_pushvalue(L,7);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local grass with idx 11
       * internal: local pos with idx 12 */
      
      
      /* pos.y = pos.y + 1 */
      lua_pushliteral(L,"y");
      lua_gettable(L,12);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_insert(L,-2);
      lua_settable(L,12);
      assert(lua_gettop(L) == 12);
      
      /* local chance = 100 */
      lua_pushnumber(L,100);
      assert(lua_gettop(L) == 13);
      
      /* for plant, def in pairs(tree.associated) do
       * internal: local f, s, var = explist */
      enum { lc56 = 13 };
      lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
      lua_pushliteral(L,"associated");
      lua_gettable(L,3);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local plant with idx 17
         * internal: local def with idx 18 */
        
        
        /* if math.random() * chance < def and minetest.get_node(pos).name == "air" then */
        enum { lc57 = 18 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,1);
        lc_mul(L,-1,13);
        lua_remove(L,-2);
        const int lc58 = lua_lessthan(L,-1,18);
        lua_pop(L,1);
        lua_pushboolean(L,lc58);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,12);
          lua_call(L,1,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"air");
          const int lc59 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc59);
        }
        const int lc60 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc60) {
          
          /* minetest.set_node(pos, {name = plant}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,12);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushvalue(L,17);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 18);
          
          /* break */
          break;
          assert(lua_gettop(L) == 18);
        }
        else {
          
          /* else
           * chance = chance - def */
          lc_sub(L,13,18);
          lua_replace(L,13);
          assert(lua_gettop(L) == 18);
        }
        lua_settop(L,lc57);
        assert(lua_gettop(L) == 18);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc56);
      assert(lua_gettop(L) == 13);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
    }
    lua_settop(L,lc55);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc53);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* function tree_growing(pos, specie)
   * 	local tree = trees[specie]
   * 	local height = math.random(tree.trunk_height.min, tree.trunk_height.max)
   * 	for dy = 0, height - 1 do
   * 		minetest.env:set_node({x = pos.x, y = pos.y + dy, z = pos.z}, {name = tree.nodes.tree})
   * 	end
   * 	local steps = math.floor((height + tree.height_above_trunk) * tree.percent_size / 100)
   * 	local corner_leaf
   * 	for dy = 1, steps do
   * 		for dx = - tree.radius, tree.radius do
   * 			for dz = - tree.radius, tree.radius do
   * 				pos.x = pos.x + dx
   * 				pos.y = pos.y + height + tree.height_above_trunk - dy
   * 				pos.z = pos.z + dz
   * 				if dy == 1 or dy == steps then
   * 					corner_leaf = 1
   * 				end
   * 				if math.abs(dx) == tree.radius then
   * 					corner_leaf = corner_leaf + 1
   * 				end
   * 				if math.abs(dz) == tree.radius then
   * 					corner_leaf = corner_leaf + 1
   * 				end
   * 				if (minetest.env:get_node(pos).name == "air" or minetest.env:get_node(pos).name == "ignore") and math.random(100) <= tree.percent_leaves and corner_leaf <= tree.corners then
   * 					minetest.env:set_node(pos, {name = tree.nodes.leaves})
   * 				end
   * 				pos.x = pos.x - dx
   * 				pos.y = pos.y - height - tree.height_above_trunk + dy
   * 				pos.z = pos.z - dz
   * 				corner_leaf = 0
   * 			end
   * 		end
   * 	end
   * 	if tree.base then
   * 		for dx = -1, 1 do
   * 			for dz = -1, 1 do
   * 				if math.random() * 100 <= tree.base then
   * 					local basepos = {x = pos.x + dx, y = pos.y, z = pos.z + dz}
   * 					minetest.set_node(basepos, {name = tree.nodes.tree})
   * 					if tree.associated then
   * 						local chance = 100
   * 						local above = {x = basepos.x, y = basepos.y + 1, z = basepos.z}
   * 						for plant, def in pairs(tree.associated) do
   * 							if math.random() * chance < def and minetest.get_node(above).name == "air" then
   * 								minetest.set_node(above, {name = plant})
   * 								break
   * 							else
   * 								chance = chance - def
   * 							end
   * 						end
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end
   * 	if tree.associated then
   * 		local grass_area = minetest.find_nodes_in_area({x = pos.x - 2, y = pos.y - 2, z = pos.z - 2}, {x = pos.x + 2, y = pos.y + 2, z = pos.z + 2}, "default:dirt_with_grass")
   * 		for grass, pos in pairs(grass_area) do
   * 			pos.y = pos.y + 1
   * 			local chance = 100
   * 			for plant, def in pairs(tree.associated) do
   * 				if math.random() * chance < def and minetest.get_node(pos).name == "air" then
   * 					minetest.set_node(pos, {name = plant})
   * 					break
   * 				else
   * 					chance = chance - def
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_tree_growing);
  lua_setfield(L,LUA_ENVIRONINDEX,"tree_growing");
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_forest_tree_growing(lua_State * L) {
	  luaL_openlibs(L);

	  lua_pushcfunction(L, traceback);

	  const int status1 = lc_handle_luainit(L);
	  if (status1 != 0) return 0;

	  /* note: IMPROVE: closure not always needed here */
	  lua_newtable(L); /* closure table */
	  lua_pushcclosure(L, lcf_main, 1);

	  int status2 = lua_pcall(L, 0, 0, -2);
	  if (status2 != 0) {
	    const char * msg = lua_tostring(L,-1);
	    if (msg == NULL) msg = "(error object is not a string)";
	    fputs(msg, stderr);
	  }
	  return 0;
	}
