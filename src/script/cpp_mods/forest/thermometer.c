/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: aff_thermometer
 * function(pos, node) */
static int lcf1_aff_thermometer (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local temperature = math.floor(get_instant_temperature(pos)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc1 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"get_instant_temperature");
  lua_pushvalue(L,1);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc1),1);
  assert(lua_gettop(L) == 3);
  
  /* node.name = "forest:_thermometer_"..temperature */
  lua_pushliteral(L,"forest:_thermometer_");
  lua_pushvalue(L,3);
  lua_concat(L,2);
  lua_pushliteral(L,"name");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 3);
  
  /* minetest.set_node(pos, node) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"set_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* function aff_thermometer(pos, node)
   * 	local temperature = math.floor(get_instant_temperature(pos))
   * 	node.name = "forest:_thermometer_"..temperature
   * 	minetest.set_node(pos, node)
   * end */
  lua_pushcfunction(L,lcf1_aff_thermometer);
  lua_setfield(L,LUA_ENVIRONINDEX,"aff_thermometer");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_node("forest:_thermometer_0", {
   * 	description = "Thermometre",
   * 	drawtype = "torchlike",
   * 	tiles = {
   * 		{name="thermometer_0b.png"},
   * 		{name="thermometer_0b.png"},
   * 		{name="thermometer_0b.png"},
   * 	},
   * 	inventory_image = "thermometer.png",
   * 	wield_image = "thermometer.png",
   * 	paramtype = "light",
   * 	paramtype2 = "wallmounted",
   * 	sunlight_propagates = true,
   * 	is_ground_content = false,
   * 	walkable = false,
   * 	light_source = 3,
   * 	selection_box = {
   * 		type = "wallmounted",
   * 		wall_top = {-0.1, -0.1, -0.1, 0.1, 0.5, 0.1},
   * 		wall_bottom = {-0.1, -0.5, -0.1, 0.1, 0.1, 0.1},
   * 		wall_side = {-0.5, -0.3, -0.1, -0.2, 0.3, 0.1},
   * 	},
   * 	groups = {dig_immediate=3, thermometer=1, attached_node=1},
   * 	legacy_wallmounted = true,
   * 	sounds = default.node_sound_defaults(),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest:_thermometer_0");
  lua_createtable(L,0,15);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Thermometre");
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"torchlike");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,3,0);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"thermometer_0b.png");
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"thermometer_0b.png");
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"thermometer_0b.png");
  lua_rawset(L,-3);
  lua_rawseti(L,-2,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushliteral(L,"thermometer.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wield_image");
  lua_pushliteral(L,"thermometer.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype2");
  lua_pushliteral(L,"wallmounted");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sunlight_propagates");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"light_source");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"selection_box");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"wallmounted");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wall_top");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.1);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.1);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.1);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.1);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.1);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"wall_bottom");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.1);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.1);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.1);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0.1);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.1);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"wall_side");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.3);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.1);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,-0.2);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0.3);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.1);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"dig_immediate");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"thermometer");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"attached_node");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"legacy_wallmounted");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* for i = 1, 20 do */
  lua_pushnumber(L,1);
  lua_pushnumber(L,20);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc2_var = lua_tonumber(L,-2);
  const double lc3_limit = lua_tonumber(L,-1);
  const double lc4_step = 1;
  lua_pop(L,2);
  enum { lc5 = 0 };
  while ((((lc4_step > 0) && (lc2_var <= lc3_limit)) || ((lc4_step <= 0) && (lc2_var >= lc3_limit)))) {
    
    /* internal: local i at index 1 */
    lua_pushnumber(L,lc2_var);
    
    /* minetest.register_node("forest:_thermometer_"..i, {
     * 	description = "Thermometre",
     * 	drawtype = "torchlike",
     * 	tiles = {
     * 		{name="thermometer_"..i.."b.png"},
     * 		{name="thermometer_"..i.."b.png"},
     * 		{name="thermometer_"..i.."b.png"}
     * 	},
     * 	inventory_image = "thermometer.png",
     * 	wield_image = "thermometer.png",
     * 	paramtype = "light",
     * 	paramtype2 = "wallmounted",
     * 	sunlight_propagates = true,
     * 	is_ground_content = false,
     * 	walkable = false,
     * 	light_source = 3,
     * 	selection_box = {
     * 		type = "wallmounted",
     * 		wall_top = {-0.1, 0.5-0.6, -0.1, 0.1, 0.5, 0.1},
     * 		wall_bottom = {-0.1, -0.5, -0.1, 0.1, -0.5+0.6, 0.1},
     * 		wall_side = {-0.5, -0.3, -0.1, -0.5+0.3, 0.3, 0.1},
     * 	},
     * 	groups = {dig_immediate=3, thermometer=1, not_in_creative_inventory=1, attached_node=1},
     * 	legacy_wallmounted = true,
     * 	sounds = default.node_sound_defaults(),
     * 	drop = "forest:_thermometer_0",
     * }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"forest:_thermometer_");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_concat(L,2);
    lua_createtable(L,0,16);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Thermometre");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"torchlike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,3,0);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"thermometer_");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushliteral(L,"b.png");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"thermometer_");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushliteral(L,"b.png");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"thermometer_");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushliteral(L,"b.png");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lua_pushliteral(L,"thermometer.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wield_image");
    lua_pushliteral(L,"thermometer.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype2");
    lua_pushliteral(L,"wallmounted");
    lua_rawset(L,-3);
    lua_pushliteral(L,"sunlight_propagates");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"light_source");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"selection_box");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"wallmounted");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wall_top");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wall_bottom");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wall_side");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.3);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,-0.2);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.3);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"thermometer");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"not_in_creative_inventory");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"attached_node");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"legacy_wallmounted");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"drop");
    lua_pushliteral(L,"forest:_thermometer_0");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc2_var += lc4_step;
  }
  lua_settop(L,(lc5 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_abm({
   * 	nodenames = {"group:thermometer"},
   * 	interval = 10,
   * 	chance = 1,
   * 	action = aff_thermometer,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,4);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:thermometer");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushnumber(L,10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_getfield(L,LUA_ENVIRONINDEX,"aff_thermometer");
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_forest_thermometer(lua_State * L) {
	  luaL_openlibs(L);

	  lua_pushcfunction(L, traceback);

	  const int status1 = lc_handle_luainit(L);
	  if (status1 != 0) return 0;

	  /* note: IMPROVE: closure not always needed here */
	  lua_newtable(L); /* closure table */
	  lua_pushcclosure(L, lcf_main, 1);

	  int status2 = lua_pcall(L, 0, 0, -2);
	  if (status2 != 0) {
	    const char * msg = lua_tostring(L,-1);
	    if (msg == NULL) msg = "(error object is not a string)";
	    fputs(msg, stderr);
	  }
	  return 0;
	}
