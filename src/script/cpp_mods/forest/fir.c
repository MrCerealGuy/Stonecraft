/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: fir_growing
 * function(pos) */
static int lcf1_fir_growing (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local height = math.random(5,13) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,5);
  lua_pushnumber(L,13);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 2);
  
  /* -- build the trunk
   * for dy = 0, height do */
  lua_pushnumber(L,0);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,2)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc1_var = lua_tonumber(L,-1);
  const double lc2_limit = lua_tonumber(L,2);
  const double lc3_step = 1;
  lua_pop(L,1);
  enum { lc4 = 2 };
  while ((((lc3_step > 0) && (lc1_var <= lc2_limit)) || ((lc3_step <= 0) && (lc1_var >= lc2_limit)))) {
    
    /* internal: local dy at index 3 */
    lua_pushnumber(L,lc1_var);
    
    /* minetest.set_node({x = pos.x, y = pos.y + dy, z = pos.z}, {name = "forest:fir_tree"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_add(L,-1,3);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"forest:fir_tree");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc1_var += lc3_step;
  }
  lua_settop(L,lc4);
  assert(lua_gettop(L) == 2);
  
  /* local steps = math.floor(height * 0.75 + 2.25) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,0.75);
  lc_mul(L,2,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,2.25);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* local dist = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 4);
  
  /* -- add the leaves, cell by cell
   * for dy = 1, steps do
   * 		-- define the width of the step : to modelize the conic shape of the tree,
   * 		-- for each step the width is proportionnal to the distance to the top */
  lua_pushnumber(L,1);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,3)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc5_var = lua_tonumber(L,-1);
  const double lc6_limit = lua_tonumber(L,3);
  const double lc7_step = 1;
  lua_pop(L,1);
  enum { lc8 = 4 };
  while ((((lc7_step > 0) && (lc5_var <= lc6_limit)) || ((lc7_step <= 0) && (lc5_var >= lc6_limit)))) {
    
    /* internal: local dy at index 5 */
    lua_pushnumber(L,lc5_var);
    
    /* -- define the width of the step : to modelize the conic shape of the tree,
     * -- for each step the width is proportionnal to the distance to the top
     * dist = math.floor(dy / 3) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,3);
    lc_div(L,5,-1);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 5);
    
    /* for dx = -dist, dist do */
    lc_unm(L,4);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,4)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc9_var = lua_tonumber(L,-1);
    const double lc10_limit = lua_tonumber(L,4);
    const double lc11_step = 1;
    lua_pop(L,1);
    enum { lc12 = 5 };
    while ((((lc11_step > 0) && (lc9_var <= lc10_limit)) || ((lc11_step <= 0) && (lc9_var >= lc10_limit)))) {
      
      /* internal: local dx at index 6 */
      lua_pushnumber(L,lc9_var);
      
      /* for dz = -dist, dist do */
      lc_unm(L,4);
      if (!((lua_isnumber(L,-1) && lua_isnumber(L,4)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc13_var = lua_tonumber(L,-1);
      const double lc14_limit = lua_tonumber(L,4);
      const double lc15_step = 1;
      lua_pop(L,1);
      enum { lc16 = 6 };
      while ((((lc15_step > 0) && (lc13_var <= lc14_limit)) || ((lc15_step <= 0) && (lc13_var >= lc14_limit)))) {
        
        /* internal: local dz at index 7 */
        lua_pushnumber(L,lc13_var);
        
        /* pos.x = pos.x + dx */
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_add(L,-1,6);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 7);
        
        /* pos.y = pos.y + height + 3 - dy */
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_add(L,-1,2);
        lua_remove(L,-2);
        lua_pushnumber(L,3);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_sub(L,-1,5);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 7);
        
        /* pos.z = pos.z + dz */
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_add(L,-1,7);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 7);
        
        /* -- for each cell we will get 60% chance to have leaves
         * if (minetest.get_node(pos).name == "air" or minetest.get_node(pos).name == "ignore") and math.random(1, 5) <= 3 then */
        enum { lc17 = 7 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"air");
        const int lc18 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc18);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"ignore");
          const int lc19 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc19);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_pushnumber(L,5);
          lua_call(L,2,1);
          lua_pushnumber(L,3);
          const int lc20 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc20);
        }
        const int lc21 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc21) {
          
          /* minetest.set_node(pos, {name = "forest:fir_leaves"}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"forest:fir_leaves");
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 7);
        }
        lua_settop(L,lc17);
        assert(lua_gettop(L) == 7);
        
        /* pos.x = pos.x - dx */
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_sub(L,-1,6);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 7);
        
        /* pos.y = pos.y - height - 3 + dy */
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_sub(L,-1,2);
        lua_remove(L,-2);
        lua_pushnumber(L,3);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-1,5);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 7);
        
        /* pos.z = pos.z - dz */
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_sub(L,-1,7);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 7);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc13_var += lc15_step;
      }
      lua_settop(L,lc16);
      assert(lua_gettop(L) == 6);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc9_var += lc11_step;
    }
    lua_settop(L,lc12);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc5_var += lc7_step;
  }
  lua_settop(L,lc8);
  assert(lua_gettop(L) == 4);
  
  /* -- if the leaves node at the top is floating, put another leaves node under
   * local node_top = minetest.get_node({x = pos.x, y = pos.y + height + 1, z = pos.z}).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* if minetest.get_node({x = pos.x, y = pos.y + height + 2, z = pos.z}).name == "forest:fir_leaves" and (node_top == "air" or node_top == "ignore") then */
  enum { lc22 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest:fir_leaves");
  const int lc23 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc23);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,5);
    lua_pushliteral(L,"air");
    const int lc24 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc24);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"ignore");
      const int lc25 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc25);
    }
  }
  const int lc26 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc26) {
    
    /* minetest.set_node({x = pos.x, y = pos.y + height + 1, z = pos.z}, {name = "forest:fir_leaves"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lc_add(L,-1,2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"forest:fir_leaves");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc22);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* function fir_growing(pos)
   * 	local height = math.random(5,13)
   * 		-- build the trunk
   * 	for dy = 0, height do
   * 		minetest.set_node({x = pos.x, y = pos.y + dy, z = pos.z}, {name = "forest:fir_tree"})
   * 	end
   * 	local steps = math.floor(height * 0.75 + 2.25)
   * 	local dist = 0
   * 		-- add the leaves, cell by cell
   * 	for dy = 1, steps do
   * 		-- define the width of the step : to modelize the conic shape of the tree,
   * 		-- for each step the width is proportionnal to the distance to the top
   * 		dist = math.floor(dy / 3)
   * 		for dx = -dist, dist do
   * 			for dz = -dist, dist do
   * 				pos.x = pos.x + dx
   * 				pos.y = pos.y + height + 3 - dy
   * 				pos.z = pos.z + dz
   * 					-- for each cell we will get 60% chance to have leaves
   * 				if (minetest.get_node(pos).name == "air" or minetest.get_node(pos).name == "ignore") and math.random(1, 5) <= 3 then
   * 					minetest.set_node(pos, {name = "forest:fir_leaves"})
   * 				end
   * 				pos.x = pos.x - dx
   * 				pos.y = pos.y - height - 3 + dy
   * 				pos.z = pos.z - dz
   * 			end
   * 		end
   * 	end
   * 		-- if the leaves node at the top is floating, put another leaves node under
   * 	local node_top = minetest.get_node({x = pos.x, y = pos.y + height + 1, z = pos.z}).name
   * 	if minetest.get_node({x = pos.x, y = pos.y + height + 2, z = pos.z}).name == "forest:fir_leaves" and (node_top == "air" or node_top == "ignore") then
   * 		minetest.set_node({x = pos.x, y = pos.y + height + 1, z = pos.z}, {name = "forest:fir_leaves"})
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_fir_growing);
  lua_setfield(L,LUA_ENVIRONINDEX,"fir_growing");
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_forest_fir(lua_State * L) {
	  luaL_openlibs(L);

	  lua_pushcfunction(L, traceback);

	  const int status1 = lc_handle_luainit(L);
	  if (status1 != 0) return 0;

	  /* note: IMPROVE: closure not always needed here */
	  lua_newtable(L); /* closure table */
	  lua_pushcclosure(L, lcf_main, 1);

	  int status2 = lua_pcall(L, 0, 0, -2);
	  if (status2 != 0) {
	    const char * msg = lua_tostring(L,-1);
	    if (msg == NULL) msg = "(error object is not a string)";
	    fputs(msg, stderr);
	  }
	  return 0;
	}

