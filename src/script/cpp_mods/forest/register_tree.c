/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(pos) */
static int lcf56 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* def.growing.method(pos, specie) */
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"growing");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"method");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(pos) */
static int lcf71 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* minetest.set_node(pos, {name = def.names.leaves}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"set_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"names");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"leaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(pos) */
static int lcf77 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* minetest.set_node(pos, {name = def.names.fruitleaves}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"set_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"names");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"fruitleaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(pos) */
static int lcf78 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* minetest.set_node(pos, {name = def.names.leaves}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"set_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"names");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"leaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: register_tree
 * function(specie, def) */
static int lcf1_register_tree (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 3 };
  assert((lua_gettop(L) == lc1));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,2);
  
  /* if not def.description then */
  enum { lc2 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"description");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc3 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc3) {
    
    /* def.description = specie */
    lc_getupvalue(L,lc1,0,1);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"description");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc2);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions then */
  enum { lc4 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* def.descriptions = {} */
    lua_newtable(L);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"descriptions");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc4);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.tree then */
  enum { lc6 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc7 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc7) {
    
    /* def.descriptions.tree = def.description.." tree" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," tree");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"tree");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.leaves then */
  enum { lc8 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"leaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc9 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc9) {
    
    /* def.descriptions.leaves = def.description.." leaves" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," leaves");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"leaves");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc8);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.wood then */
  enum { lc10 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"wood");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc11 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc11) {
    
    /* def.descriptions.wood = def.description.." wood" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," wood");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"wood");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.sapling then */
  enum { lc12 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc13 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc13) {
    
    /* def.descriptions.sapling = def.description.." sapling" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," sapling");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"sapling");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc12);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.fruitleaves then */
  enum { lc14 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"fruitleaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc15 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc15) {
    
    /* def.descriptions.fruitleaves = def.description.." fruitleaves" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," fruitleaves");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"fruitleaves");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc14);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.fruit then */
  enum { lc16 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"fruit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc17 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc17) {
    
    /* def.descriptions.fruit = def.description.." fruit" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," fruit");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"fruit");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc16);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.stair then */
  enum { lc18 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"stair");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc19 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc19) {
    
    /* def.descriptions.stair = def.description.." stair" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," stair");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"stair");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc18);
  assert(lua_gettop(L) == 3);
  
  /* if not def.descriptions.slab then */
  enum { lc20 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"descriptions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"slab");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc21 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc21) {
    
    /* def.descriptions.slab = def.description.." slab" */
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"description");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," slab");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"slab");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc20);
  assert(lua_gettop(L) == 3);
  
  /* if not def.apportionment then */
  enum { lc22 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"apportionment");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc23 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc23) {
    
    /* def.apportionment = {} */
    lua_newtable(L);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"apportionment");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc22);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles then */
  enum { lc24 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc25 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc25) {
    
    /* def.tiles = {} */
    lua_newtable(L);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"tiles");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc24);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.tree then */
  enum { lc26 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc27 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc27) {
    
    /* def.tiles.tree = specie.."_tree.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_tree.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"tree");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc26);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.tree_top then */
  enum { lc28 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"tree_top");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc29 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc29) {
    
    /* def.tiles.tree_top = specie.."_tree_top.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_tree_top.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"tree_top");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc28);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.leaves then */
  enum { lc30 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"leaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc31 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc31) {
    
    /* def.tiles.leaves = specie.."_leaves.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_leaves.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"leaves");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc30);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.sapling then */
  enum { lc32 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc33 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc33) {
    
    /* def.tiles.sapling = specie.."_sapling.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_sapling.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"sapling");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc32);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.wood then */
  enum { lc34 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"wood");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc35 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc35) {
    
    /* def.tiles.wood = specie.."_wood.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_wood.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"wood");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc34);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.fruitleaves then */
  enum { lc36 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"fruitleaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc37 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc37) {
    
    /* def.tiles.fruitleaves = specie.."_fruitleaves.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_fruitleaves.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"fruitleaves");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc36);
  assert(lua_gettop(L) == 3);
  
  /* if not def.tiles.fruit then */
  enum { lc38 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"tiles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"fruit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc39 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc39) {
    
    /* def.tiles.fruit = specie.."_fruit.png" */
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_fruit.png");
    lua_concat(L,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"fruit");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc38);
  assert(lua_gettop(L) == 3);
  
  /* if not def.growing.method then */
  enum { lc40 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"growing");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"method");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc41 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc41) {
    
    /* def.growing.method = tree_growing */
    lua_getfield(L,LUA_ENVIRONINDEX,"tree_growing");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"growing");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"method");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc40);
  assert(lua_gettop(L) == 3);
  
  /* if not def.register then */
  enum { lc42 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc43 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc43) {
    
    /* def.register = {tree = true, leaves = true, sapling = true, wood = true, stair = true, slab = true, fruitleaves = true, fruit = true, abm = true, craft = true} */
    lua_createtable(L,0,10);
    lua_pushliteral(L,"tree");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"leaves");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sapling");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wood");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"stair");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"slab");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"fruitleaves");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"fruit");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"abm");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"craft");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"register");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc42);
  assert(lua_gettop(L) == 3);
  
  /* if not def.wood_by_trunk then */
  enum { lc44 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"wood_by_trunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc45 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc45) {
    
    /* def.wood_by_trunk = 4 */
    lua_pushnumber(L,4);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"wood_by_trunk");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc44);
  assert(lua_gettop(L) == 3);
  
  /* if not def.names then */
  enum { lc46 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"names");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc47 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc47) {
    
    /* def.names = {
     * 			tree = "forest:"..specie.."_tree",
     * 			leaves = "forest:"..specie.."_leaves",
     * 			sapling = "forest:"..specie.."_sapling",
     * 			wood = "forest:"..specie.."_wood",
     * 			fruitleaves = "forest:"..specie.."_fruitleaves",
     * 			fruit = "forest:"..specie.."_fruit",
     * 			stair_slab = specie.."_wood"} */
    lua_createtable(L,0,7);
    lua_pushliteral(L,"tree");
    lua_pushliteral(L,"forest:");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_tree");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"leaves");
    lua_pushliteral(L,"forest:");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_leaves");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sapling");
    lua_pushliteral(L,"forest:");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_sapling");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wood");
    lua_pushliteral(L,"forest:");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_wood");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"fruitleaves");
    lua_pushliteral(L,"forest:");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_fruitleaves");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"fruit");
    lua_pushliteral(L,"forest:");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_fruit");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"stair_slab");
    lc_getupvalue(L,lc1,0,1);
    lua_pushliteral(L,"_wood");
    lua_concat(L,2);
    lua_rawset(L,-3);
    lc_getupvalue(L,lc1,0,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"names");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc46);
  assert(lua_gettop(L) == 3);
  
  /* if def.register.tree then */
  enum { lc48 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc49 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc49) {
    
    /* minetest.register_node(def.names.tree, {
     * 			description = def.descriptions.tree,
     * 			tiles = {def.tiles.tree_top, def.tiles.tree_top, def.tiles.tree},
     * 			paramtype2 = "facedir",
     * 			is_ground_content = false,
     * 			groups = {tree=1,choppy=2,oddly_breakable_by_hand=1,flammable=2},
     * 			sounds = default.node_sound_wood_defaults(),
     * 			on_place = minetest.rotate_node
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,7);
    lua_pushliteral(L,"description");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,3,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"tree_top");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"tree_top");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype2");
    lua_pushliteral(L,"facedir");
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"tree");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"choppy");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"oddly_breakable_by_hand");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"flammable");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_wood_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"on_place");
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"rotate_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc48);
  assert(lua_gettop(L) == 3);
  
  /* trees[specie] = def.growing */
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"growing");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"trees");
  lua_insert(L,-2);
  lc_getupvalue(L,lc1,0,1);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* trees[specie].nodes = def.names */
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"names");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"trees");
  lc_getupvalue(L,lc1,0,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"nodes");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* apportionment[specie] = def.apportionment */
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"apportionment");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"apportionment");
  lua_insert(L,-2);
  lc_getupvalue(L,lc1,0,1);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* if def.register.leaves then */
  enum { lc50 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"leaves");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc51 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc51) {
    
    /* minetest.register_node(def.names.leaves, {
     * 			description = def.descriptions.leaves,
     * 			drawtype = "allfaces_optional",
     * 			visual_scale = 1.3,
     * 			tiles = {def.tiles.leaves},
     * 			paramtype = "light",
     * 			waving = 1,
     * 			is_ground_content = false,
     * 			groups = {snappy=3, leafdecay=def.growing.radius + 1, flammable=2, leaves=1},
     * 			drop = {
     * 				max_items = 1,
     * 				items = {
     * 					{
     * 						-- player will get sapling with 1 out of chance_sapling chance
     * 						items = {def.names.sapling},
     * 						rarity = 100 / def.sapling.chance,
     * 					},
     * 					{
     * 						-- player will get leaves only if he get no saplings,
     * 						-- this is because max_items is 1
     * 						items = {def.names.leaves},
     * 					}
     * 				}
     * 			},
     * 			sounds = default.node_sound_leaves_defaults(),
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"leaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,10);
    lua_pushliteral(L,"description");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"leaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"allfaces_optional");
    lua_rawset(L,-3);
    lua_pushliteral(L,"visual_scale");
    lua_pushnumber(L,1.3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"leaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"waving");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"snappy");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"leafdecay");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"growing");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"radius");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"flammable");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"leaves");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"drop");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"max_items");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"items");
    lua_createtable(L,2,0);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"items");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"rarity");
    lua_pushnumber(L,100);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"chance");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"items");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"leaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_leaves_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc50);
  assert(lua_gettop(L) == 3);
  
  /* if def.register.sapling then */
  enum { lc52 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc53 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc53) {
    
    /* minetest.register_node(def.names.sapling, {
     * 			description = def.descriptions.sapling,
     * 			drawtype = "plantlike",
     * 			visual_scale = 1.0,
     * 			tiles = {def.tiles.sapling},
     * 			inventory_image = def.tiles.sapling,
     * 			wield_image = def.tiles.sapling,
     * 			paramtype = "light",
     * 			walkable = false,
     * 			is_ground_content = true,
     * 			selection_box = {
     * 				type = "fixed",
     * 				fixed = {-0.3, -0.5, -0.3, 0.3, 0.35, 0.3}
     * 			},
     * 			groups = {snappy=2,dig_immediate=3,flammable=2,attached_node=1},
     * 			sounds = default.node_sound_leaves_defaults(),
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,12);
    lua_pushliteral(L,"description");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"plantlike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"visual_scale");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wield_image");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"selection_box");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"fixed");
    lua_rawset(L,-3);
    lua_pushliteral(L,"fixed");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.3);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.3);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.3);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.35);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.3);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"snappy");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"flammable");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"attached_node");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_leaves_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc52);
  assert(lua_gettop(L) == 3);
  
  /* if def.register.abm then */
  enum { lc54 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc55 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc55) {
    
    /* minetest.register_abm({
     * 			nodenames = {def.names.sapling},
     * 			interval = 60,
     * 			chance = 100 / def.sapling.growing,
     * 			action = function(pos)
     * 				def.growing.method(pos, specie)
     * 			end
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,60);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,100);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"growing");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushvalue(L,lc1);
    lua_pushcclosure(L,lcf56,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc54);
  assert(lua_gettop(L) == 3);
  
  /* if def.register.wood then */
  enum { lc57 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"wood");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc58 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc58) {
    
    /* minetest.register_node(def.names.wood, {
     * 			description = def.descriptions.wood,
     * 			tiles = {def.tiles.wood},
     * 			groups = {choppy=2,oddly_breakable_by_hand=2,flammable=3,wood=1},
     * 			sounds = default.node_sound_wood_defaults(),
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"wood");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"description");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"descriptions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"wood");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"tiles");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"wood");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"choppy");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"oddly_breakable_by_hand");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"flammable");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wood");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_wood_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* -- Code from stairs
     * if def.register.stair then */
    enum { lc59 = 3 };
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"register");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"stair");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc60 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc60) {
      
      /* stairs.register_stair(def.names.stair_slab, def.names.wood,
       * 				{snappy=2,choppy=2,oddly_breakable_by_hand=2,flammable=3},
       * 				{def.tiles.wood},
       * 				def.descriptions.stair,
       * 				default.node_sound_wood_defaults()
       * 			) */
      lua_getfield(L,LUA_ENVIRONINDEX,"stairs");
      lua_pushliteral(L,"register_stair");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc61 = lua_gettop(L);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"stair_slab");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"wood");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,4);
      lua_pushliteral(L,"snappy");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"choppy");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"oddly_breakable_by_hand");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"flammable");
      lua_pushnumber(L,3);
      lua_rawset(L,-3);
      lua_createtable(L,1,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"tiles");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"wood");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"descriptions");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"stair");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"default");
      lua_pushliteral(L,"node_sound_wood_defaults");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc61),0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc59);
    assert(lua_gettop(L) == 3);
    
    /* if def.register.slab then */
    enum { lc62 = 3 };
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"register");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"slab");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc63 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc63) {
      
      /* stairs.register_slab(def.names.stair_slab, def.names.wood,
       * 				{snappy=2,choppy=2,oddly_breakable_by_hand=2,flammable=3},
       * 				{def.tiles.wood},
       * 				def.descriptions.slab,
       * 				default.node_sound_wood_defaults()
       * 			) */
      lua_getfield(L,LUA_ENVIRONINDEX,"stairs");
      lua_pushliteral(L,"register_slab");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc64 = lua_gettop(L);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"stair_slab");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"wood");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,4);
      lua_pushliteral(L,"snappy");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"choppy");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"oddly_breakable_by_hand");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"flammable");
      lua_pushnumber(L,3);
      lua_rawset(L,-3);
      lua_createtable(L,1,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"tiles");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"wood");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"descriptions");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"slab");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"default");
      lua_pushliteral(L,"node_sound_wood_defaults");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc64),0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc62);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc57);
  assert(lua_gettop(L) == 3);
  
  /* if def.register.craft then */
  enum { lc65 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"register");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc66 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc66) {
    
    /* minetest.register_craft({
     * 			output = def.names.wood..' '..def.wood_by_trunk,
     * 			recipe = {
     * 				{def.names.tree},
     * 			}
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"wood");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," ");
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"wood_by_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,1,0);
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc65);
  assert(lua_gettop(L) == 3);
  
  /* if def.fruits then */
  enum { lc67 = 3 };
  lc_getupvalue(L,lc1,0,2);
  lua_pushliteral(L,"fruits");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc68 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc68) {
    
    /* if def.register.fruitleaves then */
    enum { lc69 = 3 };
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"register");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"fruitleaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc70 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc70) {
      
      /* minetest.register_node(def.names.fruitleaves, {
       * 				description = def.descriptions.fruitleaves,
       * 				drawtype = "allfaces_optional",
       * 				visual_scale = 1.3,
       * 				tiles = {def.tiles.fruitleaves},
       * 				paramtype = "light",
       * 				waving = 1,
       * 				is_ground_content = false,
       * 				groups = {snappy=3, dig_immediate=3, leafdecay=def.growing.radius + 1, flammable=2, leaves=1},
       * 				drop = {items = {{items = {def.names.fruit}}}},
       * 				sounds = default.node_sound_leaves_defaults(),
       * 				after_destruct = function(pos)
       * 					minetest.set_node(pos, {name = def.names.leaves})
       * 				end
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"register_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruitleaves");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,11);
      lua_pushliteral(L,"description");
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"descriptions");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruitleaves");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"drawtype");
      lua_pushliteral(L,"allfaces_optional");
      lua_rawset(L,-3);
      lua_pushliteral(L,"visual_scale");
      lua_pushnumber(L,1.3);
      lua_rawset(L,-3);
      lua_pushliteral(L,"tiles");
      lua_createtable(L,1,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"tiles");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruitleaves");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"paramtype");
      lua_pushliteral(L,"light");
      lua_rawset(L,-3);
      lua_pushliteral(L,"waving");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"is_ground_content");
      lua_pushboolean(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"groups");
      lua_createtable(L,0,5);
      lua_pushliteral(L,"snappy");
      lua_pushnumber(L,3);
      lua_rawset(L,-3);
      lua_pushliteral(L,"dig_immediate");
      lua_pushnumber(L,3);
      lua_rawset(L,-3);
      lua_pushliteral(L,"leafdecay");
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"growing");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"radius");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"flammable");
      lua_pushnumber(L,2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"leaves");
      lua_pushnumber(L,1);
      lua_rawset(L,-3);
      lua_rawset(L,-3);
      lua_pushliteral(L,"drop");
      lua_createtable(L,0,1);
      lua_pushliteral(L,"items");
      lua_createtable(L,1,0);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"items");
      lua_createtable(L,1,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lua_rawset(L,-3);
      lua_rawseti(L,-2,1);
      lua_rawset(L,-3);
      lua_rawset(L,-3);
      lua_pushliteral(L,"sounds");
      lua_getfield(L,LUA_ENVIRONINDEX,"default");
      lua_pushliteral(L,"node_sound_leaves_defaults");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"after_destruct");
      lua_pushvalue(L,lc1);
      lua_pushcclosure(L,lcf71,1);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc69);
    assert(lua_gettop(L) == 3);
    
    /* if def.register.fruit then */
    enum { lc72 = 3 };
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"register");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"fruit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc73 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc73) {
      
      /* if def.fruits.hearts > 0 then */
      enum { lc74 = 3 };
      lua_pushnumber(L,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"fruits");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"hearts");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc75 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc75);
      const int lc76 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc76) {
        
        /* minetest.register_craftitem(def.names.fruit, {
         * 					description = def.descriptions.fruit,
         * 					inventory_image = def.tiles.fruit,
         * 					on_use = minetest.item_eat(def.fruits.hearts * 2),
         * 				}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"register_craftitem");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"names");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"fruit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"description");
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"descriptions");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"fruit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"inventory_image");
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"tiles");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"fruit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"on_use");
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"item_eat");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"fruits");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"hearts");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lc_mul(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 3);
      }
      else {
        
        /* else
         * minetest.register_craftitem(def.names.fruit, {
         * 					description = def.descriptions.fruit,
         * 					inventory_image = def.tiles.fruit,
         * 				}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"register_craftitem");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"names");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"fruit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"description");
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"descriptions");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"fruit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"inventory_image");
        lc_getupvalue(L,lc1,0,2);
        lua_pushliteral(L,"tiles");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"fruit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L,lc74);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc72);
    assert(lua_gettop(L) == 3);
    
    /* minetest.register_abm({
     * 			nodenames = {def.names.leaves},
     * 			interval = 60,
     * 			chance = 100 / def.fruits.chance,
     * 			action = function(pos)
     * 				minetest.set_node(pos, {name = def.names.fruitleaves})
     * 			end
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"leaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,60);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,100);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"fruits");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"chance");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushvalue(L,lc1);
    lua_pushcclosure(L,lcf77,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* minetest.register_abm({
     * 			nodenames = {def.names.fruitleaves},
     * 			interval = 60,
     * 			chance = (100 * def.fruits.max) / (def.fruits.chance * (100 - def.fruits.max)),
     * 			action = function(pos)
     * 				minetest.set_node(pos, {name = def.names.leaves})
     * 			end
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"names");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"fruitleaves");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,60);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,100);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"fruits");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"fruits");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"chance");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,100);
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"fruits");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushvalue(L,lc1);
    lua_pushcclosure(L,lcf78,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* if def.fruits.craft then */
    enum { lc79 = 3 };
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"fruits");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc80 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc80) {
      
      /* minetest.register_craft({
       * 				output = def.fruits.craft,
       * 				recipe = {
       * 					{def.names.fruit},
       * 				}
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"register_craft");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"output");
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"fruits");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"craft");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"recipe");
      lua_createtable(L,1,0);
      lua_createtable(L,1,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lua_rawseti(L,-2,1);
      lua_rawset(L,-3);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc79);
    assert(lua_gettop(L) == 3);
    
    /* if def.fruits.craft_sapling then */
    enum { lc81 = 3 };
    lc_getupvalue(L,lc1,0,2);
    lua_pushliteral(L,"fruits");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"craft_sapling");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc82 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc82) {
      
      /* minetest.register_craft({
       * 				output = def.names.sapling,
       * 				recipe = {
       * 					{def.names.fruit, def.names.fruit, def.names.fruit},
       * 					{def.names.fruit, def.names.fruit, def.names.fruit},
       * 					{def.names.fruit, def.names.fruit, def.names.fruit},
       * 				}
       * 			}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"register_craft");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"output");
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"sapling");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"recipe");
      lua_createtable(L,3,0);
      lua_createtable(L,3,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,2);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,3);
      lua_rawseti(L,-2,1);
      lua_createtable(L,3,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,2);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,3);
      lua_rawseti(L,-2,2);
      lua_createtable(L,3,0);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,1);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,2);
      lc_getupvalue(L,lc1,0,2);
      lua_pushliteral(L,"names");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_rawseti(L,-2,3);
      lua_rawseti(L,-2,3);
      lua_rawset(L,-3);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc81);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc67);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* function register_tree(specie, def)
   * 	if not def.description then
   * 		def.description = specie
   * 	end
   * 	if not def.descriptions then
   * 		def.descriptions = {}
   * 	end
   * 	if not def.descriptions.tree then
   * 		def.descriptions.tree = def.description.." tree"
   * 	end
   * 	if not def.descriptions.leaves then
   * 		def.descriptions.leaves = def.description.." leaves"
   * 	end
   * 	if not def.descriptions.wood then
   * 		def.descriptions.wood = def.description.." wood"
   * 	end
   * 	if not def.descriptions.sapling then
   * 		def.descriptions.sapling = def.description.." sapling"
   * 	end
   * 	if not def.descriptions.fruitleaves then
   * 		def.descriptions.fruitleaves = def.description.." fruitleaves"
   * 	end
   * 	if not def.descriptions.fruit then
   * 		def.descriptions.fruit = def.description.." fruit"
   * 	end
   * 	if not def.descriptions.stair then
   * 		def.descriptions.stair = def.description.." stair"
   * 	end
   * 	if not def.descriptions.slab then
   * 		def.descriptions.slab = def.description.." slab"
   * 	end
   * 	if not def.apportionment then
   * 		def.apportionment = {}
   * 	end
   * 	if not def.tiles then
   * 		def.tiles = {}
   * 	end
   * 	if not def.tiles.tree then
   * 		def.tiles.tree = specie.."_tree.png"
   * 	end
   * 	if not def.tiles.tree_top then
   * 		def.tiles.tree_top = specie.."_tree_top.png"
   * 	end
   * 	if not def.tiles.leaves then
   * 		def.tiles.leaves = specie.."_leaves.png"
   * 	end
   * 	if not def.tiles.sapling then
   * 		def.tiles.sapling = specie.."_sapling.png"
   * 	end
   * 	if not def.tiles.wood then
   * 		def.tiles.wood = specie.."_wood.png"
   * 	end
   * 	if not def.tiles.fruitleaves then
   * 		def.tiles.fruitleaves = specie.."_fruitleaves.png"
   * 	end
   * 	if not def.tiles.fruit then
   * 		def.tiles.fruit = specie.."_fruit.png"
   * 	end
   * 	if not def.growing.method then
   * 		def.growing.method = tree_growing
   * 	end
   * 	if not def.register then
   * 		def.register = {tree = true, leaves = true, sapling = true, wood = true, stair = true, slab = true, fruitleaves = true, fruit = true, abm = true, craft = true}
   * 	end
   * 	if not def.wood_by_trunk then
   * 		def.wood_by_trunk = 4
   * 	end
   * 	if not def.names then
   * 		def.names = {
   * 			tree = "forest:"..specie.."_tree",
   * 			leaves = "forest:"..specie.."_leaves",
   * 			sapling = "forest:"..specie.."_sapling",
   * 			wood = "forest:"..specie.."_wood",
   * 			fruitleaves = "forest:"..specie.."_fruitleaves",
   * 			fruit = "forest:"..specie.."_fruit",
   * 			stair_slab = specie.."_wood"}
   * 	end
   * 	if def.register.tree then
   * 		minetest.register_node(def.names.tree, {
   * 			description = def.descriptions.tree,
   * 			tiles = {def.tiles.tree_top, def.tiles.tree_top, def.tiles.tree},
   * 			paramtype2 = "facedir",
   * 			is_ground_content = false,
   * 			groups = {tree=1,choppy=2,oddly_breakable_by_hand=1,flammable=2},
   * 			sounds = default.node_sound_wood_defaults(),
   * 			on_place = minetest.rotate_node
   * 		})
   * 	end
   * 	
   * 	trees[specie] = def.growing
   * 	trees[specie].nodes = def.names
   * 	apportionment[specie] = def.apportionment
   * 	
   * 	if def.register.leaves then
   * 		minetest.register_node(def.names.leaves, {
   * 			description = def.descriptions.leaves,
   * 			drawtype = "allfaces_optional",
   * 			visual_scale = 1.3,
   * 			tiles = {def.tiles.leaves},
   * 			paramtype = "light",
   * 			waving = 1,
   * 			is_ground_content = false,
   * 			groups = {snappy=3, leafdecay=def.growing.radius + 1, flammable=2, leaves=1},
   * 			drop = {
   * 				max_items = 1,
   * 				items = {
   * 					{
   * 						-- player will get sapling with 1 out of chance_sapling chance
   * 						items = {def.names.sapling},
   * 						rarity = 100 / def.sapling.chance,
   * 					},
   * 					{
   * 						-- player will get leaves only if he get no saplings,
   * 						-- this is because max_items is 1
   * 						items = {def.names.leaves},
   * 					}
   * 				}
   * 			},
   * 			sounds = default.node_sound_leaves_defaults(),
   * 		})
   * 	end
   * 	
   * 	if def.register.sapling then
   * 		minetest.register_node(def.names.sapling, {
   * 			description = def.descriptions.sapling,
   * 			drawtype = "plantlike",
   * 			visual_scale = 1.0,
   * 			tiles = {def.tiles.sapling},
   * 			inventory_image = def.tiles.sapling,
   * 			wield_image = def.tiles.sapling,
   * 			paramtype = "light",
   * 			walkable = false,
   * 			is_ground_content = true,
   * 			selection_box = {
   * 				type = "fixed",
   * 				fixed = {-0.3, -0.5, -0.3, 0.3, 0.35, 0.3}
   * 			},
   * 			groups = {snappy=2,dig_immediate=3,flammable=2,attached_node=1},
   * 			sounds = default.node_sound_leaves_defaults(),
   * 		})
   * 	end
   * 	
   * 	if def.register.abm then
   * 		minetest.register_abm({
   * 			nodenames = {def.names.sapling},
   * 			interval = 60,
   * 			chance = 100 / def.sapling.growing,
   * 			action = function(pos)
   * 				def.growing.method(pos, specie)
   * 			end
   * 		})
   * 	end
   * 	
   * 	if def.register.wood then
   * 		minetest.register_node(def.names.wood, {
   * 			description = def.descriptions.wood,
   * 			tiles = {def.tiles.wood},
   * 			groups = {choppy=2,oddly_breakable_by_hand=2,flammable=3,wood=1},
   * 			sounds = default.node_sound_wood_defaults(),
   * 		})
   * 			-- Code from stairs
   * 		if def.register.stair then
   * 			stairs.register_stair(def.names.stair_slab, def.names.wood,
   * 				{snappy=2,choppy=2,oddly_breakable_by_hand=2,flammable=3},
   * 				{def.tiles.wood},
   * 				def.descriptions.stair,
   * 				default.node_sound_wood_defaults()
   * 			)
   * 		end
   * 		if def.register.slab then
   * 			stairs.register_slab(def.names.stair_slab, def.names.wood,
   * 				{snappy=2,choppy=2,oddly_breakable_by_hand=2,flammable=3},
   * 				{def.tiles.wood},
   * 				def.descriptions.slab,
   * 				default.node_sound_wood_defaults()
   * 			)
   * 		end
   * 	end
   * 	
   * 	if def.register.craft then
   * 		minetest.register_craft({
   * 			output = def.names.wood..' '..def.wood_by_trunk,
   * 			recipe = {
   * 				{def.names.tree},
   * 			}
   * 		})
   * 	end
   * 	
   * 	if def.fruits then
   * 		if def.register.fruitleaves then
   * 			minetest.register_node(def.names.fruitleaves, {
   * 				description = def.descriptions.fruitleaves,
   * 				drawtype = "allfaces_optional",
   * 				visual_scale = 1.3,
   * 				tiles = {def.tiles.fruitleaves},
   * 				paramtype = "light",
   * 				waving = 1,
   * 				is_ground_content = false,
   * 				groups = {snappy=3, dig_immediate=3, leafdecay=def.growing.radius + 1, flammable=2, leaves=1},
   * 				drop = {items = {{items = {def.names.fruit}}}},
   * 				sounds = default.node_sound_leaves_defaults(),
   * 				after_destruct = function(pos)
   * 					minetest.set_node(pos, {name = def.names.leaves})
   * 				end
   * 			})
   * 		end
   * 		
   * 		if def.register.fruit then
   * 			if def.fruits.hearts > 0 then
   * 				minetest.register_craftitem(def.names.fruit, {
   * 					description = def.descriptions.fruit,
   * 					inventory_image = def.tiles.fruit,
   * 					on_use = minetest.item_eat(def.fruits.hearts * 2),
   * 				})
   * 			else
   * 				minetest.register_craftitem(def.names.fruit, {
   * 					description = def.descriptions.fruit,
   * 					inventory_image = def.tiles.fruit,
   * 				})
   * 			end
   * 		end
   * 		
   * 		minetest.register_abm({
   * 			nodenames = {def.names.leaves},
   * 			interval = 60,
   * 			chance = 100 / def.fruits.chance,
   * 			action = function(pos)
   * 				minetest.set_node(pos, {name = def.names.fruitleaves})
   * 			end
   * 		})
   * 		
   * 		minetest.register_abm({
   * 			nodenames = {def.names.fruitleaves},
   * 			interval = 60,
   * 			chance = (100 * def.fruits.max) / (def.fruits.chance * (100 - def.fruits.max)),
   * 			action = function(pos)
   * 				minetest.set_node(pos, {name = def.names.leaves})
   * 			end
   * 		})
   * 		if def.fruits.craft then
   * 			minetest.register_craft({
   * 				output = def.fruits.craft,
   * 				recipe = {
   * 					{def.names.fruit},
   * 				}
   * 			})
   * 		end
   * 		if def.fruits.craft_sapling then
   * 			minetest.register_craft({
   * 				output = def.names.sapling,
   * 				recipe = {
   * 					{def.names.fruit, def.names.fruit, def.names.fruit},
   * 					{def.names.fruit, def.names.fruit, def.names.fruit},
   * 					{def.names.fruit, def.names.fruit, def.names.fruit},
   * 				}
   * 			})
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_register_tree);
  lua_setfield(L,LUA_ENVIRONINDEX,"register_tree");
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_forest_register_tree(lua_State * L) {
	  luaL_openlibs(L);

	  lua_pushcfunction(L, traceback);

	  const int status1 = lc_handle_luainit(L);
	  if (status1 != 0) return 0;

	  /* note: IMPROVE: closure not always needed here */
	  lua_newtable(L); /* closure table */
	  lua_pushcclosure(L, lcf_main, 1);

	  int status2 = lua_pcall(L, 0, 0, -2);
	  if (status2 != 0) {
	    const char * msg = lua_tostring(L,-1);
	    if (msg == NULL) msg = "(error object is not a string)";
	    fputs(msg, stderr);
	  }
	  return 0;
	}
