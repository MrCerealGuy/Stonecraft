/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <math.h>

/* __pow metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_pow(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,pow(lua_tonumber(L,idxa),lua_tonumber(L,idxb)));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__pow")||luaL_getmetafield(L,idxb,"__pow")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: distance
 * function(pos1, pos2) */
static int lcf1_distance (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* return math.sqrt((pos1.x - pos2.x) ^ 2 + (pos1.y - pos2.y) ^ 2 + (pos1.z - pos2.z) ^ 2) */
  const int lc1 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sqrt");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_pow(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_pow(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_pow(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,LUA_MULTRET);
  return (lua_gettop(L) - lc1);
  assert(lua_gettop(L) == 2);
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: get_instant_temperature
 * function(pos) */
static int lcf1_get_instant_temperature (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local temperature = minetest.get_perlin(554, 3, 0.6, 40) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,554);
  lua_pushnumber(L,3);
  lua_pushnumber(L,0.6);
  lua_pushnumber(L,40);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 2);
  
  /* local season = - math.cos(math.rad(math.mod(minetest.get_gametime(), 14400) / 40)) * 5 */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc2 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"rad");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"mod");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_gametime");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,14400);
  lua_call(L,2,1);
  lua_pushnumber(L,40);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc2),1);
  lc_unm(L,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,5);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local time = - math.cos(math.rad(minetest.get_timeofday() * 360 - 45)) * 2 */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"cos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc3 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"rad");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_timeofday");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,360);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,45);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc3),1);
  lc_unm(L,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* local value = temperature:get3d(pos) * 4 - pos.y * 0.16 + 16 + season + time */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get3d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,1);
  lua_pushnumber(L,4);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,0.16);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-1,3);
  lua_remove(L,-2);
  lc_add(L,-1,4);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* if value < 0 then */
  enum { lc4 = 5 };
  lua_pushnumber(L,0);
  const int lc5 = lua_lessthan(L,5,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc5);
  const int lc6 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc6) {
    
    /* value = 0 */
    lua_pushnumber(L,0);
    lua_replace(L,5);
    assert(lua_gettop(L) == 5);
  }
  else {
    
    /* elseif value > 20 then */
    enum { lc7 = 5 };
    lua_pushnumber(L,20);
    const int lc8 = lua_lessthan(L,-1,5);
    lua_pop(L,1);
    lua_pushboolean(L,lc8);
    const int lc9 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc9) {
      
      /* value = 20 */
      lua_pushnumber(L,20);
      lua_replace(L,5);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc7);
  }
  lua_settop(L,lc4);
  assert(lua_gettop(L) == 5);
  
  /* return value */
  lua_pushvalue(L,5);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: get_average_temperature
 * function(pos) */
static int lcf1_get_average_temperature (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local temperature = minetest.get_perlin(554, 3, 0.6, 40) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,554);
  lua_pushnumber(L,3);
  lua_pushnumber(L,0.6);
  lua_pushnumber(L,40);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 2);
  
  /* local season = minetest.get_gametime() */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_gametime");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 3);
  
  /* local value = temperature:get3d(pos) * 4 - pos.y * 0.16 + 16 */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get3d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,1);
  lua_pushnumber(L,4);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,0.16);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* if value < 0 then */
  enum { lc10 = 4 };
  lua_pushnumber(L,0);
  const int lc11 = lua_lessthan(L,4,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc11);
  const int lc12 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc12) {
    
    /* value = 0 */
    lua_pushnumber(L,0);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* elseif value > 20 then */
    enum { lc13 = 4 };
    lua_pushnumber(L,20);
    const int lc14 = lua_lessthan(L,-1,4);
    lua_pop(L,1);
    lua_pushboolean(L,lc14);
    const int lc15 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc15) {
      
      /* value = 20 */
      lua_pushnumber(L,20);
      lua_replace(L,4);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc13);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 4);
  
  /* return value */
  lua_pushvalue(L,4);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: register_season
 * function(nodename, params) */
static int lcf1_register_season (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* -- the season params are from 1.00 (early January) to 12.99 (end of December). Convert it into number like this : 0 ≥ n > 12.
   * params.start = params.start - 1 */
  lua_pushliteral(L,"start");
  lua_gettable(L,2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"start");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* params.stop = params.stop - 1 */
  lua_pushliteral(L,"stop");
  lua_gettable(L,2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"stop");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* if params.type == "appear" then */
  enum { lc16 = 2 };
  lua_pushliteral(L,"type");
  lua_gettable(L,2);
  lua_pushliteral(L,"appear");
  const int lc17 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc17);
  const int lc18 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc18) {
    
    /* if not winterblock[nodename] then */
    enum { lc19 = 2 };
    lua_getfield(L,LUA_ENVIRONINDEX,"winterblock");
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc20 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc20) {
      
      /* winterblock[nodename] = {} */
      lua_newtable(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"winterblock");
      lua_insert(L,-2);
      lua_pushvalue(L,1);
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc19);
    assert(lua_gettop(L) == 2);
    
    /* table.insert(winterblock[nodename], params) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"winterblock");
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* else
     * if not seasons[nodename] then */
    enum { lc21 = 2 };
    lua_getfield(L,LUA_ENVIRONINDEX,"seasons");
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc22 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc22) {
      
      /* seasons[nodename] = {} */
      lua_newtable(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"seasons");
      lua_insert(L,-2);
      lua_pushvalue(L,1);
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc21);
    assert(lua_gettop(L) == 2);
    
    /* table.insert(seasons[nodename], params) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"seasons");
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc16);
  assert(lua_gettop(L) == 2);
  
  /* local paramnode = minetest.registered_nodes[nodename] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* -- set the group "season"
   * if not paramnode.groups then */
  enum { lc23 = 3 };
  lua_pushliteral(L,"groups");
  lua_gettable(L,3);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc24 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc24) {
    
    /* paramnode.groups = {} */
    lua_newtable(L);
    lua_pushliteral(L,"groups");
    lua_insert(L,-2);
    lua_settable(L,3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc23);
  assert(lua_gettop(L) == 3);
  
  /* paramnode.groups.season = 1 */
  lua_pushnumber(L,1);
  lua_pushliteral(L,"groups");
  lua_gettable(L,3);
  lua_insert(L,-2);
  lua_pushliteral(L,"season");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* minetest.register_node(":"..nodename, paramnode) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,":");
  lua_pushvalue(L,1);
  lua_concat(L,2);
  lua_pushvalue(L,3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(pos) */
static int lcf41 (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local meta = minetest.get_meta(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_meta");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* local node = minetest.deserialize(meta:get_string("old_node")) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"deserialize");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc28 = lua_gettop(L);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get_string");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"old_node");
  lua_call(L,2,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc28),1);
  assert(lua_gettop(L) == 3);
  
  /* if not node then */
  enum { lc29 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc30 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc30) {
    
    /* minetest.dig_node(pos) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"dig_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc29);
  assert(lua_gettop(L) == 3);
  
  /* local superparams = winterblock[node.name] */
  lua_getfield(L,LUA_ENVIRONINDEX,"winterblock");
  lua_pushliteral(L,"name");
  lua_gettable(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* for num, params in pairs(superparams) do
   * internal: local f, s, var = explist */
  enum { lc31 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushvalue(L,4);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local num with idx 8
     * internal: local params with idx 9 */
    
    
    /* local time = math.mod(params.stop - params.start + 12, 12) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"mod");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"stop");
    lua_gettable(L,9);
    lua_pushliteral(L,"start");
    lua_gettable(L,9);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,12);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,12);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 10);
    
    /* local season = math.mod(minetest.get_gametime(), 14400) / 1200 */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"mod");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_gametime");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushnumber(L,14400);
    lua_call(L,2,1);
    lua_pushnumber(L,1200);
    lc_div(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 11);
    
    /* if math.random() * 100 < params.speed and math.mod(season - params.start + 12, 12) < time then */
    enum { lc32 = 11 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushnumber(L,100);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"speed");
    lua_gettable(L,9);
    const int lc33 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc33);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"mod");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"start");
      lua_gettable(L,9);
      lc_sub(L,11,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,12);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,12);
      lua_call(L,2,1);
      const int lc34 = lua_lessthan(L,-1,10);
      lua_pop(L,1);
      lua_pushboolean(L,lc34);
    }
    const int lc35 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc35) {
      
      /* if minetest.get_node({x = pos.x, y = pos.y - 1, z = pos.z}).name ~= "air" then */
      enum { lc36 = 11 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_call(L,1,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"air");
      const int lc37 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc37);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc38 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc38) {
        
        /* if params.new_node then */
        enum { lc39 = 11 };
        lua_pushliteral(L,"new_node");
        lua_gettable(L,9);
        const int lc40 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc40) {
          
          /* minetest.set_node(pos, params.new_node) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_pushliteral(L,"new_node");
          lua_gettable(L,9);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 11);
          
          /* print("[forest] "..node.name.." reappear as "..params.new_node.name.." at "..minetest.pos_to_string(pos)) */
          lua_getfield(L,LUA_ENVIRONINDEX,"print");
          lua_pushliteral(L,"[forest] ");
          lua_pushliteral(L,"name");
          lua_gettable(L,3);
          lua_pushliteral(L," reappear as ");
          lua_pushliteral(L,"new_node");
          lua_gettable(L,9);
          lua_pushliteral(L,"name");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L," at ");
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"pos_to_string");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 11);
        }
        else {
          
          /* else
           * minetest.set_node(pos, node) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_pushvalue(L,3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 11);
          
          /* print("[forest] "..node.name.." reappear at "..minetest.pos_to_string(pos)) */
          lua_getfield(L,LUA_ENVIRONINDEX,"print");
          lua_pushliteral(L,"[forest] ");
          lua_pushliteral(L,"name");
          lua_gettable(L,3);
          lua_pushliteral(L," reappear at ");
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"pos_to_string");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L,lc39);
        assert(lua_gettop(L) == 11);
      }
      else {
        
        /* else
         * minetest.dig_node(pos) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"dig_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L,lc36);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc32);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
  }
  lua_settop(L,lc31);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* function(pos, node) */
static int lcf59 (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local superparams = seasons[node.name] */
  lua_getfield(L,LUA_ENVIRONINDEX,"seasons");
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* for num, params in pairs(superparams) do
   * internal: local f, s, var = explist */
  enum { lc42 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local num with idx 7
     * internal: local params with idx 8 */
    
    
    /* if math.random() * 100 < params.speed then */
    enum { lc43 = 8 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_pushnumber(L,100);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"speed");
    lua_gettable(L,8);
    const int lc44 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc44);
    const int lc45 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc45) {
      
      /* local time = math.mod(params.stop - params.start + 12, 12) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"mod");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"stop");
      lua_gettable(L,8);
      lua_pushliteral(L,"start");
      lua_gettable(L,8);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,12);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,12);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 9);
      
      /* local season = math.mod(minetest.get_gametime(), 14400) / 1200 */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"mod");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_gametime");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,1);
      lua_pushnumber(L,14400);
      lua_call(L,2,1);
      lua_pushnumber(L,1200);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 10);
      
      /* if math.mod(season - params.start + 12, 12) < time then */
      enum { lc46 = 10 };
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"mod");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"start");
      lua_gettable(L,8);
      lc_sub(L,10,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,12);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,12);
      lua_call(L,2,1);
      const int lc47 = lua_lessthan(L,-1,9);
      lua_pop(L,1);
      lua_pushboolean(L,lc47);
      const int lc48 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc48) {
        
        /* if params.type == "disappear" then */
        enum { lc49 = 10 };
        lua_pushliteral(L,"type");
        lua_gettable(L,8);
        lua_pushliteral(L,"disappear");
        const int lc50 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc50);
        const int lc51 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc51) {
          
          /* minetest.set_node(pos, {name = "forest:winterblock"}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"set_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"forest:winterblock");
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 10);
          
          /* print("[forest] "..node.name.." disappears at "..minetest.pos_to_string(pos)) */
          lua_getfield(L,LUA_ENVIRONINDEX,"print");
          lua_pushliteral(L,"[forest] ");
          lua_pushliteral(L,"name");
          lua_gettable(L,2);
          lua_pushliteral(L," disappears at ");
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"pos_to_string");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 10);
          
          /* local meta = minetest.get_meta(pos) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_meta");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,1);
          assert(lua_gettop(L) == 11);
          
          /* -- memorize the old node
           * if params.new_node then */
          enum { lc52 = 11 };
          lua_pushliteral(L,"new_node");
          lua_gettable(L,8);
          const int lc53 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc53) {
            
            /* meta:set_string("old_node", minetest.serialize(params.new_node)) */
            lua_pushvalue(L,11);
            const int lc54 = lua_gettop(L);
            lua_pushliteral(L,"set_string");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushliteral(L,"old_node");
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"serialize");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"new_node");
            lua_gettable(L,8);
            lua_call(L,1,LUA_MULTRET);
            lua_call(L,(lua_gettop(L) - lc54),0);
            assert(lua_gettop(L) == 11);
          }
          else {
            
            /* else
             * meta:set_string("old_node", minetest.serialize(node)) */
            lua_pushvalue(L,11);
            const int lc55 = lua_gettop(L);
            lua_pushliteral(L,"set_string");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushliteral(L,"old_node");
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"serialize");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,2);
            lua_call(L,1,LUA_MULTRET);
            lua_call(L,(lua_gettop(L) - lc55),0);
            assert(lua_gettop(L) == 11);
          }
          lua_settop(L,lc52);
          assert(lua_gettop(L) == 11);
        }
        else {
          
          /* elseif params.type == "transforms" then */
          enum { lc56 = 10 };
          lua_pushliteral(L,"type");
          lua_gettable(L,8);
          lua_pushliteral(L,"transforms");
          const int lc57 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc57);
          const int lc58 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc58) {
            
            /* minetest.set_node(pos, params.new_node) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"set_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_pushliteral(L,"new_node");
            lua_gettable(L,8);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 10);
            
            /* print("[forest] "..node.name.." turn into "..params.new_node.name.." at "..minetest.pos_to_string(pos)) */
            lua_getfield(L,LUA_ENVIRONINDEX,"print");
            lua_pushliteral(L,"[forest] ");
            lua_pushliteral(L,"name");
            lua_gettable(L,2);
            lua_pushliteral(L," turn into ");
            lua_pushliteral(L,"new_node");
            lua_gettable(L,8);
            lua_pushliteral(L,"name");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L," at ");
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"pos_to_string");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_call(L,1,1);
            lua_concat(L,2);
            lua_concat(L,2);
            lua_concat(L,2);
            lua_concat(L,2);
            lua_concat(L,2);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 10);
          }
          lua_settop(L,lc56);
        }
        lua_settop(L,lc49);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc46);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc43);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc42);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: register_ore
 * function(def) */
static int lcf1_register_ore (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* num_ore = num_ore + 1 */
  lua_getfield(L,LUA_ENVIRONINDEX,"num_ore");
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_setfield(L,LUA_ENVIRONINDEX,"num_ore");
  assert(lua_gettop(L) == 1);
  
  /* ores[num_ore] = def */
  lua_pushvalue(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ores");
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"num_ore");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(pos) */
static int lcf66 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if get_instant_temperature(pos) + math.random() < 8 then */
  enum { lc63 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"get_instant_temperature");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  const int lc64 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc64);
  const int lc65 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc65) {
    
    /* minetest.set_node(pos, {name = "default:dirt_with_snow"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:dirt_with_snow");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* else
     * minetest.set_node(pos, {name = "default:dirt_with_grass"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc63);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(pos) */
static int lcf70 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if get_instant_temperature(pos) + math.random() < 8 then */
  enum { lc67 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"get_instant_temperature");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  const int lc68 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc68);
  const int lc69 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc69) {
    
    /* minetest.set_node(pos, {name = "default:ice"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:ice");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* else
     * minetest.set_node(pos, {name = "default:water_source"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:water_source");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc67);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(pos) */
static int lcf74 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if get_instant_temperature(pos) + math.random() < 8 then */
  enum { lc71 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"get_instant_temperature");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  const int lc72 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc72);
  const int lc73 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc73) {
    
    /* minetest.set_node(pos, {name = "forest:mud_ice"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"forest:mud_ice");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* else
     * minetest.set_node(pos, {name = "forest:mud_source"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"forest:mud_source");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc71);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(pos) */
static int lcf78 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* pos.y = pos.y - 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* if minetest.get_node(pos).name == "air" then */
  enum { lc75 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  const int lc76 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc76);
  const int lc77 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc77) {
    
    /* pos.y = pos.y + 1 */
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 1);
    
    /* minetest.dig_node(pos) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"dig_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc75);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* function(pos) */
static int lcf79 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* clockblock(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"clockblock");
  lua_pushvalue(L,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: clockblock
 * function(pos) */
static int lcf1_clockblock (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local season = math.floor(math.mod(minetest.get_gametime() + 600 - minetest.get_timeofday() * 1200, 14400) / 1200) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"mod");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_gametime");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,600);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_timeofday");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,1200);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,14400);
  lua_call(L,2,1);
  lua_pushnumber(L,1200);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* local month = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 3);
  
  /* if season == 0 then */
  enum { lc80 = 3 };
  lua_pushnumber(L,0);
  const int lc81 = lua_equal(L,2,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc81);
  const int lc82 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc82) {
    
    /* month = "Janvier" */
    lua_pushliteral(L,"Janvier");
    lua_replace(L,3);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* elseif season == 1 then */
    enum { lc83 = 3 };
    lua_pushnumber(L,1);
    const int lc84 = lua_equal(L,2,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc84);
    const int lc85 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc85) {
      
      /* month = "Fevrier" */
      lua_pushliteral(L,"Fevrier");
      lua_replace(L,3);
      assert(lua_gettop(L) == 3);
    }
    else {
      
      /* elseif season == 2 then */
      enum { lc86 = 3 };
      lua_pushnumber(L,2);
      const int lc87 = lua_equal(L,2,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc87);
      const int lc88 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc88) {
        
        /* month = "Mars" */
        lua_pushliteral(L,"Mars");
        lua_replace(L,3);
        assert(lua_gettop(L) == 3);
      }
      else {
        
        /* elseif season == 3 then */
        enum { lc89 = 3 };
        lua_pushnumber(L,3);
        const int lc90 = lua_equal(L,2,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc90);
        const int lc91 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc91) {
          
          /* month = "Avril" */
          lua_pushliteral(L,"Avril");
          lua_replace(L,3);
          assert(lua_gettop(L) == 3);
        }
        else {
          
          /* elseif season == 4 then */
          enum { lc92 = 3 };
          lua_pushnumber(L,4);
          const int lc93 = lua_equal(L,2,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc93);
          const int lc94 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc94) {
            
            /* month = "Mai" */
            lua_pushliteral(L,"Mai");
            lua_replace(L,3);
            assert(lua_gettop(L) == 3);
          }
          else {
            
            /* elseif season == 5 then */
            enum { lc95 = 3 };
            lua_pushnumber(L,5);
            const int lc96 = lua_equal(L,2,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc96);
            const int lc97 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc97) {
              
              /* month = "Juin" */
              lua_pushliteral(L,"Juin");
              lua_replace(L,3);
              assert(lua_gettop(L) == 3);
            }
            else {
              
              /* elseif season == 6 then */
              enum { lc98 = 3 };
              lua_pushnumber(L,6);
              const int lc99 = lua_equal(L,2,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc99);
              const int lc100 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc100) {
                
                /* month = "Juillet" */
                lua_pushliteral(L,"Juillet");
                lua_replace(L,3);
                assert(lua_gettop(L) == 3);
              }
              else {
                
                /* elseif season == 7 then */
                enum { lc101 = 3 };
                lua_pushnumber(L,7);
                const int lc102 = lua_equal(L,2,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc102);
                const int lc103 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc103) {
                  
                  /* month = "Aout" */
                  lua_pushliteral(L,"Aout");
                  lua_replace(L,3);
                  assert(lua_gettop(L) == 3);
                }
                else {
                  
                  /* elseif season == 8 then */
                  enum { lc104 = 3 };
                  lua_pushnumber(L,8);
                  const int lc105 = lua_equal(L,2,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc105);
                  const int lc106 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc106) {
                    
                    /* month = "Septembre" */
                    lua_pushliteral(L,"Septembre");
                    lua_replace(L,3);
                    assert(lua_gettop(L) == 3);
                  }
                  else {
                    
                    /* elseif season == 9 then */
                    enum { lc107 = 3 };
                    lua_pushnumber(L,9);
                    const int lc108 = lua_equal(L,2,-1);
                    lua_pop(L,1);
                    lua_pushboolean(L,lc108);
                    const int lc109 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc109) {
                      
                      /* month = "Octobre" */
                      lua_pushliteral(L,"Octobre");
                      lua_replace(L,3);
                      assert(lua_gettop(L) == 3);
                    }
                    else {
                      
                      /* elseif season == 10 then */
                      enum { lc110 = 3 };
                      lua_pushnumber(L,10);
                      const int lc111 = lua_equal(L,2,-1);
                      lua_pop(L,1);
                      lua_pushboolean(L,lc111);
                      const int lc112 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc112) {
                        
                        /* month = "Novembre" */
                        lua_pushliteral(L,"Novembre");
                        lua_replace(L,3);
                        assert(lua_gettop(L) == 3);
                      }
                      else {
                        
                        /* elseif season == 11 then */
                        enum { lc113 = 3 };
                        lua_pushnumber(L,11);
                        const int lc114 = lua_equal(L,2,-1);
                        lua_pop(L,1);
                        lua_pushboolean(L,lc114);
                        const int lc115 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc115) {
                          
                          /* month = "Decembre" */
                          lua_pushliteral(L,"Decembre");
                          lua_replace(L,3);
                          assert(lua_gettop(L) == 3);
                        }
                        lua_settop(L,lc113);
                      }
                      lua_settop(L,lc110);
                    }
                    lua_settop(L,lc107);
                  }
                  lua_settop(L,lc104);
                }
                lua_settop(L,lc101);
              }
              lua_settop(L,lc98);
            }
            lua_settop(L,lc95);
          }
          lua_settop(L,lc92);
        }
        lua_settop(L,lc89);
      }
      lua_settop(L,lc86);
    }
    lua_settop(L,lc83);
  }
  lua_settop(L,lc80);
  assert(lua_gettop(L) == 3);
  
  /* local year = math.floor((minetest.get_gametime() + 600 - minetest.get_timeofday() * 1200) / 14400) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_gametime");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,600);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_timeofday");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,1200);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,14400);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* local time = math.floor(minetest.get_timeofday() * 1440) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_timeofday");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,1440);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* local hour = math.floor(time / 60) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,60);
  lc_div(L,5,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* local minute = math.mod(time, 60) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"mod");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_pushnumber(L,60);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 7);
  
  /* local meta = minetest.get_meta(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_meta");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* local separator = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 9);
  
  /* if minute < 10 then */
  enum { lc116 = 9 };
  lua_pushnumber(L,10);
  const int lc117 = lua_lessthan(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc117);
  const int lc118 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc118) {
    
    /* separator = ":0" */
    lua_pushliteral(L,":0");
    lua_replace(L,9);
    assert(lua_gettop(L) == 9);
  }
  else {
    
    /* else
     * separator = ":" */
    lua_pushliteral(L,":");
    lua_replace(L,9);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc116);
  assert(lua_gettop(L) == 9);
  
  /* meta:set_string("infotext", month.." "..year..", "..hour..separator..minute) */
  lua_pushvalue(L,8);
  lua_pushliteral(L,"set_string");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"infotext");
  lua_pushvalue(L,3);
  lua_pushliteral(L," ");
  lua_pushvalue(L,4);
  lua_pushliteral(L,", ");
  lua_pushvalue(L,6);
  lua_pushvalue(L,9);
  lua_pushvalue(L,7);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 9);
  return 0;
}


/* function(pos) */
static int lcf122 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* clockblock(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"clockblock");
  lua_pushvalue(L,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* trees = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"trees");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* apportionment = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"apportionment");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* ores = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"ores");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* seasons = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"seasons");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* winterblock = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"winterblock");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* num_ore = 0 */
  lua_pushnumber(L,0);
  lua_setfield(L,LUA_ENVIRONINDEX,"num_ore");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function distance(pos1, pos2)
   * 	return math.sqrt((pos1.x - pos2.x) ^ 2 + (pos1.y - pos2.y) ^ 2 + (pos1.z - pos2.z) ^ 2)
   * end */
  lua_pushcfunction(L,lcf1_distance);
  lua_setfield(L,LUA_ENVIRONINDEX,"distance");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function get_instant_temperature(pos)
   * 	local temperature = minetest.get_perlin(554, 3, 0.6, 40)
   * 	local season = - math.cos(math.rad(math.mod(minetest.get_gametime(), 14400) / 40)) * 5
   * 	local time = - math.cos(math.rad(minetest.get_timeofday() * 360 - 45)) * 2
   * 	local value = temperature:get3d(pos) * 4 - pos.y * 0.16 + 16 + season + time
   * 	if value < 0 then
   * 		value = 0
   * 	elseif value > 20 then
   * 		value = 20
   * 	end
   * 	return value
   * end */
  lua_pushcfunction(L,lcf1_get_instant_temperature);
  lua_setfield(L,LUA_ENVIRONINDEX,"get_instant_temperature");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function get_average_temperature(pos)
   * 	local temperature = minetest.get_perlin(554, 3, 0.6, 40)
   * 	local season = minetest.get_gametime()
   * 	local value = temperature:get3d(pos) * 4 - pos.y * 0.16 + 16
   * 	if value < 0 then
   * 		value = 0
   * 	elseif value > 20 then
   * 		value = 20
   * 	end
   * 	return value
   * end */
  lua_pushcfunction(L,lcf1_get_average_temperature);
  lua_setfield(L,LUA_ENVIRONINDEX,"get_average_temperature");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function register_season(nodename, params)
   * 		-- the season params are from 1.00 (early January) to 12.99 (end of December). Convert it into number like this : 0 ≥ n > 12.
   * 	params.start = params.start - 1
   * 	params.stop = params.stop - 1
   * 	if params.type == "appear" then
   * 		if not winterblock[nodename] then
   * 			winterblock[nodename] = {}
   * 		end
   * 		table.insert(winterblock[nodename], params)
   * 	else
   * 		if not seasons[nodename] then
   * 			seasons[nodename] = {}
   * 		end
   * 		table.insert(seasons[nodename], params)
   * 	end
   * 	local paramnode = minetest.registered_nodes[nodename]
   * 		-- set the group "season"
   * 	if not paramnode.groups then
   * 		paramnode.groups = {}
   * 	end
   * 	paramnode.groups.season = 1
   * 	minetest.register_node(":"..nodename, paramnode)
   * end */
  lua_pushcfunction(L,lcf1_register_season);
  lua_setfield(L,LUA_ENVIRONINDEX,"register_season");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* if enable_forests == "true" then */
  enum { lc25 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"enable_forests");
  lua_pushliteral(L,"true");
  const int lc26 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc26);
  const int lc27 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc27) {
    
    /* minetest.register_node("forest:winterblock", {
     * 		description = "Bloc hiver",
     * 		drawtype = "airlike",
     * 		is_ground_content = true,
     * 		groups = {not_in_creative_inventory = 1},
     * 		paramtype = "light",
     * 		sunlight_propagates = true,
     * 		buildable_to = true,
     * 		pointable = false,
     * 		walkable = false,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"forest:winterblock");
    lua_createtable(L,0,9);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Bloc hiver");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"airlike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,1);
    lua_pushliteral(L,"not_in_creative_inventory");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"sunlight_propagates");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"buildable_to");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"pointable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_abm({
     * 		nodenames = {"forest:winterblock"},
     * 		interval = 60,
     * 		chance = 1,
     * 		action = function(pos)
     * 			local meta = minetest.get_meta(pos)
     * 			local node = minetest.deserialize(meta:get_string("old_node"))
     * 			if not node then
     * 				minetest.dig_node(pos)
     * 				return
     * 			end
     * 			local superparams = winterblock[node.name]
     * 			for num, params in pairs(superparams) do
     * 				local time = math.mod(params.stop - params.start + 12, 12)
     * 				local season = math.mod(minetest.get_gametime(), 14400) / 1200
     * 				if math.random() * 100 < params.speed and math.mod(season - params.start + 12, 12) < time then
     * 					if minetest.get_node({x = pos.x, y = pos.y - 1, z = pos.z}).name ~= "air" then
     * 						if params.new_node then
     * 							minetest.set_node(pos, params.new_node)
     * 							print("[forest] "..node.name.." reappear as "..params.new_node.name.." at "..minetest.pos_to_string(pos))
     * 						else
     * 							minetest.set_node(pos, node)
     * 							print("[forest] "..node.name.." reappear at "..minetest.pos_to_string(pos))
     * 						end
     * 					else
     * 						minetest.dig_node(pos)
     * 					end
     * 				end
     * 			end
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"forest:winterblock");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,60);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf41);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_abm({
     * 		nodenames = {"group:season"},
     * 		interval = 60,
     * 		chance = 1,
     * 		action = function(pos, node)
     * 			local superparams = seasons[node.name]
     * 			for num, params in pairs(superparams) do
     * 				if math.random() * 100 < params.speed then
     * 					local time = math.mod(params.stop - params.start + 12, 12)
     * 					local season = math.mod(minetest.get_gametime(), 14400) / 1200
     * 					if math.mod(season - params.start + 12, 12) < time then
     * 						if params.type == "disappear" then
     * 							minetest.set_node(pos, {name = "forest:winterblock"})
     * 							print("[forest] "..node.name.." disappears at "..minetest.pos_to_string(pos))
     * 							local meta = minetest.get_meta(pos)
     * 								-- memorize the old node
     * 							if params.new_node then
     * 								meta:set_string("old_node", minetest.serialize(params.new_node))
     * 							else
     * 								meta:set_string("old_node", minetest.serialize(node))
     * 							end
     * 						elseif params.type == "transforms" then
     * 							minetest.set_node(pos, params.new_node)
     * 							print("[forest] "..node.name.." turn into "..params.new_node.name.." at "..minetest.pos_to_string(pos))
     * 						end
     * 					end
     * 				end
     * 			end
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"group:season");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,60);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf59);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc25 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function register_ore(def)
   * 	num_ore = num_ore + 1
   * 	ores[num_ore] = def
   * end */
  lua_pushcfunction(L,lcf1_register_ore);
  lua_setfield(L,LUA_ENVIRONINDEX,"register_ore");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* dofile(minetest.get_modpath("forest").."/tree_growing.lua") */
  lc_pmain_mod_forest_tree_growing(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/tree_growing.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/register_tree.lua") */
  lc_pmain_mod_forest_register_tree(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/register_tree.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/fir.lua") */
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/fir.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* dofile(minetest.get_modpath("forest").."/trees.lua") */
  lc_pmain_mod_forest_trees(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/trees.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/mud.lua") */
  lc_pmain_mod_forest_mud(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/mud.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/oil.lua") */
  lc_pmain_mod_forest_oil(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/oil.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/ores.lua") */
  lc_pmain_mod_forest_ores(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/ores.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/mapgen.lua") */
  lc_pmain_mod_forest_mapgen(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/mapgen.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/thermometer.lua") */
  lc_pmain_mod_forest_thermometer(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/thermometer.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(minetest.get_modpath("forest").."/seasons.lua") */
  lc_pmain_mod_forest_seasons(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  lua_pushliteral(L,"/seasons.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* if enable_forests == "true" then */
  enum { lc60 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"enable_forests");
  lua_pushliteral(L,"true");
  const int lc61 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc61);
  const int lc62 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc62) {
    
    /* minetest.register_abm({
     * 		nodenames = {"default:dirt_with_grass", "default:dirt_with_snow"},
     * 		interval = 20,
     * 		chance = 3,
     * 		action = function(pos)
     * 			if get_instant_temperature(pos) + math.random() < 8 then
     * 				minetest.set_node(pos, {name = "default:dirt_with_snow"})
     * 			else
     * 				minetest.set_node(pos, {name = "default:dirt_with_grass"})
     * 			end
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:dirt_with_snow");
    lua_rawseti(L,-2,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,20);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf66);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_abm({
     * 		nodenames = {"default:water_source", "default:ice"},
     * 		interval = 20,
     * 		chance = 3,
     * 		action = function(pos)
     * 			if get_instant_temperature(pos) + math.random() < 8 then
     * 				minetest.set_node(pos, {name = "default:ice"})
     * 			else
     * 				minetest.set_node(pos, {name = "default:water_source"})
     * 			end
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:water_source");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:ice");
    lua_rawseti(L,-2,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,20);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf70);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_abm({
     * 		nodenames = {"forest:mud_source", "forest:mud_ice"},
     * 		interval = 20,
     * 		chance = 3,
     * 		action = function(pos)
     * 			if get_instant_temperature(pos) + math.random() < 8 then
     * 				minetest.set_node(pos, {name = "forest:mud_ice"})
     * 			else
     * 				minetest.set_node(pos, {name = "forest:mud_source"})
     * 			end
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,2,0);
    lua_pushliteral(L,"forest:mud_source");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:mud_ice");
    lua_rawseti(L,-2,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,20);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf74);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* -- I DETEST floating trees !
     * minetest.register_abm({
     * 		nodenames = {"group:tree"},
     * 		interval = 10,
     * 		chance = 1,
     * 		action = function(pos)
     * 		pos.y = pos.y - 1
     * 			if minetest.get_node(pos).name == "air" then
     * 				pos.y = pos.y + 1
     * 				minetest.dig_node(pos)
     * 			end
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"group:tree");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,10);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf78);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_node(":default:ice", {
     * 		description = "Ice",
     * 		drawtype = "glasslike",
     * 		tiles = {"new_ice.png"},
     * 		inventory_image = minetest.inventorycube("default_ice.png"),
     * 		is_ground_content = true,
     * 		paramtype = "light",
     * 		freezemelt = "default:water_source",
     * 		groups = {cracky=3, melts=1},
     * 		sounds = default.node_sound_glass_defaults(),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,":default:ice");
    lua_createtable(L,0,9);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Ice");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"glasslike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"new_ice.png");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"inventorycube");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default_ice.png");
    lua_call(L,1,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"freezemelt");
    lua_pushliteral(L,"default:water_source");
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"cracky");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"melts");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_glass_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_node("forest:_clock", {
     * 		description = "Clock",
     * 		tiles = {"clock.png","default_wood.png","default_wood.png","default_wood.png","default_wood.png","default_wood.png"},
     * 		is_ground_content = true,
     * 		paramtype = "light",
     * 		groups = {dig_immediate=2},
     * 		on_construct = function(pos)
     * 			clockblock(pos)
     * 		end,
     * 		on_place = minetest.rotate_node
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"forest:_clock");
    lua_createtable(L,0,7);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Clock");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,6,0);
    lua_pushliteral(L,"clock.png");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default_wood.png");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default_wood.png");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"default_wood.png");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"default_wood.png");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"default_wood.png");
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,1);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"on_construct");
    lua_pushcfunction(L,lcf79);
    lua_rawset(L,-3);
    lua_pushliteral(L,"on_place");
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"rotate_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc60 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function clockblock(pos)
   * 	local season = math.floor(math.mod(minetest.get_gametime() + 600 - minetest.get_timeofday() * 1200, 14400) / 1200)
   * 	local month = nil
   * 	if season == 0 then
   * 		month = "Janvier"
   * 	elseif season == 1 then
   * 		month = "Fevrier"
   * 	elseif season == 2 then
   * 		month = "Mars"
   * 	elseif season == 3 then
   * 		month = "Avril"
   * 	elseif season == 4 then
   * 		month = "Mai"
   * 	elseif season == 5 then
   * 		month = "Juin"
   * 	elseif season == 6 then
   * 		month = "Juillet"
   * 	elseif season == 7 then
   * 		month = "Aout"
   * 	elseif season == 8 then
   * 		month = "Septembre"
   * 	elseif season == 9 then
   * 		month = "Octobre"
   * 	elseif season == 10 then
   * 		month = "Novembre"
   * 	elseif season == 11 then
   * 		month = "Decembre"
   * 	end
   * 	local year = math.floor((minetest.get_gametime() + 600 - minetest.get_timeofday() * 1200) / 14400)
   * 	local time = math.floor(minetest.get_timeofday() * 1440)
   * 	local hour = math.floor(time / 60)
   * 	local minute = math.mod(time, 60)
   * 	local meta = minetest.get_meta(pos)
   * 	local separator = nil
   * 	if minute < 10 then
   * 		separator = ":0"
   * 	else
   * 		separator = ":"
   * 	end
   * 	meta:set_string("infotext", month.." "..year..", "..hour..separator..minute)
   * end */
  lua_pushcfunction(L,lcf1_clockblock);
  lua_setfield(L,LUA_ENVIRONINDEX,"clockblock");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* if enable_forests == "true" then */
  enum { lc119 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"enable_forests");
  lua_pushliteral(L,"true");
  const int lc120 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc120);
  const int lc121 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc121) {
    
    /* minetest.register_abm({
     * 		nodenames = {"forest:_clock"},
     * 		interval = 2,
     * 		chance = 1,
     * 		action = function(pos)
     * 			clockblock(pos)
     * 		end,
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,4);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"forest:_clock");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf122);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'forest:_clock',
     * 		recipe = {
     * 			{'group:wood', 'group:stick', 'group:wood'},
     * 			{'group:wood', 'default:mese_crystal', 'group:stick'},
     * 			{'group:wood', 'group:wood', 'group:wood'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"forest:_clock");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,3,0);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"group:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"group:stick");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"group:wood");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"group:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:mese_crystal");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"group:stick");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"group:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"group:wood");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"group:wood");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'dye:black',
     * 		recipe = {
     * 			{'default:coal_lump'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"dye:black");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,1,0);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:coal_lump");
    lua_rawseti(L,-2,1);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_node("forest:sand_way", {
     * 		description = "Sand heap",
     * 		drawtype = "raillike",
     * 		tiles = {"sand_way.png", "sand_way_curved.png", "sand_way_t_junction.png", "sand_way_crossing.png"},
     * 		inventory_image = "sand_heap.png",
     * 		wield_image = "sand_heap.png",
     * 		paramtype = "light",
     * 		walkable = false,
     * 		is_ground_content = false,
     * 		selection_box = {
     * 			type = "fixed",
     * 					fixed = {-1/2, -1/2, -1/2, 1/2, -1/2+1/16, 1/2},
     * 		},
     * 		groups = {dig_immediate=3,way=1},
     * 		sounds = default.node_sound_sand_defaults(),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"forest:sand_way");
    lua_createtable(L,0,11);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Sand heap");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"raillike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,4,0);
    lua_pushliteral(L,"sand_way.png");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"sand_way_curved.png");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"sand_way_t_junction.png");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"sand_way_crossing.png");
    lua_rawseti(L,-2,4);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lua_pushliteral(L,"sand_heap.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wield_image");
    lua_pushliteral(L,"sand_heap.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"selection_box");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"fixed");
    lua_rawset(L,-3);
    lua_pushliteral(L,"fixed");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,-0.4375);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"way");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_sand_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_node("forest:gravel_way", {
     * 		description = "Gravel heap",
     * 		drawtype = "raillike",
     * 		tiles = {"gravel_way.png", "gravel_way_curved.png", "gravel_way_t_junction.png", "gravel_way_crossing.png"},
     * 		inventory_image = "gravel_heap.png",
     * 		wield_image = "gravel_heap.png",
     * 		paramtype = "light",
     * 		walkable = false,
     * 		is_ground_content = false,
     * 		selection_box = {
     * 			type = "fixed",
     * 					fixed = {-1/2, -1/2, -1/2, 1/2, -1/2+1/16, 1/2},
     * 		},
     * 		groups = {dig_immediate=3,way=1},
     * 		sounds = default.node_sound_sand_defaults(),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"forest:gravel_way");
    lua_createtable(L,0,11);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Gravel heap");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"raillike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,4,0);
    lua_pushliteral(L,"gravel_way.png");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"gravel_way_curved.png");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"gravel_way_t_junction.png");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"gravel_way_crossing.png");
    lua_rawseti(L,-2,4);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lua_pushliteral(L,"gravel_heap.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wield_image");
    lua_pushliteral(L,"gravel_heap.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"selection_box");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"fixed");
    lua_rawset(L,-3);
    lua_pushliteral(L,"fixed");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,-0.4375);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"way");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_sand_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_node("forest:desert_sand_way", {
     * 		description = "Desert sand heap",
     * 		drawtype = "raillike",
     * 		tiles = {"desert_sand_way.png", "desert_sand_way_curved.png", "desert_sand_way_t_junction.png", "desert_sand_way_crossing.png"},
     * 		inventory_image = "desert_sand_heap.png",
     * 		wield_image = "desert_sand_heap.png",
     * 		paramtype = "light",
     * 		walkable = false,
     * 		is_ground_content = false,
     * 		selection_box = {
     * 			type = "fixed",
     * 					fixed = {-1/2, -1/2, -1/2, 1/2, -1/2+1/16, 1/2},
     * 		},
     * 		groups = {dig_immediate=3,way=1},
     * 		sounds = default.node_sound_dirt_defaults({
     * 			footstep = {name="default_gravel_footstep", gain=0.5},
     * 			dug = {name="default_gravel_footstep", gain=1.0},
     * 		}),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_createtable(L,0,11);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Desert sand heap");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"raillike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,4,0);
    lua_pushliteral(L,"desert_sand_way.png");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"desert_sand_way_curved.png");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"desert_sand_way_t_junction.png");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"desert_sand_way_crossing.png");
    lua_rawseti(L,-2,4);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lua_pushliteral(L,"desert_sand_heap.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wield_image");
    lua_pushliteral(L,"desert_sand_heap.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"selection_box");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"fixed");
    lua_rawset(L,-3);
    lua_pushliteral(L,"fixed");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,-0.4375);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"way");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_dirt_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"footstep");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default_gravel_footstep");
    lua_rawset(L,-3);
    lua_pushliteral(L,"gain");
    lua_pushnumber(L,0.5);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"dug");
    lua_createtable(L,0,2);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default_gravel_footstep");
    lua_rawset(L,-3);
    lua_pushliteral(L,"gain");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'forest:sand_way 9',
     * 		recipe = {
     * 			{'default:sand'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"forest:sand_way 9");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,1,0);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:sand");
    lua_rawseti(L,-2,1);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'forest:gravel_way 9',
     * 		recipe = {
     * 			{'default:gravel'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"forest:gravel_way 9");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,1,0);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:gravel");
    lua_rawseti(L,-2,1);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'forest:desert_sand_way 9',
     * 		recipe = {
     * 			{'default:desert_sand'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"forest:desert_sand_way 9");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,1,0);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:desert_sand");
    lua_rawseti(L,-2,1);
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'default:sand',
     * 		recipe = {
     * 			{'forest:sand_way', 'forest:sand_way', 'forest:sand_way'},
     * 			{'forest:sand_way', 'forest:sand_way', 'forest:sand_way'},
     * 			{'forest:sand_way', 'forest:sand_way', 'forest:sand_way'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"default:sand");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,3,0);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:sand_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'default:gravel',
     * 		recipe = {
     * 			{'forest:gravel_way', 'forest:gravel_way', 'forest:gravel_way'},
     * 			{'forest:gravel_way', 'forest:gravel_way', 'forest:gravel_way'},
     * 			{'forest:gravel_way', 'forest:gravel_way', 'forest:gravel_way'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"default:gravel");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,3,0);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:gravel_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'default:desert_sand',
     * 		recipe = {
     * 			{'forest:desert_sand_way', 'forest:desert_sand_way', 'forest:desert_sand_way'},
     * 			{'forest:desert_sand_way', 'forest:desert_sand_way', 'forest:desert_sand_way'},
     * 			{'forest:desert_sand_way', 'forest:desert_sand_way', 'forest:desert_sand_way'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"default:desert_sand");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,3,0);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"forest:desert_sand_way");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 			output = "moreblocks:circular_saw 1", 
     * 			recipe = {
     * 					{ "",  "default:steel_ingot",  "" },
     * 					{ "group:tree",  "group:tree",  "group:tree"},
     * 					{ "group:tree",  "",  "group:tree"},
     * 			}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"moreblocks:circular_saw 1");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,3,0);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:steel_ingot");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"group:tree");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"group:tree");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"group:tree");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"group:tree");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"group:tree");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* minetest.register_craft({
     * 		output = 'default:mese_crystal',
     * 		recipe = {
     * 			{'default:mese_crystal_fragment', 'default:mese_crystal_fragment', 'default:mese_crystal_fragment'},
     * 			{'default:mese_crystal_fragment', 'default:mese_crystal_fragment', 'default:mese_crystal_fragment'},
     * 			{'default:mese_crystal_fragment', 'default:mese_crystal_fragment', 'default:mese_crystal_fragment'},
     * 		}
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"default:mese_crystal");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,3,0);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:mese_crystal_fragment");
    lua_rawseti(L,-2,3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc119 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_forest_init(lua_State * L) {
	  luaL_openlibs(L);

	  lua_pushcfunction(L, traceback);

	  const int status1 = lc_handle_luainit(L);
	  if (status1 != 0) return 0;

	  /* note: IMPROVE: closure not always needed here */
	  lua_newtable(L); /* closure table */
	  lua_pushcclosure(L, lcf_main, 1);

	  int status2 = lua_pcall(L, 0, 0, -2);
	  if (status2 != 0) {
	    const char * msg = lua_tostring(L,-1);
	    if (msg == NULL) msg = "(error object is not a string)";
	    fputs(msg, stderr);
	  }
	  return 0;
	}
