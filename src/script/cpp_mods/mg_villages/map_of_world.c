/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: mg_villages.draw_tile
 * function( content_id, image, x, z, dx, dz, tile_nr) */
static int lcf1_mg_villages_draw_tile (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* if( not( image )) then */
  enum { lc1 = 7 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* local node_name = minetest.get_name_from_content_id( content_id ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_name_from_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 8);
    
    /* if( not( node_name )) then */
    enum { lc3 = 8 };
    lua_pushboolean(L,!(lua_toboolean(L,8)));
    const int lc4 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc4) {
      
      /* return '' */
      lua_pushliteral(L,"");
      return 1;
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc3);
    assert(lua_gettop(L) == 8);
    
    /* local node_def  = minetest.registered_nodes[ node_name ] */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,8);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 9);
    
    /* if( not( node_def )) then */
    enum { lc5 = 9 };
    lua_pushboolean(L,!(lua_toboolean(L,9)));
    const int lc6 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc6) {
      
      /* return '' */
      lua_pushliteral(L,"");
      return 1;
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc5);
    assert(lua_gettop(L) == 9);
    
    /* local tiles = node_def.tiles */
    lua_pushliteral(L,"tiles");
    lua_gettable(L,9);
    assert(lua_gettop(L) == 10);
    
    /* local tile = nil */
    lua_pushnil(L);
    assert(lua_gettop(L) == 11);
    
    /* if( tiles ~= nil ) then */
    enum { lc7 = 11 };
    lua_pushnil(L);
    const int lc8 = lua_equal(L,10,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc8);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc9 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc9) {
      
      /* if( not(tile_nr) or tile_nr > #tiles or tile_nr < 1 ) then */
      enum { lc10 = 11 };
      lua_pushboolean(L,!(lua_toboolean(L,7)));
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        const double lc11 = lua_objlen(L,10);
        lua_pushnumber(L,lc11);
        const int lc12 = lua_lessthan(L,-1,7);
        lua_pop(L,1);
        lua_pushboolean(L,lc12);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushnumber(L,1);
        const int lc13 = lua_lessthan(L,7,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc13);
      }
      const int lc14 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc14) {
        
        /* tile_nr = 1 */
        lua_pushnumber(L,1);
        lua_replace(L,7);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L,lc10);
      assert(lua_gettop(L) == 11);
      
      /* tile = tiles[tile_nr] */
      lua_pushvalue(L,7);
      lua_gettable(L,10);
      lua_replace(L,11);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc7);
    assert(lua_gettop(L) == 11);
    
    /* if type(tile)=="table" then */
    enum { lc15 = 11 };
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,11);
    lua_call(L,1,1);
    lua_pushliteral(L,"table");
    const int lc16 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc16);
    const int lc17 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc17) {
      
      /* tile=tile["name"] */
      lua_pushliteral(L,"name");
      lua_gettable(L,11);
      lua_replace(L,11);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc15);
    assert(lua_gettop(L) == 11);
    
    /* image = tile */
    lua_pushvalue(L,11);
    lua_replace(L,2);
    assert(lua_gettop(L) == 11);
    
    /* if( not( image )) then */
    enum { lc18 = 11 };
    lua_pushboolean(L,!(lua_toboolean(L,2)));
    const int lc19 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc19) {
      
      /* image = "unknown_object.png" */
      lua_pushliteral(L,"unknown_object.png");
      lua_replace(L,2);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc18);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 7);
  
  /* return "image["..tostring(x)..",".. tostring(z) ..";"..dx..','..dz..";" .. image .."]" */
  lua_pushliteral(L,"image[");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,",");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  lua_pushliteral(L,";");
  lua_pushvalue(L,5);
  lua_pushliteral(L,",");
  lua_pushvalue(L,6);
  lua_pushliteral(L,";");
  lua_pushvalue(L,2);
  lua_pushliteral(L,"]");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <math.h>

/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: mg_villages.map_of_world
 * function( pname) */
static int lcf1_mg_villages_map_of_world (lua_State * L) {
  lua_checkstack(L,34);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local player = minetest.get_player_by_name( pname ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_player_by_name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* if( not( player )) then */
  enum { lc20 = 2 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  const int lc21 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc21) {
    
    /* return '' */
    lua_pushliteral(L,"");
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc20);
  assert(lua_gettop(L) == 2);
  
  /* local ppos  = player:getpos() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* -- also usable: diamond_block, sand, water
   * local formspec = "size[14.4,10]"..
   * 			"background[0,0;10,10;"..mg_villages.MAP_BACKGROUND_IMAGE.."]"..
   * 			"label[10,10;x axis]"..
   * 			"label[0,0;z axis]"..
   * 			"label[0,10;|]"..
   * 			"label[0.2,10;->]" */
  lua_pushliteral(L,"size[14.4,10]");
  lua_pushliteral(L,"background[0,0;10,10;");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"MAP_BACKGROUND_IMAGE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"label[10,10;x axis]");
  lua_pushliteral(L,"label[0,0;z axis]");
  lua_pushliteral(L,"label[0,10;|]");
  lua_pushliteral(L,"label[0.2,10;->]");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  assert(lua_gettop(L) == 4);
  
  /* local r  = mg_villages.MAP_RANGE */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"MAP_RANGE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* local f1 = 10/(2*r) */
  lua_pushnumber(L,10);
  lua_pushnumber(L,2);
  lc_mul(L,-1,5);
  lua_remove(L,-2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 6);
  
  /* local map_tiles_shown = math.floor( mg_villages.MAP_RANGE/80 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"MAP_RANGE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,80);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local center_x = math.floor( ppos.x/80 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lua_pushnumber(L,80);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* local center_z = math.floor( ppos.z/80 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  lua_pushnumber(L,80);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* for x = center_x - map_tiles_shown, center_x + map_tiles_shown do */
  lc_sub(L,8,7);
  lc_add(L,8,7);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc22_var = lua_tonumber(L,-2);
  const double lc23_limit = lua_tonumber(L,-1);
  const double lc24_step = 1;
  lua_pop(L,2);
  enum { lc25 = 9 };
  while ((((lc24_step > 0) && (lc22_var <= lc23_limit)) || ((lc24_step <= 0) && (lc22_var >= lc23_limit)))) {
    
    /* internal: local x at index 10 */
    lua_pushnumber(L,lc22_var);
    
    /* for z = center_z - map_tiles_shown, center_z + map_tiles_shown do */
    lc_sub(L,9,7);
    lc_add(L,9,7);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc26_var = lua_tonumber(L,-2);
    const double lc27_limit = lua_tonumber(L,-1);
    const double lc28_step = 1;
    lua_pop(L,2);
    enum { lc29 = 10 };
    while ((((lc28_step > 0) && (lc26_var <= lc27_limit)) || ((lc28_step <= 0) && (lc26_var >= lc27_limit)))) {
      
      /* internal: local z at index 11 */
      lua_pushnumber(L,lc26_var);
      
      /* if( mg_villages.mg_generated_map[ x ] and mg_villages.mg_generated_map[ x ][ z ] ) then */
      enum { lc30 = 11 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"mg_generated_map");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,10);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"mg_generated_map");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,11);
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      const int lc31 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc31) {
        
        /* local surface_types     = mg_villages.mg_generated_map[ x ][ z ] */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"mg_generated_map");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,11);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 12);
        
        /* local content_id        = 0 */
        lua_pushnumber(L,0);
        assert(lua_gettop(L) == 13);
        
        /* if( type( surface_types )=='table' ) then */
        enum { lc32 = 13 };
        lua_getfield(L,LUA_ENVIRONINDEX,"type");
        lua_pushvalue(L,12);
        lua_call(L,1,1);
        lua_pushliteral(L,"table");
        const int lc33 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc33);
        const int lc34 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc34) {
          
          /* content_id      = surface_types[ 26 ] */
          lua_pushnumber(L,26);
          lua_gettable(L,12);
          lua_replace(L,13);
          assert(lua_gettop(L) == 13);
        }
        else {
          
          /* else
           * content_id      = surface_types */
          lua_pushvalue(L,12);
          lua_replace(L,13);
          assert(lua_gettop(L) == 13);
        }
        lua_settop(L,lc32);
        assert(lua_gettop(L) == 13);
        
        /* local x1 = f1 * ((x*80) - ppos.x +r) */
        lua_pushnumber(L,80);
        lc_mul(L,10,-1);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_gettable(L,3);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-1,5);
        lua_remove(L,-2);
        lc_mul(L,6,-1);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 14);
        
        /* local z1 = f1 * ( (2*r) - ((z*80) - ppos.z + r)) */
        lua_pushnumber(L,2);
        lc_mul(L,-1,5);
        lua_remove(L,-2);
        lua_pushnumber(L,80);
        lc_mul(L,11,-1);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,3);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_add(L,-1,5);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lc_mul(L,6,-1);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 15);
        
        /* local dx = f1 * 80 */
        lua_pushnumber(L,80);
        lc_mul(L,6,-1);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 16);
        
        /* local dz = f1 * 80 */
        lua_pushnumber(L,80);
        lc_mul(L,6,-1);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 17);
        
        /* formspec = formspec..mg_villages.draw_tile( content_id, nil, x1+0.5, z1-0.5, dx*1.25, dz*1.25, 1 ) */
        lua_pushvalue(L,4);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"draw_tile");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,13);
        lua_pushnil(L);
        lua_pushnumber(L,0.5);
        lc_add(L,14,-1);
        lua_remove(L,-2);
        lua_pushnumber(L,0.5);
        lc_sub(L,15,-1);
        lua_remove(L,-2);
        lua_pushnumber(L,1.25);
        lc_mul(L,16,-1);
        lua_remove(L,-2);
        lua_pushnumber(L,1.25);
        lc_mul(L,17,-1);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_call(L,7,1);
        lua_concat(L,2);
        lua_replace(L,4);
        assert(lua_gettop(L) == 17);
        
        /* -- if more detailed information is available, draw those tiles that differ from the most common tile
         * if( type( surface_types )=='table' and false) then */
        enum { lc35 = 17 };
        lua_getfield(L,LUA_ENVIRONINDEX,"type");
        lua_pushvalue(L,12);
        lua_call(L,1,1);
        lua_pushliteral(L,"table");
        const int lc36 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc36);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushboolean(L,0);
        }
        const int lc37 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc37) {
          
          /* -- TODO: disabled for now
           * dx = dx/5 */
          lua_pushnumber(L,5);
          lc_div(L,16,-1);
          lua_remove(L,-2);
          lua_replace(L,16);
          assert(lua_gettop(L) == 17);
          
          /* dz = dz/5 */
          lua_pushnumber(L,5);
          lc_div(L,17,-1);
          lua_remove(L,-2);
          lua_replace(L,17);
          assert(lua_gettop(L) == 17);
          
          /* for i,v in ipairs( surface_types ) do
           * internal: local f, s, var = explist */
          enum { lc38 = 17 };
          lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
          lua_pushvalue(L,12);
          lua_call(L,1,3);
          while (1) {
            
            /* internal: local var_1, ..., var_n = f(s, var)
             *           if var_1 == nil then break end
             *           var = var_1 */
            lua_pushvalue(L,-3);
            lua_pushvalue(L,-3);
            lua_pushvalue(L,-3);
            lua_call(L,2,2);
            if (lua_isnil(L,-2)) {
              break;
            }
            lua_pushvalue(L,-2);
            lua_replace(L,-4);
            
            /* internal: local i with idx 21
             * internal: local v with idx 22 */
            
            
            /* if( v ~= content_id ) then */
            enum { lc39 = 22 };
            const int lc40 = lua_equal(L,22,13);
            lua_pushboolean(L,lc40);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            const int lc41 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc41) {
              
              /* local x2 = x1+( math.floor( (i-1)/5 )*dx) */
              lua_getfield(L,LUA_ENVIRONINDEX,"math");
              lua_pushliteral(L,"floor");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,1);
              lc_sub(L,21,-1);
              lua_remove(L,-2);
              lua_pushnumber(L,5);
              lc_div(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_call(L,1,1);
              lc_mul(L,-1,16);
              lua_remove(L,-2);
              lc_add(L,14,-1);
              lua_remove(L,-2);
              assert(lua_gettop(L) == 23);
              
              /* local z2 = z1+( math.floor( (i-1)%5 )*dz) */
              lua_getfield(L,LUA_ENVIRONINDEX,"math");
              lua_pushliteral(L,"floor");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,1);
              lc_sub(L,21,-1);
              lua_remove(L,-2);
              lua_pushnumber(L,5);
              lc_mod(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_call(L,1,1);
              lc_mul(L,-1,17);
              lua_remove(L,-2);
              lc_add(L,15,-1);
              lua_remove(L,-2);
              assert(lua_gettop(L) == 24);
              
              /* formspec = formspec..mg_villages.draw_tile( v, nil, x2+0.5, z2-0.5, dx*1.3, dz*1.3, 1) */
              lua_pushvalue(L,4);
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"draw_tile");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,22);
              lua_pushnil(L);
              lua_pushnumber(L,0.5);
              lc_add(L,23,-1);
              lua_remove(L,-2);
              lua_pushnumber(L,0.5);
              lc_sub(L,24,-1);
              lua_remove(L,-2);
              lua_pushnumber(L,1.3);
              lc_mul(L,16,-1);
              lua_remove(L,-2);
              lua_pushnumber(L,1.3);
              lc_mul(L,17,-1);
              lua_remove(L,-2);
              lua_pushnumber(L,1);
              lua_call(L,7,1);
              lua_concat(L,2);
              lua_replace(L,4);
              assert(lua_gettop(L) == 24);
            }
            lua_settop(L,lc39);
            assert(lua_gettop(L) == 22);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,2);
          }
          lua_settop(L,lc38);
          assert(lua_gettop(L) == 17);
        }
        lua_settop(L,lc35);
        assert(lua_gettop(L) == 17);
      }
      lua_settop(L,lc30);
      assert(lua_gettop(L) == 11);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc26_var += lc28_step;
    }
    lua_settop(L,lc29);
    assert(lua_gettop(L) == 10);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc22_var += lc24_step;
  }
  lua_settop(L,lc25);
  assert(lua_gettop(L) == 9);
  
  /* local shown_villages = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 10);
  
  /* r  = mg_villages.MAP_RANGE */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"MAP_RANGE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_replace(L,5);
  assert(lua_gettop(L) == 10);
  
  /* f1 = 10/(2*r) */
  lua_pushnumber(L,10);
  lua_pushnumber(L,2);
  lc_mul(L,-1,5);
  lua_remove(L,-2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_replace(L,6);
  assert(lua_gettop(L) == 10);
  
  /* for name,v in pairs( mg_villages.all_villages ) do
   * internal: local f, s, var = explist */
  enum { lc42 = 10 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local name with idx 14
     * internal: local v with idx 15 */
    
    
    /* local data = v */
    lua_pushvalue(L,15);
    assert(lua_gettop(L) == 16);
    
    /* --minetest.deserialize( v );
     * local x = data.vx - ppos.x */
    lua_pushliteral(L,"vx");
    lua_gettable(L,16);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 17);
    
    /* local z = data.vz - ppos.z */
    lua_pushliteral(L,"vz");
    lua_gettable(L,16);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 18);
    
    /* -- show only villages which are at max mg_villages.MAP_RANGE away from player
     * if( x and z 
     * 		   and mg_villages.village_type_data[ data.village_type ]
     * 		   and mg_villages.village_type_data[ data.village_type ].texture
     * 		   and math.abs( x ) < r
     * 		   and math.abs( z ) < r ) then */
    enum { lc43 = 18 };
    lua_pushvalue(L,17);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,18);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_type_data");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"village_type");
      lua_gettable(L,16);
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_type_data");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"village_type");
      lua_gettable(L,16);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"texture");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,17);
      lua_call(L,1,1);
      const int lc44 = lua_lessthan(L,-1,5);
      lua_pop(L,1);
      lua_pushboolean(L,lc44);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,18);
      lua_call(L,1,1);
      const int lc45 = lua_lessthan(L,-1,5);
      lua_pop(L,1);
      lua_pushboolean(L,lc45);
    }
    const int lc46 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc46) {
      
      /* -- the village size determines the texture size
       * local dx = f1 * (data.vs*2) *1.25 */
      lua_pushliteral(L,"vs");
      lua_gettable(L,16);
      lua_pushnumber(L,2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,6,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,1.25);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 19);
      
      /* local dz = f1 * (data.vs*2) *1.0 */
      lua_pushliteral(L,"vs");
      lua_gettable(L,16);
      lua_pushnumber(L,2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,6,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 20);
      
      /* -- center the village texture
       * x = x - (data.vs/2) */
      lua_pushliteral(L,"vs");
      lua_gettable(L,16);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,17,-1);
      lua_remove(L,-2);
      lua_replace(L,17);
      assert(lua_gettop(L) == 20);
      
      /* z = z + (data.vs/2) */
      lua_pushliteral(L,"vs");
      lua_gettable(L,16);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,18,-1);
      lua_remove(L,-2);
      lua_replace(L,18);
      assert(lua_gettop(L) == 20);
      
      /* -- calculate the position for the village texture
       * x = f1 * (x+r) */
      lc_add(L,17,5);
      lc_mul(L,6,-1);
      lua_remove(L,-2);
      lua_replace(L,17);
      assert(lua_gettop(L) == 20);
      
      /* z = f1 * ( (2*r) -(z+r)) */
      lua_pushnumber(L,2);
      lc_mul(L,-1,5);
      lua_remove(L,-2);
      lc_add(L,18,5);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,6,-1);
      lua_remove(L,-2);
      lua_replace(L,18);
      assert(lua_gettop(L) == 20);
      
      /* formspec = formspec..
       * 				"label["..x..",".. z ..";"..tostring( data.nr ).."]"..mg_villages.draw_tile( nil,  mg_villages.village_type_data[ data.village_type ].texture, x, z, dx, dz, 1 ) */
      lua_pushvalue(L,4);
      lua_pushliteral(L,"label[");
      lua_pushvalue(L,17);
      lua_pushliteral(L,",");
      lua_pushvalue(L,18);
      lua_pushliteral(L,";");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"nr");
      lua_gettable(L,16);
      lua_call(L,1,1);
      lua_pushliteral(L,"]");
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"draw_tile");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnil(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_type_data");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"village_type");
      lua_gettable(L,16);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"texture");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,17);
      lua_pushvalue(L,18);
      lua_pushvalue(L,19);
      lua_pushvalue(L,20);
      lua_pushnumber(L,1);
      lua_call(L,7,1);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,4);
      assert(lua_gettop(L) == 20);
      
      /* shown_villages[ #shown_villages+1 ] = tostring( data.nr )..". "..tostring( v.name or 'unknown' ).."]" */
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"nr");
      lua_gettable(L,16);
      lua_call(L,1,1);
      lua_pushliteral(L,". ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"name");
      lua_gettable(L,15);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"unknown");
      }
      lua_call(L,1,1);
      lua_pushliteral(L,"]");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      const double lc47 = lua_objlen(L,10);
      lua_pushnumber(L,lc47);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,10);
      assert(lua_gettop(L) == 20);
    }
    lua_settop(L,lc43);
    assert(lua_gettop(L) == 18);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,5);
  }
  lua_settop(L,lc42);
  assert(lua_gettop(L) == 10);
  
  /* -- code and arrows taken from mapp mod
   * local yaw = player:get_look_yaw() */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get_look_yaw");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 11);
  
  /* local rotate = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 12);
  
  /* if yaw ~= nil then */
  enum { lc48 = 12 };
  lua_pushnil(L);
  const int lc49 = lua_equal(L,11,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc49);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc50 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc50) {
    
    /* -- Find rotation and texture based on yaw.
     * yaw = math.deg(yaw) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"deg");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,11);
    lua_call(L,1,1);
    lua_replace(L,11);
    assert(lua_gettop(L) == 12);
    
    /* yaw = math.fmod (yaw, 360) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"fmod");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,11);
    lua_pushnumber(L,360);
    lua_call(L,2,1);
    lua_replace(L,11);
    assert(lua_gettop(L) == 12);
    
    /* if yaw<0 then */
    enum { lc51 = 12 };
    lua_pushnumber(L,0);
    const int lc52 = lua_lessthan(L,11,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc52);
    const int lc53 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc53) {
      
      /* yaw = 360 + yaw */
      lua_pushnumber(L,360);
      lc_add(L,-1,11);
      lua_remove(L,-2);
      lua_replace(L,11);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc51);
    assert(lua_gettop(L) == 12);
    
    /* if yaw>360 then */
    enum { lc54 = 12 };
    lua_pushnumber(L,360);
    const int lc55 = lua_lessthan(L,-1,11);
    lua_pop(L,1);
    lua_pushboolean(L,lc55);
    const int lc56 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc56) {
      
      /* yaw = yaw - 360 */
      lua_pushnumber(L,360);
      lc_sub(L,11,-1);
      lua_remove(L,-2);
      lua_replace(L,11);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc54);
    assert(lua_gettop(L) == 12);
    
    /* if yaw < 90 then */
    enum { lc57 = 12 };
    lua_pushnumber(L,90);
    const int lc58 = lua_lessthan(L,11,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc58);
    const int lc59 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc59) {
      
      /* rotate = 90 */
      lua_pushnumber(L,90);
      lua_replace(L,12);
      assert(lua_gettop(L) == 12);
    }
    else {
      
      /* elseif yaw < 180 then */
      enum { lc60 = 12 };
      lua_pushnumber(L,180);
      const int lc61 = lua_lessthan(L,11,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc61);
      const int lc62 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc62) {
        
        /* rotate = 180 */
        lua_pushnumber(L,180);
        lua_replace(L,12);
        assert(lua_gettop(L) == 12);
      }
      else {
        
        /* elseif yaw < 270 then */
        enum { lc63 = 12 };
        lua_pushnumber(L,270);
        const int lc64 = lua_lessthan(L,11,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc64);
        const int lc65 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc65) {
          
          /* rotate = 270 */
          lua_pushnumber(L,270);
          lua_replace(L,12);
          assert(lua_gettop(L) == 12);
        }
        else {
          
          /* else
           * rotate = 0 */
          lua_pushnumber(L,0);
          lua_replace(L,12);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc63);
      }
      lua_settop(L,lc60);
    }
    lua_settop(L,lc57);
    assert(lua_gettop(L) == 12);
    
    /* yaw = math.fmod(yaw, 90) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"fmod");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,11);
    lua_pushnumber(L,90);
    lua_call(L,2,1);
    lua_replace(L,11);
    assert(lua_gettop(L) == 12);
    
    /* yaw = math.floor(yaw / 10) * 10 */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,10);
    lc_div(L,11,-1);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_pushnumber(L,10);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,11);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc48);
  assert(lua_gettop(L) == 12);
  
  /* -- show the players yaw
   * if rotate ~= 0 then */
  enum { lc66 = 12 };
  lua_pushnumber(L,0);
  const int lc67 = lua_equal(L,12,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc67);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc68 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc68) {
    
    /* formspec = formspec.."image[".. 4.95 ..",".. 4.85 ..";0.4,0.4;d" .. yaw .. ".png^[transformFYR".. rotate .."]" */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"image[");
    lua_pushnumber(L,4.95);
    lua_pushliteral(L,",");
    lua_pushnumber(L,4.85);
    lua_pushliteral(L,";0.4,0.4;d");
    lua_pushvalue(L,11);
    lua_pushliteral(L,".png^[transformFYR");
    lua_pushvalue(L,12);
    lua_pushliteral(L,"]");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_replace(L,4);
    assert(lua_gettop(L) == 12);
  }
  else {
    
    /* else
     * formspec = formspec.."image[".. 4.95 ..",".. 4.85 ..";0.4,0.4;d" .. yaw .. ".png^[transformFY]" */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"image[");
    lua_pushnumber(L,4.95);
    lua_pushliteral(L,",");
    lua_pushnumber(L,4.85);
    lua_pushliteral(L,";0.4,0.4;d");
    lua_pushvalue(L,11);
    lua_pushliteral(L,".png^[transformFY]");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_replace(L,4);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc66);
  assert(lua_gettop(L) == 12);
  
  /* local i = 0.05 */
  lua_pushnumber(L,0.05);
  assert(lua_gettop(L) == 13);
  
  /* formspec = formspec.."label[10,-0.4;Village types:]" */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"label[10,-0.4;Village types:]");
  lua_concat(L,2);
  lua_replace(L,4);
  assert(lua_gettop(L) == 13);
  
  /* -- explain the meaning of the textures
   * if mg_villages.village_types ~= nil then */
  enum { lc69 = 13 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc70 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc70);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc71 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc71) {
    
    /* for _,typ in ipairs(mg_villages.village_types) do
     * internal: local f, s, var = explist */
    enum { lc72 = 13 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_types");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 17
       * internal: local typ with idx 18 */
      
      
      /* formspec = formspec.."label[10.5,"..tostring(i)..";"..tostring( typ ).."]"..
       * 				             "image[10.0,"..tostring(i+0.1)..";0.4,0.4;"..tostring( mg_villages.village_type_data[ typ ].texture ).."]" */
      lua_pushvalue(L,4);
      lua_pushliteral(L,"label[10.5,");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushvalue(L,13);
      lua_call(L,1,1);
      lua_pushliteral(L,";");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushvalue(L,18);
      lua_call(L,1,1);
      lua_pushliteral(L,"]");
      lua_pushliteral(L,"image[10.0,");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushnumber(L,0.1);
      lc_add(L,13,-1);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,";0.4,0.4;");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_type_data");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,18);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"texture");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"]");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,4);
      assert(lua_gettop(L) == 18);
      
      /* i = i+0.45 */
      lua_pushnumber(L,0.45);
      lc_add(L,13,-1);
      lua_remove(L,-2);
      lua_replace(L,13);
      assert(lua_gettop(L) == 18);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc72);
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc69);
  assert(lua_gettop(L) == 13);
  
  /* i = i+0.45 */
  lua_pushnumber(L,0.45);
  lc_add(L,13,-1);
  lua_remove(L,-2);
  lua_replace(L,13);
  assert(lua_gettop(L) == 13);
  
  /* formspec = formspec.."label[10.0,"..tostring(i)..";Villages shown on this map:]" */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"label[10.0,");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,13);
  lua_call(L,1,1);
  lua_pushliteral(L,";Villages shown on this map:]");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_replace(L,4);
  assert(lua_gettop(L) == 13);
  
  /* i = i+0.45 */
  lua_pushnumber(L,0.45);
  lc_add(L,13,-1);
  lua_remove(L,-2);
  lua_replace(L,13);
  assert(lua_gettop(L) == 13);
  
  /* local j = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 14);
  
  /* while (i<10.5 and j<=#shown_villages) do */
  enum { lc73 = 14 };
  while (1) {
    lua_pushnumber(L,10.5);
    const int lc74 = lua_lessthan(L,13,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc74);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      const double lc75 = lua_objlen(L,10);
      lua_pushnumber(L,lc75);
      const int lc76 = lc_le(L,14,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc76);
    }
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* formspec = formspec.."label[10.0,"..tostring(i)..";"..tostring( shown_villages[ j ] ).."]" */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"label[10.0,");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushvalue(L,13);
    lua_call(L,1,1);
    lua_pushliteral(L,";");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushvalue(L,14);
    lua_gettable(L,10);
    lua_call(L,1,1);
    lua_pushliteral(L,"]");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_replace(L,4);
    assert(lua_gettop(L) == 14);
    
    /* i = i+0.45 */
    lua_pushnumber(L,0.45);
    lc_add(L,13,-1);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 14);
    
    /* j = j+1 */
    lua_pushnumber(L,1);
    lc_add(L,14,-1);
    lua_remove(L,-2);
    lua_replace(L,14);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc73);
  assert(lua_gettop(L) == 14);
  
  /* return formspec */
  lua_pushvalue(L,4);
  return 1;
  assert(lua_gettop(L) == 14);
}


/* function(name, param) */
static int lcf78 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* minetest.show_formspec( name, 'mg:world_map', mg_villages.map_of_world( name )) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"show_formspec");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc77 = lua_gettop(L);
  lua_pushvalue(L,1);
  lua_pushliteral(L,"mg:world_map");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"map_of_world");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc77),0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* -- villages up to this many nodes in each direction are shown on the map
   * mg_villages.MAP_RANGE = 1000 */
  lua_pushnumber(L,1000);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"MAP_RANGE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.draw_tile = function( content_id, image, x, z, dx, dz, tile_nr )
   * 	if( not( image )) then
   * 		local node_name = minetest.get_name_from_content_id( content_id );
   * 		if( not( node_name )) then
   * 			return '';
   * 		end
   * 		local node_def  = minetest.registered_nodes[ node_name ];
   * 		if( not( node_def )) then
   * 			return '';
   * 		end
   * 		local tiles = node_def.tiles;
   * 		local tile = nil;
   * 		if( tiles ~= nil ) then
   * 			if( not(tile_nr) or tile_nr > #tiles or tile_nr < 1 ) then
   * 				tile_nr = 1;
   * 			end
   * 			tile = tiles[tile_nr];
   * 		end
   * 		if type(tile)=="table" then
   * 			tile=tile["name"]
   * 		end
   * 		image = tile;
   * 		if( not( image )) then
   * 			image = "unknown_object.png";
   * 		end
   * 	end
   * 	return "image["..tostring(x)..",".. tostring(z) ..";"..dx..','..dz..";" .. image .."]";
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_draw_tile);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"draw_tile");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.map_of_world = function( pname )
   * 
   * 	local player = minetest.get_player_by_name( pname );
   * 	if( not( player )) then
   * 		return '';
   * 	end
   * 	local ppos  = player:getpos();
   * 
   * 	-- also usable: diamond_block, sand, water
   * 	local formspec = "size[14.4,10]"..
   * 			"background[0,0;10,10;"..mg_villages.MAP_BACKGROUND_IMAGE.."]"..
   * 			"label[10,10;x axis]"..
   * 			"label[0,0;z axis]"..
   * 			"label[0,10;|]"..
   * 			"label[0.2,10;->]";
   * 
   * 
   * 	local r  = mg_villages.MAP_RANGE;
   * 	local f1 = 10/(2*r);
   * 
   * 	local map_tiles_shown = math.floor( mg_villages.MAP_RANGE/80 );
   * 	local center_x = math.floor( ppos.x/80 );
   * 	local center_z = math.floor( ppos.z/80 );
   * 	for x = center_x - map_tiles_shown, center_x + map_tiles_shown do
   * 		for z = center_z - map_tiles_shown, center_z + map_tiles_shown do  
   * 			if( mg_villages.mg_generated_map[ x ] and mg_villages.mg_generated_map[ x ][ z ] ) then
   * 				local surface_types     = mg_villages.mg_generated_map[ x ][ z ];
   * 				local content_id        = 0;
   * 				if( type( surface_types )=='table' ) then
   * 					content_id      = surface_types[ 26 ];
   * 				else
   * 					content_id      = surface_types;
   * 				end
   * 
   * 				local x1 = f1 * ((x*80) - ppos.x +r);
   * 				local z1 = f1 * ( (2*r) - ((z*80) - ppos.z + r));
   * 				local dx = f1 * 80;
   * 				local dz = f1 * 80;
   * 
   * 				formspec = formspec..mg_villages.draw_tile( content_id, nil, x1+0.5, z1-0.5, dx*1.25, dz*1.25, 1 );
   * 
   * 				-- if more detailed information is available, draw those tiles that differ from the most common tile
   * 				if( type( surface_types )=='table' and false) then -- TODO: disabled for now
   * 					dx = dx/5;
   * 					dz = dz/5;
   * 					for i,v in ipairs( surface_types ) do
   * 						if( v ~= content_id ) then
   * 							local x2 = x1+( math.floor( (i-1)/5 )*dx); 
   * 							local z2 = z1+( math.floor( (i-1)%5 )*dz);
   * 							formspec = formspec..mg_villages.draw_tile( v, nil, x2+0.5, z2-0.5, dx*1.3, dz*1.3, 1);
   * 						end
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end
   * 
   * 	local shown_villages = {};
   * 
   * 	r  = mg_villages.MAP_RANGE;
   * 	f1 = 10/(2*r);
   * 	for name,v in pairs( mg_villages.all_villages ) do
   * 
   * 		local data = v; --minetest.deserialize( v );
   * 		local x = data.vx - ppos.x;
   * 		local z = data.vz - ppos.z;
   * 
   * 		-- show only villages which are at max mg_villages.MAP_RANGE away from player
   * 		if( x and z 
   * 		   and mg_villages.village_type_data[ data.village_type ]
   * 		   and mg_villages.village_type_data[ data.village_type ].texture
   * 		   and math.abs( x ) < r
   * 		   and math.abs( z ) < r ) then
   * 
   * 			-- the village size determines the texture size
   * 			local dx = f1 * (data.vs*2) *1.25;
   * 			local dz = f1 * (data.vs*2) *1.0;
   * 
   * 			-- center the village texture
   * 			x = x - (data.vs/2);
   * 			z = z + (data.vs/2);
   * 
   * 			-- calculate the position for the village texture
   * 			x = f1 * (x+r);
   * 			z = f1 * ( (2*r) -(z+r));
   * 
   * 			formspec = formspec..
   * 				"label["..x..",".. z ..";"..tostring( data.nr ).."]"..mg_villages.draw_tile( nil,  mg_villages.village_type_data[ data.village_type ].texture, x, z, dx, dz, 1 );
   * 
   * 			shown_villages[ #shown_villages+1 ] = tostring( data.nr )..". "..tostring( v.name or 'unknown' ).."]"; 
   * 		end
   * 	end
   * 
   * 	-- code and arrows taken from mapp mod
   * 	local yaw = player:get_look_yaw()
   * 	local rotate = 0;
   * 	if yaw ~= nil then
   * 		-- Find rotation and texture based on yaw.
   * 		yaw = math.deg(yaw)
   * 		yaw = math.fmod (yaw, 360)
   * 		if yaw<0 then yaw = 360 + yaw end
   * 		if yaw>360 then yaw = yaw - 360 end
   * 		if yaw < 90 then
   * 			rotate = 90
   * 		elseif yaw < 180 then
   * 			rotate = 180
   * 		elseif yaw < 270 then
   * 			rotate = 270
   * 		else
   * 			rotate = 0
   * 		end
   * 		yaw = math.fmod(yaw, 90)
   * 		yaw = math.floor(yaw / 10) * 10
   * 
   * 	end
   * 
   * 	-- show the players yaw
   * 	if rotate ~= 0 then
   * 		formspec = formspec.."image[".. 4.95 ..",".. 4.85 ..";0.4,0.4;d" .. yaw .. ".png^[transformFYR".. rotate .."]"
   * 	else
   * 		formspec = formspec.."image[".. 4.95 ..",".. 4.85 ..";0.4,0.4;d" .. yaw .. ".png^[transformFY]"
   * 	end
   * 
   * 	local i = 0.05;
   * 	formspec = formspec.."label[10,-0.4;Village types:]";
   * 	-- explain the meaning of the textures
   * 	if mg_villages.village_types ~= nil then
   * 		for _,typ in ipairs(mg_villages.village_types) do 
   * 			formspec = formspec.."label[10.5,"..tostring(i)..";"..tostring( typ ).."]"..
   * 				             "image[10.0,"..tostring(i+0.1)..";0.4,0.4;"..tostring( mg_villages.village_type_data[ typ ].texture ).."]";
   * 			i = i+0.45;
   * 		end
   * 	end
   * 
   * 	i = i+0.45;
   * 	formspec = formspec.."label[10.0,"..tostring(i)..";Villages shown on this map:]";
   * 	i = i+0.45;
   * 	local j = 1;
   * 	while (i<10.5 and j<=#shown_villages) do
   * 		
   * 		formspec = formspec.."label[10.0,"..tostring(i)..";"..tostring( shown_villages[ j ] ).."]";
   * 		i = i+0.45;
   * 		j = j+1;
   * 	end
   * 
   * 	return formspec;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_map_of_world);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"map_of_world");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_chatcommand( 'vmap', {
   * 	description = "Shows a map of all known villages withhin "..tostring( mg_villages.MAP_RANGE ).." blocks.",
   * 	privs = {},
   * 	func = function(name, param)
   * 		minetest.show_formspec( name, 'mg:world_map', mg_villages.map_of_world( name ));
   *         end
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_chatcommand");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vmap");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Shows a map of all known villages withhin ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"MAP_RANGE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L," blocks.");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"privs");
  lua_newtable(L);
  lua_rawset(L,-3);
  lua_pushliteral(L,"func");
  lua_pushcfunction(L,lcf78);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_map_of_world(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


