/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.grow_tree
 * function(data, a, pos, is_apple_tree, seed, snow) */
static int lcf1_mg_villages_grow_tree (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* --[[
   *                 NOTE: Tree-placing code is currently duplicated in the engine
   *                 and in games that have saplings; both are deprecated but not
   *                 replaced yet
   *         ]]-
   * --
   * local leaves_type = c_leaves */
  lc_getupvalue(L,lua_upvalueindex(1),6,4);
  assert(lua_gettop(L) == 7);
  
  /* if(  snow
   *       or data[ a:index(pos.x, pos.y,   pos.z) ] == c_snow
   *       or data[ a:index(pos.x, pos.y+1, pos.z) ] == c_snow ) then */
  enum { lc15 = 7 };
  lua_pushvalue(L,6);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),3,7);
    const int lc16 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc16);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),3,7);
    const int lc17 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc17);
  }
  const int lc18 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc18) {
    
    /* leaves_type = c_msnow_leaves2 */
    lc_getupvalue(L,lua_upvalueindex(1),0,10);
    lua_replace(L,7);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc15);
  assert(lua_gettop(L) == 7);
  
  /* local hight = math.random(4, 5) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,4);
  lua_pushnumber(L,5);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 8);
  
  /* for x_area = -2, 2 do */
  lua_pushnumber(L,-2);
  lua_pushnumber(L,2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc19_var = lua_tonumber(L,-2);
  const double lc20_limit = lua_tonumber(L,-1);
  const double lc21_step = 1;
  lua_pop(L,2);
  enum { lc22 = 8 };
  while ((((lc21_step > 0) && (lc19_var <= lc20_limit)) || ((lc21_step <= 0) && (lc19_var >= lc20_limit)))) {
    
    /* internal: local x_area at index 9 */
    lua_pushnumber(L,lc19_var);
    
    /* for y_area = -1, 2 do */
    lua_pushnumber(L,-1);
    lua_pushnumber(L,2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc23_var = lua_tonumber(L,-2);
    const double lc24_limit = lua_tonumber(L,-1);
    const double lc25_step = 1;
    lua_pop(L,2);
    enum { lc26 = 9 };
    while ((((lc25_step > 0) && (lc23_var <= lc24_limit)) || ((lc25_step <= 0) && (lc23_var >= lc24_limit)))) {
      
      /* internal: local y_area at index 10 */
      lua_pushnumber(L,lc23_var);
      
      /* for z_area = -2, 2 do */
      lua_pushnumber(L,-2);
      lua_pushnumber(L,2);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc27_var = lua_tonumber(L,-2);
      const double lc28_limit = lua_tonumber(L,-1);
      const double lc29_step = 1;
      lua_pop(L,2);
      enum { lc30 = 10 };
      while ((((lc29_step > 0) && (lc27_var <= lc28_limit)) || ((lc29_step <= 0) && (lc27_var >= lc28_limit)))) {
        
        /* internal: local z_area at index 11 */
        lua_pushnumber(L,lc27_var);
        
        /* if math.random(1,30) < 23 then */
        enum { lc31 = 11 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushnumber(L,30);
        lua_call(L,2,1);
        lua_pushnumber(L,23);
        const int lc32 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc32);
        const int lc33 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc33) {
          
          /* --randomize leaves
           * local area_l = a:index(pos.x+x_area, pos.y+hight+y_area-1, pos.z+z_area) */
          lua_pushvalue(L,2);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"x");
          lua_gettable(L,3);
          lc_add(L,-1,9);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          lc_add(L,-1,8);
          lua_remove(L,-2);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"z");
          lua_gettable(L,3);
          lc_add(L,-1,11);
          lua_remove(L,-2);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 12);
          
          /* --sets area for leaves
           * if data[area_l] == c_air or data[area_l] == c_ignore or data[area_l]== c_snow then */
          enum { lc34 = 12 };
          lua_pushvalue(L,12);
          lua_gettable(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),9,1);
          const int lc35 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc35);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,12);
            lua_gettable(L,1);
            lc_getupvalue(L,lua_upvalueindex(1),8,2);
            const int lc36 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc36);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,12);
            lua_gettable(L,1);
            lc_getupvalue(L,lua_upvalueindex(1),3,7);
            const int lc37 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc37);
          }
          const int lc38 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc38) {
            
            /* --sets if it's air or ignore 
             * if( snow and c_msnow_leaves1 and math.random( 1,5 )==1) then */
            enum { lc39 = 12 };
            lua_pushvalue(L,6);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lc_getupvalue(L,lua_upvalueindex(1),1,9);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"math");
              lua_pushliteral(L,"random");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,1);
              lua_pushnumber(L,5);
              lua_call(L,2,1);
              lua_pushnumber(L,1);
              const int lc40 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc40);
            }
            const int lc41 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc41) {
              
              /* data[area_l] = c_msnow_leaves1 */
              lc_getupvalue(L,lua_upvalueindex(1),1,9);
              lua_pushvalue(L,12);
              lua_insert(L,-2);
              lua_settable(L,1);
              assert(lua_gettop(L) == 12);
            }
            else {
              
              /* else
               * data[area_l] = leaves_type */
              lua_pushvalue(L,7);
              lua_pushvalue(L,12);
              lua_insert(L,-2);
              lua_settable(L,1);
              assert(lua_gettop(L) == 12);
            }
            lua_settop(L,lc39);
            assert(lua_gettop(L) == 12);
          }
          lua_settop(L,lc34);
          assert(lua_gettop(L) == 12);
          
          /* -- put a snow top on some leaves
           * if ( snow and math.random(1,3)==1 ) then */
          enum { lc42 = 12 };
          lua_pushvalue(L,6);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"math");
            lua_pushliteral(L,"random");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lua_pushnumber(L,3);
            lua_call(L,2,1);
            lua_pushnumber(L,1);
            const int lc43 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc43);
          }
          const int lc44 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc44) {
            
            /* mg_villages.trees_add_snow(data, a:index(pos.x+x_area, pos.y+hight+y_area, pos.z+z_area), c_air, c_ignore, c_snow) */
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"trees_add_snow");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_pushvalue(L,2);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushliteral(L,"x");
            lua_gettable(L,3);
            lc_add(L,-1,9);
            lua_remove(L,-2);
            lua_pushliteral(L,"y");
            lua_gettable(L,3);
            lc_add(L,-1,8);
            lua_remove(L,-2);
            lc_add(L,-1,10);
            lua_remove(L,-2);
            lua_pushliteral(L,"z");
            lua_gettable(L,3);
            lc_add(L,-1,11);
            lua_remove(L,-2);
            lua_call(L,4,1);
            lc_getupvalue(L,lua_upvalueindex(1),9,1);
            lc_getupvalue(L,lua_upvalueindex(1),8,2);
            lc_getupvalue(L,lua_upvalueindex(1),3,7);
            lua_call(L,5,0);
            assert(lua_gettop(L) == 12);
          }
          lua_settop(L,lc42);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc31);
        assert(lua_gettop(L) == 11);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc27_var += lc29_step;
      }
      lua_settop(L,lc30);
      assert(lua_gettop(L) == 10);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc23_var += lc25_step;
    }
    lua_settop(L,lc26);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc19_var += lc21_step;
  }
  lua_settop(L,lc22);
  assert(lua_gettop(L) == 8);
  
  /* for tree_h = 0, hight-1 do  -- add the trunk */
  lua_pushnumber(L,0);
  lua_pushnumber(L,1);
  lc_sub(L,8,-1);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc45_var = lua_tonumber(L,-2);
  const double lc46_limit = lua_tonumber(L,-1);
  const double lc47_step = 1;
  lua_pop(L,2);
  enum { lc48 = 8 };
  while ((((lc47_step > 0) && (lc45_var <= lc46_limit)) || ((lc47_step <= 0) && (lc45_var >= lc46_limit)))) {
    
    /* internal: local tree_h at index 9 */
    lua_pushnumber(L,lc45_var);
    
    /* -- add the trunk
     * local area_t = a:index(pos.x, pos.y+tree_h, pos.z) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lc_add(L,-1,9);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    assert(lua_gettop(L) == 10);
    
    /* --set area for tree
     * if data[area_t] == c_air or data[area_t] == c_leaves or data[area_t] == c_sapling or data[area_t] == c_snow or data[area_t] == c_msnow_top or data[area_t] == c_msnow_leaves1 or data[area_t] == c_msnow_leaves2 then */
    enum { lc49 = 10 };
    lua_pushvalue(L,10);
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),9,1);
    const int lc50 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc50);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),6,4);
      const int lc51 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc51);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),5,5);
      const int lc52 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc52);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),3,7);
      const int lc53 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc53);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),2,8);
      const int lc54 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc54);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),1,9);
      const int lc55 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc55);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,10);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,10);
      const int lc56 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc56);
    }
    const int lc57 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc57) {
      
      /* --sets if air
       * data[area_t] = c_tree */
      lc_getupvalue(L,lua_upvalueindex(1),7,3);
      lua_pushvalue(L,10);
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc49);
    assert(lua_gettop(L) == 10);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc45_var += lc47_step;
  }
  lua_settop(L,lc48);
  assert(lua_gettop(L) == 8);
  return 0;
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: mg_villages.grow_jungletree
 * function(data, a, pos, seed, snow) */
static int lcf1_mg_villages_grow_jungletree (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* --[[
   *                 NOTE: Tree-placing code is currently duplicated in the engine
   *                 and in games that have saplings; both are deprecated but not
   *                 replaced yet
   *         ]]-
   * --
   * local leaves_type = c_jungleleaves */
  lc_getupvalue(L,lua_upvalueindex(1),0,12);
  assert(lua_gettop(L) == 6);
  
  /* if(  snow
   *       or data[ a:index(pos.x, pos.y,   pos.z) ] == c_snow
   *       or data[ a:index(pos.x, pos.y+1, pos.z) ] == c_snow ) then */
  enum { lc60 = 6 };
  lua_pushvalue(L,5);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),5,7);
    const int lc61 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc61);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),5,7);
    const int lc62 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc62);
  }
  const int lc63 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc63) {
    
    /* leaves_type = c_msnow_leaves1 */
    lc_getupvalue(L,lua_upvalueindex(1),3,9);
    lua_replace(L,6);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc60);
  assert(lua_gettop(L) == 6);
  
  /* local hight = math.random(8, 12) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  lua_pushnumber(L,12);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 7);
  
  /* for x_area = -3, 3 do */
  lua_pushnumber(L,-3);
  lua_pushnumber(L,3);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc64_var = lua_tonumber(L,-2);
  const double lc65_limit = lua_tonumber(L,-1);
  const double lc66_step = 1;
  lua_pop(L,2);
  enum { lc67 = 7 };
  while ((((lc66_step > 0) && (lc64_var <= lc65_limit)) || ((lc66_step <= 0) && (lc64_var >= lc65_limit)))) {
    
    /* internal: local x_area at index 8 */
    lua_pushnumber(L,lc64_var);
    
    /* for y_area = -2, 2 do */
    lua_pushnumber(L,-2);
    lua_pushnumber(L,2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc68_var = lua_tonumber(L,-2);
    const double lc69_limit = lua_tonumber(L,-1);
    const double lc70_step = 1;
    lua_pop(L,2);
    enum { lc71 = 8 };
    while ((((lc70_step > 0) && (lc68_var <= lc69_limit)) || ((lc70_step <= 0) && (lc68_var >= lc69_limit)))) {
      
      /* internal: local y_area at index 9 */
      lua_pushnumber(L,lc68_var);
      
      /* for z_area = -3, 3 do */
      lua_pushnumber(L,-3);
      lua_pushnumber(L,3);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc72_var = lua_tonumber(L,-2);
      const double lc73_limit = lua_tonumber(L,-1);
      const double lc74_step = 1;
      lua_pop(L,2);
      enum { lc75 = 9 };
      while ((((lc74_step > 0) && (lc72_var <= lc73_limit)) || ((lc74_step <= 0) && (lc72_var >= lc73_limit)))) {
        
        /* internal: local z_area at index 10 */
        lua_pushnumber(L,lc72_var);
        
        /* if math.random(1,30) < 23 then */
        enum { lc76 = 10 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_pushnumber(L,30);
        lua_call(L,2,1);
        lua_pushnumber(L,23);
        const int lc77 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc77);
        const int lc78 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc78) {
          
          /* --randomize leaves
           * local area_l = a:index(pos.x+x_area, pos.y+hight+y_area-1, pos.z+z_area) */
          lua_pushvalue(L,2);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"x");
          lua_gettable(L,3);
          lc_add(L,-1,8);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          lc_add(L,-1,7);
          lua_remove(L,-2);
          lc_add(L,-1,9);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"z");
          lua_gettable(L,3);
          lc_add(L,-1,10);
          lua_remove(L,-2);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 11);
          
          /* --sets area for leaves
           * if data[area_l] == c_air or data[area_l] == c_ignore then */
          enum { lc79 = 11 };
          lua_pushvalue(L,11);
          lua_gettable(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),11,1);
          const int lc80 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc80);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,11);
            lua_gettable(L,1);
            lc_getupvalue(L,lua_upvalueindex(1),10,2);
            const int lc81 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc81);
          }
          const int lc82 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc82) {
            
            /* --sets if it's air or ignore
             * data[area_l] = leaves_type */
            lua_pushvalue(L,6);
            lua_pushvalue(L,11);
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 11);
          }
          lua_settop(L,lc79);
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L,lc76);
        assert(lua_gettop(L) == 10);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc72_var += lc74_step;
      }
      lua_settop(L,lc75);
      assert(lua_gettop(L) == 9);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc68_var += lc70_step;
    }
    lua_settop(L,lc71);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc64_var += lc66_step;
  }
  lua_settop(L,lc67);
  assert(lua_gettop(L) == 7);
  
  /* for tree_h = 0, hight-1 do  -- add the trunk */
  lua_pushnumber(L,0);
  lua_pushnumber(L,1);
  lc_sub(L,7,-1);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc83_var = lua_tonumber(L,-2);
  const double lc84_limit = lua_tonumber(L,-1);
  const double lc85_step = 1;
  lua_pop(L,2);
  enum { lc86 = 7 };
  while ((((lc85_step > 0) && (lc83_var <= lc84_limit)) || ((lc85_step <= 0) && (lc83_var >= lc84_limit)))) {
    
    /* internal: local tree_h at index 8 */
    lua_pushnumber(L,lc83_var);
    
    /* -- add the trunk
     * local area_t = a:index(pos.x, pos.y+tree_h, pos.z) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lc_add(L,-1,8);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    assert(lua_gettop(L) == 9);
    
    /* --set area for tree
     * if data[area_t] == c_air or data[area_t] == c_jungleleaves or data[area_t] == c_junglesapling or data[area_t] == c_snow or data[area_t] == c_msnow_top then */
    enum { lc87 = 9 };
    lua_pushvalue(L,9);
    lua_gettable(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),11,1);
    const int lc88 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc88);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,9);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,12);
      const int lc89 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc89);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,9);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),6,6);
      const int lc90 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc90);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,9);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),5,7);
      const int lc91 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc91);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,9);
      lua_gettable(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),4,8);
      const int lc92 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc92);
    }
    const int lc93 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc93) {
      
      /* --sets if air
       * data[area_t] = c_jungletree */
      lc_getupvalue(L,lua_upvalueindex(1),1,11);
      lua_pushvalue(L,9);
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc87);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc83_var += lc85_step;
  }
  lua_settop(L,lc86);
  assert(lua_gettop(L) == 7);
  
  /* for roots_x = -1, 1 do */
  lua_pushnumber(L,-1);
  lua_pushnumber(L,1);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc94_var = lua_tonumber(L,-2);
  const double lc95_limit = lua_tonumber(L,-1);
  const double lc96_step = 1;
  lua_pop(L,2);
  enum { lc97 = 7 };
  while ((((lc96_step > 0) && (lc94_var <= lc95_limit)) || ((lc96_step <= 0) && (lc94_var >= lc95_limit)))) {
    
    /* internal: local roots_x at index 8 */
    lua_pushnumber(L,lc94_var);
    
    /* for roots_z = -1, 1 do */
    lua_pushnumber(L,-1);
    lua_pushnumber(L,1);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc98_var = lua_tonumber(L,-2);
    const double lc99_limit = lua_tonumber(L,-1);
    const double lc100_step = 1;
    lua_pop(L,2);
    enum { lc101 = 8 };
    while ((((lc100_step > 0) && (lc98_var <= lc99_limit)) || ((lc100_step <= 0) && (lc98_var >= lc99_limit)))) {
      
      /* internal: local roots_z at index 9 */
      lua_pushnumber(L,lc98_var);
      
      /* if math.random(1, 3) >= 2 then */
      enum { lc102 = 9 };
      lua_pushnumber(L,2);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,3);
      lua_call(L,2,1);
      const int lc103 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc103);
      const int lc104 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc104) {
        
        /* --randomize roots
         * if a:contains(pos.x+roots_x, pos.y-1, pos.z+roots_z) and data[a:index(pos.x+roots_x, pos.y-1, pos.z+roots_z)] == c_air then */
        enum { lc105 = 9 };
        lua_pushvalue(L,2);
        lua_pushliteral(L,"contains");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"x");
        lua_gettable(L,3);
        lc_add(L,-1,8);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_gettable(L,3);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,3);
        lc_add(L,-1,9);
        lua_remove(L,-2);
        lua_call(L,4,1);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,2);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"x");
          lua_gettable(L,3);
          lc_add(L,-1,8);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"z");
          lua_gettable(L,3);
          lc_add(L,-1,9);
          lua_remove(L,-2);
          lua_call(L,4,1);
          lua_gettable(L,1);
          lc_getupvalue(L,lua_upvalueindex(1),11,1);
          const int lc106 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc106);
        }
        const int lc107 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc107) {
          
          /* data[a:index(pos.x+roots_x, pos.y-1, pos.z+roots_z)] = c_jungletree */
          lc_getupvalue(L,lua_upvalueindex(1),1,11);
          lua_pushvalue(L,2);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"x");
          lua_gettable(L,3);
          lc_add(L,-1,8);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"z");
          lua_gettable(L,3);
          lc_add(L,-1,9);
          lua_remove(L,-2);
          lua_call(L,4,1);
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 9);
        }
        else {
          
          /* elseif a:contains(pos.x+roots_x, pos.y, pos.z+roots_z) and data[a:index(pos.x+roots_x, pos.y, pos.z+roots_z)] == c_air then */
          enum { lc108 = 9 };
          lua_pushvalue(L,2);
          lua_pushliteral(L,"contains");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"x");
          lua_gettable(L,3);
          lc_add(L,-1,8);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          lua_pushliteral(L,"z");
          lua_gettable(L,3);
          lc_add(L,-1,9);
          lua_remove(L,-2);
          lua_call(L,4,1);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushvalue(L,2);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushliteral(L,"x");
            lua_gettable(L,3);
            lc_add(L,-1,8);
            lua_remove(L,-2);
            lua_pushliteral(L,"y");
            lua_gettable(L,3);
            lua_pushliteral(L,"z");
            lua_gettable(L,3);
            lc_add(L,-1,9);
            lua_remove(L,-2);
            lua_call(L,4,1);
            lua_gettable(L,1);
            lc_getupvalue(L,lua_upvalueindex(1),11,1);
            const int lc109 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc109);
          }
          const int lc110 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc110) {
            
            /* data[a:index(pos.x+roots_x, pos.y, pos.z+roots_z)] = c_jungletree */
            lc_getupvalue(L,lua_upvalueindex(1),1,11);
            lua_pushvalue(L,2);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushliteral(L,"x");
            lua_gettable(L,3);
            lc_add(L,-1,8);
            lua_remove(L,-2);
            lua_pushliteral(L,"y");
            lua_gettable(L,3);
            lua_pushliteral(L,"z");
            lua_gettable(L,3);
            lc_add(L,-1,9);
            lua_remove(L,-2);
            lua_call(L,4,1);
            lua_insert(L,-2);
            lua_settable(L,1);
            assert(lua_gettop(L) == 9);
          }
          lua_settop(L,lc108);
        }
        lua_settop(L,lc105);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc102);
      assert(lua_gettop(L) == 9);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc98_var += lc100_step;
    }
    lua_settop(L,lc101);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc94_var += lc96_step;
  }
  lua_settop(L,lc97);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: mg_villages.trees_add_pine_needles
 * function(data, vi, c_air, c_ignore, c_snow, c_pine_needles) */
static int lcf1_mg_villages_trees_add_pine_needles (lua_State * L) {
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* if data[vi] == c_air or data[vi] == c_ignore or data[vi] == c_snow then */
  enum { lc111 = 6 };
  lua_pushvalue(L,2);
  lua_gettable(L,1);
  lua_pushvalue(L,3);
  const int lc112 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc112);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_gettable(L,1);
    lua_pushvalue(L,4);
    const int lc113 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc113);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_gettable(L,1);
    lua_pushvalue(L,5);
    const int lc114 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc114);
  }
  const int lc115 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc115) {
    
    /* data[vi] = c_pine_needles */
    lua_pushvalue(L,6);
    lua_pushvalue(L,2);
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc111);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* name: mg_villages.trees_add_snow
 * function(data, vi, c_air, c_ignore, c_snow) */
static int lcf1_mg_villages_trees_add_snow (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* if data[vi] == c_air or data[vi] == c_ignore then */
  enum { lc116 = 5 };
  lua_pushvalue(L,2);
  lua_gettable(L,1);
  lua_pushvalue(L,3);
  const int lc117 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc117);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_gettable(L,1);
    lua_pushvalue(L,4);
    const int lc118 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc118);
  }
  const int lc119 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc119) {
    
    /* data[vi] = c_snow */
    lua_pushvalue(L,5);
    lua_pushvalue(L,2);
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc116);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.grow_pinetree
 * function(data, a, pos, snow) */
static int lcf1_mg_villages_grow_pinetree (lua_State * L) {
  lua_checkstack(L,35);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local x, y, z = pos.x, pos.y, pos.z */
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lua_pushliteral(L,"y");
  lua_gettable(L,3);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  assert(lua_gettop(L) == 7);
  
  /* local maxy = y + math.random(9, 13) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,9);
  lua_pushnumber(L,13);
  lua_call(L,2,1);
  lc_add(L,6,-1);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 8);
  
  /* -- Trunk top
   * local c_air = minetest.get_content_id("air") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* local c_ignore = minetest.get_content_id("ignore") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ignore");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 10);
  
  /* local c_pinetree = minetest.get_content_id("default:pine_tree") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:pine_tree");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 11);
  
  /* local c_pine_needles  = minetest.get_content_id("default:pine_needles") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:pine_needles");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 12);
  
  /* local c_snow = minetest.get_content_id("default:snow") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:snow");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 13);
  
  /* local c_snowblock = minetest.get_content_id("default:snowblock") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:snowblock");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 14);
  
  /* local c_dirtsnow = minetest.get_content_id("default:dirt_with_snow") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt_with_snow");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 15);
  
  /* -- Scan for snow nodes near sapling
   * --	local snow = false
   * for yy = y - 1, y + 1 do */
  lua_pushnumber(L,1);
  lc_sub(L,6,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,6,-1);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc120_var = lua_tonumber(L,-2);
  const double lc121_limit = lua_tonumber(L,-1);
  const double lc122_step = 1;
  lua_pop(L,2);
  enum { lc123 = 15 };
  while ((((lc122_step > 0) && (lc120_var <= lc121_limit)) || ((lc122_step <= 0) && (lc120_var >= lc121_limit)))) {
    
    /* internal: local yy at index 16 */
    lua_pushnumber(L,lc120_var);
    
    /* for zz = z - 1, z + 1 do */
    lua_pushnumber(L,1);
    lc_sub(L,7,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,7,-1);
    lua_remove(L,-2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc124_var = lua_tonumber(L,-2);
    const double lc125_limit = lua_tonumber(L,-1);
    const double lc126_step = 1;
    lua_pop(L,2);
    enum { lc127 = 16 };
    while ((((lc126_step > 0) && (lc124_var <= lc125_limit)) || ((lc126_step <= 0) && (lc124_var >= lc125_limit)))) {
      
      /* internal: local zz at index 17 */
      lua_pushnumber(L,lc124_var);
      
      /* local vi  = a:index(x - 1, yy, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,5,-1);
      lua_remove(L,-2);
      lua_pushvalue(L,16);
      lua_pushvalue(L,17);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 18);
      
      /* for xx = x - 1, x + 1 do */
      lua_pushnumber(L,1);
      lc_sub(L,5,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_add(L,5,-1);
      lua_remove(L,-2);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc128_var = lua_tonumber(L,-2);
      const double lc129_limit = lua_tonumber(L,-1);
      const double lc130_step = 1;
      lua_pop(L,2);
      enum { lc131 = 18 };
      while ((((lc130_step > 0) && (lc128_var <= lc129_limit)) || ((lc130_step <= 0) && (lc128_var >= lc129_limit)))) {
        
        /* internal: local xx at index 19 */
        lua_pushnumber(L,lc128_var);
        
        /* local nodid = data[vi] */
        lua_pushvalue(L,18);
        lua_gettable(L,1);
        assert(lua_gettop(L) == 20);
        
        /* if nodid == c_snow
         * 			or nodid == c_snowblock
         * 			or nodid == c_dirtsnow then */
        enum { lc132 = 20 };
        lua_pushvalue(L,20);
        lua_pushvalue(L,13);
        const int lc133 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc133);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,20);
          lua_pushvalue(L,14);
          const int lc134 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc134);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,20);
          lua_pushvalue(L,15);
          const int lc135 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc135);
        }
        const int lc136 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc136) {
          
          /* snow = true */
          lua_pushboolean(L,1);
          lua_replace(L,4);
          assert(lua_gettop(L) == 20);
        }
        lua_settop(L,lc132);
        assert(lua_gettop(L) == 20);
        
        /* vi  = vi + 1 */
        lua_pushnumber(L,1);
        lc_add(L,18,-1);
        lua_remove(L,-2);
        lua_replace(L,18);
        assert(lua_gettop(L) == 20);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc128_var += lc130_step;
      }
      lua_settop(L,lc131);
      assert(lua_gettop(L) == 18);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc124_var += lc126_step;
    }
    lua_settop(L,lc127);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc120_var += lc122_step;
  }
  lua_settop(L,lc123);
  assert(lua_gettop(L) == 15);
  
  /* -- Upper branches layer
   * local dev = 3 */
  lua_pushnumber(L,3);
  assert(lua_gettop(L) == 16);
  
  /* for yy = maxy - 1, maxy + 1 do */
  lua_pushnumber(L,1);
  lc_sub(L,8,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,8,-1);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc137_var = lua_tonumber(L,-2);
  const double lc138_limit = lua_tonumber(L,-1);
  const double lc139_step = 1;
  lua_pop(L,2);
  enum { lc140 = 16 };
  while ((((lc139_step > 0) && (lc137_var <= lc138_limit)) || ((lc139_step <= 0) && (lc137_var >= lc138_limit)))) {
    
    /* internal: local yy at index 17 */
    lua_pushnumber(L,lc137_var);
    
    /* for zz = z - dev, z + dev do */
    lc_sub(L,7,16);
    lc_add(L,7,16);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc141_var = lua_tonumber(L,-2);
    const double lc142_limit = lua_tonumber(L,-1);
    const double lc143_step = 1;
    lua_pop(L,2);
    enum { lc144 = 17 };
    while ((((lc143_step > 0) && (lc141_var <= lc142_limit)) || ((lc143_step <= 0) && (lc141_var >= lc142_limit)))) {
      
      /* internal: local zz at index 18 */
      lua_pushnumber(L,lc141_var);
      
      /* local vi = a:index(x - dev, yy, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lc_sub(L,5,16);
      lua_pushvalue(L,17);
      lua_pushvalue(L,18);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 19);
      
      /* local via = a:index(x - dev, yy + 1, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lc_sub(L,5,16);
      lua_pushnumber(L,1);
      lc_add(L,17,-1);
      lua_remove(L,-2);
      lua_pushvalue(L,18);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 20);
      
      /* for xx = x - dev, x + dev do */
      lc_sub(L,5,16);
      lc_add(L,5,16);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc145_var = lua_tonumber(L,-2);
      const double lc146_limit = lua_tonumber(L,-1);
      const double lc147_step = 1;
      lua_pop(L,2);
      enum { lc148 = 20 };
      while ((((lc147_step > 0) && (lc145_var <= lc146_limit)) || ((lc147_step <= 0) && (lc145_var >= lc146_limit)))) {
        
        /* internal: local xx at index 21 */
        lua_pushnumber(L,lc145_var);
        
        /* if math.random() < 0.95 - dev * 0.05 then */
        enum { lc149 = 21 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,1);
        lua_pushnumber(L,0.95);
        lua_pushnumber(L,0.05);
        lc_mul(L,16,-1);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc150 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc150);
        const int lc151 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc151) {
          
          /* mg_villages.trees_add_pine_needles(data, vi, c_air, c_ignore, c_snow,
           * 							c_pine_needles) */
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"trees_add_pine_needles");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_pushvalue(L,19);
          lua_pushvalue(L,9);
          lua_pushvalue(L,10);
          lua_pushvalue(L,13);
          lua_pushvalue(L,12);
          lua_call(L,6,0);
          assert(lua_gettop(L) == 21);
          
          /* if snow then */
          enum { lc152 = 21 };
          if (lua_toboolean(L,4)) {
            
            /* mg_villages.trees_add_snow(data, via, c_air, c_ignore, c_snow) */
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"trees_add_snow");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_pushvalue(L,20);
            lua_pushvalue(L,9);
            lua_pushvalue(L,10);
            lua_pushvalue(L,13);
            lua_call(L,5,0);
            assert(lua_gettop(L) == 21);
          }
          lua_settop(L,lc152);
          assert(lua_gettop(L) == 21);
        }
        lua_settop(L,lc149);
        assert(lua_gettop(L) == 21);
        
        /* vi  = vi + 1 */
        lua_pushnumber(L,1);
        lc_add(L,19,-1);
        lua_remove(L,-2);
        lua_replace(L,19);
        assert(lua_gettop(L) == 21);
        
        /* via = via + 1 */
        lua_pushnumber(L,1);
        lc_add(L,20,-1);
        lua_remove(L,-2);
        lua_replace(L,20);
        assert(lua_gettop(L) == 21);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc145_var += lc147_step;
      }
      lua_settop(L,lc148);
      assert(lua_gettop(L) == 20);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
      lc141_var += lc143_step;
    }
    lua_settop(L,lc144);
    assert(lua_gettop(L) == 17);
    
    /* dev = dev - 1 */
    lua_pushnumber(L,1);
    lc_sub(L,16,-1);
    lua_remove(L,-2);
    lua_replace(L,16);
    assert(lua_gettop(L) == 17);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc137_var += lc139_step;
  }
  lua_settop(L,lc140);
  assert(lua_gettop(L) == 16);
  
  /* -- Centre top nodes
   * mg_villages.trees_add_pine_needles(data, a:index(x, maxy + 1, z), c_air, c_ignore, c_snow,
   * 			c_pine_needles) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"trees_add_pine_needles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"index");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_pushnumber(L,1);
  lc_add(L,8,-1);
  lua_remove(L,-2);
  lua_pushvalue(L,7);
  lua_call(L,4,1);
  lua_pushvalue(L,9);
  lua_pushvalue(L,10);
  lua_pushvalue(L,13);
  lua_pushvalue(L,12);
  lua_call(L,6,0);
  assert(lua_gettop(L) == 16);
  
  /* mg_villages.trees_add_pine_needles(data, a:index(x, maxy + 2, z), c_air, c_ignore, c_snow,
   * 			c_pine_needles) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"trees_add_pine_needles");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"index");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_pushnumber(L,2);
  lc_add(L,8,-1);
  lua_remove(L,-2);
  lua_pushvalue(L,7);
  lua_call(L,4,1);
  lua_pushvalue(L,9);
  lua_pushvalue(L,10);
  lua_pushvalue(L,13);
  lua_pushvalue(L,12);
  lua_call(L,6,0);
  assert(lua_gettop(L) == 16);
  
  /* -- Paramat added a pointy top node
   * if snow then */
  enum { lc153 = 16 };
  if (lua_toboolean(L,4)) {
    
    /* mg_villages.trees_add_snow(data, a:index(x, maxy + 3, z), c_air, c_ignore, c_snow) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"trees_add_snow");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,5);
    lua_pushnumber(L,3);
    lc_add(L,8,-1);
    lua_remove(L,-2);
    lua_pushvalue(L,7);
    lua_call(L,4,1);
    lua_pushvalue(L,9);
    lua_pushvalue(L,10);
    lua_pushvalue(L,13);
    lua_call(L,5,0);
    assert(lua_gettop(L) == 16);
  }
  lua_settop(L,lc153);
  assert(lua_gettop(L) == 16);
  
  /* -- Lower branches layer
   * local my = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 17);
  
  /* for i = 1, 20 do -- Random 2x2 squares of needles */
  lua_pushnumber(L,1);
  lua_pushnumber(L,20);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc154_var = lua_tonumber(L,-2);
  const double lc155_limit = lua_tonumber(L,-1);
  const double lc156_step = 1;
  lua_pop(L,2);
  enum { lc157 = 17 };
  while ((((lc156_step > 0) && (lc154_var <= lc155_limit)) || ((lc156_step <= 0) && (lc154_var >= lc155_limit)))) {
    
    /* internal: local i at index 18 */
    lua_pushnumber(L,lc154_var);
    
    /* -- Random 2x2 squares of needles
     * local xi = x + math.random(-3, 2) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,-3);
    lua_pushnumber(L,2);
    lua_call(L,2,1);
    lc_add(L,5,-1);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 19);
    
    /* local yy = maxy + math.random(-6, -5) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,-6);
    lua_pushnumber(L,-5);
    lua_call(L,2,1);
    lc_add(L,8,-1);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 20);
    
    /* local zi = z + math.random(-3, 2) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,-3);
    lua_pushnumber(L,2);
    lua_call(L,2,1);
    lc_add(L,7,-1);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 21);
    
    /* if yy > my then */
    enum { lc158 = 21 };
    const int lc159 = lua_lessthan(L,17,20);
    lua_pushboolean(L,lc159);
    const int lc160 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc160) {
      
      /* my = yy */
      lua_pushvalue(L,20);
      lua_replace(L,17);
      assert(lua_gettop(L) == 21);
    }
    lua_settop(L,lc158);
    assert(lua_gettop(L) == 21);
    
    /* for zz = zi, zi+1 do */
    lua_pushnumber(L,1);
    lc_add(L,21,-1);
    lua_remove(L,-2);
    if (!((lua_isnumber(L,21) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc161_var = lua_tonumber(L,21);
    const double lc162_limit = lua_tonumber(L,-1);
    const double lc163_step = 1;
    lua_pop(L,1);
    enum { lc164 = 21 };
    while ((((lc163_step > 0) && (lc161_var <= lc162_limit)) || ((lc163_step <= 0) && (lc161_var >= lc162_limit)))) {
      
      /* internal: local zz at index 22 */
      lua_pushnumber(L,lc161_var);
      
      /* local vi = a:index(xi, yy, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,19);
      lua_pushvalue(L,20);
      lua_pushvalue(L,22);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 23);
      
      /* local via = a:index(xi, yy + 1, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,19);
      lua_pushnumber(L,1);
      lc_add(L,20,-1);
      lua_remove(L,-2);
      lua_pushvalue(L,22);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 24);
      
      /* for xx = xi, xi + 1 do */
      lua_pushnumber(L,1);
      lc_add(L,19,-1);
      lua_remove(L,-2);
      if (!((lua_isnumber(L,19) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc165_var = lua_tonumber(L,19);
      const double lc166_limit = lua_tonumber(L,-1);
      const double lc167_step = 1;
      lua_pop(L,1);
      enum { lc168 = 24 };
      while ((((lc167_step > 0) && (lc165_var <= lc166_limit)) || ((lc167_step <= 0) && (lc165_var >= lc166_limit)))) {
        
        /* internal: local xx at index 25 */
        lua_pushnumber(L,lc165_var);
        
        /* mg_villages.trees_add_pine_needles(data, vi, c_air, c_ignore, c_snow,
         * 						c_pine_needles) */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"trees_add_pine_needles");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,23);
        lua_pushvalue(L,9);
        lua_pushvalue(L,10);
        lua_pushvalue(L,13);
        lua_pushvalue(L,12);
        lua_call(L,6,0);
        assert(lua_gettop(L) == 25);
        
        /* if snow then */
        enum { lc169 = 25 };
        if (lua_toboolean(L,4)) {
          
          /* mg_villages.trees_add_snow(data, via, c_air, c_ignore, c_snow) */
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"trees_add_snow");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_pushvalue(L,24);
          lua_pushvalue(L,9);
          lua_pushvalue(L,10);
          lua_pushvalue(L,13);
          lua_call(L,5,0);
          assert(lua_gettop(L) == 25);
        }
        lua_settop(L,lc169);
        assert(lua_gettop(L) == 25);
        
        /* vi  = vi + 1 */
        lua_pushnumber(L,1);
        lc_add(L,23,-1);
        lua_remove(L,-2);
        lua_replace(L,23);
        assert(lua_gettop(L) == 25);
        
        /* via = via + 1 */
        lua_pushnumber(L,1);
        lc_add(L,24,-1);
        lua_remove(L,-2);
        lua_replace(L,24);
        assert(lua_gettop(L) == 25);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc165_var += lc167_step;
      }
      lua_settop(L,lc168);
      assert(lua_gettop(L) == 24);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
      lc161_var += lc163_step;
    }
    lua_settop(L,lc164);
    assert(lua_gettop(L) == 21);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
    lc154_var += lc156_step;
  }
  lua_settop(L,lc157);
  assert(lua_gettop(L) == 17);
  
  /* local dev = 2 */
  lua_pushnumber(L,2);
  assert(lua_gettop(L) == 18);
  
  /* for yy = my + 1, my + 2 do */
  lua_pushnumber(L,1);
  lc_add(L,17,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_add(L,17,-1);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc170_var = lua_tonumber(L,-2);
  const double lc171_limit = lua_tonumber(L,-1);
  const double lc172_step = 1;
  lua_pop(L,2);
  enum { lc173 = 18 };
  while ((((lc172_step > 0) && (lc170_var <= lc171_limit)) || ((lc172_step <= 0) && (lc170_var >= lc171_limit)))) {
    
    /* internal: local yy at index 19 */
    lua_pushnumber(L,lc170_var);
    
    /* for zz = z - dev, z + dev do */
    lc_sub(L,7,18);
    lc_add(L,7,18);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc174_var = lua_tonumber(L,-2);
    const double lc175_limit = lua_tonumber(L,-1);
    const double lc176_step = 1;
    lua_pop(L,2);
    enum { lc177 = 19 };
    while ((((lc176_step > 0) && (lc174_var <= lc175_limit)) || ((lc176_step <= 0) && (lc174_var >= lc175_limit)))) {
      
      /* internal: local zz at index 20 */
      lua_pushnumber(L,lc174_var);
      
      /* local vi = a:index(x - dev, yy, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lc_sub(L,5,18);
      lua_pushvalue(L,19);
      lua_pushvalue(L,20);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 21);
      
      /* local via = a:index(x - dev, yy + 1, zz) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lc_sub(L,5,18);
      lua_pushnumber(L,1);
      lc_add(L,19,-1);
      lua_remove(L,-2);
      lua_pushvalue(L,20);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 22);
      
      /* for xx = x - dev, x + dev do */
      lc_sub(L,5,18);
      lc_add(L,5,18);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc178_var = lua_tonumber(L,-2);
      const double lc179_limit = lua_tonumber(L,-1);
      const double lc180_step = 1;
      lua_pop(L,2);
      enum { lc181 = 22 };
      while ((((lc180_step > 0) && (lc178_var <= lc179_limit)) || ((lc180_step <= 0) && (lc178_var >= lc179_limit)))) {
        
        /* internal: local xx at index 23 */
        lua_pushnumber(L,lc178_var);
        
        /* if math.random() < 0.95 - dev * 0.05 then */
        enum { lc182 = 23 };
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,1);
        lua_pushnumber(L,0.95);
        lua_pushnumber(L,0.05);
        lc_mul(L,18,-1);
        lua_remove(L,-2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc183 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc183);
        const int lc184 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc184) {
          
          /* mg_villages.trees_add_pine_needles(data, vi, c_air, c_ignore, c_snow,
           * 							c_pine_needles) */
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"trees_add_pine_needles");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_pushvalue(L,21);
          lua_pushvalue(L,9);
          lua_pushvalue(L,10);
          lua_pushvalue(L,13);
          lua_pushvalue(L,12);
          lua_call(L,6,0);
          assert(lua_gettop(L) == 23);
          
          /* if snow then */
          enum { lc185 = 23 };
          if (lua_toboolean(L,4)) {
            
            /* mg_villages.trees_add_snow(data, via, c_air, c_ignore, c_snow) */
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"trees_add_snow");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_pushvalue(L,22);
            lua_pushvalue(L,9);
            lua_pushvalue(L,10);
            lua_pushvalue(L,13);
            lua_call(L,5,0);
            assert(lua_gettop(L) == 23);
          }
          lua_settop(L,lc185);
          assert(lua_gettop(L) == 23);
        }
        lua_settop(L,lc182);
        assert(lua_gettop(L) == 23);
        
        /* vi  = vi + 1 */
        lua_pushnumber(L,1);
        lc_add(L,21,-1);
        lua_remove(L,-2);
        lua_replace(L,21);
        assert(lua_gettop(L) == 23);
        
        /* via = via + 1 */
        lua_pushnumber(L,1);
        lc_add(L,22,-1);
        lua_remove(L,-2);
        lua_replace(L,22);
        assert(lua_gettop(L) == 23);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc178_var += lc180_step;
      }
      lua_settop(L,lc181);
      assert(lua_gettop(L) == 22);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
      lc174_var += lc176_step;
    }
    lua_settop(L,lc177);
    assert(lua_gettop(L) == 19);
    
    /* dev = dev - 1 */
    lua_pushnumber(L,1);
    lc_sub(L,18,-1);
    lua_remove(L,-2);
    lua_replace(L,18);
    assert(lua_gettop(L) == 19);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc170_var += lc172_step;
  }
  lua_settop(L,lc173);
  assert(lua_gettop(L) == 18);
  
  /* -- Trunk
   * for yy = y, maxy do */
  if (!((lua_isnumber(L,6) && lua_isnumber(L,8)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc186_var = lua_tonumber(L,6);
  const double lc187_limit = lua_tonumber(L,8);
  const double lc188_step = 1;
  lua_pop(L,0);
  enum { lc189 = 18 };
  while ((((lc188_step > 0) && (lc186_var <= lc187_limit)) || ((lc188_step <= 0) && (lc186_var >= lc187_limit)))) {
    
    /* internal: local yy at index 19 */
    lua_pushnumber(L,lc186_var);
    
    /* local vi = a:index(x, yy, z) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,5);
    lua_pushvalue(L,19);
    lua_pushvalue(L,7);
    lua_call(L,4,1);
    assert(lua_gettop(L) == 20);
    
    /* data[vi] = c_pinetree */
    lua_pushvalue(L,11);
    lua_pushvalue(L,20);
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 20);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc186_var += lc188_step;
  }
  lua_settop(L,lc189);
  assert(lua_gettop(L) == 18);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- this code is taken from https://github.com/VanessaE/dreambuilder_game/blob/master/mods/default/trees.lua
   * local c_air = minetest.get_content_id("air") */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local c_ignore = minetest.get_content_id("ignore") */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ignore");
  lua_call(L,1,1);
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local c_tree = minetest.get_content_id("default:tree") */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc3 = 3 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:tree");
  lua_call(L,1,1);
  lua_rawseti(L,(lc3 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local c_leaves = minetest.get_content_id("default:leaves") */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 4 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:leaves");
  lua_call(L,1,1);
  lua_rawseti(L,(lc4 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local c_sapling = minetest.get_content_id("default:sapling") */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc5 = 5 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:sapling");
  lua_call(L,1,1);
  lua_rawseti(L,(lc5 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local c_junglesapling = minetest.get_content_id("default:junglesapling") */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc6 = 6 };
  assert((lua_gettop(L) == (lc6 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:junglesapling");
  lua_call(L,1,1);
  lua_rawseti(L,(lc6 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local c_snow = minetest.get_content_id("default:snow") */
  lc_newclosuretable(L,(lc6 + lc_nextra));
  enum { lc7 = 7 };
  assert((lua_gettop(L) == (lc7 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:snow");
  lua_call(L,1,1);
  lua_rawseti(L,(lc7 + lc_nextra),7);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* local c_msnow_top = minetest.get_content_id( 'moresnow:snow_top' ) */
  lc_newclosuretable(L,(lc7 + lc_nextra));
  enum { lc8 = 8 };
  assert((lua_gettop(L) == (lc8 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_top");
  lua_call(L,1,1);
  lua_rawseti(L,(lc8 + lc_nextra),8);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local c_msnow_leaves1 = minetest.get_content_id( 'default:leaves' ) */
  lc_newclosuretable(L,(lc8 + lc_nextra));
  enum { lc9 = 9 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:leaves");
  lua_call(L,1,1);
  lua_rawseti(L,(lc9 + lc_nextra),9);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* local c_msnow_leaves2 = minetest.get_content_id( 'default:leaves' ) */
  lc_newclosuretable(L,(lc9 + lc_nextra));
  enum { lc10 = 10 };
  assert((lua_gettop(L) == (lc10 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:leaves");
  lua_call(L,1,1);
  lua_rawseti(L,(lc10 + lc_nextra),10);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* if( minetest.registered_nodes[ 'moresnow:autumnleaves_tree' ] ) then */
  enum { lc11 = 10 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:autumnleaves_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc12 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc12) {
    
    /* c_msnow_leaves1 = minetest.get_content_id( 'moresnow:autumnleaves_tree' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moresnow:autumnleaves_tree");
    lua_call(L,1,1);
    lc_setupvalue(L,(lc10 + lc_nextra),1,9);
    assert(lua_gettop(L) - lc_nextra == 10);
  }
  lua_settop(L,(lc11 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* if( minetest.registered_nodes[ 'moresnow:winterleaves_tree' ] ) then */
  enum { lc13 = 10 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:winterleaves_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc14 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc14) {
    
    /* c_msnow_leaves2 = minetest.get_content_id( 'moresnow:winterleaves_tree' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moresnow:winterleaves_tree");
    lua_call(L,1,1);
    lc_setupvalue(L,(lc10 + lc_nextra),0,10);
    assert(lua_gettop(L) - lc_nextra == 10);
  }
  lua_settop(L,(lc13 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* mg_villages.grow_tree = function(data, a, pos, is_apple_tree, seed, snow)
   *         --[[
   *                 NOTE: Tree-placing code is currently duplicated in the engine
   *                 and in games that have saplings; both are deprecated but not
   *                 replaced yet
   *         ]]--
   *     local leaves_type = c_leaves;
   *     if(  snow
   *       or data[ a:index(pos.x, pos.y,   pos.z) ] == c_snow
   *       or data[ a:index(pos.x, pos.y+1, pos.z) ] == c_snow ) then
   *        leaves_type = c_msnow_leaves2; 
   *     end
   * 
   *     local hight = math.random(4, 5)
   *     for x_area = -2, 2 do
   *     for y_area = -1, 2 do
   *     for z_area = -2, 2 do
   *         if math.random(1,30) < 23 then  --randomize leaves
   *             local area_l = a:index(pos.x+x_area, pos.y+hight+y_area-1, pos.z+z_area)  --sets area for leaves
   *             if data[area_l] == c_air or data[area_l] == c_ignore or data[area_l]== c_snow then    --sets if it's air or ignore 
   * 		if( snow and c_msnow_leaves1 and math.random( 1,5 )==1) then
   * 			data[area_l] = c_msnow_leaves1;
   * 		else
   * 	                data[area_l] = leaves_type    --add leaves now
   * 		end
   *             end
   *             -- put a snow top on some leaves
   *             if ( snow and math.random(1,3)==1 )then
   *                mg_villages.trees_add_snow(data, a:index(pos.x+x_area, pos.y+hight+y_area, pos.z+z_area), c_air, c_ignore, c_snow)
   *             end
   *          end       
   *     end
   *     end
   *     end
   *     for tree_h = 0, hight-1 do  -- add the trunk
   *         local area_t = a:index(pos.x, pos.y+tree_h, pos.z)  --set area for tree
   *         if data[area_t] == c_air or data[area_t] == c_leaves or data[area_t] == c_sapling or data[area_t] == c_snow or data[area_t] == c_msnow_top or data[area_t] == c_msnow_leaves1 or data[area_t] == c_msnow_leaves2 then    --sets if air
   *             data[area_t] = c_tree    --add tree now
   *         end
   *     end
   * end */
  lua_pushvalue(L,(lc10 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_grow_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* local c_jungletree = minetest.get_content_id("default:jungletree") */
  lc_newclosuretable(L,(lc10 + lc_nextra));
  enum { lc58 = 11 };
  assert((lua_gettop(L) == (lc58 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:jungletree");
  lua_call(L,1,1);
  lua_rawseti(L,(lc58 + lc_nextra),11);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local c_jungleleaves = minetest.get_content_id("default:jungleleaves") */
  lc_newclosuretable(L,(lc58 + lc_nextra));
  enum { lc59 = 12 };
  assert((lua_gettop(L) == (lc59 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:jungleleaves");
  lua_call(L,1,1);
  lua_rawseti(L,(lc59 + lc_nextra),12);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* mg_villages.grow_jungletree = function(data, a, pos, seed, snow)
   *         --[[
   *                 NOTE: Tree-placing code is currently duplicated in the engine
   *                 and in games that have saplings; both are deprecated but not
   *                 replaced yet
   *         ]]--
   *     local leaves_type = c_jungleleaves;
   *     if(  snow
   *       or data[ a:index(pos.x, pos.y,   pos.z) ] == c_snow
   *       or data[ a:index(pos.x, pos.y+1, pos.z) ] == c_snow ) then
   *        leaves_type = c_msnow_leaves1;
   *     end
   * 
   *     local hight = math.random(8, 12)
   *     for x_area = -3, 3 do
   *     for y_area = -2, 2 do
   *     for z_area = -3, 3 do
   *         if math.random(1,30) < 23 then  --randomize leaves
   *             local area_l = a:index(pos.x+x_area, pos.y+hight+y_area-1, pos.z+z_area)  --sets area for leaves
   *             if data[area_l] == c_air or data[area_l] == c_ignore then    --sets if it's air or ignore
   *                 data[area_l] = leaves_type    --add leaves now
   *             end
   *          end       
   *     end
   *     end
   *     end
   *     for tree_h = 0, hight-1 do  -- add the trunk
   *         local area_t = a:index(pos.x, pos.y+tree_h, pos.z)  --set area for tree
   *         if data[area_t] == c_air or data[area_t] == c_jungleleaves or data[area_t] == c_junglesapling or data[area_t] == c_snow or data[area_t] == c_msnow_top then    --sets if air
   *             data[area_t] = c_jungletree    --add tree now
   *         end
   *     end
   *     for roots_x = -1, 1 do
   *     for roots_z = -1, 1 do
   *         if math.random(1, 3) >= 2 then  --randomize roots
   *             if a:contains(pos.x+roots_x, pos.y-1, pos.z+roots_z) and data[a:index(pos.x+roots_x, pos.y-1, pos.z+roots_z)] == c_air then
   *                 data[a:index(pos.x+roots_x, pos.y-1, pos.z+roots_z)] = c_jungletree
   *             elseif a:contains(pos.x+roots_x, pos.y, pos.z+roots_z) and data[a:index(pos.x+roots_x, pos.y, pos.z+roots_z)] == c_air then
   *                 data[a:index(pos.x+roots_x, pos.y, pos.z+roots_z)] = c_jungletree
   *             end
   *         end
   *     end
   *     end
   * end */
  lua_pushvalue(L,(lc59 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_grow_jungletree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_jungletree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* -- taken from minetest_game/mods/default/trees.lua
   * mg_villages.trees_add_pine_needles = function(data, vi, c_air, c_ignore, c_snow, c_pine_needles)
   * 	if data[vi] == c_air or data[vi] == c_ignore or data[vi] == c_snow then
   * 		data[vi] = c_pine_needles
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_trees_add_pine_needles);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"trees_add_pine_needles");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* mg_villages.trees_add_snow = function(data, vi, c_air, c_ignore, c_snow)
   * 	if data[vi] == c_air or data[vi] == c_ignore then
   * 		data[vi] = c_snow
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_trees_add_snow);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"trees_add_snow");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* mg_villages.grow_pinetree = function(data, a, pos, snow)
   * 	local x, y, z = pos.x, pos.y, pos.z
   * 	local maxy = y + math.random(9, 13) -- Trunk top
   * 
   * 	local c_air = minetest.get_content_id("air")
   * 	local c_ignore = minetest.get_content_id("ignore")
   * 	local c_pinetree = minetest.get_content_id("default:pine_tree")
   * 	local c_pine_needles  = minetest.get_content_id("default:pine_needles")
   * 	local c_snow = minetest.get_content_id("default:snow")
   * 	local c_snowblock = minetest.get_content_id("default:snowblock")
   * 	local c_dirtsnow = minetest.get_content_id("default:dirt_with_snow")
   * 
   * 	-- Scan for snow nodes near sapling
   * --	local snow = false
   * 	for yy = y - 1, y + 1 do
   * 	for zz = z - 1, z + 1 do
   * 		local vi  = a:index(x - 1, yy, zz)
   * 		for xx = x - 1, x + 1 do
   * 			local nodid = data[vi]
   * 			if nodid == c_snow
   * 			or nodid == c_snowblock
   * 			or nodid == c_dirtsnow then
   * 				snow = true
   * 			end
   * 			vi  = vi + 1
   * 		end
   * 	end
   * 	end
   * 
   * 	-- Upper branches layer
   * 	local dev = 3
   * 	for yy = maxy - 1, maxy + 1 do
   * 		for zz = z - dev, z + dev do
   * 			local vi = a:index(x - dev, yy, zz)
   * 			local via = a:index(x - dev, yy + 1, zz)
   * 			for xx = x - dev, x + dev do
   * 				if math.random() < 0.95 - dev * 0.05 then
   * 					mg_villages.trees_add_pine_needles(data, vi, c_air, c_ignore, c_snow,
   * 							c_pine_needles)
   * 					if snow then
   * 						mg_villages.trees_add_snow(data, via, c_air, c_ignore, c_snow)
   * 					end
   * 				end
   * 				vi  = vi + 1
   * 				via = via + 1
   * 			end
   * 		end
   * 		dev = dev - 1
   * 	end
   * 
   * 	-- Centre top nodes
   * 	mg_villages.trees_add_pine_needles(data, a:index(x, maxy + 1, z), c_air, c_ignore, c_snow,
   * 			c_pine_needles)
   * 	mg_villages.trees_add_pine_needles(data, a:index(x, maxy + 2, z), c_air, c_ignore, c_snow,
   * 			c_pine_needles) -- Paramat added a pointy top node
   * 	if snow then
   * 		mg_villages.trees_add_snow(data, a:index(x, maxy + 3, z), c_air, c_ignore, c_snow)
   * 	end
   * 
   * 	-- Lower branches layer
   * 	local my = 0
   * 	for i = 1, 20 do -- Random 2x2 squares of needles
   * 		local xi = x + math.random(-3, 2)
   * 		local yy = maxy + math.random(-6, -5)
   * 		local zi = z + math.random(-3, 2)
   * 		if yy > my then
   * 			my = yy
   * 		end
   * 		for zz = zi, zi+1 do
   * 			local vi = a:index(xi, yy, zz)
   * 			local via = a:index(xi, yy + 1, zz)
   * 			for xx = xi, xi + 1 do
   * 				mg_villages.trees_add_pine_needles(data, vi, c_air, c_ignore, c_snow,
   * 						c_pine_needles)
   * 				if snow then
   * 					mg_villages.trees_add_snow(data, via, c_air, c_ignore, c_snow)
   * 				end
   * 				vi  = vi + 1
   * 				via = via + 1
   * 			end
   * 		end
   * 	end
   * 
   * 	local dev = 2
   * 	for yy = my + 1, my + 2 do
   * 		for zz = z - dev, z + dev do
   * 			local vi = a:index(x - dev, yy, zz)
   * 			local via = a:index(x - dev, yy + 1, zz)
   * 			for xx = x - dev, x + dev do
   * 				if math.random() < 0.95 - dev * 0.05 then
   * 					mg_villages.trees_add_pine_needles(data, vi, c_air, c_ignore, c_snow,
   * 							c_pine_needles)
   * 					if snow then
   * 						mg_villages.trees_add_snow(data, via, c_air, c_ignore, c_snow)
   * 					end
   * 				end
   * 				vi  = vi + 1
   * 				via = via + 1
   * 			end
   * 		end
   * 		dev = dev - 1
   * 	end
   * 
   * 	-- Trunk
   * 	for yy = y, maxy do
   * 		local vi = a:index(x, yy, z)
   * 		data[vi] = c_pinetree
   * 	end
   * 
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_grow_pinetree);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_pinetree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_trees(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}



