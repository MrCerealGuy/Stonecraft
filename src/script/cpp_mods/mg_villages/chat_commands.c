/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.list_villages_formspec
 * function( player, formname, fields) */
static int lcf1_mg_villages_list_villages_formspec (lua_State * L) {
  lua_checkstack(L,26);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if( not( player ) or fields.quit) then */
  enum { lc1 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,1)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"quit");
    lua_gettable(L,3);
  }
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 3);
  
  /* local pname = player:get_player_name() */
  lua_pushvalue(L,1);
  lua_pushliteral(L,"get_player_name");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* local ppos  = player:getpos() */
  lua_pushvalue(L,1);
  lua_pushliteral(L,"getpos");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* local radius = 1000000 */
  lua_pushnumber(L,1000000);
  assert(lua_gettop(L) == 6);
  
  /* -- without the special priv, players can only obtain informatoin about villages which are very close by
   * if( not( minetest.check_player_privs( pname, {mg_villages=true}))) then */
  enum { lc3 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"check_player_privs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"mg_villages");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc4 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc4) {
    
    /* radius = mg_villages.VILLAGE_DETECT_RANGE */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"VILLAGE_DETECT_RANGE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,6);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc3);
  assert(lua_gettop(L) == 6);
  
  /* local formspec = 'size[12,12]'..
   * 			'button_exit[4.0,1.5;2,0.5;quit;Quit]'..
   * 			'tablecolumns[' ..
   * 			'text,align=right;'..	-- village number
   * 			'text,align=right;'..	-- distance from player
   * 			'text,align=center;'..	-- name of village
   * 			'text,align=center;'..	-- typ of village
   * 			'text,align=right;'..	-- x
   * 			'text,align=right;'..	-- y
   * 			'text,align=right;'..	-- z
   * 			'text,align=right;'..	-- size
   * 			'text,align=right;'..	-- #houses where inhabitants may live or work
   * 			'text,align=right]'..
   *                         'table[0.1,2.7;11.4,8.8;'..formname..';' */
  lua_pushliteral(L,"size[12,12]");
  lua_pushliteral(L,"button_exit[4.0,1.5;2,0.5;quit;Quit]");
  lua_pushliteral(L,"tablecolumns[");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=center;");
  lua_pushliteral(L,"text,align=center;");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=right;");
  lua_pushliteral(L,"text,align=right]");
  lua_pushliteral(L,"table[0.1,2.7;11.4,8.8;");
  lua_pushvalue(L,2);
  lua_pushliteral(L,";");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  assert(lua_gettop(L) == 7);
  
  /* for k,v in pairs( mg_villages.all_villages ) do
   * internal: local f, s, var = explist */
  enum { lc5 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local k with idx 11
     * internal: local v with idx 12 */
    
    
    /* local dx = math.abs( v.vx - ppos.x ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"vx");
    lua_gettable(L,12);
    lua_pushliteral(L,"x");
    lua_gettable(L,5);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 13);
    
    /* local dz = math.abs( v.vz - ppos.z ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"vz");
    lua_gettable(L,12);
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 14);
    
    /* -- distance in y direction is less relevant here and may be ignored
     * if( dx + dz < radius ) then */
    enum { lc6 = 14 };
    lc_add(L,13,14);
    const int lc7 = lua_lessthan(L,-1,6);
    lua_pop(L,1);
    lua_pushboolean(L,lc7);
    const int lc8 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc8) {
      
      /* local dist = math.sqrt( dx * dx + dz * dz ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"sqrt");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_mul(L,13,13);
      lc_mul(L,14,14);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 15);
      
      /* local is_full_village = 'village' */
      lua_pushliteral(L,"village");
      assert(lua_gettop(L) == 16);
      
      /* if( v.is_single_house ) then */
      enum { lc9 = 16 };
      lua_pushliteral(L,"is_single_house");
      lua_gettable(L,12);
      const int lc10 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc10) {
        
        /* is_full_village = '' */
        lua_pushliteral(L,"");
        lua_replace(L,16);
        assert(lua_gettop(L) == 16);
      }
      lua_settop(L,lc9);
      assert(lua_gettop(L) == 16);
      
      /* formspec = formspec..
       * 				v.nr..','..
       * 				tostring( math.floor( dist ))..','..
       * 				tostring( v.name or 'unknown' )..','..
       * 				v.village_type..','..
       * 				tostring( v.vx )..','..
       * 				tostring( v.vh )..','..
       * 				tostring( v.vz )..','..
       * 				tostring( v.vs )..','..
       * 				tostring( v.anz_buildings )..','..
       * 				tostring( is_full_village )..',' */
      lua_pushvalue(L,7);
      lua_pushliteral(L,"nr");
      lua_gettable(L,12);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      const int lc11 = lua_gettop(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"floor");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,15);
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc11),1);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"name");
      lua_gettable(L,12);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"unknown");
      }
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_pushliteral(L,"village_type");
      lua_gettable(L,12);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vx");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vh");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vz");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vs");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"anz_buildings");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushvalue(L,16);
      lua_call(L,1,1);
      lua_pushliteral(L,",");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,7);
      assert(lua_gettop(L) == 16);
    }
    lua_settop(L,lc6);
    assert(lua_gettop(L) == 14);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
  }
  lua_settop(L,lc5);
  assert(lua_gettop(L) == 7);
  
  /* formspec = formspec..';]'..
   * 			'tabheader[0.1,2.2;spalte;Nr,Dist,Name of village,Type of village,_X_,_H_,_Z_,Size,Buildings;;true;true]' */
  lua_pushvalue(L,7);
  lua_pushliteral(L,";]");
  lua_pushliteral(L,"tabheader[0.1,2.2;spalte;Nr,Dist,Name of village,Type of village,_X_,_H_,_Z_,Size,Buildings;;true;true]");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_replace(L,7);
  assert(lua_gettop(L) == 7);
  
  /* minetest.show_formspec( pname, formname, formspec ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"show_formspec");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_pushvalue(L,2);
  lua_pushvalue(L,7);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* function(name, param) */
static int lcf12 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* mg_villages.list_villages_formspec( minetest.get_player_by_name( name ), "mg:village_list", {}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"list_villages_formspec");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_player_by_name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"mg:village_list");
  lua_newtable(L);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* function(name, param) */
static int lcf22 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if( mg_villages.REQUIRE_PRIV_FOR_TELEPORT and not( minetest.check_player_privs( name, {mg_villages=true}))) then */
  enum { lc13 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"REQUIRE_PRIV_FOR_TELEPORT");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"check_player_privs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"mg_villages");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc14 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc14) {
    
    /* minetest.chat_send_player( name, "You need the 'mg_villages' priv in order to teleport to villages using this command.") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"chat_send_player");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushliteral(L,"You need the 'mg_villages' priv in order to teleport to villages using this command.");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc13);
  assert(lua_gettop(L) == 2);
  
  /* if( not( param ) or param == "" ) then */
  enum { lc15 = 2 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"");
    const int lc16 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc16);
  }
  const int lc17 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc17) {
    
    /* minetest.chat_send_player( name, "Which village do you want to visit? Please provide the village number!") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"chat_send_player");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushliteral(L,"Which village do you want to visit? Please provide the village number!");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc15);
  assert(lua_gettop(L) == 2);
  
  /* local nr = tonumber( param ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* for id, v in pairs( mg_villages.all_villages ) do
   * 			-- we have found the village
   * internal: local f, s, var = explist */
  enum { lc18 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local id with idx 7
     * internal: local v with idx 8 */
    
    
    /* -- we have found the village
     * if( v and v.nr == nr ) then */
    enum { lc19 = 8 };
    lua_pushvalue(L,8);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"nr");
      lua_gettable(L,8);
      lua_pushvalue(L,3);
      const int lc20 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc20);
    }
    const int lc21 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc21) {
      
      /* minetest.chat_send_player( name, "Initiating transfer to village no. "..tostring( v.nr )..", called "..( tostring( v.name or 'unknown'))..".") */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"chat_send_player");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_pushliteral(L,"Initiating transfer to village no. ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"nr");
      lua_gettable(L,8);
      lua_call(L,1,1);
      lua_pushliteral(L,", called ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"name");
      lua_gettable(L,8);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"unknown");
      }
      lua_call(L,1,1);
      lua_pushliteral(L,".");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 8);
      
      /* local player =  minetest.get_player_by_name( name ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_player_by_name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 9);
      
      /* player:moveto( { x=v.vx, y=(v.vh+1), z=v.vz }, false) */
      lua_pushvalue(L,9);
      lua_pushliteral(L,"moveto");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"vx");
      lua_gettable(L,8);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"vh");
      lua_gettable(L,8);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"vz");
      lua_gettable(L,8);
      lua_rawset(L,-3);
      lua_pushboolean(L,0);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 9);
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc19);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc18);
  assert(lua_gettop(L) == 3);
  
  /* -- no village found
   * minetest.chat_send_player( name, "There is no village with the number "..tostring( param ).." (yet?).") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"chat_send_player");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushliteral(L,"There is no village with the number ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_pushliteral(L," (yet?).");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* minetest.register_privilege("mg_villages", { description = "Allows to teleport to villages via /vist <nr>", give_to_singleplayer = false}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_privilege");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Allows to teleport to villages via /vist <nr>");
  lua_rawset(L,-3);
  lua_pushliteral(L,"give_to_singleplayer");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- this function is only used for the chat command currently
   * mg_villages.list_villages_formspec = function( player, formname, fields )
   * 
   * 	if( not( player ) or fields.quit) then
   * 		return
   * 	end
   * 	local pname = player:get_player_name();
   * 	local ppos  = player:getpos();
   * 
   * 
   * 	local radius = 1000000;
   * 	-- without the special priv, players can only obtain informatoin about villages which are very close by
   * 	if( not( minetest.check_player_privs( pname, {mg_villages=true}))) then
   * 		radius = mg_villages.VILLAGE_DETECT_RANGE;
   * 	end
   * 
   * 	local formspec = 'size[12,12]'..
   * 			'button_exit[4.0,1.5;2,0.5;quit;Quit]'..
   * 			'tablecolumns[' ..
   * 			'text,align=right;'..	-- village number
   * 			'text,align=right;'..	-- distance from player
   * 			'text,align=center;'..	-- name of village
   * 			'text,align=center;'..	-- typ of village
   * 			'text,align=right;'..	-- x
   * 			'text,align=right;'..	-- y
   * 			'text,align=right;'..	-- z
   * 			'text,align=right;'..	-- size
   * 			'text,align=right;'..	-- #houses where inhabitants may live or work
   * 			'text,align=right]'..
   *                         'table[0.1,2.7;11.4,8.8;'..formname..';';
   * 
   * 	for k,v in pairs( mg_villages.all_villages ) do
   * 
   * 		local dx = math.abs( v.vx - ppos.x );
   * 		local dz = math.abs( v.vz - ppos.z );
   * 		-- distance in y direction is less relevant here and may be ignored
   * 		if( dx + dz < radius ) then
   * 			local dist = math.sqrt( dx * dx + dz * dz );
   * 			local is_full_village = 'village';
   * 			if( v.is_single_house ) then
   * 				is_full_village = '';
   * 			end
   * 			formspec = formspec..
   * 				v.nr..','..
   * 				tostring( math.floor( dist ))..','..
   * 				tostring( v.name or 'unknown' )..','..
   * 				v.village_type..','..
   * 				tostring( v.vx )..','..
   * 				tostring( v.vh )..','..
   * 				tostring( v.vz )..','..
   * 				tostring( v.vs )..','..
   * 				tostring( v.anz_buildings )..','..
   * 				tostring( is_full_village )..',';
   * 		end
   * 	end
   * 
   *  	formspec = formspec..';]'..
   * 			'tabheader[0.1,2.2;spalte;Nr,Dist,Name of village,Type of village,_X_,_H_,_Z_,Size,Buildings;;true;true]';
   * 
   * 	minetest.show_formspec( pname, formname, formspec );
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_list_villages_formspec);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"list_villages_formspec");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_chatcommand( 'villages', {
   * 	description = "Shows a list of all known villages.",
   * 	privs = {},
   * 	func = function(name, param)
   * 		mg_villages.list_villages_formspec( minetest.get_player_by_name( name ), "mg:village_list", {});
   *         end
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_chatcommand");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"villages");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Shows a list of all known villages.");
  lua_rawset(L,-3);
  lua_pushliteral(L,"privs");
  lua_newtable(L);
  lua_rawset(L,-3);
  lua_pushliteral(L,"func");
  lua_pushcfunction(L,lcf12);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_chatcommand( 'visit', {
   *         description = "Teleports you to a known village.",
   * 	params = "<village number>",
   *         privs = {},
   *         func = function(name, param)
   * 
   * 
   * 		if( mg_villages.REQUIRE_PRIV_FOR_TELEPORT and not( minetest.check_player_privs( name, {mg_villages=true}))) then
   * 			minetest.chat_send_player( name, "You need the 'mg_villages' priv in order to teleport to villages using this command.");
   * 			return;
   * 		end
   * 
   * 		if( not( param ) or param == "" ) then
   * 			minetest.chat_send_player( name, "Which village do you want to visit? Please provide the village number!");
   * 			return;
   * 		end
   * 
   * 		local nr = tonumber( param );
   * 		for id, v in pairs( mg_villages.all_villages ) do
   * 			-- we have found the village
   * 			if( v and v.nr == nr ) then
   * 
   * 				minetest.chat_send_player( name, "Initiating transfer to village no. "..tostring( v.nr )..", called "..( tostring( v.name or 'unknown'))..".");
   * 				local player =  minetest.get_player_by_name( name );
   * 				player:moveto( { x=v.vx, y=(v.vh+1), z=v.vz }, false);
   * 				return;
   * 			end
   * 		end
   * 		-- no village found
   * 		minetest.chat_send_player( name, "There is no village with the number "..tostring( param ).." (yet?).");
   *         end
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_chatcommand");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"visit");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Teleports you to a known village.");
  lua_rawset(L,-3);
  lua_pushliteral(L,"params");
  lua_pushliteral(L,"<village number>");
  lua_rawset(L,-3);
  lua_pushliteral(L,"privs");
  lua_newtable(L);
  lua_rawset(L,-3);
  lua_pushliteral(L,"func");
  lua_pushcfunction(L,lcf22);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_chat_commands(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


