/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function( pos, node, clicker, itemstack, pointed_thing) */
static int lcf7 (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* return mg_villages.plotmarker_formspec( pos, nil, {}, clicker ) */
  const int lc6 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"plotmarker_formspec");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnil(L);
  lua_newtable(L);
  lua_pushvalue(L,3);
  lua_call(L,4,LUA_MULTRET);
  return (lua_gettop(L) - lc6);
  assert(lua_gettop(L) == 5);
}


/* function(pos, formname, fields, sender) */
static int lcf9 (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* return mg_villages.plotmarker_formspec( pos, formname, fields, sender ) */
  const int lc8 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"plotmarker_formspec");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,4,LUA_MULTRET);
  return (lua_gettop(L) - lc8);
  assert(lua_gettop(L) == 4);
}


/* function( pos, player) */
static int lcf14 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local meta = minetest.get_meta( pos ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_meta");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if( meta and meta:get_string( 'village_id' )~='' and meta:get_int( 'plot_nr' ) and meta:get_int( 'plot_nr' )>0) then */
  enum { lc10 = 3 };
  lua_pushvalue(L,3);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_string");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"village_id");
    lua_call(L,2,1);
    lua_pushliteral(L,"");
    const int lc11 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc11);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_int");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"plot_nr");
    lua_call(L,2,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"get_int");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"plot_nr");
    lua_call(L,2,1);
    const int lc12 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc12);
  }
  const int lc13 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc13) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 3);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* minetest.register_node("mg_villages:road", {
   * 	description = "village road",
   * 	tiles = {"default_gravel.png", "default_dirt.png"},
   *         is_ground_content = false, -- will not be removed by the cave generator
   *         groups = {crumbly=2}, -- does not fall
   *         sounds = default.node_sound_dirt_defaults({
   *                 footstep = {name="default_gravel_footstep", gain=0.5},
   *                 dug = {name="default_gravel_footstep", gain=1.0},
   * 	}),
   * 	paramtype  = "light",
   * 	paramtype2 = "facedir",
   * 	drawtype   = "nodebox",
   * 	node_box = {
   * 		type = "fixed",
   * 		fixed = { { -0.5, -0.5, -0.5, 0.5, 0.5-2/16, 0.5}, },
   * 		},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:road");
  lua_createtable(L,0,9);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"village road");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default_gravel.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default_dirt.png");
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_dirt_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"footstep");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default_gravel_footstep");
  lua_rawset(L,-3);
  lua_pushliteral(L,"gain");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dug");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default_gravel_footstep");
  lua_rawset(L,-3);
  lua_pushliteral(L,"gain");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype2");
  lua_pushliteral(L,"facedir");
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"nodebox");
  lua_rawset(L,-3);
  lua_pushliteral(L,"node_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,1,0);
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0.375);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.road_node = minetest.get_content_id( 'mg_villages:road' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:road");
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"road_node");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- do not drop snow on roads
   * if( moresnow ) then */
  enum { lc1 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"moresnow");
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* moresnow.snow_cover[ mg_villages.road_node ] = moresnow.c_air */
    lua_getfield(L,LUA_ENVIRONINDEX,"moresnow");
    lua_pushliteral(L,"c_air");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"moresnow");
    lua_pushliteral(L,"snow_cover");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"road_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_node("mg_villages:soil", {
   * 	description = "Soil found on a field",
   * 	tiles = {"default_dirt.png^farming_soil_wet.png", "default_dirt.png"},
   * 	drop = "default:dirt",
   * 	is_ground_content = true,
   * 	groups = {crumbly=3, not_in_creative_inventory=1, grassland = 1},
   * 	sounds = default.node_sound_dirt_defaults(),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:soil");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Soil found on a field");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default_dirt.png^farming_soil_wet.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default_dirt.png");
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"default:dirt");
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"not_in_creative_inventory");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"grassland");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_dirt_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_node("mg_villages:desert_sand_soil", {
   * 	description = "Desert Sand",
   * 	tiles = {"default_desert_sand.png^farming_soil_wet.png", "default_desert_sand.png"},
   * 	is_ground_content = true,
   * 	drop   = "default:desert_sand",
   * 	groups = {crumbly=3, not_in_creative_inventory = 1, sand=1, desert = 1},
   * 	sounds = default.node_sound_sand_defaults(),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:desert_sand_soil");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Desert Sand");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default_desert_sand.png^farming_soil_wet.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default_desert_sand.png");
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"default:desert_sand");
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"not_in_creative_inventory");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sand");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"desert");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_sand_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* if( mg_villages.USE_DEFAULT_3D_TORCHES == false ) then */
  enum { lc3 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"USE_DEFAULT_3D_TORCHES");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,0);
  const int lc4 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc4);
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* -- This torch is not hot. It will not melt snow and cause no floodings in villages.
     * minetest.register_node("mg_villages:torch", {
     * 		description = "Torch",
     * 		drawtype = "torchlike",
     * 		--tiles = {"default_torch_on_floor.png", "default_torch_on_ceiling.png", "default_torch.png"},
     * 		tiles = {
     * 			{name="default_torch_on_floor_animated.png", animation={type="vertical_frames", aspect_w=16, aspect_h=16, length=3.0}},
     * 			{name="default_torch_on_ceiling_animated.png", animation={type="vertical_frames", aspect_w=16, aspect_h=16, length=3.0}},
     * 			{name="default_torch_animated.png", animation={type="vertical_frames", aspect_w=16, aspect_h=16, length=3.0}}
     * 		},
     * 		inventory_image = "default_torch_on_floor.png",
     * 		wield_image = "default_torch_on_floor.png",
     * 		paramtype = "light",
     * 		paramtype2 = "wallmounted",
     * 		sunlight_propagates = true,
     * 		is_ground_content = false,
     * 		walkable = false,
     * 		light_source = LIGHT_MAX-1,
     * 		selection_box = {
     * 			type = "wallmounted",
     * 			wall_top = {-0.1, 0.5-0.6, -0.1, 0.1, 0.5, 0.1},
     * 			wall_bottom = {-0.1, -0.5, -0.1, 0.1, -0.5+0.6, 0.1},
     * 			wall_side = {-0.5, -0.3, -0.1, -0.5+0.3, 0.3, 0.1},
     * 		},
     * 		groups = {choppy=2,dig_immediate=3,flammable=1,attached_node=1},
     * 		legacy_wallmounted = true,
     * 		sounds = default.node_sound_defaults(),
     * 		drop   = "default:torch",
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"mg_villages:torch");
    lua_createtable(L,0,16);
    lua_pushliteral(L,"description");
    lua_pushliteral(L,"Torch");
    lua_rawset(L,-3);
    lua_pushliteral(L,"drawtype");
    lua_pushliteral(L,"torchlike");
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,3,0);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default_torch_on_floor_animated.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"animation");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"vertical_frames");
    lua_rawset(L,-3);
    lua_pushliteral(L,"aspect_w");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_pushliteral(L,"aspect_h");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_pushliteral(L,"length");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,1);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default_torch_on_ceiling_animated.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"animation");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"vertical_frames");
    lua_rawset(L,-3);
    lua_pushliteral(L,"aspect_w");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_pushliteral(L,"aspect_h");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_pushliteral(L,"length");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default_torch_animated.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"animation");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"vertical_frames");
    lua_rawset(L,-3);
    lua_pushliteral(L,"aspect_w");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_pushliteral(L,"aspect_h");
    lua_pushnumber(L,16);
    lua_rawset(L,-3);
    lua_pushliteral(L,"length");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"inventory_image");
    lua_pushliteral(L,"default_torch_on_floor.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wield_image");
    lua_pushliteral(L,"default_torch_on_floor.png");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype");
    lua_pushliteral(L,"light");
    lua_rawset(L,-3);
    lua_pushliteral(L,"paramtype2");
    lua_pushliteral(L,"wallmounted");
    lua_rawset(L,-3);
    lua_pushliteral(L,"sunlight_propagates");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"walkable");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"light_source");
    lua_getfield(L,LUA_ENVIRONINDEX,"LIGHT_MAX");
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"selection_box");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"wallmounted");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wall_top");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.5);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wall_bottom");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_pushliteral(L,"wall_side");
    lua_createtable(L,6,0);
    lua_pushnumber(L,-0.5);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,-0.3);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,-0.1);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,-0.2);
    lua_rawseti(L,-2,4);
    lua_pushnumber(L,0.3);
    lua_rawseti(L,-2,5);
    lua_pushnumber(L,0.1);
    lua_rawseti(L,-2,6);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,4);
    lua_pushliteral(L,"choppy");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"dig_immediate");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"flammable");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"attached_node");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"legacy_wallmounted");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"drop");
    lua_pushliteral(L,"default:torch");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc3 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_node("mg_villages:plotmarker", {
   * 	description = "Plot marker",
   * 	drawtype = "nodebox",
   * 	tiles = {"default_stone_brick.png"},
   * 	paramtype = "light",
   * 	paramtype2 = "facedir",
   * 	node_box = {
   * 		type = "fixed",
   * 		fixed = {
   * 			{-0.5+2/16, -0.5, -0.5+2/16,  0.5-2/16, -0.5+3/16, 0.5-2/16},
   * 		},
   * 	},
   * 	groups = {cracky=3,stone=2},
   * 
   * 	on_rightclick = function( pos, node, clicker, itemstack, pointed_thing)
   * 		return mg_villages.plotmarker_formspec( pos, nil, {}, clicker )
   * 	end,
   * 
   * 	on_receive_fields = function(pos, formname, fields, sender)
   * 		return mg_villages.plotmarker_formspec( pos, formname, fields, sender );
   * 	end,
   * 
   * 	-- protect against digging
   * 	can_dig = function( pos, player )
   * 			local meta = minetest.get_meta( pos );
   * 			if( meta and meta:get_string( 'village_id' )~='' and meta:get_int( 'plot_nr' ) and meta:get_int( 'plot_nr' )>0) then
   * 				return false;
   * 			end
   * 			return true;
   * 		end
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:plotmarker");
  lua_createtable(L,0,10);
  lua_pushliteral(L,"description");
  lua_pushliteral(L,"Plot marker");
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"nodebox");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default_stone_brick.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype2");
  lua_pushliteral(L,"facedir");
  lua_rawset(L,-3);
  lua_pushliteral(L,"node_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,1,0);
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.375);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.375);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.375);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,-0.3125);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.375);
  lua_rawseti(L,-2,6);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"stone");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_rightclick");
  lua_pushcfunction(L,lcf7);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_receive_fields");
  lua_pushcfunction(L,lcf9);
  lua_rawset(L,-3);
  lua_pushliteral(L,"can_dig");
  lua_pushcfunction(L,lcf14);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- default to safe lava
   * if( not( mg_villages.use_normal_unsafe_lava )) then */
  enum { lc15 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"use_normal_unsafe_lava");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc16 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc16) {
    
    /* local lava = minetest.registered_nodes[ "default:lava_source"] */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:lava_source");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* if( lava ) then */
    enum { lc17 = 1 };
    if (lua_toboolean(L,(1 + lc_nextra))) {
      
      /* -- a deep copy for the table would be more helpful...but, well, ...
       * local new_def = minetest.deserialize( minetest.serialize( lava )) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"deserialize");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc18 = lua_gettop(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"serialize");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,(1 + lc_nextra));
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc18),1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* -- this lava does not cause fire to spread
       * new_def.name           = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"name");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.lava    = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"lava");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.hot     = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"hot");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.igniter = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"igniter");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.lava_tamed = 3 */
      lua_pushnumber(L,3);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"lava_tamed");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.description = "Lava Source (tame)" */
      lua_pushliteral(L,"Lava Source (tame)");
      lua_pushliteral(L,"description");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.liquid_alternative_flowing = "mg_villages:lava_flowing_tamed" */
      lua_pushliteral(L,"mg_villages:lava_flowing_tamed");
      lua_pushliteral(L,"liquid_alternative_flowing");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.liquid_alternative_source = "mg_villages:lava_source_tamed" */
      lua_pushliteral(L,"mg_villages:lava_source_tamed");
      lua_pushliteral(L,"liquid_alternative_source");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* -- we create a NEW type of lava for this
       * minetest.register_node( "mg_villages:lava_source_tamed", new_def ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"register_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"mg_villages:lava_source_tamed");
      lua_pushvalue(L,(2 + lc_nextra));
      lua_call(L,2,0);
      assert(lua_gettop(L) - lc_nextra == 2);
    }
    lua_settop(L,(lc17 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* -- take care of the flowing variant as well
     * lava = minetest.registered_nodes[ "default:lava_flowing"] */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:lava_flowing");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,(1 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* if( lava ) then */
    enum { lc19 = 1 };
    if (lua_toboolean(L,(1 + lc_nextra))) {
      
      /* -- a deep copy for the table would be more helpful...but, well, ...
       * local new_def = minetest.deserialize( minetest.serialize( lava )) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"deserialize");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc20 = lua_gettop(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"serialize");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,(1 + lc_nextra));
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc20),1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* -- this lava does not cause fire to spread
       * new_def.name           = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"name");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.lava    = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"lava");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.hot     = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"hot");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.igniter = nil */
      lua_pushnil(L);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"igniter");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.groups.lava_tamed = 3 */
      lua_pushnumber(L,3);
      lua_pushliteral(L,"groups");
      lua_gettable(L,(2 + lc_nextra));
      lua_insert(L,-2);
      lua_pushliteral(L,"lava_tamed");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.description = "Flowing Lava (tame)" */
      lua_pushliteral(L,"Flowing Lava (tame)");
      lua_pushliteral(L,"description");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.liquid_alternative_flowing = "mg_villages:lava_flowing_tamed" */
      lua_pushliteral(L,"mg_villages:lava_flowing_tamed");
      lua_pushliteral(L,"liquid_alternative_flowing");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* new_def.liquid_alternative_source = "mg_villages:lava_source_tamed" */
      lua_pushliteral(L,"mg_villages:lava_source_tamed");
      lua_pushliteral(L,"liquid_alternative_source");
      lua_insert(L,-2);
      lua_settable(L,(2 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 2);
      
      /* -- and a NEW type of flowing lava...
       * minetest.register_node( "mg_villages:lava_flowing_tamed", new_def ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"register_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"mg_villages:lava_flowing_tamed");
      lua_pushvalue(L,(2 + lc_nextra));
      lua_call(L,2,0);
      assert(lua_gettop(L) - lc_nextra == 2);
    }
    lua_settop(L,(lc19 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc15 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_nodes(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}



