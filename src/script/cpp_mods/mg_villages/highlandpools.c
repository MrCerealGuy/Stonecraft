/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: highlandpools_remtree
 * function(x, y, z, area, data) */
static int lcf1_highlandpools_remtree (lua_State * L) {
  lua_checkstack(L,23);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* local c_tree = minetest.get_content_id("default:tree") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:tree");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* local c_apple = minetest.get_content_id("default:apple") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:apple");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local c_leaves = minetest.get_content_id("default:leaves") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:leaves");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* local c_air = minetest.get_content_id("air") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* for j = 1, 7 do */
  lua_pushnumber(L,1);
  lua_pushnumber(L,7);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc3_var = lua_tonumber(L,-2);
  const double lc4_limit = lua_tonumber(L,-1);
  const double lc5_step = 1;
  lua_pop(L,2);
  enum { lc6 = 9 };
  while ((((lc5_step > 0) && (lc3_var <= lc4_limit)) || ((lc5_step <= 0) && (lc3_var >= lc4_limit)))) {
    
    /* internal: local j at index 10 */
    lua_pushnumber(L,lc3_var);
    
    /* for i = -2, 2 do */
    lua_pushnumber(L,-2);
    lua_pushnumber(L,2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc7_var = lua_tonumber(L,-2);
    const double lc8_limit = lua_tonumber(L,-1);
    const double lc9_step = 1;
    lua_pop(L,2);
    enum { lc10 = 10 };
    while ((((lc9_step > 0) && (lc7_var <= lc8_limit)) || ((lc9_step <= 0) && (lc7_var >= lc8_limit)))) {
      
      /* internal: local i at index 11 */
      lua_pushnumber(L,lc7_var);
      
      /* for k = -2, 2 do */
      lua_pushnumber(L,-2);
      lua_pushnumber(L,2);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc11_var = lua_tonumber(L,-2);
      const double lc12_limit = lua_tonumber(L,-1);
      const double lc13_step = 1;
      lua_pop(L,2);
      enum { lc14 = 11 };
      while ((((lc13_step > 0) && (lc11_var <= lc12_limit)) || ((lc13_step <= 0) && (lc11_var >= lc12_limit)))) {
        
        /* internal: local k at index 12 */
        lua_pushnumber(L,lc11_var);
        
        /* local vi = area:index(x+i, y+j, z+k) */
        lua_pushvalue(L,4);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lc_add(L,1,11);
        lc_add(L,2,10);
        lc_add(L,3,12);
        lua_call(L,4,1);
        assert(lua_gettop(L) == 13);
        
        /* if data[vi] == c_tree
         * 		or data[vi] == c_apple
         * 		or data[vi] == c_leaves then */
        enum { lc15 = 13 };
        lua_pushvalue(L,13);
        lua_gettable(L,5);
        lua_pushvalue(L,6);
        const int lc16 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc16);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,5);
          lua_pushvalue(L,7);
          const int lc17 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc17);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,5);
          lua_pushvalue(L,8);
          const int lc18 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc18);
        }
        const int lc19 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc19) {
          
          /* data[vi] = c_air */
          lua_pushvalue(L,9);
          lua_pushvalue(L,13);
          lua_insert(L,-2);
          lua_settable(L,5);
          assert(lua_gettop(L) == 13);
        }
        lua_settop(L,lc15);
        assert(lua_gettop(L) == 13);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc11_var += lc13_step;
      }
      lua_settop(L,lc14);
      assert(lua_gettop(L) == 11);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc7_var += lc9_step;
    }
    lua_settop(L,lc10);
    assert(lua_gettop(L) == 10);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc3_var += lc5_step;
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 9);
  
  /* for j = 1, 7 do */
  lua_pushnumber(L,1);
  lua_pushnumber(L,7);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc20_var = lua_tonumber(L,-2);
  const double lc21_limit = lua_tonumber(L,-1);
  const double lc22_step = 1;
  lua_pop(L,2);
  enum { lc23 = 9 };
  while ((((lc22_step > 0) && (lc20_var <= lc21_limit)) || ((lc22_step <= 0) && (lc20_var >= lc21_limit)))) {
    
    /* internal: local j at index 10 */
    lua_pushnumber(L,lc20_var);
    
    /* for i = -2, 2 do */
    lua_pushnumber(L,-2);
    lua_pushnumber(L,2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc24_var = lua_tonumber(L,-2);
    const double lc25_limit = lua_tonumber(L,-1);
    const double lc26_step = 1;
    lua_pop(L,2);
    enum { lc27 = 10 };
    while ((((lc26_step > 0) && (lc24_var <= lc25_limit)) || ((lc26_step <= 0) && (lc24_var >= lc25_limit)))) {
      
      /* internal: local i at index 11 */
      lua_pushnumber(L,lc24_var);
      
      /* for k = -2, 2 do */
      lua_pushnumber(L,-2);
      lua_pushnumber(L,2);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc28_var = lua_tonumber(L,-2);
      const double lc29_limit = lua_tonumber(L,-1);
      const double lc30_step = 1;
      lua_pop(L,2);
      enum { lc31 = 11 };
      while ((((lc30_step > 0) && (lc28_var <= lc29_limit)) || ((lc30_step <= 0) && (lc28_var >= lc29_limit)))) {
        
        /* internal: local k at index 12 */
        lua_pushnumber(L,lc28_var);
        
        /* local vi = area:index(x+i, y-j, z+k) */
        lua_pushvalue(L,4);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lc_add(L,1,11);
        lc_sub(L,2,10);
        lc_add(L,3,12);
        lua_call(L,4,1);
        assert(lua_gettop(L) == 13);
        
        /* if data[vi] == c_tree
         * 		or data[vi] == c_apple
         * 		or data[vi] == c_leaves then */
        enum { lc32 = 13 };
        lua_pushvalue(L,13);
        lua_gettable(L,5);
        lua_pushvalue(L,6);
        const int lc33 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc33);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,5);
          lua_pushvalue(L,7);
          const int lc34 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc34);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,5);
          lua_pushvalue(L,8);
          const int lc35 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc35);
        }
        const int lc36 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc36) {
          
          /* data[vi] = c_air */
          lua_pushvalue(L,9);
          lua_pushvalue(L,13);
          lua_insert(L,-2);
          lua_settable(L,5);
          assert(lua_gettop(L) == 13);
        }
        lua_settop(L,lc32);
        assert(lua_gettop(L) == 13);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc28_var += lc30_step;
      }
      lua_settop(L,lc31);
      assert(lua_gettop(L) == 11);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc24_var += lc26_step;
    }
    lua_settop(L,lc27);
    assert(lua_gettop(L) == 10);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc20_var += lc22_step;
  }
  lua_settop(L,lc23);
  assert(lua_gettop(L) == 9);
  return 0;
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: mg_villages.do_highlandpools
 * function(minp, maxp, seed, vm, area, data, village_area) */
static int lcf1_mg_villages_do_highlandpools (lua_State * L) {
  lua_checkstack(L,46);
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* local y0 = minp.y */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* if y0 < -32 or y0 > YMAX then */
  enum { lc37 = 8 };
  lua_pushnumber(L,-32);
  const int lc38 = lua_lessthan(L,8,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc38);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),1,1);
    const int lc39 = lua_lessthan(L,-1,8);
    lua_pop(L,1);
    lua_pushboolean(L,lc39);
  }
  const int lc40 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc40) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc37);
  assert(lua_gettop(L) == 8);
  
  /* local x0 = minp.x */
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 9);
  
  /* local z0 = minp.z */
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 10);
  
  /* local x1 = maxp.x */
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  assert(lua_gettop(L) == 11);
  
  /* local y1 = maxp.y */
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  assert(lua_gettop(L) == 12);
  
  /* local z1 = maxp.z */
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  assert(lua_gettop(L) == 13);
  
  /* local sidelen = x1 - x0 */
  lc_sub(L,11,9);
  assert(lua_gettop(L) == 14);
  
  /* -- actually sidelen - 1
   * local c_air = minetest.get_content_id("air") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 15);
  
  /* local c_ignore = minetest.get_content_id("ignore") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ignore");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 16);
  
  /* local c_watsour = minetest.get_content_id("default:river_water_source") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:river_water_source");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 17);
  
  /* local c_grass = minetest.get_content_id("default:dirt_with_grass") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt_with_grass");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 18);
  
  /* local c_tree = minetest.get_content_id("default:tree") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:tree");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 19);
  
  /* local c_apple = minetest.get_content_id("default:apple") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:apple");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 20);
  
  /* local c_leaves = minetest.get_content_id("default:leaves") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:leaves");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 21);
  
  /* local c_dirt = minetest.get_content_id("default:dirt") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 22);
  
  /* for xcen = x0 + 8, x1 - 7, 8 do */
  lua_pushnumber(L,8);
  lc_add(L,9,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,7);
  lc_sub(L,11,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc41_var = lua_tonumber(L,-3);
  const double lc42_limit = lua_tonumber(L,-2);
  const double lc43_step = lua_tonumber(L,-1);
  lua_pop(L,3);
  enum { lc44 = 22 };
  while ((((lc43_step > 0) && (lc41_var <= lc42_limit)) || ((lc43_step <= 0) && (lc41_var >= lc42_limit)))) {
    
    /* internal: local xcen at index 23 */
    lua_pushnumber(L,lc41_var);
    
    /* for zcen = z0 + 8, z1 - 7, 8 do
     * 		-- TODO: village_area[ x ][ z ][ 2 ] == 0 means: not inside any village area or terrain blend area */
    lua_pushnumber(L,8);
    lc_add(L,10,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,7);
    lc_sub(L,13,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,8);
    if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc45_var = lua_tonumber(L,-3);
    const double lc46_limit = lua_tonumber(L,-2);
    const double lc47_step = lua_tonumber(L,-1);
    lua_pop(L,3);
    enum { lc48 = 23 };
    while ((((lc47_step > 0) && (lc45_var <= lc46_limit)) || ((lc47_step <= 0) && (lc45_var >= lc46_limit)))) {
      
      /* internal: local zcen at index 24 */
      lua_pushnumber(L,lc45_var);
      
      /* -- TODO: village_area[ x ][ z ][ 2 ] == 0 means: not inside any village area or terrain blend area
       * local yasurf = false */
      lua_pushboolean(L,0);
      assert(lua_gettop(L) == 25);
      
      /* -- y of above surface node
       * for y = y1, 2, -1 do */
      lua_pushnumber(L,2);
      lua_pushnumber(L,-1);
      if (!(((lua_isnumber(L,12) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc49_var = lua_tonumber(L,12);
      const double lc50_limit = lua_tonumber(L,-2);
      const double lc51_step = lua_tonumber(L,-1);
      lua_pop(L,2);
      enum { lc52 = 25 };
      while ((((lc51_step > 0) && (lc49_var <= lc50_limit)) || ((lc51_step <= 0) && (lc49_var >= lc50_limit)))) {
        
        /* internal: local y at index 26 */
        lua_pushnumber(L,lc49_var);
        
        /* local vi = area:index(xcen, y, zcen) */
        lua_pushvalue(L,5);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,23);
        lua_pushvalue(L,26);
        lua_pushvalue(L,24);
        lua_call(L,4,1);
        assert(lua_gettop(L) == 27);
        
        /* local c_node = data[vi] */
        lua_pushvalue(L,27);
        lua_gettable(L,6);
        assert(lua_gettop(L) == 28);
        
        /* if y == y1 and c_node ~= c_air then */
        enum { lc53 = 28 };
        lua_pushvalue(L,26);
        lua_pushvalue(L,12);
        const int lc54 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc54);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          const int lc55 = lua_equal(L,28,15);
          lua_pushboolean(L,lc55);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc56 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc56) {
          
          /* -- if top node solid
           * break */
          break;
          assert(lua_gettop(L) == 28);
        }
        else {
          
          /* elseif c_node == c_watsour then */
          enum { lc57 = 28 };
          const int lc58 = lua_equal(L,28,17);
          lua_pushboolean(L,lc58);
          const int lc59 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc59) {
            
            /* break */
            break;
            assert(lua_gettop(L) == 28);
          }
          else {
            
            /* elseif c_node == c_grass then */
            enum { lc60 = 28 };
            const int lc61 = lua_equal(L,28,18);
            lua_pushboolean(L,lc61);
            const int lc62 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc62) {
              
              /* yasurf = y + 1 */
              lua_pushnumber(L,1);
              lc_add(L,26,-1);
              lua_remove(L,-2);
              lua_replace(L,25);
              assert(lua_gettop(L) == 28);
              
              /* break */
              break;
              assert(lua_gettop(L) == 28);
            }
            lua_settop(L,lc60);
          }
          lua_settop(L,lc57);
        }
        lua_settop(L,lc53);
        assert(lua_gettop(L) == 28);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,3);
        lc49_var += lc51_step;
      }
      lua_settop(L,lc52);
      assert(lua_gettop(L) == 25);
      
      /* if yasurf then */
      enum { lc63 = 25 };
      if (lua_toboolean(L,25)) {
        
        /* local abort = false */
        lua_pushboolean(L,0);
        assert(lua_gettop(L) == 26);
        
        /* for ser = 1, 80 do */
        lua_pushnumber(L,1);
        lua_pushnumber(L,80);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc64_var = lua_tonumber(L,-2);
        const double lc65_limit = lua_tonumber(L,-1);
        const double lc66_step = 1;
        lua_pop(L,2);
        enum { lc67 = 26 };
        while ((((lc66_step > 0) && (lc64_var <= lc65_limit)) || ((lc66_step <= 0) && (lc64_var >= lc65_limit)))) {
          
          /* internal: local ser at index 27 */
          lua_pushnumber(L,lc64_var);
          
          /* local vi = area:index(xcen + ser, yasurf, zcen) */
          lua_pushvalue(L,5);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lc_add(L,23,27);
          lua_pushvalue(L,25);
          lua_pushvalue(L,24);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 28);
          
          /* local c_node = data[vi] */
          lua_pushvalue(L,28);
          lua_gettable(L,6);
          assert(lua_gettop(L) == 29);
          
          /* if xcen + ser == x1 then */
          enum { lc68 = 29 };
          lc_add(L,23,27);
          const int lc69 = lua_equal(L,-1,11);
          lua_pop(L,1);
          lua_pushboolean(L,lc69);
          const int lc70 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc70) {
            
            /* abort = true */
            lua_pushboolean(L,1);
            lua_replace(L,26);
            assert(lua_gettop(L) == 29);
          }
          else {
            
            /* elseif c_node ~= c_air
             * 				and c_node ~= c_tree
             * 				and c_node ~= c_leaves
             * 				and c_node ~= c_apple then */
            enum { lc71 = 29 };
            const int lc72 = lua_equal(L,29,15);
            lua_pushboolean(L,lc72);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc73 = lua_equal(L,29,19);
              lua_pushboolean(L,lc73);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc74 = lua_equal(L,29,21);
              lua_pushboolean(L,lc74);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc75 = lua_equal(L,29,20);
              lua_pushboolean(L,lc75);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc76 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc76) {
              
              /* break */
              break;
              assert(lua_gettop(L) == 29);
            }
            lua_settop(L,lc71);
          }
          lua_settop(L,lc68);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
          lc64_var += lc66_step;
        }
        lua_settop(L,lc67);
        assert(lua_gettop(L) == 26);
        
        /* for ser = 1, 80 do */
        lua_pushnumber(L,1);
        lua_pushnumber(L,80);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc77_var = lua_tonumber(L,-2);
        const double lc78_limit = lua_tonumber(L,-1);
        const double lc79_step = 1;
        lua_pop(L,2);
        enum { lc80 = 26 };
        while ((((lc79_step > 0) && (lc77_var <= lc78_limit)) || ((lc79_step <= 0) && (lc77_var >= lc78_limit)))) {
          
          /* internal: local ser at index 27 */
          lua_pushnumber(L,lc77_var);
          
          /* local vi = area:index(xcen - ser, yasurf, zcen) */
          lua_pushvalue(L,5);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lc_sub(L,23,27);
          lua_pushvalue(L,25);
          lua_pushvalue(L,24);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 28);
          
          /* local c_node = data[vi] */
          lua_pushvalue(L,28);
          lua_gettable(L,6);
          assert(lua_gettop(L) == 29);
          
          /* if xcen - ser == x0 then */
          enum { lc81 = 29 };
          lc_sub(L,23,27);
          const int lc82 = lua_equal(L,-1,9);
          lua_pop(L,1);
          lua_pushboolean(L,lc82);
          const int lc83 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc83) {
            
            /* abort = true */
            lua_pushboolean(L,1);
            lua_replace(L,26);
            assert(lua_gettop(L) == 29);
          }
          else {
            
            /* elseif c_node ~= c_air
             * 				and c_node ~= c_tree
             * 				and c_node ~= c_leaves
             * 				and c_node ~= c_apple then */
            enum { lc84 = 29 };
            const int lc85 = lua_equal(L,29,15);
            lua_pushboolean(L,lc85);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc86 = lua_equal(L,29,19);
              lua_pushboolean(L,lc86);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc87 = lua_equal(L,29,21);
              lua_pushboolean(L,lc87);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc88 = lua_equal(L,29,20);
              lua_pushboolean(L,lc88);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc89 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc89) {
              
              /* break */
              break;
              assert(lua_gettop(L) == 29);
            }
            lua_settop(L,lc84);
          }
          lua_settop(L,lc81);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
          lc77_var += lc79_step;
        }
        lua_settop(L,lc80);
        assert(lua_gettop(L) == 26);
        
        /* for ser = 1, 80 do */
        lua_pushnumber(L,1);
        lua_pushnumber(L,80);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc90_var = lua_tonumber(L,-2);
        const double lc91_limit = lua_tonumber(L,-1);
        const double lc92_step = 1;
        lua_pop(L,2);
        enum { lc93 = 26 };
        while ((((lc92_step > 0) && (lc90_var <= lc91_limit)) || ((lc92_step <= 0) && (lc90_var >= lc91_limit)))) {
          
          /* internal: local ser at index 27 */
          lua_pushnumber(L,lc90_var);
          
          /* local vi = area:index(xcen, yasurf, zcen + ser) */
          lua_pushvalue(L,5);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,23);
          lua_pushvalue(L,25);
          lc_add(L,24,27);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 28);
          
          /* local c_node = data[vi] */
          lua_pushvalue(L,28);
          lua_gettable(L,6);
          assert(lua_gettop(L) == 29);
          
          /* if zcen + ser == z1 then */
          enum { lc94 = 29 };
          lc_add(L,24,27);
          const int lc95 = lua_equal(L,-1,13);
          lua_pop(L,1);
          lua_pushboolean(L,lc95);
          const int lc96 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc96) {
            
            /* abort = true */
            lua_pushboolean(L,1);
            lua_replace(L,26);
            assert(lua_gettop(L) == 29);
          }
          else {
            
            /* elseif c_node ~= c_air
             * 				and c_node ~= c_tree
             * 				and c_node ~= c_leaves
             * 				and c_node ~= c_apple then */
            enum { lc97 = 29 };
            const int lc98 = lua_equal(L,29,15);
            lua_pushboolean(L,lc98);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc99 = lua_equal(L,29,19);
              lua_pushboolean(L,lc99);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc100 = lua_equal(L,29,21);
              lua_pushboolean(L,lc100);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc101 = lua_equal(L,29,20);
              lua_pushboolean(L,lc101);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc102 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc102) {
              
              /* break */
              break;
              assert(lua_gettop(L) == 29);
            }
            lua_settop(L,lc97);
          }
          lua_settop(L,lc94);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
          lc90_var += lc92_step;
        }
        lua_settop(L,lc93);
        assert(lua_gettop(L) == 26);
        
        /* for ser = 1, 80 do */
        lua_pushnumber(L,1);
        lua_pushnumber(L,80);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc103_var = lua_tonumber(L,-2);
        const double lc104_limit = lua_tonumber(L,-1);
        const double lc105_step = 1;
        lua_pop(L,2);
        enum { lc106 = 26 };
        while ((((lc105_step > 0) && (lc103_var <= lc104_limit)) || ((lc105_step <= 0) && (lc103_var >= lc104_limit)))) {
          
          /* internal: local ser at index 27 */
          lua_pushnumber(L,lc103_var);
          
          /* local vi = area:index(xcen, yasurf, zcen - ser) */
          lua_pushvalue(L,5);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,23);
          lua_pushvalue(L,25);
          lc_sub(L,24,27);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 28);
          
          /* local c_node = data[vi] */
          lua_pushvalue(L,28);
          lua_gettable(L,6);
          assert(lua_gettop(L) == 29);
          
          /* if zcen - ser == z0 then */
          enum { lc107 = 29 };
          lc_sub(L,24,27);
          const int lc108 = lua_equal(L,-1,10);
          lua_pop(L,1);
          lua_pushboolean(L,lc108);
          const int lc109 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc109) {
            
            /* abort = true */
            lua_pushboolean(L,1);
            lua_replace(L,26);
            assert(lua_gettop(L) == 29);
          }
          else {
            
            /* elseif c_node ~= c_air
             * 				and c_node ~= c_tree
             * 				and c_node ~= c_leaves
             * 				and c_node ~= c_apple then */
            enum { lc110 = 29 };
            const int lc111 = lua_equal(L,29,15);
            lua_pushboolean(L,lc111);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc112 = lua_equal(L,29,19);
              lua_pushboolean(L,lc112);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc113 = lua_equal(L,29,21);
              lua_pushboolean(L,lc113);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              const int lc114 = lua_equal(L,29,20);
              lua_pushboolean(L,lc114);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            const int lc115 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc115) {
              
              /* break */
              break;
              assert(lua_gettop(L) == 29);
            }
            lua_settop(L,lc110);
          }
          lua_settop(L,lc107);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
          lc103_var += lc105_step;
        }
        lua_settop(L,lc106);
        assert(lua_gettop(L) == 26);
        
        /* if abort then */
        enum { lc116 = 26 };
        if (lua_toboolean(L,26)) {
          
          /* break */
          break;
          assert(lua_gettop(L) == 26);
        }
        lua_settop(L,lc116);
        assert(lua_gettop(L) == 26);
        
        /* local vi = area:index(xcen, yasurf, zcen) */
        lua_pushvalue(L,5);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,23);
        lua_pushvalue(L,25);
        lua_pushvalue(L,24);
        lua_call(L,4,1);
        assert(lua_gettop(L) == 27);
        
        /* data[vi] = c_watsour */
        lua_pushvalue(L,17);
        lua_pushvalue(L,27);
        lua_insert(L,-2);
        lua_settable(L,6);
        assert(lua_gettop(L) == 27);
        
        /* local flab = false */
        lua_pushboolean(L,0);
        assert(lua_gettop(L) == 28);
        
        /* -- flow abort
         * for flow = 1, FLOW do */
        lua_pushnumber(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),0,2);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc117_var = lua_tonumber(L,-2);
        const double lc118_limit = lua_tonumber(L,-1);
        const double lc119_step = 1;
        lua_pop(L,2);
        enum { lc120 = 28 };
        while ((((lc119_step > 0) && (lc117_var <= lc118_limit)) || ((lc119_step <= 0) && (lc117_var >= lc118_limit)))) {
          
          /* internal: local flow at index 29 */
          lua_pushnumber(L,lc117_var);
          
          /* for z = z0, z1 do */
          if (!((lua_isnumber(L,10) && lua_isnumber(L,13)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc121_var = lua_tonumber(L,10);
          const double lc122_limit = lua_tonumber(L,13);
          const double lc123_step = 1;
          lua_pop(L,0);
          enum { lc124 = 29 };
          while ((((lc123_step > 0) && (lc121_var <= lc122_limit)) || ((lc123_step <= 0) && (lc121_var >= lc122_limit)))) {
            
            /* internal: local z at index 30 */
            lua_pushnumber(L,lc121_var);
            
            /* for x = x0, x1 do */
            if (!((lua_isnumber(L,9) && lua_isnumber(L,11)))) {
              luaL_error(L,"'for' limit must be a number");
            }
            double lc125_var = lua_tonumber(L,9);
            const double lc126_limit = lua_tonumber(L,11);
            const double lc127_step = 1;
            lua_pop(L,0);
            enum { lc128 = 30 };
            while ((((lc127_step > 0) && (lc125_var <= lc126_limit)) || ((lc127_step <= 0) && (lc125_var >= lc126_limit)))) {
              
              /* internal: local x at index 31 */
              lua_pushnumber(L,lc125_var);
              
              /* local vif = area:index(x, yasurf, z) */
              lua_pushvalue(L,5);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,31);
              lua_pushvalue(L,25);
              lua_pushvalue(L,30);
              lua_call(L,4,1);
              assert(lua_gettop(L) == 32);
              
              /* if data[vif] == c_watsour then */
              enum { lc129 = 32 };
              lua_pushvalue(L,32);
              lua_gettable(L,6);
              const int lc130 = lua_equal(L,-1,17);
              lua_pop(L,1);
              lua_pushboolean(L,lc130);
              const int lc131 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc131) {
                
                /* if x == x0 or x == x1 or z == z0 or z == z1 then */
                enum { lc132 = 32 };
                lua_pushvalue(L,31);
                lua_pushvalue(L,9);
                const int lc133 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc133);
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushvalue(L,31);
                  lua_pushvalue(L,11);
                  const int lc134 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc134);
                }
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushvalue(L,30);
                  lua_pushvalue(L,10);
                  const int lc135 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc135);
                }
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushvalue(L,30);
                  lua_pushvalue(L,13);
                  const int lc136 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc136);
                }
                const int lc137 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc137) {
                  
                  /* flab = true */
                  lua_pushboolean(L,1);
                  lua_replace(L,28);
                  assert(lua_gettop(L) == 32);
                  
                  /* -- if water at chunk edge abort flow
                   * break */
                  break;
                  assert(lua_gettop(L) == 32);
                }
                else {
                  
                  /* else
                   * -- flow water
                   * local vie = area:index(x + 1, yasurf, z) */
                  lua_pushvalue(L,5);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushnumber(L,1);
                  lc_add(L,31,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,25);
                  lua_pushvalue(L,30);
                  lua_call(L,4,1);
                  assert(lua_gettop(L) == 33);
                  
                  /* local viw = area:index(x - 1, yasurf, z) */
                  lua_pushvalue(L,5);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushnumber(L,1);
                  lc_sub(L,31,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,25);
                  lua_pushvalue(L,30);
                  lua_call(L,4,1);
                  assert(lua_gettop(L) == 34);
                  
                  /* local vin = area:index(x, yasurf, z + 1) */
                  lua_pushvalue(L,5);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,31);
                  lua_pushvalue(L,25);
                  lua_pushnumber(L,1);
                  lc_add(L,30,-1);
                  lua_remove(L,-2);
                  lua_call(L,4,1);
                  assert(lua_gettop(L) == 35);
                  
                  /* local vis = area:index(x, yasurf, z - 1) */
                  lua_pushvalue(L,5);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,31);
                  lua_pushvalue(L,25);
                  lua_pushnumber(L,1);
                  lc_sub(L,30,-1);
                  lua_remove(L,-2);
                  lua_call(L,4,1);
                  assert(lua_gettop(L) == 36);
                  
                  /* if data[vie] == c_tree then */
                  enum { lc138 = 36 };
                  lua_pushvalue(L,33);
                  lua_gettable(L,6);
                  const int lc139 = lua_equal(L,-1,19);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc139);
                  const int lc140 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc140) {
                    
                    /* highlandpools_remtree(x + 1, yasurf, z, area, data) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"highlandpools_remtree");
                    lua_pushnumber(L,1);
                    lc_add(L,31,-1);
                    lua_remove(L,-2);
                    lua_pushvalue(L,25);
                    lua_pushvalue(L,30);
                    lua_pushvalue(L,5);
                    lua_pushvalue(L,6);
                    lua_call(L,5,0);
                    assert(lua_gettop(L) == 36);
                    
                    /* data[vie] = c_watsour */
                    lua_pushvalue(L,17);
                    lua_pushvalue(L,33);
                    lua_insert(L,-2);
                    lua_settable(L,6);
                    assert(lua_gettop(L) == 36);
                  }
                  else {
                    
                    /* elseif data[vie] == c_air
                     * 								or data[vie] == c_apple
                     * 								or data[vie] == c_leaves then */
                    enum { lc141 = 36 };
                    lua_pushvalue(L,33);
                    lua_gettable(L,6);
                    lua_pushvalue(L,15);
                    const int lc142 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc142);
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,33);
                      lua_gettable(L,6);
                      lua_pushvalue(L,20);
                      const int lc143 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc143);
                    }
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,33);
                      lua_gettable(L,6);
                      lua_pushvalue(L,21);
                      const int lc144 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc144);
                    }
                    const int lc145 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc145) {
                      
                      /* data[vie] = c_watsour */
                      lua_pushvalue(L,17);
                      lua_pushvalue(L,33);
                      lua_insert(L,-2);
                      lua_settable(L,6);
                      assert(lua_gettop(L) == 36);
                    }
                    lua_settop(L,lc141);
                  }
                  lua_settop(L,lc138);
                  assert(lua_gettop(L) == 36);
                  
                  /* if data[viw] == c_tree then */
                  enum { lc146 = 36 };
                  lua_pushvalue(L,34);
                  lua_gettable(L,6);
                  const int lc147 = lua_equal(L,-1,19);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc147);
                  const int lc148 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc148) {
                    
                    /* highlandpools_remtree(x - 1, yasurf, z, area, data) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"highlandpools_remtree");
                    lua_pushnumber(L,1);
                    lc_sub(L,31,-1);
                    lua_remove(L,-2);
                    lua_pushvalue(L,25);
                    lua_pushvalue(L,30);
                    lua_pushvalue(L,5);
                    lua_pushvalue(L,6);
                    lua_call(L,5,0);
                    assert(lua_gettop(L) == 36);
                    
                    /* data[viw] = c_watsour */
                    lua_pushvalue(L,17);
                    lua_pushvalue(L,34);
                    lua_insert(L,-2);
                    lua_settable(L,6);
                    assert(lua_gettop(L) == 36);
                  }
                  else {
                    
                    /* elseif data[viw] == c_air
                     * 								or data[viw] == c_apple
                     * 								or data[viw] == c_leaves then */
                    enum { lc149 = 36 };
                    lua_pushvalue(L,34);
                    lua_gettable(L,6);
                    lua_pushvalue(L,15);
                    const int lc150 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc150);
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,34);
                      lua_gettable(L,6);
                      lua_pushvalue(L,20);
                      const int lc151 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc151);
                    }
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,34);
                      lua_gettable(L,6);
                      lua_pushvalue(L,21);
                      const int lc152 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc152);
                    }
                    const int lc153 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc153) {
                      
                      /* data[viw] = c_watsour */
                      lua_pushvalue(L,17);
                      lua_pushvalue(L,34);
                      lua_insert(L,-2);
                      lua_settable(L,6);
                      assert(lua_gettop(L) == 36);
                    }
                    lua_settop(L,lc149);
                  }
                  lua_settop(L,lc146);
                  assert(lua_gettop(L) == 36);
                  
                  /* if data[vin] == c_tree then */
                  enum { lc154 = 36 };
                  lua_pushvalue(L,35);
                  lua_gettable(L,6);
                  const int lc155 = lua_equal(L,-1,19);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc155);
                  const int lc156 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc156) {
                    
                    /* highlandpools_remtree(x, yasurf, z + 1, area, data) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"highlandpools_remtree");
                    lua_pushvalue(L,31);
                    lua_pushvalue(L,25);
                    lua_pushnumber(L,1);
                    lc_add(L,30,-1);
                    lua_remove(L,-2);
                    lua_pushvalue(L,5);
                    lua_pushvalue(L,6);
                    lua_call(L,5,0);
                    assert(lua_gettop(L) == 36);
                    
                    /* data[vin] = c_watsour */
                    lua_pushvalue(L,17);
                    lua_pushvalue(L,35);
                    lua_insert(L,-2);
                    lua_settable(L,6);
                    assert(lua_gettop(L) == 36);
                  }
                  else {
                    
                    /* elseif data[vin] == c_air
                     * 								or data[vin] == c_apple
                     * 								or data[vin] == c_leaves then */
                    enum { lc157 = 36 };
                    lua_pushvalue(L,35);
                    lua_gettable(L,6);
                    lua_pushvalue(L,15);
                    const int lc158 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc158);
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,35);
                      lua_gettable(L,6);
                      lua_pushvalue(L,20);
                      const int lc159 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc159);
                    }
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,35);
                      lua_gettable(L,6);
                      lua_pushvalue(L,21);
                      const int lc160 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc160);
                    }
                    const int lc161 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc161) {
                      
                      /* data[vin] = c_watsour */
                      lua_pushvalue(L,17);
                      lua_pushvalue(L,35);
                      lua_insert(L,-2);
                      lua_settable(L,6);
                      assert(lua_gettop(L) == 36);
                    }
                    lua_settop(L,lc157);
                  }
                  lua_settop(L,lc154);
                  assert(lua_gettop(L) == 36);
                  
                  /* if data[vis] == c_tree then */
                  enum { lc162 = 36 };
                  lua_pushvalue(L,36);
                  lua_gettable(L,6);
                  const int lc163 = lua_equal(L,-1,19);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc163);
                  const int lc164 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc164) {
                    
                    /* highlandpools_remtree(x, yasurf, z - 1, area, data) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"highlandpools_remtree");
                    lua_pushvalue(L,31);
                    lua_pushvalue(L,25);
                    lua_pushnumber(L,1);
                    lc_sub(L,30,-1);
                    lua_remove(L,-2);
                    lua_pushvalue(L,5);
                    lua_pushvalue(L,6);
                    lua_call(L,5,0);
                    assert(lua_gettop(L) == 36);
                    
                    /* data[vis] = c_watsour */
                    lua_pushvalue(L,17);
                    lua_pushvalue(L,36);
                    lua_insert(L,-2);
                    lua_settable(L,6);
                    assert(lua_gettop(L) == 36);
                  }
                  else {
                    
                    /* elseif data[vis] == c_air
                     * 								or data[vis] == c_apple
                     * 								or data[vis] == c_leaves then */
                    enum { lc165 = 36 };
                    lua_pushvalue(L,36);
                    lua_gettable(L,6);
                    lua_pushvalue(L,15);
                    const int lc166 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc166);
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,36);
                      lua_gettable(L,6);
                      lua_pushvalue(L,20);
                      const int lc167 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc167);
                    }
                    if (!(lua_toboolean(L,-1))) {
                      lua_pop(L,1);
                      lua_pushvalue(L,36);
                      lua_gettable(L,6);
                      lua_pushvalue(L,21);
                      const int lc168 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc168);
                    }
                    const int lc169 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc169) {
                      
                      /* data[vis] = c_watsour */
                      lua_pushvalue(L,17);
                      lua_pushvalue(L,36);
                      lua_insert(L,-2);
                      lua_settable(L,6);
                      assert(lua_gettop(L) == 36);
                    }
                    lua_settop(L,lc165);
                  }
                  lua_settop(L,lc162);
                  assert(lua_gettop(L) == 36);
                }
                lua_settop(L,lc132);
                assert(lua_gettop(L) == 32);
              }
              lua_settop(L,lc129);
              assert(lua_gettop(L) == 32);
              
              /* internal: stack cleanup on scope exit */
              lua_pop(L,2);
              lc125_var += lc127_step;
            }
            lua_settop(L,lc128);
            assert(lua_gettop(L) == 30);
            
            /* if flab then */
            enum { lc170 = 30 };
            if (lua_toboolean(L,28)) {
              
              /* break */
              break;
              assert(lua_gettop(L) == 30);
            }
            lua_settop(L,lc170);
            assert(lua_gettop(L) == 30);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,1);
            lc121_var += lc123_step;
          }
          lua_settop(L,lc124);
          assert(lua_gettop(L) == 29);
          
          /* if flab then */
          enum { lc171 = 29 };
          if (lua_toboolean(L,28)) {
            
            /* break */
            break;
            assert(lua_gettop(L) == 29);
          }
          lua_settop(L,lc171);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
          lc117_var += lc119_step;
        }
        lua_settop(L,lc120);
        assert(lua_gettop(L) == 28);
        
        /* if flab then */
        enum { lc172 = 28 };
        if (lua_toboolean(L,28)) {
          
          /* -- erase water from this y level
           * for z = z0, z1 do */
          if (!((lua_isnumber(L,10) && lua_isnumber(L,13)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc173_var = lua_tonumber(L,10);
          const double lc174_limit = lua_tonumber(L,13);
          const double lc175_step = 1;
          lua_pop(L,0);
          enum { lc176 = 28 };
          while ((((lc175_step > 0) && (lc173_var <= lc174_limit)) || ((lc175_step <= 0) && (lc173_var >= lc174_limit)))) {
            
            /* internal: local z at index 29 */
            lua_pushnumber(L,lc173_var);
            
            /* for x = x0, x1 do */
            if (!((lua_isnumber(L,9) && lua_isnumber(L,11)))) {
              luaL_error(L,"'for' limit must be a number");
            }
            double lc177_var = lua_tonumber(L,9);
            const double lc178_limit = lua_tonumber(L,11);
            const double lc179_step = 1;
            lua_pop(L,0);
            enum { lc180 = 29 };
            while ((((lc179_step > 0) && (lc177_var <= lc178_limit)) || ((lc179_step <= 0) && (lc177_var >= lc178_limit)))) {
              
              /* internal: local x at index 30 */
              lua_pushnumber(L,lc177_var);
              
              /* local vi = area:index(x, yasurf, z) */
              lua_pushvalue(L,5);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,30);
              lua_pushvalue(L,25);
              lua_pushvalue(L,29);
              lua_call(L,4,1);
              assert(lua_gettop(L) == 31);
              
              /* if data[vi] == c_watsour then */
              enum { lc181 = 31 };
              lua_pushvalue(L,31);
              lua_gettable(L,6);
              const int lc182 = lua_equal(L,-1,17);
              lua_pop(L,1);
              lua_pushboolean(L,lc182);
              const int lc183 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc183) {
                
                /* data[vi] = c_air */
                lua_pushvalue(L,15);
                lua_pushvalue(L,31);
                lua_insert(L,-2);
                lua_settable(L,6);
                assert(lua_gettop(L) == 31);
              }
              lua_settop(L,lc181);
              assert(lua_gettop(L) == 31);
              
              /* internal: stack cleanup on scope exit */
              lua_pop(L,2);
              lc177_var += lc179_step;
            }
            lua_settop(L,lc180);
            assert(lua_gettop(L) == 29);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,1);
            lc173_var += lc175_step;
          }
          lua_settop(L,lc176);
          assert(lua_gettop(L) == 28);
        }
        else {
          
          /* else
           * -- flow downwards add dirt
           * for z = z0, z1 do */
          if (!((lua_isnumber(L,10) && lua_isnumber(L,13)))) {
            luaL_error(L,"'for' limit must be a number");
          }
          double lc184_var = lua_tonumber(L,10);
          const double lc185_limit = lua_tonumber(L,13);
          const double lc186_step = 1;
          lua_pop(L,0);
          enum { lc187 = 28 };
          while ((((lc186_step > 0) && (lc184_var <= lc185_limit)) || ((lc186_step <= 0) && (lc184_var >= lc185_limit)))) {
            
            /* internal: local z at index 29 */
            lua_pushnumber(L,lc184_var);
            
            /* for x = x0, x1 do */
            if (!((lua_isnumber(L,9) && lua_isnumber(L,11)))) {
              luaL_error(L,"'for' limit must be a number");
            }
            double lc188_var = lua_tonumber(L,9);
            const double lc189_limit = lua_tonumber(L,11);
            const double lc190_step = 1;
            lua_pop(L,0);
            enum { lc191 = 29 };
            while ((((lc190_step > 0) && (lc188_var <= lc189_limit)) || ((lc190_step <= 0) && (lc188_var >= lc189_limit)))) {
              
              /* internal: local x at index 30 */
              lua_pushnumber(L,lc188_var);
              
              /* local vi = area:index(x, yasurf, z) */
              lua_pushvalue(L,5);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,30);
              lua_pushvalue(L,25);
              lua_pushvalue(L,29);
              lua_call(L,4,1);
              assert(lua_gettop(L) == 31);
              
              /* if data[vi] == c_watsour then */
              enum { lc192 = 31 };
              lua_pushvalue(L,31);
              lua_gettable(L,6);
              const int lc193 = lua_equal(L,-1,17);
              lua_pop(L,1);
              lua_pushboolean(L,lc193);
              const int lc194 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc194) {
                
                /* for y = yasurf - 1, y0, -1 do */
                lua_pushnumber(L,1);
                lc_sub(L,25,-1);
                lua_remove(L,-2);
                lua_pushnumber(L,-1);
                if (!(((lua_isnumber(L,-2) && lua_isnumber(L,8)) && lua_isnumber(L,-1)))) {
                  luaL_error(L,"'for' limit must be a number");
                }
                double lc195_var = lua_tonumber(L,-2);
                const double lc196_limit = lua_tonumber(L,8);
                const double lc197_step = lua_tonumber(L,-1);
                lua_pop(L,2);
                enum { lc198 = 31 };
                while ((((lc197_step > 0) && (lc195_var <= lc196_limit)) || ((lc197_step <= 0) && (lc195_var >= lc196_limit)))) {
                  
                  /* internal: local y at index 32 */
                  lua_pushnumber(L,lc195_var);
                  
                  /* local viu = area:index(x, y, z) */
                  lua_pushvalue(L,5);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,30);
                  lua_pushvalue(L,32);
                  lua_pushvalue(L,29);
                  lua_call(L,4,1);
                  assert(lua_gettop(L) == 33);
                  
                  /* if data[viu] == c_air then */
                  enum { lc199 = 33 };
                  lua_pushvalue(L,33);
                  lua_gettable(L,6);
                  const int lc200 = lua_equal(L,-1,15);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc200);
                  const int lc201 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc201) {
                    
                    /* data[viu] = c_watsour */
                    lua_pushvalue(L,17);
                    lua_pushvalue(L,33);
                    lua_insert(L,-2);
                    lua_settable(L,6);
                    assert(lua_gettop(L) == 33);
                  }
                  else {
                    
                    /* elseif data[viu] == c_grass then */
                    enum { lc202 = 33 };
                    lua_pushvalue(L,33);
                    lua_gettable(L,6);
                    const int lc203 = lua_equal(L,-1,18);
                    lua_pop(L,1);
                    lua_pushboolean(L,lc203);
                    const int lc204 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc204) {
                      
                      /* data[viu] = c_dirt */
                      lua_pushvalue(L,22);
                      lua_pushvalue(L,33);
                      lua_insert(L,-2);
                      lua_settable(L,6);
                      assert(lua_gettop(L) == 33);
                      
                      /* break */
                      break;
                      assert(lua_gettop(L) == 33);
                    }
                    else {
                      
                      /* else
                       * break */
                      break;
                      assert(lua_gettop(L) == 33);
                    }
                    lua_settop(L,lc202);
                  }
                  lua_settop(L,lc199);
                  assert(lua_gettop(L) == 33);
                  
                  /* internal: stack cleanup on scope exit */
                  lua_pop(L,2);
                  lc195_var += lc197_step;
                }
                lua_settop(L,lc198);
                assert(lua_gettop(L) == 31);
              }
              lua_settop(L,lc192);
              assert(lua_gettop(L) == 31);
              
              /* internal: stack cleanup on scope exit */
              lua_pop(L,2);
              lc188_var += lc190_step;
            }
            lua_settop(L,lc191);
            assert(lua_gettop(L) == 29);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,1);
            lc184_var += lc186_step;
          }
          lua_settop(L,lc187);
          assert(lua_gettop(L) == 28);
        }
        lua_settop(L,lc172);
        assert(lua_gettop(L) == 28);
      }
      lua_settop(L,lc63);
      assert(lua_gettop(L) == 25);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc45_var += lc47_step;
    }
    lua_settop(L,lc48);
    assert(lua_gettop(L) == 23);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc41_var += lc43_step;
  }
  lua_settop(L,lc44);
  assert(lua_gettop(L) == 22);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- highlandpools 0.1.1 by paramat
   * -- For latest stable Minetest back to 0.4.8
   * -- Depends default
   * -- Licenses: code WTFPL
   * -- Parameters
   * local YMAX = 33000 */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_pushnumber(L,33000);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Maximum altitude for pools
   * local FLOW = 256 */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_pushnumber(L,256);
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- Stuff
   * highlandpools = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"highlandpools");
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- Functions
   * function highlandpools_remtree(x, y, z, area, data)
   * 	local c_tree = minetest.get_content_id("default:tree")
   * 	local c_apple = minetest.get_content_id("default:apple")
   * 	local c_leaves = minetest.get_content_id("default:leaves")
   * 	local c_air = minetest.get_content_id("air")
   * 	for j = 1, 7 do
   * 	for i = -2, 2 do
   * 	for k = -2, 2 do
   * 		local vi = area:index(x+i, y+j, z+k)
   * 		if data[vi] == c_tree
   * 		or data[vi] == c_apple
   * 		or data[vi] == c_leaves then
   * 			data[vi] = c_air
   * 		end
   * 	end
   * 	end
   * 	end
   * 	for j = 1, 7 do
   * 	for i = -2, 2 do
   * 	for k = -2, 2 do
   * 		local vi = area:index(x+i, y-j, z+k)
   * 		if data[vi] == c_tree
   * 		or data[vi] == c_apple
   * 		or data[vi] == c_leaves then
   * 			data[vi] = c_air
   * 		end
   * 	end
   * 	end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_highlandpools_remtree);
  lua_setfield(L,LUA_ENVIRONINDEX,"highlandpools_remtree");
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- On generated function
   * mg_villages.do_highlandpools = function(minp, maxp, seed, vm, area, data, village_area)
   * 	local y0 = minp.y
   * 	if y0 < -32 or y0 > YMAX then
   * 		return
   * 	end
   * 	
   * 	local x0 = minp.x
   * 	local z0 = minp.z
   * 	local x1 = maxp.x
   * 	local y1 = maxp.y
   * 	local z1 = maxp.z
   * 	local sidelen = x1 - x0 -- actually sidelen - 1
   * 	
   * 	local c_air = minetest.get_content_id("air")
   * 	local c_ignore = minetest.get_content_id("ignore")
   * 	local c_watsour = minetest.get_content_id("default:river_water_source")
   * 	local c_grass = minetest.get_content_id("default:dirt_with_grass")
   * 	local c_tree = minetest.get_content_id("default:tree")
   * 	local c_apple = minetest.get_content_id("default:apple")
   * 	local c_leaves = minetest.get_content_id("default:leaves")
   * 	local c_dirt = minetest.get_content_id("default:dirt")
   * 	
   * 	for xcen = x0 + 8, x1 - 7, 8 do
   * 	for zcen = z0 + 8, z1 - 7, 8 do
   * 		-- TODO: village_area[ x ][ z ][ 2 ] == 0 means: not inside any village area or terrain blend area
   * 		local yasurf = false -- y of above surface node
   * 		for y = y1, 2, -1 do
   * 			local vi = area:index(xcen, y, zcen)
   * 			local c_node = data[vi]
   * 			if y == y1 and c_node ~= c_air then -- if top node solid
   * 				break
   * 			elseif c_node == c_watsour then
   * 				break
   * 			elseif c_node == c_grass then
   * 				yasurf = y + 1
   * 				break
   * 			end
   * 		end
   * 		if yasurf then
   * 			local abort = false
   * 			for ser = 1, 80 do
   * 				local vi = area:index(xcen + ser, yasurf, zcen)
   * 				local c_node = data[vi]
   * 				if xcen + ser == x1 then
   * 					abort = true
   * 				elseif c_node ~= c_air
   * 				and c_node ~= c_tree
   * 				and c_node ~= c_leaves
   * 				and c_node ~= c_apple then
   * 					break
   * 				end
   * 			end
   * 			for ser = 1, 80 do
   * 				local vi = area:index(xcen - ser, yasurf, zcen)
   * 				local c_node = data[vi]
   * 				if xcen - ser == x0 then
   * 					abort = true
   * 				elseif c_node ~= c_air
   * 				and c_node ~= c_tree
   * 				and c_node ~= c_leaves
   * 				and c_node ~= c_apple then
   * 					break
   * 				end
   * 			end
   * 			for ser = 1, 80 do
   * 				local vi = area:index(xcen, yasurf, zcen + ser)
   * 				local c_node = data[vi]
   * 				if zcen + ser == z1 then
   * 					abort = true
   * 				elseif c_node ~= c_air
   * 				and c_node ~= c_tree
   * 				and c_node ~= c_leaves
   * 				and c_node ~= c_apple then
   * 					break
   * 				end
   * 			end
   * 			for ser = 1, 80 do
   * 				local vi = area:index(xcen, yasurf, zcen - ser)
   * 				local c_node = data[vi]
   * 				if zcen - ser == z0 then
   * 					abort = true
   * 				elseif c_node ~= c_air
   * 				and c_node ~= c_tree
   * 				and c_node ~= c_leaves
   * 				and c_node ~= c_apple then
   * 					break
   * 				end
   * 			end
   * 			if abort then
   * 				break
   * 			end
   * 			
   * 			local vi = area:index(xcen, yasurf, zcen)
   * 			data[vi] = c_watsour
   * 			local flab = false -- flow abort
   * 			for flow = 1, FLOW do
   * 				for z = z0, z1 do
   * 					for x = x0, x1 do
   * 						local vif = area:index(x, yasurf, z)
   * 						if data[vif] == c_watsour then
   * 							if x == x0 or x == x1 or z == z0 or z == z1 then
   * 								flab = true -- if water at chunk edge abort flow
   * 								break
   * 							else -- flow water
   * 								local vie = area:index(x + 1, yasurf, z)
   * 								local viw = area:index(x - 1, yasurf, z)
   * 								local vin = area:index(x, yasurf, z + 1)
   * 								local vis = area:index(x, yasurf, z - 1)
   * 								if data[vie] == c_tree then
   * 									highlandpools_remtree(x + 1, yasurf, z, area, data)
   * 									data[vie] = c_watsour
   * 								elseif data[vie] == c_air
   * 								or data[vie] == c_apple
   * 								or data[vie] == c_leaves then
   * 									data[vie] = c_watsour
   * 								end
   * 								if data[viw] == c_tree then
   * 									highlandpools_remtree(x - 1, yasurf, z, area, data)
   * 									data[viw] = c_watsour
   * 								elseif data[viw] == c_air
   * 								or data[viw] == c_apple
   * 								or data[viw] == c_leaves then
   * 									data[viw] = c_watsour
   * 								end
   * 								if data[vin] == c_tree then
   * 									highlandpools_remtree(x, yasurf, z + 1, area, data)
   * 									data[vin] = c_watsour
   * 								elseif data[vin] == c_air
   * 								or data[vin] == c_apple
   * 								or data[vin] == c_leaves then
   * 									data[vin] = c_watsour
   * 								end
   * 								if data[vis] == c_tree then
   * 									highlandpools_remtree(x, yasurf, z - 1, area, data)
   * 									data[vis] = c_watsour
   * 								elseif data[vis] == c_air
   * 								or data[vis] == c_apple
   * 								or data[vis] == c_leaves then
   * 									data[vis] = c_watsour
   * 								end
   * 							end
   * 						end
   * 					end
   * 					if flab then
   * 						break
   * 					end
   * 				end
   * 				if flab then
   * 					break
   * 				end
   * 			end
   * 			if flab then -- erase water from this y level
   * 				for z = z0, z1 do
   * 				for x = x0, x1 do
   * 					local vi = area:index(x, yasurf, z)
   * 					if data[vi] == c_watsour then
   * 						data[vi] = c_air
   * 					end
   * 				end
   * 				end
   * 			else -- flow downwards add dirt
   * 				for z = z0, z1 do
   * 				for x = x0, x1 do
   * 					local vi = area:index(x, yasurf, z)
   * 					if data[vi] == c_watsour then
   * 						for y = yasurf - 1, y0, -1 do
   * 							local viu = area:index(x, y, z)
   * 							if data[viu] == c_air then
   * 								data[viu] = c_watsour
   * 							elseif data[viu] == c_grass then
   * 								data[viu] = c_dirt
   * 								break
   * 							else
   * 								break
   * 							end
   * 						end
   * 					end
   * 				end
   * 				end
   * 			end
   * 		end
   * 	end
   * 	end
   * 	
   * end */
  lua_pushvalue(L,(lc2 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_do_highlandpools,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"do_highlandpools");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_highlandpools(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}

