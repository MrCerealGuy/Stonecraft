/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: mg_villages.replace_materials
 * function( replacements, pr, original_materials, prefixes, materials, old_material) */
static int lcf1_mg_villages_replace_materials (lua_State * L) {
  lua_checkstack(L,30);
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* local postfixes = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 7);
  
  /* local use_realtest_stairs = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 8);
  
  /* -- handle realtest stairs/slabs
   * if( mg_villages.realtest_trees 
   * 		and #prefixes==3
   * 		and prefixes[1]=='stairs:stair_' and prefixes[2]=='stairs:slab_' and prefixes[3]=='default:' ) then */
  enum { lc10 = 8 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    const double lc11 = lua_objlen(L,4);
    lua_pushnumber(L,lc11);
    lua_pushnumber(L,3);
    const int lc12 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc12);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
    lua_gettable(L,4);
    lua_pushliteral(L,"stairs:stair_");
    const int lc13 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc13);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,2);
    lua_gettable(L,4);
    lua_pushliteral(L,"stairs:slab_");
    const int lc14 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc14);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,3);
    lua_gettable(L,4);
    lua_pushliteral(L,"default:");
    const int lc15 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc15);
  }
  const int lc16 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc16) {
    
    /* prefixes  = {''} */
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 8);
    
    /* materials = mg_villages.realtest_stairs */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_stairs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,5);
    assert(lua_gettop(L) == 8);
    
    /* postfixes = {''} */
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_replace(L,7);
    assert(lua_gettop(L) == 8);
    
    /* use_realtest_stairs = true */
    lua_pushboolean(L,1);
    lua_replace(L,8);
    assert(lua_gettop(L) == 8);
  }
  else {
    
    /* elseif( mg_villages.realtest_trees 
     * 		and #prefixes==1 
     * 		and prefixes[1]=='stairs:stair_') then */
    enum { lc17 = 8 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      const double lc18 = lua_objlen(L,4);
      lua_pushnumber(L,lc18);
      lua_pushnumber(L,1);
      const int lc19 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc19);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,1);
      lua_gettable(L,4);
      lua_pushliteral(L,"stairs:stair_");
      const int lc20 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc20);
    }
    const int lc21 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc21) {
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 8);
    }
    else {
      
      /* else
       * for i,v in ipairs( prefixes ) do
       * internal: local f, s, var = explist */
      enum { lc22 = 8 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
      lua_pushvalue(L,4);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local i with idx 12
         * internal: local v with idx 13 */
        
        
        /* postfixes[i] = '' */
        lua_pushliteral(L,"");
        lua_pushvalue(L,12);
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 13);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc22);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc17);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 8);
  
  /* local known_materials = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 9);
  
  /* local wood_found = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 10);
  
  /* -- for all alternate materials
   * for i,m in ipairs( materials ) do
   * 		-- check if that material exists for each supplied prefix
   * internal: local f, s, var = explist */
  enum { lc23 = 10 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,5);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 14
     * internal: local m with idx 15 */
    
    
    /* -- check if that material exists for each supplied prefix
     * for j,p in ipairs( prefixes ) do
     * 			-- if wood is present, later on try moretrees wood as well
     * internal: local f, s, var = explist */
    enum { lc24 = 15 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushvalue(L,4);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local j with idx 19
       * internal: local p with idx 20 */
      
      
      /* -- if wood is present, later on try moretrees wood as well
       * if( 'default:wood' == m ) then */
      enum { lc25 = 20 };
      lua_pushliteral(L,"default:wood");
      const int lc26 = lua_equal(L,-1,15);
      lua_pop(L,1);
      lua_pushboolean(L,lc26);
      const int lc27 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc27) {
        
        /* wood_found = true */
        lua_pushboolean(L,1);
        lua_replace(L,10);
        assert(lua_gettop(L) == 20);
      }
      lua_settop(L,lc25);
      assert(lua_gettop(L) == 20);
      
      /* if( minetest.registered_nodes[ p..m..postfixes[j] ] ) then */
      enum { lc28 = 20 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,20);
      lua_pushvalue(L,15);
      lua_pushvalue(L,19);
      lua_gettable(L,7);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc29 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc29) {
        
        /* table.insert( known_materials, m..postfixes[j] ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushvalue(L,15);
        lua_pushvalue(L,19);
        lua_gettable(L,7);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 20);
      }
      lua_settop(L,lc28);
      assert(lua_gettop(L) == 20);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc24);
    assert(lua_gettop(L) == 15);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc23);
  assert(lua_gettop(L) == 10);
  
  /* -- support wooden planks from moretrees
   * if( wood_found and mg_villages.moretrees_treelist ) then */
  enum { lc30 = 10 };
  lua_pushvalue(L,10);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"moretrees_treelist");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc31 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc31) {
    
    /* for _,v in ipairs( mg_villages.moretrees_treelist ) do
     * internal: local f, s, var = explist */
    enum { lc32 = 10 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"moretrees_treelist");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 14
       * internal: local v with idx 15 */
      
      
      /* if( minetest.registered_nodes[ "moretrees:"..v[1].."_planks"] ) then */
      enum { lc33 = 15 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"moretrees:");
      lua_pushnumber(L,1);
      lua_gettable(L,15);
      lua_pushliteral(L,"_planks");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc34 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc34) {
        
        /* table.insert( known_materials, "moretrees:"..v[1].."_planks" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"moretrees:");
        lua_pushnumber(L,1);
        lua_gettable(L,15);
        lua_pushliteral(L,"_planks");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc33);
      assert(lua_gettop(L) == 15);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc32);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc30);
  assert(lua_gettop(L) == 10);
  
  /* --[[
   * 	-- deco is used by BigFreakingDig; as that one lacks default nodes, it doesn't work out here
   * 	if( wood_found and minetest.get_modpath('deco')) then
   * 		local bfd_treelist = {'birch', 'cherry', 'evergreen', 'oak' };
   * 		for _,v in ipairs( bfd_treelist ) do
   * 			if( minetest.registered_nodes[ "deco:"..v.."_plank"] ) then
   * 				table.insert( known_materials, "deco:"..v.."_plank" );
   * 			end	
   * 		end
   * 	end
   * --]]
   * if( wood_found and mg_villages.ethereal_trees ) then */
  enum { lc35 = 10 };
  lua_pushvalue(L,10);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"ethereal_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc36 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc36) {
    
    /* for _,v in ipairs( mg_villages.ethereal_trees ) do
     * 			-- mushroom in ethereal is a pretty decorative material; increase its probability
     * internal: local f, s, var = explist */
    enum { lc37 = 10 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"ethereal_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 14
       * internal: local v with idx 15 */
      
      
      /* -- mushroom in ethereal is a pretty decorative material; increase its probability
       * if( v == 'mushroom' ) then */
      enum { lc38 = 15 };
      lua_pushliteral(L,"mushroom");
      const int lc39 = lua_equal(L,15,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc39);
      const int lc40 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc40) {
        
        /* table.insert( known_materials, "ethereal:mushroom_pore" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"ethereal:mushroom_pore");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
        
        /* table.insert( known_materials, "ethereal:mushroom_pore" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"ethereal:mushroom_pore");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
        
        /* table.insert( known_materials, "ethereal:mushroom_pore" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"ethereal:mushroom_pore");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
        
        /* -- also increase probability for the decorative blueish wood
         * table.insert( known_materials, "ethereal:frost_wood" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"ethereal:frost_wood");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
        
        /* table.insert( known_materials, "ethereal:frost_wood" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"ethereal:frost_wood");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
      }
      else {
        
        /* elseif( minetest.registered_nodes[ "ethereal:"..v.."_wood"] ) then */
        enum { lc41 = 15 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"registered_nodes");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"ethereal:");
        lua_pushvalue(L,15);
        lua_pushliteral(L,"_wood");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc42 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc42) {
          
          /* table.insert( known_materials, "ethereal:"..v.."_wood" ) */
          lua_getfield(L,LUA_ENVIRONINDEX,"table");
          lua_pushliteral(L,"insert");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,9);
          lua_pushliteral(L,"ethereal:");
          lua_pushvalue(L,15);
          lua_pushliteral(L,"_wood");
          lua_concat(L,2);
          lua_concat(L,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 15);
        }
        lua_settop(L,lc41);
      }
      lua_settop(L,lc38);
      assert(lua_gettop(L) == 15);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc37);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc35);
  assert(lua_gettop(L) == 10);
  
  /* if( wood_found and mg_villages.forest_trees ) then */
  enum { lc43 = 10 };
  lua_pushvalue(L,10);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"forest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc44 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc44) {
    
    /* for _,v in ipairs( mg_villages.forest_trees ) do
     * internal: local f, s, var = explist */
    enum { lc45 = 10 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"forest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 14
       * internal: local v with idx 15 */
      
      
      /* if( minetest.registered_nodes[ 'forest:'..v..'_wood'] ) then */
      enum { lc46 = 15 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"forest:");
      lua_pushvalue(L,15);
      lua_pushliteral(L,"_wood");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc47 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc47) {
        
        /* table.insert( known_materials, 'forest:'..v..'_wood' ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"forest:");
        lua_pushvalue(L,15);
        lua_pushliteral(L,"_wood");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc46);
      assert(lua_gettop(L) == 15);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc45);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc43);
  assert(lua_gettop(L) == 10);
  
  /* if( wood_found and mg_villages.tinytrees_trees ) then */
  enum { lc48 = 10 };
  lua_pushvalue(L,10);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"tinytrees_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc49 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc49) {
    
    /* for _,v in ipairs( mg_villages.tinytrees_trees ) do
     * internal: local f, s, var = explist */
    enum { lc50 = 10 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"tinytrees_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 14
       * internal: local v with idx 15 */
      
      
      /* if( minetest.registered_nodes[ 'trees:wood_'..v] ) then */
      enum { lc51 = 15 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"trees:wood_");
      lua_pushvalue(L,15);
      lua_concat(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc52 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc52) {
        
        /* table.insert( known_materials, 'trees:wood_'..v ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"trees:wood_");
        lua_pushvalue(L,15);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc51);
      assert(lua_gettop(L) == 15);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc50);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc48);
  assert(lua_gettop(L) == 10);
  
  /* if( wood_found and mg_villages.realtest_trees ) then */
  enum { lc53 = 10 };
  lua_pushvalue(L,10);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc54 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc54) {
    
    /* for _,v in ipairs( mg_villages.realtest_trees ) do
     * internal: local f, s, var = explist */
    enum { lc55 = 10 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 14
       * internal: local v with idx 15 */
      
      
      /* if( minetest.registered_nodes[ 'trees:'..v..'_planks'] ) then */
      enum { lc56 = 15 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"trees:");
      lua_pushvalue(L,15);
      lua_pushliteral(L,"_planks");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc57 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc57) {
        
        /* table.insert( known_materials, 'trees:'..v..'_planks' ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"trees:");
        lua_pushvalue(L,15);
        lua_pushliteral(L,"_planks");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc56);
      assert(lua_gettop(L) == 15);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc55);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc53);
  assert(lua_gettop(L) == 10);
  
  /* -- nothing found which could be used
   * if( #known_materials < 1 ) then */
  enum { lc58 = 10 };
  const double lc59 = lua_objlen(L,9);
  lua_pushnumber(L,lc59);
  lua_pushnumber(L,1);
  const int lc60 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc60);
  const int lc61 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc61) {
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc58);
  assert(lua_gettop(L) == 10);
  
  /* local new_material  = known_materials[ pr:next( 1, #known_materials )] */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  const double lc62 = lua_objlen(L,9);
  lua_pushnumber(L,lc62);
  lua_call(L,3,1);
  lua_gettable(L,9);
  assert(lua_gettop(L) == 11);
  
  /* if( use_realtest_stairs == true	) then */
  enum { lc63 = 11 };
  lua_pushboolean(L,1);
  const int lc64 = lua_equal(L,8,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc64);
  const int lc65 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc65) {
    
    /* table.insert( replacements, { original_materials[ 1 ], new_material..'_stair' } ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushnumber(L,1);
    lua_gettable(L,3);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"_stair");
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
    
    /* table.insert( replacements, { original_materials[ 2 ], new_material..'_slab' } ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushnumber(L,2);
    lua_gettable(L,3);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"_slab");
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
    
    /* table.insert( replacements, { original_materials[ 3 ], new_material } ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushnumber(L,3);
    lua_gettable(L,3);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,11);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
    
    /* table.insert( replacements, { original_materials[ 1 ]..'upside_down', new_material..'_stair_upside_down' } ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushnumber(L,1);
    lua_gettable(L,3);
    lua_pushliteral(L,"upside_down");
    lua_concat(L,2);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"_stair_upside_down");
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
    
    /* table.insert( replacements, { original_materials[ 2 ]..'upside_down', new_material..'_slab_upside_down' } ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushnumber(L,2);
    lua_gettable(L,3);
    lua_pushliteral(L,"upside_down");
    lua_concat(L,2);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"_slab_upside_down");
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 11);
    
    /* return new_material */
    lua_pushvalue(L,11);
    return 1;
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc63);
  assert(lua_gettop(L) == 11);
  
  /* -- no replacement necessary if we did choose the same material as before
   * if( new_material == old_material or old_material == (prefixes[1]..new_material)) then */
  enum { lc66 = 11 };
  lua_pushvalue(L,11);
  lua_pushvalue(L,6);
  const int lc67 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc67);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,6);
    lua_pushnumber(L,1);
    lua_gettable(L,4);
    lua_pushvalue(L,11);
    lua_concat(L,2);
    const int lc68 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc68);
  }
  const int lc69 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc69) {
    
    /* return old_material */
    lua_pushvalue(L,6);
    return 1;
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc66);
  assert(lua_gettop(L) == 11);
  
  /* for i,v in ipairs( prefixes ) do
   * internal: local f, s, var = explist */
  enum { lc70 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,4);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 15
     * internal: local v with idx 16 */
    
    
    /* table.insert( replacements, { original_materials[ i ], v..new_material } ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushvalue(L,15);
    lua_gettable(L,3);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,16);
    lua_pushvalue(L,11);
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc70);
  assert(lua_gettop(L) == 11);
  
  /* return new_material */
  lua_pushvalue(L,11);
  return 1;
  assert(lua_gettop(L) == 11);
}


/* name: mg_villages.replace_tree_trunk
 * function( replacements, wood_type) */
static int lcf1_mg_villages_replace_tree_trunk (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if(     wood_type == 'default:junglewood' ) then */
  enum { lc71 = 2 };
  lua_pushliteral(L,"default:junglewood");
  const int lc72 = lua_equal(L,2,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc72);
  const int lc73 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc73) {
    
    /* table.insert( replacements, {'default:tree',  'default:jungletree'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:tree");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:jungletree");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* elseif( wood_type == 'default:pine_wood' ) then */
    enum { lc74 = 2 };
    lua_pushliteral(L,"default:pine_wood");
    const int lc75 = lua_equal(L,2,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc75);
    const int lc76 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc76) {
      
      /* table.insert( replacements, {'default:tree',  'default:pine_tree'}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"default:tree");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"default:pine_tree");
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 2);
    }
    else {
      
      /* elseif( wood_type == 'default:acacia_wood' ) then */
      enum { lc77 = 2 };
      lua_pushliteral(L,"default:acacia_wood");
      const int lc78 = lua_equal(L,2,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc78);
      const int lc79 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc79) {
        
        /* table.insert( replacements, {'default:tree',  'default:acacia_tree'}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_createtable(L,2,0);
        lua_pushliteral(L,"default:tree");
        lua_rawseti(L,-2,1);
        lua_pushliteral(L,"default:acacia_tree");
        lua_rawseti(L,-2,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 2);
      }
      else {
        
        /* elseif( wood_type == 'default:aspen_wood' ) then */
        enum { lc80 = 2 };
        lua_pushliteral(L,"default:aspen_wood");
        const int lc81 = lua_equal(L,2,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc81);
        const int lc82 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc82) {
          
          /* table.insert( replacements, {'default:tree',  'default:aspen_tree'}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"table");
          lua_pushliteral(L,"insert");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_createtable(L,2,0);
          lua_pushliteral(L,"default:tree");
          lua_rawseti(L,-2,1);
          lua_pushliteral(L,"default:aspen_tree");
          lua_rawseti(L,-2,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 2);
        }
        else {
          
          /* elseif( wood_type == 'mg:savannawood' ) then */
          enum { lc83 = 2 };
          lua_pushliteral(L,"mg:savannawood");
          const int lc84 = lua_equal(L,2,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc84);
          const int lc85 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc85) {
            
            /* table.insert( replacements, {'default:tree',  'mg:savannatree'}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"table");
            lua_pushliteral(L,"insert");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_createtable(L,2,0);
            lua_pushliteral(L,"default:tree");
            lua_rawseti(L,-2,1);
            lua_pushliteral(L,"mg:savannatree");
            lua_rawseti(L,-2,2);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 2);
          }
          else {
            
            /* elseif( wood_type == 'mg:pinewood' ) then */
            enum { lc86 = 2 };
            lua_pushliteral(L,"mg:pinewood");
            const int lc87 = lua_equal(L,2,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc87);
            const int lc88 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc88) {
              
              /* table.insert( replacements, {'default:tree',  'mg:pinetree'}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"table");
              lua_pushliteral(L,"insert");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,1);
              lua_createtable(L,2,0);
              lua_pushliteral(L,"default:tree");
              lua_rawseti(L,-2,1);
              lua_pushliteral(L,"mg:pinetree");
              lua_rawseti(L,-2,2);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 2);
            }
            else {
              
              /* elseif( mg_villages.moretrees_treelist ) then */
              enum { lc89 = 2 };
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"moretrees_treelist");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc90 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc90) {
                
                /* for _,v in ipairs( mg_villages.moretrees_treelist ) do
                 * internal: local f, s, var = explist */
                enum { lc91 = 2 };
                lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"moretrees_treelist");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_call(L,1,3);
                while (1) {
                  
                  /* internal: local var_1, ..., var_n = f(s, var)
                   *           if var_1 == nil then break end
                   *           var = var_1 */
                  lua_pushvalue(L,-3);
                  lua_pushvalue(L,-3);
                  lua_pushvalue(L,-3);
                  lua_call(L,2,2);
                  if (lua_isnil(L,-2)) {
                    break;
                  }
                  lua_pushvalue(L,-2);
                  lua_replace(L,-4);
                  
                  /* internal: local _ with idx 6
                   * internal: local v with idx 7 */
                  
                  
                  /* if( wood_type == "moretrees:"..v[1].."_planks" ) then */
                  enum { lc92 = 7 };
                  lua_pushliteral(L,"moretrees:");
                  lua_pushnumber(L,1);
                  lua_gettable(L,7);
                  lua_pushliteral(L,"_planks");
                  lua_concat(L,2);
                  lua_concat(L,2);
                  const int lc93 = lua_equal(L,2,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc93);
                  const int lc94 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc94) {
                    
                    /* table.insert( replacements, {'default:tree',   "moretrees:"..v[1].."_trunk"}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"table");
                    lua_pushliteral(L,"insert");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,1);
                    lua_createtable(L,2,0);
                    lua_pushliteral(L,"default:tree");
                    lua_rawseti(L,-2,1);
                    lua_pushliteral(L,"moretrees:");
                    lua_pushnumber(L,1);
                    lua_gettable(L,7);
                    lua_pushliteral(L,"_trunk");
                    lua_concat(L,2);
                    lua_concat(L,2);
                    lua_rawseti(L,-2,2);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 7);
                    
                    /* table.insert( replacements, {'default:leaves', "moretrees:"..v[1].."_leaves"}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"table");
                    lua_pushliteral(L,"insert");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,1);
                    lua_createtable(L,2,0);
                    lua_pushliteral(L,"default:leaves");
                    lua_rawseti(L,-2,1);
                    lua_pushliteral(L,"moretrees:");
                    lua_pushnumber(L,1);
                    lua_gettable(L,7);
                    lua_pushliteral(L,"_leaves");
                    lua_concat(L,2);
                    lua_concat(L,2);
                    lua_rawseti(L,-2,2);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 7);
                  }
                  lua_settop(L,lc92);
                  assert(lua_gettop(L) == 7);
                  
                  /* internal: stack cleanup on scope exit */
                  lua_pop(L,2);
                }
                lua_settop(L,lc91);
                assert(lua_gettop(L) == 2);
              }
              else {
                
                /* elseif( wood_type == 'deco:birch_plank' ) then */
                enum { lc95 = 2 };
                lua_pushliteral(L,"deco:birch_plank");
                const int lc96 = lua_equal(L,2,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc96);
                const int lc97 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc97) {
                  
                  /* table.insert( replacements, {'default:tree', "mapgen:birch_log"}) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"table");
                  lua_pushliteral(L,"insert");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,1);
                  lua_createtable(L,2,0);
                  lua_pushliteral(L,"default:tree");
                  lua_rawseti(L,-2,1);
                  lua_pushliteral(L,"mapgen:birch_log");
                  lua_rawseti(L,-2,2);
                  lua_call(L,2,0);
                  assert(lua_gettop(L) == 2);
                }
                else {
                  
                  /* elseif( wood_type == 'deco:cherry_plank' ) then */
                  enum { lc98 = 2 };
                  lua_pushliteral(L,"deco:cherry_plank");
                  const int lc99 = lua_equal(L,2,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc99);
                  const int lc100 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc100) {
                    
                    /* table.insert( replacements, {'default:tree', "mapgen:cherry_log"}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"table");
                    lua_pushliteral(L,"insert");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,1);
                    lua_createtable(L,2,0);
                    lua_pushliteral(L,"default:tree");
                    lua_rawseti(L,-2,1);
                    lua_pushliteral(L,"mapgen:cherry_log");
                    lua_rawseti(L,-2,2);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 2);
                  }
                  else {
                    
                    /* elseif( wood_type == 'deco:evergreen_plank' ) then */
                    enum { lc101 = 2 };
                    lua_pushliteral(L,"deco:evergreen_plank");
                    const int lc102 = lua_equal(L,2,-1);
                    lua_pop(L,1);
                    lua_pushboolean(L,lc102);
                    const int lc103 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc103) {
                      
                      /* table.insert( replacements, {'default:tree', "mapgen:evergreen_log"}) */
                      lua_getfield(L,LUA_ENVIRONINDEX,"table");
                      lua_pushliteral(L,"insert");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_pushvalue(L,1);
                      lua_createtable(L,2,0);
                      lua_pushliteral(L,"default:tree");
                      lua_rawseti(L,-2,1);
                      lua_pushliteral(L,"mapgen:evergreen_log");
                      lua_rawseti(L,-2,2);
                      lua_call(L,2,0);
                      assert(lua_gettop(L) == 2);
                    }
                    else {
                      
                      /* elseif( wood_type == 'deco:oak_plank' ) then */
                      enum { lc104 = 2 };
                      lua_pushliteral(L,"deco:oak_plank");
                      const int lc105 = lua_equal(L,2,-1);
                      lua_pop(L,1);
                      lua_pushboolean(L,lc105);
                      const int lc106 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc106) {
                        
                        /* table.insert( replacements, {'default:tree', "mapgen:oak_log"}) */
                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                        lua_pushliteral(L,"insert");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_pushvalue(L,1);
                        lua_createtable(L,2,0);
                        lua_pushliteral(L,"default:tree");
                        lua_rawseti(L,-2,1);
                        lua_pushliteral(L,"mapgen:oak_log");
                        lua_rawseti(L,-2,2);
                        lua_call(L,2,0);
                        assert(lua_gettop(L) == 2);
                      }
                      else {
                        
                        /* elseif( wood_type == 'ethereal:frost_wood' ) then */
                        enum { lc107 = 2 };
                        lua_pushliteral(L,"ethereal:frost_wood");
                        const int lc108 = lua_equal(L,2,-1);
                        lua_pop(L,1);
                        lua_pushboolean(L,lc108);
                        const int lc109 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc109) {
                          
                          /* table.insert( replacements, {'default:tree', "ethereal:frost_tree"}) */
                          lua_getfield(L,LUA_ENVIRONINDEX,"table");
                          lua_pushliteral(L,"insert");
                          lua_gettable(L,-2);
                          lua_remove(L,-2);
                          lua_pushvalue(L,1);
                          lua_createtable(L,2,0);
                          lua_pushliteral(L,"default:tree");
                          lua_rawseti(L,-2,1);
                          lua_pushliteral(L,"ethereal:frost_tree");
                          lua_rawseti(L,-2,2);
                          lua_call(L,2,0);
                          assert(lua_gettop(L) == 2);
                        }
                        else {
                          
                          /* elseif( wood_type == "ethereal:mushroom_pore" ) then */
                          enum { lc110 = 2 };
                          lua_pushliteral(L,"ethereal:mushroom_pore");
                          const int lc111 = lua_equal(L,2,-1);
                          lua_pop(L,1);
                          lua_pushboolean(L,lc111);
                          const int lc112 = lua_toboolean(L,-1);
                          lua_pop(L,1);
                          if (lc112) {
                            
                            /* table.insert( replacements, {'default:tree', "ethereal:mushroom_trunk"}) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"table");
                            lua_pushliteral(L,"insert");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,1);
                            lua_createtable(L,2,0);
                            lua_pushliteral(L,"default:tree");
                            lua_rawseti(L,-2,1);
                            lua_pushliteral(L,"ethereal:mushroom_trunk");
                            lua_rawseti(L,-2,2);
                            lua_call(L,2,0);
                            assert(lua_gettop(L) == 2);
                          }
                          else {
                            
                            /* elseif( mg_villages.ethereal_trees ) then */
                            enum { lc113 = 2 };
                            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                            lua_pushliteral(L,"ethereal_trees");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            const int lc114 = lua_toboolean(L,-1);
                            lua_pop(L,1);
                            if (lc114) {
                              
                              /* for _,v in ipairs( mg_villages.ethereal_trees ) do
                               * internal: local f, s, var = explist */
                              enum { lc115 = 2 };
                              lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                              lua_pushliteral(L,"ethereal_trees");
                              lua_gettable(L,-2);
                              lua_remove(L,-2);
                              lua_call(L,1,3);
                              while (1) {
                                
                                /* internal: local var_1, ..., var_n = f(s, var)
                                 *           if var_1 == nil then break end
                                 *           var = var_1 */
                                lua_pushvalue(L,-3);
                                lua_pushvalue(L,-3);
                                lua_pushvalue(L,-3);
                                lua_call(L,2,2);
                                if (lua_isnil(L,-2)) {
                                  break;
                                }
                                lua_pushvalue(L,-2);
                                lua_replace(L,-4);
                                
                                /* internal: local _ with idx 6
                                 * internal: local v with idx 7 */
                                
                                
                                /* if( wood_type == "ethereal:"..v.."_wood" ) then */
                                enum { lc116 = 7 };
                                lua_pushliteral(L,"ethereal:");
                                lua_pushvalue(L,7);
                                lua_pushliteral(L,"_wood");
                                lua_concat(L,2);
                                lua_concat(L,2);
                                const int lc117 = lua_equal(L,2,-1);
                                lua_pop(L,1);
                                lua_pushboolean(L,lc117);
                                const int lc118 = lua_toboolean(L,-1);
                                lua_pop(L,1);
                                if (lc118) {
                                  
                                  /* table.insert( replacements, {'default:tree', "ethereal:"..v.."_trunk"}) */
                                  lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                  lua_pushliteral(L,"insert");
                                  lua_gettable(L,-2);
                                  lua_remove(L,-2);
                                  lua_pushvalue(L,1);
                                  lua_createtable(L,2,0);
                                  lua_pushliteral(L,"default:tree");
                                  lua_rawseti(L,-2,1);
                                  lua_pushliteral(L,"ethereal:");
                                  lua_pushvalue(L,7);
                                  lua_pushliteral(L,"_trunk");
                                  lua_concat(L,2);
                                  lua_concat(L,2);
                                  lua_rawseti(L,-2,2);
                                  lua_call(L,2,0);
                                  assert(lua_gettop(L) == 7);
                                }
                                lua_settop(L,lc116);
                                assert(lua_gettop(L) == 7);
                                
                                /* internal: stack cleanup on scope exit */
                                lua_pop(L,2);
                              }
                              lua_settop(L,lc115);
                              assert(lua_gettop(L) == 2);
                            }
                            else {
                              
                              /* elseif( mg_villages.forest_trees ) then */
                              enum { lc119 = 2 };
                              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                              lua_pushliteral(L,"forest_trees");
                              lua_gettable(L,-2);
                              lua_remove(L,-2);
                              const int lc120 = lua_toboolean(L,-1);
                              lua_pop(L,1);
                              if (lc120) {
                                
                                /* for _,v in ipairs( mg_villages.forest_trees ) do
                                 * internal: local f, s, var = explist */
                                enum { lc121 = 2 };
                                lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                                lua_pushliteral(L,"forest_trees");
                                lua_gettable(L,-2);
                                lua_remove(L,-2);
                                lua_call(L,1,3);
                                while (1) {
                                  
                                  /* internal: local var_1, ..., var_n = f(s, var)
                                   *           if var_1 == nil then break end
                                   *           var = var_1 */
                                  lua_pushvalue(L,-3);
                                  lua_pushvalue(L,-3);
                                  lua_pushvalue(L,-3);
                                  lua_call(L,2,2);
                                  if (lua_isnil(L,-2)) {
                                    break;
                                  }
                                  lua_pushvalue(L,-2);
                                  lua_replace(L,-4);
                                  
                                  /* internal: local _ with idx 6
                                   * internal: local v with idx 7 */
                                  
                                  
                                  /* if( wood_type == "forest:"..v.."_wood" ) then */
                                  enum { lc122 = 7 };
                                  lua_pushliteral(L,"forest:");
                                  lua_pushvalue(L,7);
                                  lua_pushliteral(L,"_wood");
                                  lua_concat(L,2);
                                  lua_concat(L,2);
                                  const int lc123 = lua_equal(L,2,-1);
                                  lua_pop(L,1);
                                  lua_pushboolean(L,lc123);
                                  const int lc124 = lua_toboolean(L,-1);
                                  lua_pop(L,1);
                                  if (lc124) {
                                    
                                    /* table.insert( replacements, {'default:tree', "forest:"..v.."_tree"}) */
                                    lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                    lua_pushliteral(L,"insert");
                                    lua_gettable(L,-2);
                                    lua_remove(L,-2);
                                    lua_pushvalue(L,1);
                                    lua_createtable(L,2,0);
                                    lua_pushliteral(L,"default:tree");
                                    lua_rawseti(L,-2,1);
                                    lua_pushliteral(L,"forest:");
                                    lua_pushvalue(L,7);
                                    lua_pushliteral(L,"_tree");
                                    lua_concat(L,2);
                                    lua_concat(L,2);
                                    lua_rawseti(L,-2,2);
                                    lua_call(L,2,0);
                                    assert(lua_gettop(L) == 7);
                                  }
                                  lua_settop(L,lc122);
                                  assert(lua_gettop(L) == 7);
                                  
                                  /* internal: stack cleanup on scope exit */
                                  lua_pop(L,2);
                                }
                                lua_settop(L,lc121);
                                assert(lua_gettop(L) == 2);
                              }
                              else {
                                
                                /* elseif( mg_villages.tinytrees_trees ) then */
                                enum { lc125 = 2 };
                                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                                lua_pushliteral(L,"tinytrees_trees");
                                lua_gettable(L,-2);
                                lua_remove(L,-2);
                                const int lc126 = lua_toboolean(L,-1);
                                lua_pop(L,1);
                                if (lc126) {
                                  
                                  /* for _,v in ipairs( mg_villages.tinytrees_trees ) do
                                   * internal: local f, s, var = explist */
                                  enum { lc127 = 2 };
                                  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                                  lua_pushliteral(L,"tinytrees_trees");
                                  lua_gettable(L,-2);
                                  lua_remove(L,-2);
                                  lua_call(L,1,3);
                                  while (1) {
                                    
                                    /* internal: local var_1, ..., var_n = f(s, var)
                                     *           if var_1 == nil then break end
                                     *           var = var_1 */
                                    lua_pushvalue(L,-3);
                                    lua_pushvalue(L,-3);
                                    lua_pushvalue(L,-3);
                                    lua_call(L,2,2);
                                    if (lua_isnil(L,-2)) {
                                      break;
                                    }
                                    lua_pushvalue(L,-2);
                                    lua_replace(L,-4);
                                    
                                    /* internal: local _ with idx 6
                                     * internal: local v with idx 7 */
                                    
                                    
                                    /* if( wood_type == "trees:wood_"..v ) then */
                                    enum { lc128 = 7 };
                                    lua_pushliteral(L,"trees:wood_");
                                    lua_pushvalue(L,7);
                                    lua_concat(L,2);
                                    const int lc129 = lua_equal(L,2,-1);
                                    lua_pop(L,1);
                                    lua_pushboolean(L,lc129);
                                    const int lc130 = lua_toboolean(L,-1);
                                    lua_pop(L,1);
                                    if (lc130) {
                                      
                                      /* table.insert( replacements, {'default:tree', "trees:tree_"..v}) */
                                      lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                      lua_pushliteral(L,"insert");
                                      lua_gettable(L,-2);
                                      lua_remove(L,-2);
                                      lua_pushvalue(L,1);
                                      lua_createtable(L,2,0);
                                      lua_pushliteral(L,"default:tree");
                                      lua_rawseti(L,-2,1);
                                      lua_pushliteral(L,"trees:tree_");
                                      lua_pushvalue(L,7);
                                      lua_concat(L,2);
                                      lua_rawseti(L,-2,2);
                                      lua_call(L,2,0);
                                      assert(lua_gettop(L) == 7);
                                    }
                                    lua_settop(L,lc128);
                                    assert(lua_gettop(L) == 7);
                                    
                                    /* internal: stack cleanup on scope exit */
                                    lua_pop(L,2);
                                  }
                                  lua_settop(L,lc127);
                                  assert(lua_gettop(L) == 2);
                                }
                                else {
                                  
                                  /* elseif( mg_villages.realtest_trees ) then */
                                  enum { lc131 = 2 };
                                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                                  lua_pushliteral(L,"realtest_trees");
                                  lua_gettable(L,-2);
                                  lua_remove(L,-2);
                                  const int lc132 = lua_toboolean(L,-1);
                                  lua_pop(L,1);
                                  if (lc132) {
                                    
                                    /* for _,v in ipairs( mg_villages.realtest_trees ) do
                                     * internal: local f, s, var = explist */
                                    enum { lc133 = 2 };
                                    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                                    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                                    lua_pushliteral(L,"realtest_trees");
                                    lua_gettable(L,-2);
                                    lua_remove(L,-2);
                                    lua_call(L,1,3);
                                    while (1) {
                                      
                                      /* internal: local var_1, ..., var_n = f(s, var)
                                       *           if var_1 == nil then break end
                                       *           var = var_1 */
                                      lua_pushvalue(L,-3);
                                      lua_pushvalue(L,-3);
                                      lua_pushvalue(L,-3);
                                      lua_call(L,2,2);
                                      if (lua_isnil(L,-2)) {
                                        break;
                                      }
                                      lua_pushvalue(L,-2);
                                      lua_replace(L,-4);
                                      
                                      /* internal: local _ with idx 6
                                       * internal: local v with idx 7 */
                                      
                                      
                                      /* if( wood_type == 'trees:'..v..'_planks' ) then */
                                      enum { lc134 = 7 };
                                      lua_pushliteral(L,"trees:");
                                      lua_pushvalue(L,7);
                                      lua_pushliteral(L,"_planks");
                                      lua_concat(L,2);
                                      lua_concat(L,2);
                                      const int lc135 = lua_equal(L,2,-1);
                                      lua_pop(L,1);
                                      lua_pushboolean(L,lc135);
                                      const int lc136 = lua_toboolean(L,-1);
                                      lua_pop(L,1);
                                      if (lc136) {
                                        
                                        /* table.insert( replacements, {'default:tree', "trees:"..v..'_log'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:tree");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_log");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* -- realtest does not have most of the nodes from default, so we need to replace them as well
                                         * table.insert( replacements, {'default:wood',         'trees:'..v..'_planks'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:wood");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_planks");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'default:leaves',       'trees:'..v..'_leaves'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:leaves");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_leaves");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'default:ladder',       'trees:'..v..'_ladder'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:ladder");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_ladder");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'default:chest',        'trees:'..v..'_chest'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:chest");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_chest");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'default:chest_locked', 'trees:'..v..'_chest_locked'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:chest_locked");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_chest_locked");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'default:fence_wood',   'fences:'..v..'_fence'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:fence_wood");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"fences:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_fence");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'default:bookshelf',    'decorations:bookshelf_'..v}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:bookshelf");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"decorations:bookshelf_");
                                        lua_pushvalue(L,7);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'doors:door_wood_t_1',  'doors:door_'..v..'_t_1'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"doors:door_wood_t_1");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"doors:door_");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_t_1");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'doors:door_wood_b_1',  'doors:door_'..v..'_b_1'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"doors:door_wood_b_1");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"doors:door_");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_b_1");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'doors:door_wood_t_2',  'doors:door_'..v..'_t_2'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"doors:door_wood_t_2");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"doors:door_");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_t_2");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'doors:door_wood_b_2',  'doors:door_'..v..'_b_2'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"doors:door_wood_b_2");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"doors:door_");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_b_2");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* -- not really wood-realted, but needs to be replaced as well
                                         * table.insert( replacements, {'default:furnace',      'oven:oven'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"default:furnace");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"oven:oven");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* -- farming is also handled diffrently
                                         * table.insert( replacements, {'farming:soil_wet',     'farming:soil'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:soil_wet");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:soil");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_1',     'farming:flax_1'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_1");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_1");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_2',     'farming:flax_1'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_2");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_1");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_3',     'farming:flax_2'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_3");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_2");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_4',     'farming:flax_2'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_4");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_2");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_5',     'farming:flax_3'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_5");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_3");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_6',     'farming:flax_3'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_6");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_3");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_7',     'farming:flax_4'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_7");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_4");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'farming:cotton_8',     'farming:flax_4'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"farming:cotton_8");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"farming:flax_4");
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* -- stairs and slabs made out of default wood
                                         * table.insert( replacements, {'stairs:stair_wood',    'trees:'..v..'_planks_stair'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"stairs:stair_wood");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_planks_stair");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'stairs:slab_wood',     'trees:'..v..'_planks_slab'}) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"stairs:slab_wood");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_planks_slab");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'stairs:stair_woodupside_down','trees:'..v..'_planks_stair_upside_down' } ) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"stairs:stair_woodupside_down");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_planks_stair_upside_down");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                        
                                        /* table.insert( replacements, {'stairs:slab_woodupside_down', 'trees:'..v..'_planks_slab_upside_down' } ) */
                                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                        lua_pushliteral(L,"insert");
                                        lua_gettable(L,-2);
                                        lua_remove(L,-2);
                                        lua_pushvalue(L,1);
                                        lua_createtable(L,2,0);
                                        lua_pushliteral(L,"stairs:slab_woodupside_down");
                                        lua_rawseti(L,-2,1);
                                        lua_pushliteral(L,"trees:");
                                        lua_pushvalue(L,7);
                                        lua_pushliteral(L,"_planks_slab_upside_down");
                                        lua_concat(L,2);
                                        lua_concat(L,2);
                                        lua_rawseti(L,-2,2);
                                        lua_call(L,2,0);
                                        assert(lua_gettop(L) == 7);
                                      }
                                      lua_settop(L,lc134);
                                      assert(lua_gettop(L) == 7);
                                      
                                      /* internal: stack cleanup on scope exit */
                                      lua_pop(L,2);
                                    }
                                    lua_settop(L,lc133);
                                    assert(lua_gettop(L) == 2);
                                  }
                                  else {
                                    
                                    /* else
                                     * return nil */
                                    lua_pushnil(L);
                                    return 1;
                                    assert(lua_gettop(L) == 2);
                                  }
                                  lua_settop(L,lc131);
                                }
                                lua_settop(L,lc125);
                              }
                              lua_settop(L,lc119);
                            }
                            lua_settop(L,lc113);
                          }
                          lua_settop(L,lc110);
                        }
                        lua_settop(L,lc107);
                      }
                      lua_settop(L,lc104);
                    }
                    lua_settop(L,lc101);
                  }
                  lua_settop(L,lc98);
                }
                lua_settop(L,lc95);
              }
              lua_settop(L,lc89);
            }
            lua_settop(L,lc86);
          }
          lua_settop(L,lc83);
        }
        lua_settop(L,lc80);
      }
      lua_settop(L,lc77);
    }
    lua_settop(L,lc74);
  }
  lua_settop(L,lc71);
  assert(lua_gettop(L) == 2);
  
  /* return wood_type */
  lua_pushvalue(L,2);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* name: mg_villages.replace_saplings
 * function( replacements, wood_type) */
static int lcf1_mg_villages_replace_saplings (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if(     wood_type == 'default:junglewood' ) then */
  enum { lc137 = 2 };
  lua_pushliteral(L,"default:junglewood");
  const int lc138 = lua_equal(L,2,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc138);
  const int lc139 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc139) {
    
    /* table.insert( replacements, {'default:sapling',  'default:junglesapling'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:sapling");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:junglesapling");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* elseif( wood_type == 'default:pine_wood' ) then */
    enum { lc140 = 2 };
    lua_pushliteral(L,"default:pine_wood");
    const int lc141 = lua_equal(L,2,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc141);
    const int lc142 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc142) {
      
      /* table.insert( replacements, {'default:sapling',  'default:pine_sapling'}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"default:sapling");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"default:pine_sapling");
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 2);
    }
    else {
      
      /* elseif( wood_type == 'default:acacia_wood' ) then */
      enum { lc143 = 2 };
      lua_pushliteral(L,"default:acacia_wood");
      const int lc144 = lua_equal(L,2,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc144);
      const int lc145 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc145) {
        
        /* table.insert( replacements, {'default:sapling',  'default:acacia_sapling'}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_createtable(L,2,0);
        lua_pushliteral(L,"default:sapling");
        lua_rawseti(L,-2,1);
        lua_pushliteral(L,"default:acacia_sapling");
        lua_rawseti(L,-2,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 2);
      }
      else {
        
        /* elseif( wood_type == 'default:aspen_wood' ) then */
        enum { lc146 = 2 };
        lua_pushliteral(L,"default:aspen_wood");
        const int lc147 = lua_equal(L,2,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc147);
        const int lc148 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc148) {
          
          /* table.insert( replacements, {'default:sapling',  'default:aspen_sapling'}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"table");
          lua_pushliteral(L,"insert");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_createtable(L,2,0);
          lua_pushliteral(L,"default:sapling");
          lua_rawseti(L,-2,1);
          lua_pushliteral(L,"default:aspen_sapling");
          lua_rawseti(L,-2,2);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 2);
        }
        else {
          
          /* elseif( wood_type == 'mg:savannawood' ) then */
          enum { lc149 = 2 };
          lua_pushliteral(L,"mg:savannawood");
          const int lc150 = lua_equal(L,2,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc150);
          const int lc151 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc151) {
            
            /* table.insert( replacements, {'default:sapling',  'mg:savannasapling'}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"table");
            lua_pushliteral(L,"insert");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_createtable(L,2,0);
            lua_pushliteral(L,"default:sapling");
            lua_rawseti(L,-2,1);
            lua_pushliteral(L,"mg:savannasapling");
            lua_rawseti(L,-2,2);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 2);
          }
          else {
            
            /* elseif( wood_type == 'mg:pinewood' ) then */
            enum { lc152 = 2 };
            lua_pushliteral(L,"mg:pinewood");
            const int lc153 = lua_equal(L,2,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc153);
            const int lc154 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc154) {
              
              /* table.insert( replacements, {'default:sapling',  'mg:pinesapling'}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"table");
              lua_pushliteral(L,"insert");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,1);
              lua_createtable(L,2,0);
              lua_pushliteral(L,"default:sapling");
              lua_rawseti(L,-2,1);
              lua_pushliteral(L,"mg:pinesapling");
              lua_rawseti(L,-2,2);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 2);
            }
            else {
              
              /* elseif( mg_villages.moretrees_treelist ) then */
              enum { lc155 = 2 };
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"moretrees_treelist");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc156 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc156) {
                
                /* for _,v in ipairs( mg_villages.moretrees_treelist ) do
                 * internal: local f, s, var = explist */
                enum { lc157 = 2 };
                lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"moretrees_treelist");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_call(L,1,3);
                while (1) {
                  
                  /* internal: local var_1, ..., var_n = f(s, var)
                   *           if var_1 == nil then break end
                   *           var = var_1 */
                  lua_pushvalue(L,-3);
                  lua_pushvalue(L,-3);
                  lua_pushvalue(L,-3);
                  lua_call(L,2,2);
                  if (lua_isnil(L,-2)) {
                    break;
                  }
                  lua_pushvalue(L,-2);
                  lua_replace(L,-4);
                  
                  /* internal: local _ with idx 6
                   * internal: local v with idx 7 */
                  
                  
                  /* if( wood_type == "moretrees:"..v[1].."_planks" ) then */
                  enum { lc158 = 7 };
                  lua_pushliteral(L,"moretrees:");
                  lua_pushnumber(L,1);
                  lua_gettable(L,7);
                  lua_pushliteral(L,"_planks");
                  lua_concat(L,2);
                  lua_concat(L,2);
                  const int lc159 = lua_equal(L,2,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc159);
                  const int lc160 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc160) {
                    
                    /* table.insert( replacements, {'default:sapling', "moretrees:"..v[1].."_sapling_ongen"}) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"table");
                    lua_pushliteral(L,"insert");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,1);
                    lua_createtable(L,2,0);
                    lua_pushliteral(L,"default:sapling");
                    lua_rawseti(L,-2,1);
                    lua_pushliteral(L,"moretrees:");
                    lua_pushnumber(L,1);
                    lua_gettable(L,7);
                    lua_pushliteral(L,"_sapling_ongen");
                    lua_concat(L,2);
                    lua_concat(L,2);
                    lua_rawseti(L,-2,2);
                    lua_call(L,2,0);
                    assert(lua_gettop(L) == 7);
                  }
                  lua_settop(L,lc158);
                  assert(lua_gettop(L) == 7);
                  
                  /* internal: stack cleanup on scope exit */
                  lua_pop(L,2);
                }
                lua_settop(L,lc157);
                assert(lua_gettop(L) == 2);
              }
              else {
                
                /* elseif( mg_villages.ethereal_trees ) then */
                enum { lc161 = 2 };
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"ethereal_trees");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                const int lc162 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc162) {
                  
                  /* for _,v in ipairs( mg_villages.ethereal_trees ) do
                   * internal: local f, s, var = explist */
                  enum { lc163 = 2 };
                  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                  lua_pushliteral(L,"ethereal_trees");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_call(L,1,3);
                  while (1) {
                    
                    /* internal: local var_1, ..., var_n = f(s, var)
                     *           if var_1 == nil then break end
                     *           var = var_1 */
                    lua_pushvalue(L,-3);
                    lua_pushvalue(L,-3);
                    lua_pushvalue(L,-3);
                    lua_call(L,2,2);
                    if (lua_isnil(L,-2)) {
                      break;
                    }
                    lua_pushvalue(L,-2);
                    lua_replace(L,-4);
                    
                    /* internal: local _ with idx 6
                     * internal: local v with idx 7 */
                    
                    
                    /* if( wood_type == "ethereal:"..v.."_wood" ) then */
                    enum { lc164 = 7 };
                    lua_pushliteral(L,"ethereal:");
                    lua_pushvalue(L,7);
                    lua_pushliteral(L,"_wood");
                    lua_concat(L,2);
                    lua_concat(L,2);
                    const int lc165 = lua_equal(L,2,-1);
                    lua_pop(L,1);
                    lua_pushboolean(L,lc165);
                    const int lc166 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc166) {
                      
                      /* table.insert( replacements, {'default:sapling', "ethereal:"..v.."_sapling"}) */
                      lua_getfield(L,LUA_ENVIRONINDEX,"table");
                      lua_pushliteral(L,"insert");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_pushvalue(L,1);
                      lua_createtable(L,2,0);
                      lua_pushliteral(L,"default:sapling");
                      lua_rawseti(L,-2,1);
                      lua_pushliteral(L,"ethereal:");
                      lua_pushvalue(L,7);
                      lua_pushliteral(L,"_sapling");
                      lua_concat(L,2);
                      lua_concat(L,2);
                      lua_rawseti(L,-2,2);
                      lua_call(L,2,0);
                      assert(lua_gettop(L) == 7);
                    }
                    lua_settop(L,lc164);
                    assert(lua_gettop(L) == 7);
                    
                    /* internal: stack cleanup on scope exit */
                    lua_pop(L,2);
                  }
                  lua_settop(L,lc163);
                  assert(lua_gettop(L) == 2);
                }
                else {
                  
                  /* elseif( mg_villages.forest_trees ) then */
                  enum { lc167 = 2 };
                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                  lua_pushliteral(L,"forest_trees");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  const int lc168 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc168) {
                    
                    /* for _,v in ipairs( mg_villages.forest_trees ) do
                     * internal: local f, s, var = explist */
                    enum { lc169 = 2 };
                    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                    lua_pushliteral(L,"forest_trees");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_call(L,1,3);
                    while (1) {
                      
                      /* internal: local var_1, ..., var_n = f(s, var)
                       *           if var_1 == nil then break end
                       *           var = var_1 */
                      lua_pushvalue(L,-3);
                      lua_pushvalue(L,-3);
                      lua_pushvalue(L,-3);
                      lua_call(L,2,2);
                      if (lua_isnil(L,-2)) {
                        break;
                      }
                      lua_pushvalue(L,-2);
                      lua_replace(L,-4);
                      
                      /* internal: local _ with idx 6
                       * internal: local v with idx 7 */
                      
                      
                      /* if( wood_type == "forest:"..v.."_wood" ) then */
                      enum { lc170 = 7 };
                      lua_pushliteral(L,"forest:");
                      lua_pushvalue(L,7);
                      lua_pushliteral(L,"_wood");
                      lua_concat(L,2);
                      lua_concat(L,2);
                      const int lc171 = lua_equal(L,2,-1);
                      lua_pop(L,1);
                      lua_pushboolean(L,lc171);
                      const int lc172 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc172) {
                        
                        /* table.insert( replacements, {'default:sapling', "forest:"..v.."_sapling"}) */
                        lua_getfield(L,LUA_ENVIRONINDEX,"table");
                        lua_pushliteral(L,"insert");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_pushvalue(L,1);
                        lua_createtable(L,2,0);
                        lua_pushliteral(L,"default:sapling");
                        lua_rawseti(L,-2,1);
                        lua_pushliteral(L,"forest:");
                        lua_pushvalue(L,7);
                        lua_pushliteral(L,"_sapling");
                        lua_concat(L,2);
                        lua_concat(L,2);
                        lua_rawseti(L,-2,2);
                        lua_call(L,2,0);
                        assert(lua_gettop(L) == 7);
                      }
                      lua_settop(L,lc170);
                      assert(lua_gettop(L) == 7);
                      
                      /* internal: stack cleanup on scope exit */
                      lua_pop(L,2);
                    }
                    lua_settop(L,lc169);
                    assert(lua_gettop(L) == 2);
                  }
                  else {
                    
                    /* elseif( mg_villages.tinytrees_trees ) then */
                    enum { lc173 = 2 };
                    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                    lua_pushliteral(L,"tinytrees_trees");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    const int lc174 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc174) {
                      
                      /* for _,v in ipairs( mg_villages.tinytrees_trees ) do
                       * internal: local f, s, var = explist */
                      enum { lc175 = 2 };
                      lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                      lua_pushliteral(L,"tinytrees_trees");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_call(L,1,3);
                      while (1) {
                        
                        /* internal: local var_1, ..., var_n = f(s, var)
                         *           if var_1 == nil then break end
                         *           var = var_1 */
                        lua_pushvalue(L,-3);
                        lua_pushvalue(L,-3);
                        lua_pushvalue(L,-3);
                        lua_call(L,2,2);
                        if (lua_isnil(L,-2)) {
                          break;
                        }
                        lua_pushvalue(L,-2);
                        lua_replace(L,-4);
                        
                        /* internal: local _ with idx 6
                         * internal: local v with idx 7 */
                        
                        
                        /* if( wood_type == "trees:wood_"..v ) then */
                        enum { lc176 = 7 };
                        lua_pushliteral(L,"trees:wood_");
                        lua_pushvalue(L,7);
                        lua_concat(L,2);
                        const int lc177 = lua_equal(L,2,-1);
                        lua_pop(L,1);
                        lua_pushboolean(L,lc177);
                        const int lc178 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc178) {
                          
                          /* table.insert( replacements, {'default:sapling', "trees:sapling_"..v}) */
                          lua_getfield(L,LUA_ENVIRONINDEX,"table");
                          lua_pushliteral(L,"insert");
                          lua_gettable(L,-2);
                          lua_remove(L,-2);
                          lua_pushvalue(L,1);
                          lua_createtable(L,2,0);
                          lua_pushliteral(L,"default:sapling");
                          lua_rawseti(L,-2,1);
                          lua_pushliteral(L,"trees:sapling_");
                          lua_pushvalue(L,7);
                          lua_concat(L,2);
                          lua_rawseti(L,-2,2);
                          lua_call(L,2,0);
                          assert(lua_gettop(L) == 7);
                        }
                        lua_settop(L,lc176);
                        assert(lua_gettop(L) == 7);
                        
                        /* internal: stack cleanup on scope exit */
                        lua_pop(L,2);
                      }
                      lua_settop(L,lc175);
                      assert(lua_gettop(L) == 2);
                    }
                    else {
                      
                      /* elseif( mg_villages.realtest_trees ) then */
                      enum { lc179 = 2 };
                      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                      lua_pushliteral(L,"realtest_trees");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      const int lc180 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc180) {
                        
                        /* for _,v in ipairs( mg_villages.realtest_trees ) do
                         * internal: local f, s, var = explist */
                        enum { lc181 = 2 };
                        lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
                        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                        lua_pushliteral(L,"realtest_trees");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_call(L,1,3);
                        while (1) {
                          
                          /* internal: local var_1, ..., var_n = f(s, var)
                           *           if var_1 == nil then break end
                           *           var = var_1 */
                          lua_pushvalue(L,-3);
                          lua_pushvalue(L,-3);
                          lua_pushvalue(L,-3);
                          lua_call(L,2,2);
                          if (lua_isnil(L,-2)) {
                            break;
                          }
                          lua_pushvalue(L,-2);
                          lua_replace(L,-4);
                          
                          /* internal: local _ with idx 6
                           * internal: local v with idx 7 */
                          
                          
                          /* if( wood_type == 'trees:'..v..'_planks' ) then */
                          enum { lc182 = 7 };
                          lua_pushliteral(L,"trees:");
                          lua_pushvalue(L,7);
                          lua_pushliteral(L,"_planks");
                          lua_concat(L,2);
                          lua_concat(L,2);
                          const int lc183 = lua_equal(L,2,-1);
                          lua_pop(L,1);
                          lua_pushboolean(L,lc183);
                          const int lc184 = lua_toboolean(L,-1);
                          lua_pop(L,1);
                          if (lc184) {
                            
                            /* table.insert( replacements, {'default:sapling', "trees:"..v.."_sapling"}) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"table");
                            lua_pushliteral(L,"insert");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,1);
                            lua_createtable(L,2,0);
                            lua_pushliteral(L,"default:sapling");
                            lua_rawseti(L,-2,1);
                            lua_pushliteral(L,"trees:");
                            lua_pushvalue(L,7);
                            lua_pushliteral(L,"_sapling");
                            lua_concat(L,2);
                            lua_concat(L,2);
                            lua_rawseti(L,-2,2);
                            lua_call(L,2,0);
                            assert(lua_gettop(L) == 7);
                            
                            /* table.insert( replacements, {'default:junglesapling', "trees:"..v.."_sapling"}) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"table");
                            lua_pushliteral(L,"insert");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,1);
                            lua_createtable(L,2,0);
                            lua_pushliteral(L,"default:junglesapling");
                            lua_rawseti(L,-2,1);
                            lua_pushliteral(L,"trees:");
                            lua_pushvalue(L,7);
                            lua_pushliteral(L,"_sapling");
                            lua_concat(L,2);
                            lua_concat(L,2);
                            lua_rawseti(L,-2,2);
                            lua_call(L,2,0);
                            assert(lua_gettop(L) == 7);
                            
                            /* table.insert( replacements, {'default:pine_sapling',  "trees:"..v.."_sapling"}) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"table");
                            lua_pushliteral(L,"insert");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,1);
                            lua_createtable(L,2,0);
                            lua_pushliteral(L,"default:pine_sapling");
                            lua_rawseti(L,-2,1);
                            lua_pushliteral(L,"trees:");
                            lua_pushvalue(L,7);
                            lua_pushliteral(L,"_sapling");
                            lua_concat(L,2);
                            lua_concat(L,2);
                            lua_rawseti(L,-2,2);
                            lua_call(L,2,0);
                            assert(lua_gettop(L) == 7);
                            
                            /* table.insert( replacements, {'default:aspen_sapling', "trees:"..v.."_sapling"}) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"table");
                            lua_pushliteral(L,"insert");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,1);
                            lua_createtable(L,2,0);
                            lua_pushliteral(L,"default:aspen_sapling");
                            lua_rawseti(L,-2,1);
                            lua_pushliteral(L,"trees:");
                            lua_pushvalue(L,7);
                            lua_pushliteral(L,"_sapling");
                            lua_concat(L,2);
                            lua_concat(L,2);
                            lua_rawseti(L,-2,2);
                            lua_call(L,2,0);
                            assert(lua_gettop(L) == 7);
                          }
                          lua_settop(L,lc182);
                          assert(lua_gettop(L) == 7);
                          
                          /* internal: stack cleanup on scope exit */
                          lua_pop(L,2);
                        }
                        lua_settop(L,lc181);
                        assert(lua_gettop(L) == 2);
                      }
                      else {
                        
                        /* elseif( wood_type == 'deco:birch_plank' ) then */
                        enum { lc185 = 2 };
                        lua_pushliteral(L,"deco:birch_plank");
                        const int lc186 = lua_equal(L,2,-1);
                        lua_pop(L,1);
                        lua_pushboolean(L,lc186);
                        const int lc187 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc187) {
                          
                          /* table.insert( replacements, {'default:sapling', "mapgen:birch_sapling"}) */
                          lua_getfield(L,LUA_ENVIRONINDEX,"table");
                          lua_pushliteral(L,"insert");
                          lua_gettable(L,-2);
                          lua_remove(L,-2);
                          lua_pushvalue(L,1);
                          lua_createtable(L,2,0);
                          lua_pushliteral(L,"default:sapling");
                          lua_rawseti(L,-2,1);
                          lua_pushliteral(L,"mapgen:birch_sapling");
                          lua_rawseti(L,-2,2);
                          lua_call(L,2,0);
                          assert(lua_gettop(L) == 2);
                        }
                        else {
                          
                          /* elseif( wood_type == 'deco:cherry_plank' ) then */
                          enum { lc188 = 2 };
                          lua_pushliteral(L,"deco:cherry_plank");
                          const int lc189 = lua_equal(L,2,-1);
                          lua_pop(L,1);
                          lua_pushboolean(L,lc189);
                          const int lc190 = lua_toboolean(L,-1);
                          lua_pop(L,1);
                          if (lc190) {
                            
                            /* table.insert( replacements, {'default:sapling', "mapgen:cherry_sapling"}) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"table");
                            lua_pushliteral(L,"insert");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,1);
                            lua_createtable(L,2,0);
                            lua_pushliteral(L,"default:sapling");
                            lua_rawseti(L,-2,1);
                            lua_pushliteral(L,"mapgen:cherry_sapling");
                            lua_rawseti(L,-2,2);
                            lua_call(L,2,0);
                            assert(lua_gettop(L) == 2);
                          }
                          else {
                            
                            /* elseif( wood_type == 'deco:evergreen_plank' ) then */
                            enum { lc191 = 2 };
                            lua_pushliteral(L,"deco:evergreen_plank");
                            const int lc192 = lua_equal(L,2,-1);
                            lua_pop(L,1);
                            lua_pushboolean(L,lc192);
                            const int lc193 = lua_toboolean(L,-1);
                            lua_pop(L,1);
                            if (lc193) {
                              
                              /* table.insert( replacements, {'default:sapling', "mapgen:evergreen_sapling"}) */
                              lua_getfield(L,LUA_ENVIRONINDEX,"table");
                              lua_pushliteral(L,"insert");
                              lua_gettable(L,-2);
                              lua_remove(L,-2);
                              lua_pushvalue(L,1);
                              lua_createtable(L,2,0);
                              lua_pushliteral(L,"default:sapling");
                              lua_rawseti(L,-2,1);
                              lua_pushliteral(L,"mapgen:evergreen_sapling");
                              lua_rawseti(L,-2,2);
                              lua_call(L,2,0);
                              assert(lua_gettop(L) == 2);
                            }
                            else {
                              
                              /* elseif( wood_type == 'deco:oak_plank' ) then */
                              enum { lc194 = 2 };
                              lua_pushliteral(L,"deco:oak_plank");
                              const int lc195 = lua_equal(L,2,-1);
                              lua_pop(L,1);
                              lua_pushboolean(L,lc195);
                              const int lc196 = lua_toboolean(L,-1);
                              lua_pop(L,1);
                              if (lc196) {
                                
                                /* table.insert( replacements, {'default:sapling', "mapgen:oak_sapling"}) */
                                lua_getfield(L,LUA_ENVIRONINDEX,"table");
                                lua_pushliteral(L,"insert");
                                lua_gettable(L,-2);
                                lua_remove(L,-2);
                                lua_pushvalue(L,1);
                                lua_createtable(L,2,0);
                                lua_pushliteral(L,"default:sapling");
                                lua_rawseti(L,-2,1);
                                lua_pushliteral(L,"mapgen:oak_sapling");
                                lua_rawseti(L,-2,2);
                                lua_call(L,2,0);
                                assert(lua_gettop(L) == 2);
                              }
                              lua_settop(L,lc194);
                            }
                            lua_settop(L,lc191);
                          }
                          lua_settop(L,lc188);
                        }
                        lua_settop(L,lc185);
                      }
                      lua_settop(L,lc179);
                    }
                    lua_settop(L,lc173);
                  }
                  lua_settop(L,lc167);
                }
                lua_settop(L,lc161);
              }
              lua_settop(L,lc155);
            }
            lua_settop(L,lc152);
          }
          lua_settop(L,lc149);
        }
        lua_settop(L,lc146);
      }
      lua_settop(L,lc143);
    }
    lua_settop(L,lc140);
  }
  lua_settop(L,lc137);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <math.h>

/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.get_replacement_list
 * function( housetype, pr) */
static int lcf1_mg_villages_get_replacement_list (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local replacements = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 3);
  
  /* -- else some grass would never (re)grow (if it's below a roof)
   * --   table.insert( replacements, {'default:dirt',            dirt_with_grass_replacement });
   * --   table.insert( replacements, {'default:dirt_with_grass', dirt_with_grass_replacement });
   * table.insert( replacements, {'default:dirt',            'default:dirt_with_grass' }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:dirt");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:dirt_with_grass");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* -- realtest lacks quite a lot from default
   * if( mg_villages.realtest_trees ) then */
  enum { lc197 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc198 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc198) {
    
    /* for i=1,8 do */
    lua_pushnumber(L,1);
    lua_pushnumber(L,8);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc199_var = lua_tonumber(L,-2);
    const double lc200_limit = lua_tonumber(L,-1);
    const double lc201_step = 1;
    lua_pop(L,2);
    enum { lc202 = 3 };
    while ((((lc201_step > 0) && (lc199_var <= lc200_limit)) || ((lc201_step <= 0) && (lc199_var >= lc200_limit)))) {
      
      /* internal: local i at index 4 */
      lua_pushnumber(L,lc199_var);
      
      /* table.insert( replacements, {'farming:wheat_'..i,       'farming:spelt_'..tostring( (i+(i%2))/2) }) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"farming:wheat_");
      lua_pushvalue(L,4);
      lua_concat(L,2);
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"farming:spelt_");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushnumber(L,2);
      lc_mod(L,4,-1);
      lua_remove(L,-2);
      lc_add(L,4,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_concat(L,2);
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
      
      /* table.insert( replacements, {'farming:cotton_'..i,      'farming:flax_' ..tostring( (i+(i%2))/2) }) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"farming:cotton_");
      lua_pushvalue(L,4);
      lua_concat(L,2);
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"farming:flax_");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushnumber(L,2);
      lc_mod(L,4,-1);
      lua_remove(L,-2);
      lc_add(L,4,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_concat(L,2);
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc199_var += lc201_step;
    }
    lua_settop(L,lc202);
    assert(lua_gettop(L) == 3);
    
    /* for i=1,5 do */
    lua_pushnumber(L,1);
    lua_pushnumber(L,5);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc203_var = lua_tonumber(L,-2);
    const double lc204_limit = lua_tonumber(L,-1);
    const double lc205_step = 1;
    lua_pop(L,2);
    enum { lc206 = 3 };
    while ((((lc205_step > 0) && (lc203_var <= lc204_limit)) || ((lc205_step <= 0) && (lc203_var >= lc204_limit)))) {
      
      /* internal: local i at index 4 */
      lua_pushnumber(L,lc203_var);
      
      /* table.insert( replacements, {'default:grass_'..i,       'air' }) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"default:grass_");
      lua_pushvalue(L,4);
      lua_concat(L,2);
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"air");
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc203_var += lc205_step;
    }
    lua_settop(L,lc206);
    assert(lua_gettop(L) == 3);
    
    /* table.insert(         replacements, {'default:apple',           'air' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:apple");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"air");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert(         replacements, {'default:cobble',          'default:stone_macadam' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_macadam");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert(         replacements, {'default:obsidian_glass',  'default:glass' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:obsidian_glass");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:glass");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * table.insert( replacements, {'doors:door_wood_t_1',  'doors:hidden'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"doors:door_wood_t_1");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"doors:hidden");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'doors:door_wood_b_1',  'doors:door_wood_a'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"doors:door_wood_b_1");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"doors:door_wood_a");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'doors:door_wood_t_2',  'doors:hidden'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"doors:door_wood_t_2");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"doors:hidden");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'doors:door_wood_b_2',  'doors:door_wood_b'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"doors:door_wood_b_2");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"doors:door_wood_b");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc197);
  assert(lua_gettop(L) == 3);
  
  /* if( housetype and mg_villages.village_type_data[ housetype ] and mg_villages.village_type_data[ housetype ].replacement_function ) then */
  enum { lc207 = 3 };
  lua_pushvalue(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"replacement_function");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc208 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc208) {
    
    /* return mg_villages.village_type_data[ housetype ].replacement_function( housetype, pr, replacements ) */
    const int lc209 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"replacement_function");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_call(L,3,LUA_MULTRET);
    return (lua_gettop(L) - lc209);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc207);
  assert(lua_gettop(L) == 3);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: mg_villages.replacements_taoki
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_taoki (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local wood_type = 'default:wood' */
  lua_pushliteral(L,"default:wood");
  assert(lua_gettop(L) == 4);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc210 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc211 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc211) {
    
    /* wood_type = mg_villages.replace_materials( replacements, pr,
     * 		{'default:wood'},
     * 		{''},
     * 		{'default:wood'},
     *  		'default:wood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:wood");
    lua_call(L,6,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:stair_cobble', 'default:stone_bricks_stair' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_stair");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:slab_cobble',  'default:stone_bricks_slab' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_slab");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:stair_stone',  'default:stone_flat_stair' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_stone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_flat_stair");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:slab_stone',   'default:stone_flat_slab' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_stone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_flat_slab");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* else
     * -- the main body of the houses in the .mts files is made out of wood
     * wood_type = mg_villages.replace_materials( replacements, pr,
     * 		{'default:wood'},
     * 		{''},
     * 		{'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:pinewood', 'mg:savannawood',
     * 		'default:clay', 'default:brick', 'default:sandstone', 
     * 		'default:stonebrick', 'default:desert_stonebrick','default:sandstonebrick', 'default:sandstone','default:stone','default:desert_stone',
     * 		'default:coalblock','default:steelblock','default:goldblock', 'default:bronzeblock', 'default:copperblock', 'wool:white',
     * 		'default:stone_flat', 'default:desert_stone_flat', -- realtest
     * 		'darkage:adobe', 'darkage:basalt', 'darkage:basalt_cobble', 'darkage:chalk',
     * 		'darkage:gneiss', 'darkage:gneiss_cobble', 'darkage:marble', 'darkage:marble_tile',
     * 		'darkage:mud', 'darkage:ors', 'darkage:ors_cobble',
     * 		'darkage:schist', 'darkage:serpentine', 'darkage:shale', 'darkage:silt', 'darkage:slate',
     * 		'mapgen:mese_stone', 'mapgen:soap_stone'},
     * 		'default:wood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,42,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:junglewood");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:pine_wood");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"default:acacia_wood");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"default:aspen_wood");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"mg:pinewood");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"mg:savannawood");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"default:clay");
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"default:brick");
    lua_rawseti(L,-2,9);
    lua_pushliteral(L,"default:sandstone");
    lua_rawseti(L,-2,10);
    lua_pushliteral(L,"default:stonebrick");
    lua_rawseti(L,-2,11);
    lua_pushliteral(L,"default:desert_stonebrick");
    lua_rawseti(L,-2,12);
    lua_pushliteral(L,"default:sandstonebrick");
    lua_rawseti(L,-2,13);
    lua_pushliteral(L,"default:sandstone");
    lua_rawseti(L,-2,14);
    lua_pushliteral(L,"default:stone");
    lua_rawseti(L,-2,15);
    lua_pushliteral(L,"default:desert_stone");
    lua_rawseti(L,-2,16);
    lua_pushliteral(L,"default:coalblock");
    lua_rawseti(L,-2,17);
    lua_pushliteral(L,"default:steelblock");
    lua_rawseti(L,-2,18);
    lua_pushliteral(L,"default:goldblock");
    lua_rawseti(L,-2,19);
    lua_pushliteral(L,"default:bronzeblock");
    lua_rawseti(L,-2,20);
    lua_pushliteral(L,"default:copperblock");
    lua_rawseti(L,-2,21);
    lua_pushliteral(L,"wool:white");
    lua_rawseti(L,-2,22);
    lua_pushliteral(L,"default:stone_flat");
    lua_rawseti(L,-2,23);
    lua_pushliteral(L,"default:desert_stone_flat");
    lua_rawseti(L,-2,24);
    lua_pushliteral(L,"darkage:adobe");
    lua_rawseti(L,-2,25);
    lua_pushliteral(L,"darkage:basalt");
    lua_rawseti(L,-2,26);
    lua_pushliteral(L,"darkage:basalt_cobble");
    lua_rawseti(L,-2,27);
    lua_pushliteral(L,"darkage:chalk");
    lua_rawseti(L,-2,28);
    lua_pushliteral(L,"darkage:gneiss");
    lua_rawseti(L,-2,29);
    lua_pushliteral(L,"darkage:gneiss_cobble");
    lua_rawseti(L,-2,30);
    lua_pushliteral(L,"darkage:marble");
    lua_rawseti(L,-2,31);
    lua_pushliteral(L,"darkage:marble_tile");
    lua_rawseti(L,-2,32);
    lua_pushliteral(L,"darkage:mud");
    lua_rawseti(L,-2,33);
    lua_pushliteral(L,"darkage:ors");
    lua_rawseti(L,-2,34);
    lua_pushliteral(L,"darkage:ors_cobble");
    lua_rawseti(L,-2,35);
    lua_pushliteral(L,"darkage:schist");
    lua_rawseti(L,-2,36);
    lua_pushliteral(L,"darkage:serpentine");
    lua_rawseti(L,-2,37);
    lua_pushliteral(L,"darkage:shale");
    lua_rawseti(L,-2,38);
    lua_pushliteral(L,"darkage:silt");
    lua_rawseti(L,-2,39);
    lua_pushliteral(L,"darkage:slate");
    lua_rawseti(L,-2,40);
    lua_pushliteral(L,"mapgen:mese_stone");
    lua_rawseti(L,-2,41);
    lua_pushliteral(L,"mapgen:soap_stone");
    lua_rawseti(L,-2,42);
    lua_pushliteral(L,"default:wood");
    lua_call(L,6,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc210);
  assert(lua_gettop(L) == 4);
  
  /* -- tree trunks are seldom used in these houses; let's change them anyway
   * mg_villages.replace_tree_trunk( replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_tree_trunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* -- all this comes in variants for stairs and slabs as well
   * mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_stonebrick',  'stairs:slab_stonebrick', 'default:stonebrick'},
   * 		{'stairs:stair_',            'stairs:slab_',           'default:'          },
   * 		{ 'stonebrick', 'stone', 'sandstone', 'cobble'},
   * 		'stonebrick') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_stonebrick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_stonebrick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:stonebrick");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,3);
  lua_createtable(L,4,0);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"cobble");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"stonebrick");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 4);
  
  /* -- decorative slabs above doors etc.
   * mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_wood'},
   * 		{'stairs:stair_'},
   * 		{'stonebrick', 'stone', 'sandstone', 'cobble', 'wood', 'junglewood', 'pine_wood', 'acaica_wood', 'aspen_wood' },
   * 		'wood') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"stairs:stair_wood");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_createtable(L,9,0);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"cobble");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"junglewood");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"pine_wood");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"acaica_wood");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"aspen_wood");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"wood");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 4);
  
  /* -- brick roofs are a bit odd; but then...
   * -- all three shapes of roof parts have to fit together
   * mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_brick',  'stairs:slab_brick', 'default:brick'},
   * 		{'stairs:stair_',       'stairs:slab_',      'default:'     },
   * 		{ 'brick', 'stone', 'cobble', 'stonebrick', 'wood', 'junglewood', 'pine_wood', 'acacia_wood', 'aspen_wood', 'sandstone' },
   * 		'brick' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_brick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_brick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:brick");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,3);
  lua_createtable(L,10,0);
  lua_pushliteral(L,"brick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"cobble");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"junglewood");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"pine_wood");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"acacia_wood");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"aspen_wood");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"brick");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 4);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.replacements_nore
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_nore (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* mg_villages.replace_materials( replacements, pr,
   * --		{'default:stonebrick'},
   * --		{'default:'},
   * 		{'stairs:stair_stonebrick',  'stairs:slab_stonebrick', 'default:stonebrick'},
   * 		{'stairs:stair_',       'stairs:slab_',      'default:'     },
   * 		{'stonebrick', 'desert_stonebrick','sandstonebrick', 'sandstone','stone','desert_stone','stone_flat','desert_stone_flat','stone_bricks','desert_strone_bricks'},
   * 		'stonebrick') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_stonebrick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_stonebrick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:stonebrick");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,3);
  lua_createtable(L,10,0);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"desert_stonebrick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"sandstonebrick");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"desert_stone");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"stone_flat");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"desert_stone_flat");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"stone_bricks");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"desert_strone_bricks");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"stonebrick");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 3);
  
  /* -- replace the wood as well
   * local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:savannawood', 'mg:pinewood' },
   * 		'default:wood') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_createtable(L,7,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:junglewood");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:pine_wood");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"default:acacia_wood");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"default:aspen_wood");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"default:wood");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_tree_trunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_saplings(   replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_saplings");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* if( pr:next(1,3)==1 and not( mg_villages.realtest_trees)) then */
  enum { lc212 = 4 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,3);
  lua_call(L,3,1);
  lua_pushnumber(L,1);
  const int lc213 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc213);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc214 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc214) {
    
    /* table.insert( replacements, {'default:glass', 'default:obsidian_glass'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:glass");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:obsidian_glass");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc212);
  assert(lua_gettop(L) == 4);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc215 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc216 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc216) {
    
    /* table.insert( replacements, {'stairs:stair_cobble', 'default:stone_bricks_stair' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_stair");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:slab_cobble',  'default:stone_bricks_slab' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_slab");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc215);
  assert(lua_gettop(L) == 4);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.replacements_lumberjack
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_lumberjack (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- replace the wood - those are lumberjacks after all
   * local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:savannawood', 'mg:pinewood' },
   * 		'default:wood') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_createtable(L,7,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:junglewood");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:pine_wood");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"default:acacia_wood");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"default:aspen_wood");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"default:wood");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_tree_trunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_saplings(   replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_saplings");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* if( not( minetest.get_modpath('bell' ))) then */
  enum { lc217 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"bell");
  lua_call(L,1,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc218 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc218) {
    
    /* table.insert( replacements, {'bell:bell',               'default:goldblock' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"bell:bell");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:goldblock");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc217);
  assert(lua_gettop(L) == 4);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc219 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc220 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc220) {
    
    /* table.insert( replacements, {'stairs:stair_cobble', 'default:stone_bricks_stair' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_stair");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:slab_cobble',  'default:stone_bricks_slab' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_slab");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc219);
  assert(lua_gettop(L) == 4);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.replacements_logcabin
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_logcabin (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- for logcabins, wood is the most likely type of roof material
   * local roof_type = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_cobble',      'stairs:slab_cobble' },
   * 		{'cottages:roof_connector_', 'cottages:roof_flat_' },
   * 		{'straw', 'wood',  'wood', 'wood', 'reet', 'slate', 'red', 'brown', 'black'},
   * 		'' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"stairs:stair_cobble");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_cobble");
  lua_rawseti(L,-2,2);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"cottages:roof_connector_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"cottages:roof_flat_");
  lua_rawseti(L,-2,2);
  lua_createtable(L,9,0);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"slate");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"red");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"brown");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"black");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 4);
  
  /* -- some houses have junglewood roofs
   * if( roof_type ) then */
  enum { lc221 = 4 };
  if (lua_toboolean(L,4)) {
    
    /* table.insert( replacements, {'stairs:stair_junglewood',          'cottages:roof_connector_'..roof_type }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_junglewood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_connector_");
    lua_pushvalue(L,4);
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:slab_junglewood',           'cottages:roof_flat_'..roof_type }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_junglewood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_flat_");
    lua_pushvalue(L,4);
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'cottages:roof_connector_wood',     'cottages:roof_connector_'..roof_type }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"cottages:roof_connector_wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_connector_");
    lua_pushvalue(L,4);
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'cottages:roof_flat_wood',          'cottages:roof_flat_'..roof_type }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"cottages:roof_flat_wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_flat_");
    lua_pushvalue(L,4);
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* -- realtest does not have normal stairs
     *       elseif( mg_villages.realtest_trees ) then */
    enum { lc222 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc223 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc223) {
      
      /* table.insert( replacements, {'stairs:stair_junglewood',          'trees:aspen_planks_stair' }) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"stairs:stair_junglewood");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"trees:aspen_planks_stair");
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
      
      /* table.insert( replacements, {'stairs:slab_junglewood',           'trees:aspen_planks_slab' }) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"stairs:slab_junglewood");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"trees:aspen_planks_slab");
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc222);
  }
  lua_settop(L,lc221);
  assert(lua_gettop(L) == 4);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc224 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc225 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc225) {
    
    /* local wood_type = mg_villages.replace_materials( replacements, pr,
     * 		{'default:wood'},
     * 		{''},
     * 		{ 'default:wood' },
     * 		'default:wood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:wood");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 5);
    
    /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_tree_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,5);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* mg_villages.replace_saplings(   replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_saplings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,5);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* table.insert( replacements, {'default:stonebrick',      'default:stone_bricks' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:stonebrick");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* -- used for chimneys
     * table.insert( replacements, {'stairs:stair_stonebrick', 'default:stone_bricks_stair' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_stonebrick");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_bricks_stair");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* -- table.insert( replacements, {'default:junglewood', wood_type }); -- replace the floor
     * -- replace the floor with another type of wood (looks better than the same type as above)
     * mg_villages.replace_materials( replacements, pr,
     * 		{'default:junglewood'},
     * 		{''},
     * 		{ 'default:wood' },
     * 		'default:junglewood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:junglewood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:junglewood");
    lua_call(L,6,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc224);
  assert(lua_gettop(L) == 4);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.replacements_chateau
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_chateau (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if( minetest.get_modpath( 'cottages' )) then */
  enum { lc226 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"cottages");
  lua_call(L,1,1);
  const int lc227 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc227) {
    
    /* -- straw is the most likely building material for roofs for historical buildings
     * mg_villages.replace_materials( replacements, pr,
     * 		-- all three shapes of roof parts have to fit together
     * 		{ 'cottages:roof_straw',    'cottages:roof_connector_straw',   'cottages:roof_flat_straw' },
     * 		{ 'cottages:roof_',         'cottages:roof_connector_',        'cottages:roof_flat_'},
     * 		{'straw', 'straw', 'straw', 'straw', 'straw',
     * 			   'reet', 'reet', 'reet',
     * 			   'slate', 'slate',
     *                            'wood',  'wood',  
     *                            'red',
     *                            'brown',
     *                            'black'},
     * 		'straw') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"cottages:roof_straw");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_connector_straw");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"cottages:roof_flat_straw");
    lua_rawseti(L,-2,3);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"cottages:roof_");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_connector_");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"cottages:roof_flat_");
    lua_rawseti(L,-2,3);
    lua_createtable(L,15,0);
    lua_pushliteral(L,"straw");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"straw");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"straw");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"straw");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"straw");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"reet");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"reet");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"reet");
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"slate");
    lua_rawseti(L,-2,9);
    lua_pushliteral(L,"slate");
    lua_rawseti(L,-2,10);
    lua_pushliteral(L,"wood");
    lua_rawseti(L,-2,11);
    lua_pushliteral(L,"wood");
    lua_rawseti(L,-2,12);
    lua_pushliteral(L,"red");
    lua_rawseti(L,-2,13);
    lua_pushliteral(L,"brown");
    lua_rawseti(L,-2,14);
    lua_pushliteral(L,"black");
    lua_rawseti(L,-2,15);
    lua_pushliteral(L,"straw");
    lua_call(L,6,0);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * mg_villages.replace_materials( replacements, pr,
     * 		-- all three shapes of roof parts have to fit together
     * 		{ 'cottages:roof_straw',    'cottages:roof_connector_straw',   'cottages:roof_flat_straw' },
     * 		{ 'stairs:stair_',          'stairs:stair_',                   'stairs:slab_'},
     * 		{'cobble', 'stonebrick', 'desert_cobble', 'desert_stonebrick', 'stone'},
     * 		'stonebrick') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"cottages:roof_straw");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_connector_straw");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"cottages:roof_flat_straw");
    lua_rawseti(L,-2,3);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:stair_");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"stairs:slab_");
    lua_rawseti(L,-2,3);
    lua_createtable(L,5,0);
    lua_pushliteral(L,"cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stonebrick");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"desert_cobble");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"desert_stonebrick");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"stone");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"stonebrick");
    lua_call(L,6,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, { 'cottages:glass_pane', 'default:glass' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"cottages:glass_pane");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:glass");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc226);
  assert(lua_gettop(L) == 3);
  
  /* local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:savannawood', 'mg:pinewood'}, --, 'default:brick', 'default:sandstone', 'default:desert_cobble' },
   * 		'default:wood') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_createtable(L,7,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:junglewood");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:pine_wood");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"default:acacia_wood");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"default:aspen_wood");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"default:wood");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_tree_trunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_saplings(   replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_saplings");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc228 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc229 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc229) {
    
    /* -- replace the floor with another type of wood (looks better than the same type as above)
     * mg_villages.replace_materials( replacements, pr,
     * 		{'stairs:stair_junglewood',  'stairs:slab_junglewood', 'default:junglewood'},
     * 		{'stairs:stair_',            'stairs:slab_',           'default:'     },
     * 		{ 'default:wood' },
     * 		'wood' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_junglewood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_junglewood");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:junglewood");
    lua_rawseti(L,-2,3);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:");
    lua_rawseti(L,-2,3);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"wood");
    lua_call(L,6,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc228);
  assert(lua_gettop(L) == 4);
  
  /* local mfs2 = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
   * 		{'stairs:stair_',        'stairs:slab_',       'default:'      },
   * 		{ 'cobble', 'brick', 'clay', 'desert_cobble', 'desert_stone', 'desert_stonebrick', 'sandstone', 'sandstonebrick', 'stonebrick' },
   * 		'cobble') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_cobble");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_cobble");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:cobble");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,3);
  lua_createtable(L,9,0);
  lua_pushliteral(L,"cobble");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"brick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"clay");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"desert_cobble");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"desert_stone");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"desert_stonebrick");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"sandstonebrick");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"cobble");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 5);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: mg_villages.replacements_tent
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_tent (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* table.insert( replacements, { "glasspanes:wool_pane",  "cottages:wool_tent" }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"glasspanes:wool_pane");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"cottages:wool_tent");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* table.insert( replacements, { "default:gravel",        "default:sand"       }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:gravel");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:sand");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* -- realtest needs diffrent fence posts and doors
   * if( mg_villages.realtest_trees ) then */
  enum { lc230 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc231 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc231) {
    
    /* local wood_type = mg_villages.replace_materials( replacements, pr,
     * 		{'default:wood'},
     * 		{''},
     * 		{ 'default:wood' },
     * 		'default:wood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:wood");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_tree_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.replace_saplings(   replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_saplings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc230);
  assert(lua_gettop(L) == 3);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: mg_villages.replacements_grasshut
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_grasshut (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* table.insert( replacements, {'moreblocks:fence_jungle_wood',     'default:fence' }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"moreblocks:fence_jungle_wood");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:fence");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* if( pr:next( 1, 4) == 1 ) then */
  enum { lc232 = 3 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,4);
  lua_call(L,3,1);
  lua_pushnumber(L,1);
  const int lc233 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc233);
  const int lc234 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc234) {
    
    /* table.insert( replacements, {'dryplants:reed_roof',              'cottages:roof_straw'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"dryplants:reed_roof");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_straw");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'dryplants:reed_slab',              'cottages:roof_flat_straw' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"dryplants:reed_slab");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_flat_straw");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'dryplants:wetreed_roof',           'cottages:roof_reet' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"dryplants:wetreed_roof");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_reet");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'dryplants:wetreed_slab',           'cottages:roof_flat_reet' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"dryplants:wetreed_slab");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:roof_flat_reet");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * -- replace the straw and cobble one of the huts uses
     * table.insert( replacements, {'cottages:straw',                   'dryplants:wetreed' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"cottages:straw");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"dryplants:wetreed");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'stairs:slab_cobble',               'dryplants:reed_slab' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"dryplants:reed_slab");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc232);
  assert(lua_gettop(L) == 3);
  
  /* if( pr:next( 1, 4) == 1 ) then */
  enum { lc235 = 3 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,4);
  lua_call(L,3,1);
  lua_pushnumber(L,1);
  const int lc236 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc236);
  const int lc237 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc237) {
    
    /* table.insert( replacements, {'dryplants:wetreed_roof_corner',    'default:wood' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"dryplants:wetreed_roof_corner");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* table.insert( replacements, {'dryplants:wetreed_roof_corner_2',  'default:junglewood' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"dryplants:wetreed_roof_corner_2");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:junglewood");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc235);
  assert(lua_gettop(L) == 3);
  
  /* if( not( minetest.get_modpath( 'cavestuff' ))) then */
  enum { lc238 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"cavestuff");
  lua_call(L,1,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc239 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc239) {
    
    /* table.insert( replacements, {'cavestuff:desert_pebble_2',        'default:slab_cobble' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"cavestuff:desert_pebble_2");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:slab_cobble");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc238);
  assert(lua_gettop(L) == 3);
  
  /* table.insert( replacements, {'default:desert_sand', 'default:dirt_with_grass' }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:desert_sand");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:dirt_with_grass");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: mg_villages.replacements_claytrader
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_claytrader (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- the walls of the clay trader houses are made out of brick
   * mg_villages.replace_materials( replacements, pr,
   * 		{ 'stairs:stair_brick', 'stairs:slab_brick', 'default:brick' }, -- default_materials
   * 		{ 'stairs:stair_',      'stairs:slab_',      'default:'      }, -- prefixes (for new materials)
   * 		{ 'brick', 'stone', 'sandstone', 'sandstonebrick', 'desert_stone', 'desert_cobble', 'desert_stonebrick' }, -- new materials
   * 		'brick' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_brick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_brick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:brick");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,3);
  lua_createtable(L,7,0);
  lua_pushliteral(L,"brick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"sandstonebrick");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"desert_stone");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"desert_cobble");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"desert_stonebrick");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"brick");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 3);
  
  /* -- original material
   * -- material for the floor
   * mg_villages.replace_materials( replacements, pr,
   * 		{'default:stone'},
   * 		{'default:'},
   * 		{ 'brick', 'stone', 'sandstone', 'sandstonebrick', 'clay', 'desert_stone', 'desert_cobble', 'desert_stonebrick',
   * 		'default:stone_flat', 'default:desert_stone_flat', -- realtest
   * 		},
   * 		'stone') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,1);
  lua_createtable(L,10,0);
  lua_pushliteral(L,"brick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"sandstonebrick");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"clay");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"desert_stone");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"desert_cobble");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"desert_stonebrick");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"default:stone_flat");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"default:desert_stone_flat");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"stone");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 3);
  
  /* -- the clay trader homes come with stone stair roofs; slabs are used in other places as well (but those replacements here are ok)
   * mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_stone',       'stairs:slab_stone' },
   * 		{'cottages:roof_connector_', 'cottages:roof_flat_' },
   * 		{'straw', 'straw', 'straw', 'straw', 'straw',
   * 			   'reet', 'reet', 'reet',
   * 			   'slate', 'slate',
   *                            'wood',  'wood',  
   *                            'red',
   *                            'brown',
   *                            'black'},
   * 		'') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"stairs:stair_stone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_stone");
  lua_rawseti(L,-2,2);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"cottages:roof_connector_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"cottages:roof_flat_");
  lua_rawseti(L,-2,2);
  lua_createtable(L,15,0);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"slate");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"slate");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,11);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,12);
  lua_pushliteral(L,"red");
  lua_rawseti(L,-2,13);
  lua_pushliteral(L,"brown");
  lua_rawseti(L,-2,14);
  lua_pushliteral(L,"black");
  lua_rawseti(L,-2,15);
  lua_pushliteral(L,"");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 3);
  
  /* -- hills and pits that contain the materials clay traders dig for
   * mg_villages.replace_materials( replacements, pr,
   * 		{'default:stone_with_coal'},
   * 		{'default:'},
   * 		{'sand', 'sandstone', 'clay'},
   * 		'') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:stone_with_coal");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,1);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"sand");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"clay");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 3);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc240 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc241 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc241) {
    
    /* local wood_type = mg_villages.replace_materials( replacements, pr,
     * 		{'default:wood'},
     * 		{''},
     * 		{ 'default:wood' },
     * 		'default:wood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:wood");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_tree_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.replace_saplings(   replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_saplings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'default:clay', 'default:dirt_with_clay'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:clay");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:dirt_with_clay");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* local mfs2 = mg_villages.replace_materials( replacements, pr,
     * 		{'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
     * 		{'stairs:stair_',        'stairs:slab_',       'default:'      },
     * 		{ 'stone' }, -- will be replaced by mg_villages.realtest_stairs
     * 		'sandstone') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_cobble");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:cobble");
    lua_rawseti(L,-2,3);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:");
    lua_rawseti(L,-2,3);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"stone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"sandstone");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc240);
  assert(lua_gettop(L) == 3);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: mg_villages.replacements_charachoal
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_charachoal (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc242 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc243 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc243) {
    
    /* local wood_type = mg_villages.replace_materials( replacements, pr,
     * 		{'default:wood'},
     * 		{''},
     * 		{ 'default:wood' },
     * 		'default:wood') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:wood");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_tree_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.replace_saplings(   replacements, wood_type ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_saplings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:slab_loam',     'cottages:loam'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_loam");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:loam");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* table.insert( replacements, {'stairs:stair_loam',    'cottages:loam'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:stair_loam");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cottages:loam");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc242);
  assert(lua_gettop(L) == 3);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: mg_villages.replacements_medieval
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_medieval (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if( not( minetest.get_modpath('bell' ))) then */
  enum { lc244 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"bell");
  lua_call(L,1,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc245 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc245) {
    
    /* table.insert( replacements, {'bell:bell',               'default:goldblock' }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"bell:bell");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:goldblock");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc244);
  assert(lua_gettop(L) == 3);
  
  /* -- glass that served as a marker got copied accidently; there's usually no glass in cottages
   * table.insert( replacements, {'default:glass',           'air'}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:glass");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* -- some plants started growing while the buildings where saved - eliminate them
   * table.insert( replacements, {'junglegrass:medium',      'air'}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"junglegrass:medium");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* table.insert( replacements, {'junglegrass:short',       'air'}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"junglegrass:short");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* table.insert( replacements, {'poisonivy:seedling',      'air'}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"poisonivy:seedling");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"air");
  lua_rawseti(L,-2,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  
  /* -- TODO: sometimes, half_door/half_door_inverted gets rotated wrong
   * --   table.insert( replacements, {'cottages:half_door',      'cottages:half_door_inverted'});
   * --   table.insert( replacements, {'cottages:half_door_inverted', 'cottages:half_door'});
   * -- some poor cottage owners cannot afford glass
   * if( pr:next( 1, 2 ) == 2 ) then */
  enum { lc246 = 3 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,2);
  lua_call(L,3,1);
  lua_pushnumber(L,2);
  const int lc247 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc247);
  const int lc248 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc248) {
    
    /* --      table.insert( replacements, {'cottages:glass_pane',    'default:fence_wood'});
     * local gp = mg_villages.replace_materials( replacements, pr,
     * 	{'cottages:glass_pane'},
     * 	{''},
     * 	{'xpanes:pane', 'default:glass', 'default:obsidian_glass', 'default:fence_wood',
     * 	 'darkage:medieval_glass', 'darkage:iron_bars', 'darkage:iron_grille', 'darkage:wood_bars',
     * 	 'darkage:wood_frame', 'darkage:wood_grille'},
     * 	'cottages:glass_pane') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"cottages:glass_pane");
    lua_rawseti(L,-2,1);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"");
    lua_rawseti(L,-2,1);
    lua_createtable(L,10,0);
    lua_pushliteral(L,"xpanes:pane");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:glass");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:obsidian_glass");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"default:fence_wood");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"darkage:medieval_glass");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"darkage:iron_bars");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"darkage:iron_grille");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"darkage:wood_bars");
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"darkage:wood_frame");
    lua_rawseti(L,-2,9);
    lua_pushliteral(L,"darkage:wood_grille");
    lua_rawseti(L,-2,10);
    lua_pushliteral(L,"cottages:glass_pane");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc246);
  assert(lua_gettop(L) == 3);
  
  /* -- 'glass' is admittedly debatable; yet it may represent modernized old houses where only the tree-part was left standing
   * -- loam and clay are mentioned multiple times because those are the most likely building materials in reality
   * local materials = {'cottages:loam', 'cottages:loam', 'cottages:loam', 'cottages:loam', 'cottages:loam', 
   *                       'default:clay',  'default:clay',  'default:clay',  'default:clay',  'default:clay',
   *                       'default:wood','default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'default:sandstone',
   *                       'default:desert_stone','default:brick','default:cobble','default:stonebrick',
   *                       'default:desert_stonebrick','default:sandstonebrick','default:stone',
   *                       'mg:savannawood', 'mg:savannawood', 'mg:savannawood', 'mg:savannawood',
   *                       'mg:pinewood',    'mg:pinewood',    'mg:pinewood',    'mg:pinewood',
   * 		'default:stone_flat', 'default:desert_stone_flat', -- realtest
   * 		'darkage:adobe', 'darkage:basalt', 'darkage:basalt_cobble', 'darkage:chalk',
   * 		'darkage:gneiss', 'darkage:gneiss_cobble', 'darkage:marble', 'darkage:marble_tile',
   * 		'darkage:mud', 'darkage:ors', 'darkage:ors_cobble', 'darkage:reinforced_chalk',
   * 		'darkage:reinforced_wood', 'darkage:reinforced_wood_left', 'darkage:reinforced_wood_right',
   * 		'darkage:schist', 'darkage:serpentine', 'darkage:shale', 'darkage:silt', 'darkage:slate',
   * 		'darkage:slate_cobble', 'darkage:slate_tile', 'darkage:stone_brick',
   * 		'mapgen:mese_stone', 'mapgen:soap_stone'} */
  lua_createtable(L,58,0);
  lua_pushliteral(L,"cottages:loam");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"cottages:loam");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"cottages:loam");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"cottages:loam");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"cottages:loam");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"default:clay");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"default:clay");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"default:clay");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"default:clay");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"default:clay");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,11);
  lua_pushliteral(L,"default:junglewood");
  lua_rawseti(L,-2,12);
  lua_pushliteral(L,"default:pine_wood");
  lua_rawseti(L,-2,13);
  lua_pushliteral(L,"default:acacia_wood");
  lua_rawseti(L,-2,14);
  lua_pushliteral(L,"default:aspen_wood");
  lua_rawseti(L,-2,15);
  lua_pushliteral(L,"default:sandstone");
  lua_rawseti(L,-2,16);
  lua_pushliteral(L,"default:desert_stone");
  lua_rawseti(L,-2,17);
  lua_pushliteral(L,"default:brick");
  lua_rawseti(L,-2,18);
  lua_pushliteral(L,"default:cobble");
  lua_rawseti(L,-2,19);
  lua_pushliteral(L,"default:stonebrick");
  lua_rawseti(L,-2,20);
  lua_pushliteral(L,"default:desert_stonebrick");
  lua_rawseti(L,-2,21);
  lua_pushliteral(L,"default:sandstonebrick");
  lua_rawseti(L,-2,22);
  lua_pushliteral(L,"default:stone");
  lua_rawseti(L,-2,23);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,24);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,25);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,26);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,27);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,28);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,29);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,30);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,31);
  lua_pushliteral(L,"default:stone_flat");
  lua_rawseti(L,-2,32);
  lua_pushliteral(L,"default:desert_stone_flat");
  lua_rawseti(L,-2,33);
  lua_pushliteral(L,"darkage:adobe");
  lua_rawseti(L,-2,34);
  lua_pushliteral(L,"darkage:basalt");
  lua_rawseti(L,-2,35);
  lua_pushliteral(L,"darkage:basalt_cobble");
  lua_rawseti(L,-2,36);
  lua_pushliteral(L,"darkage:chalk");
  lua_rawseti(L,-2,37);
  lua_pushliteral(L,"darkage:gneiss");
  lua_rawseti(L,-2,38);
  lua_pushliteral(L,"darkage:gneiss_cobble");
  lua_rawseti(L,-2,39);
  lua_pushliteral(L,"darkage:marble");
  lua_rawseti(L,-2,40);
  lua_pushliteral(L,"darkage:marble_tile");
  lua_rawseti(L,-2,41);
  lua_pushliteral(L,"darkage:mud");
  lua_rawseti(L,-2,42);
  lua_pushliteral(L,"darkage:ors");
  lua_rawseti(L,-2,43);
  lua_pushliteral(L,"darkage:ors_cobble");
  lua_rawseti(L,-2,44);
  lua_pushliteral(L,"darkage:reinforced_chalk");
  lua_rawseti(L,-2,45);
  lua_pushliteral(L,"darkage:reinforced_wood");
  lua_rawseti(L,-2,46);
  lua_pushliteral(L,"darkage:reinforced_wood_left");
  lua_rawseti(L,-2,47);
  lua_pushliteral(L,"darkage:reinforced_wood_right");
  lua_rawseti(L,-2,48);
  lua_pushliteral(L,"darkage:schist");
  lua_rawseti(L,-2,49);
  lua_pushliteral(L,"darkage:serpentine");
  lua_rawseti(L,-2,50);
  lua_pushliteral(L,"darkage:shale");
  lua_rawseti(L,-2,51);
  lua_pushliteral(L,"darkage:silt");
  lua_rawseti(L,-2,52);
  lua_pushliteral(L,"darkage:slate");
  lua_rawseti(L,-2,53);
  lua_pushliteral(L,"darkage:slate_cobble");
  lua_rawseti(L,-2,54);
  lua_pushliteral(L,"darkage:slate_tile");
  lua_rawseti(L,-2,55);
  lua_pushliteral(L,"darkage:stone_brick");
  lua_rawseti(L,-2,56);
  lua_pushliteral(L,"mapgen:mese_stone");
  lua_rawseti(L,-2,57);
  lua_pushliteral(L,"mapgen:soap_stone");
  lua_rawseti(L,-2,58);
  assert(lua_gettop(L) == 4);
  
  /* -- what is sandstone (the floor) may be turned into something else
   * local mfs = mg_villages.replace_materials( replacements, pr,
   * 	{'default:sandstone'},
   * 	{''},
   * 	materials,
   * 	'default:sandstone') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:sandstone");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"default:sandstone");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 5);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc249 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc250 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc250) {
    
    /* table.insert( replacements, {'stairs:slab_sandstone',   'default:stone_slab'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"stairs:slab_sandstone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_slab");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* local mfs2 = mg_villages.replace_materials( replacements, pr,
     * 		{'stairs:stair_sandstone',  'stairs:slab_sandstone', 'default:sandstone'},
     * 		{'stairs:stair_',           'stairs:slab_',          'default:'         },
     * 		{ 'stone' }, -- will be replaced by mg_villages.realtest_stairs
     * 		'sandstone') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_sandstone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_sandstone");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:sandstone");
    lua_rawseti(L,-2,3);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:");
    lua_rawseti(L,-2,3);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"stone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"sandstone");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* elseif( mfs and mfs ~= 'default:sandstone' ) then */
    enum { lc251 = 5 };
    lua_pushvalue(L,5);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"default:sandstone");
      const int lc252 = lua_equal(L,5,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc252);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc253 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc253) {
      
      /* if( mfs == 'cottages:loam' or mfs == 'default:clay' or mfs == 'mg:savannawood' or mfs == 'mg:pinewood') then */
      enum { lc254 = 5 };
      lua_pushvalue(L,5);
      lua_pushliteral(L,"cottages:loam");
      const int lc255 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc255);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,5);
        lua_pushliteral(L,"default:clay");
        const int lc256 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc256);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,5);
        lua_pushliteral(L,"mg:savannawood");
        const int lc257 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc257);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,5);
        lua_pushliteral(L,"mg:pinewood");
        const int lc258 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc258);
      }
      const int lc259 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc259) {
        
        /* mfs = 'default:wood' */
        lua_pushliteral(L,"default:wood");
        lua_replace(L,5);
        assert(lua_gettop(L) == 5);
      }
      else {
        
        /* elseif( mfs =='default:sandstonebrick' or mfs == 'default:desert_stone' or mfs == 'default:desert_stonebrick'
         *               or not( minetest.registered_nodes[ 'stairs:slab_'..string.sub( mfs, 9 )] )) then */
        enum { lc260 = 5 };
        lua_pushvalue(L,5);
        lua_pushliteral(L,"default:sandstonebrick");
        const int lc261 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc261);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,5);
          lua_pushliteral(L,"default:desert_stone");
          const int lc262 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc262);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,5);
          lua_pushliteral(L,"default:desert_stonebrick");
          const int lc263 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc263);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"stairs:slab_");
          lua_getfield(L,LUA_ENVIRONINDEX,"string");
          lua_pushliteral(L,"sub");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,5);
          lua_pushnumber(L,9);
          lua_call(L,2,1);
          lua_concat(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc264 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc264) {
          
          /* mfs = '' */
          lua_pushliteral(L,"");
          lua_replace(L,5);
          assert(lua_gettop(L) == 5);
        }
        lua_settop(L,lc260);
      }
      lua_settop(L,lc254);
      assert(lua_gettop(L) == 5);
      
      /* if( mfs and mfs ~= '' ) then */
      enum { lc265 = 5 };
      lua_pushvalue(L,5);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"");
        const int lc266 = lua_equal(L,5,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc266);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc267 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc267) {
        
        /* -- realtest needs special treatment
         * table.insert( replacements, {'stairs:slab_sandstone',   'stairs:slab_'..string.sub( mfs, 9 )}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,3);
        lua_createtable(L,2,0);
        lua_pushliteral(L,"stairs:slab_sandstone");
        lua_rawseti(L,-2,1);
        lua_pushliteral(L,"stairs:slab_");
        lua_getfield(L,LUA_ENVIRONINDEX,"string");
        lua_pushliteral(L,"sub");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,5);
        lua_pushnumber(L,9);
        lua_call(L,2,1);
        lua_concat(L,2);
        lua_rawseti(L,-2,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc265);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc251);
  }
  lua_settop(L,lc249);
  assert(lua_gettop(L) == 5);
  
  /* -- except for the floor, everything else may be glass
   * table.insert( materials, 'default:glass' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"insert");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"default:glass");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 5);
  
  /* local uses_wood = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 6);
  
  /* -- bottom part of the house (usually ground floor from outside)
   * local replace_clay = mg_villages.replace_materials( replacements, pr,
   * 	{'default:clay'},
   * 	{''},
   * 	materials,
   * 	'default:clay') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:clay");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"default:clay");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 7);
  
  /* if( replace_clay and replace_clay ~= 'default:clay' ) then */
  enum { lc268 = 7 };
  lua_pushvalue(L,7);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"default:clay");
    const int lc269 = lua_equal(L,7,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc269);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc270 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc270) {
    
    /* uses_wood = mg_villages.replace_tree_trunk( replacements, replace_clay ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_tree_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,7);
    lua_call(L,2,1);
    lua_replace(L,6);
    assert(lua_gettop(L) == 7);
    
    /* mg_villages.replace_saplings(               replacements, replace_clay ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_saplings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,7);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc268);
  assert(lua_gettop(L) == 7);
  
  /* -- upper part of the house (may be the same as the material for the lower part)
   * local replace_loam = mg_villages.replace_materials( replacements, pr,
   * 	{'cottages:loam'},
   * 	{''},
   * 	materials,
   * 	'cottages:loam') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"cottages:loam");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"cottages:loam");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 8);
  
  /* -- if the bottom was not replaced by wood, perhaps the top is
   * if( not( uses_wood ) and replace_loam ) then */
  enum { lc271 = 8 };
  lua_pushboolean(L,!(lua_toboolean(L,6)));
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,8);
  }
  const int lc272 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc272) {
    
    /* mg_villages.replace_tree_trunk( replacements, replace_loam ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_tree_trunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,8);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 8);
    
    /* mg_villages.replace_saplings(   replacements, replace_loam ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_saplings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,8);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 8);
  }
  else {
    
    /* elseif( mg_villages.realtest_trees ) then */
    enum { lc273 = 8 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"realtest_trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc274 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc274) {
      
      /* local wood_type = mg_villages.replace_materials( replacements, pr,
       * 		{'default:wood'},
       * 		{''},
       * 		{ 'default:wood' },
       * 		'default:wood') */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"replace_materials");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,2);
      lua_createtable(L,1,0);
      lua_pushliteral(L,"default:wood");
      lua_rawseti(L,-2,1);
      lua_createtable(L,1,0);
      lua_pushliteral(L,"");
      lua_rawseti(L,-2,1);
      lua_createtable(L,1,0);
      lua_pushliteral(L,"default:wood");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"default:wood");
      lua_call(L,6,1);
      assert(lua_gettop(L) == 9);
      
      /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"replace_tree_trunk");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,9);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 9);
      
      /* mg_villages.replace_saplings(   replacements, wood_type ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"replace_saplings");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,9);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc273);
  }
  lua_settop(L,lc271);
  assert(lua_gettop(L) == 8);
  
  /* -- replace cobble; for these nodes, a stony material is needed (used in wells as well)
   * -- mossycobble is fine here as well
   * local mcs = mg_villages.replace_materials( replacements, pr,
   * 		{'default:cobble'},
   * 		{'default:'},
   * 		{'sandstone', 'desert_stone', 'desert_cobble',
   *                       'cobble',      'cobble',
   *                       'stonebrick',  'stonebrick', 'stonebrick', -- more common than other materials
   *                       'mossycobble', 'mossycobble','mossycobble',
   *                       'stone',       'stone',
   *                       'desert_stonebrick','sandstonebrick'},
   * 		'cobble') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:cobble");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,1);
  lua_createtable(L,15,0);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"desert_stone");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"desert_cobble");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"cobble");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"cobble");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"mossycobble");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"mossycobble");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"mossycobble");
  lua_rawseti(L,-2,11);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,12);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,13);
  lua_pushliteral(L,"desert_stonebrick");
  lua_rawseti(L,-2,14);
  lua_pushliteral(L,"sandstonebrick");
  lua_rawseti(L,-2,15);
  lua_pushliteral(L,"cobble");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 9);
  
  /* -- set a fitting material for the slabs; mossycobble uses the default cobble slabs
   * if( mg_villages.realtest_trees ) then */
  enum { lc275 = 9 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc276 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc276) {
    
    /* local mcs2 = mg_villages.replace_materials( replacements, pr,
     * 		{'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
     * 		{'stairs:stair_',        'stairs:slab_',       'default:'          },
     * 		{ 'stone' }, -- will be replaced by mg_villages.realtest_stairs
     * 		'cobble') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"replace_materials");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_cobble");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:cobble");
    lua_rawseti(L,-2,3);
    lua_createtable(L,3,0);
    lua_pushliteral(L,"stairs:stair_");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"stairs:slab_");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:");
    lua_rawseti(L,-2,3);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"stone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"cobble");
    lua_call(L,6,1);
    assert(lua_gettop(L) == 10);
    
    /* table.insert( replacements, {'moreblocks:slab_cobble',   'default:'..mcs..'_slab'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"moreblocks:slab_cobble");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:");
    lua_pushvalue(L,9);
    lua_pushliteral(L,"_slab");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 10);
  }
  else {
    
    /* elseif( mcs ~= 'mossycobble' and mcs ~= 'cobble') then */
    enum { lc277 = 9 };
    lua_pushliteral(L,"mossycobble");
    const int lc278 = lua_equal(L,9,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc278);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"cobble");
      const int lc279 = lua_equal(L,9,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc279);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc280 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc280) {
      
      /* -- if no slab exists, use sandstone slabs
       * if( not( mcs ) or not( minetest.registered_nodes[ 'stairs:slab_'..mcs ])) then */
      enum { lc281 = 9 };
      lua_pushboolean(L,!(lua_toboolean(L,9)));
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"registered_nodes");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"stairs:slab_");
        lua_pushvalue(L,9);
        lua_concat(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc282 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc282) {
        
        /* mcs = 'sandstone' */
        lua_pushliteral(L,"sandstone");
        lua_replace(L,9);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc281);
      assert(lua_gettop(L) == 9);
      
      /* table.insert( replacements, {'stairs:slab_cobble',      'stairs:slab_'..mcs}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"stairs:slab_cobble");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"stairs:slab_");
      lua_pushvalue(L,9);
      lua_concat(L,2);
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 9);
      
      /* table.insert( replacements, {'moreblocks:slab_cobble',  'stairs:slab_'..mcs}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"moreblocks:slab_cobble");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"stairs:slab_");
      lua_pushvalue(L,9);
      lua_concat(L,2);
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 9);
    }
    else {
      
      /* else
       * table.insert( replacements, {'moreblocks:slab_cobble',  'stairs:slab_'..mcs}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_createtable(L,2,0);
      lua_pushliteral(L,"moreblocks:slab_cobble");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"stairs:slab_");
      lua_pushvalue(L,9);
      lua_concat(L,2);
      lua_rawseti(L,-2,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc277);
  }
  lua_settop(L,lc275);
  assert(lua_gettop(L) == 9);
  
  /* -- straw is the most likely building material for roofs for historical buildings
   * mg_villages.replace_materials( replacements, pr,
   * 		-- all three shapes of roof parts have to fit together
   * 		{ 'cottages:roof_straw',    'cottages:roof_connector_straw',   'cottages:roof_flat_straw' },
   * 		{ 'cottages:roof_',         'cottages:roof_connector_',        'cottages:roof_flat_'},
   * 		{'straw', 'straw', 'straw', 'straw', 'straw',
   * 			   'reet', 'reet', 'reet',
   * 			   'slate', 'slate',
   *                            'wood',  'wood',  
   *                            'red',
   *                            'brown',
   *                            'black'},
   * 		'straw') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"cottages:roof_straw");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"cottages:roof_connector_straw");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"cottages:roof_flat_straw");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"cottages:roof_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"cottages:roof_connector_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"cottages:roof_flat_");
  lua_rawseti(L,-2,3);
  lua_createtable(L,15,0);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"straw");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"reet");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"slate");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"slate");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,11);
  lua_pushliteral(L,"wood");
  lua_rawseti(L,-2,12);
  lua_pushliteral(L,"red");
  lua_rawseti(L,-2,13);
  lua_pushliteral(L,"brown");
  lua_rawseti(L,-2,14);
  lua_pushliteral(L,"black");
  lua_rawseti(L,-2,15);
  lua_pushliteral(L,"straw");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 9);
  
  /* --print('REPLACEMENTS used: '..minetest.serialize( replacements )); 
   * return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 9);
}


/* name: mg_villages.replacements_tower
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_replacements_tower (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- replace the wood - this is needed in particular for the fences
   * local wood_type = mg_villages.replace_materials( replacements, pr,
   *                 {'default:wood'},
   *                 {''},
   *                 { 'default:wood', 'default:junglewood', 'mg:savannawood', 'mg:pinewood' },
   *                 'default:wood') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"");
  lua_rawseti(L,-2,1);
  lua_createtable(L,4,0);
  lua_pushliteral(L,"default:wood");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:junglewood");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"mg:savannawood");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"mg:pinewood");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"default:wood");
  lua_call(L,6,1);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_tree_trunk( replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_tree_trunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_saplings(   replacements, wood_type ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_saplings");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  
  /* mg_villages.replace_materials( replacements, pr,
   *                 {'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
   *                 {'stairs:stair_',         'stairs:slab_',      'default:'     },
   *                 {'stonebrick', 'desert_stonebrick','sandstonebrick', 'sandstone','stone','desert_stone','stone_flat','desert_stone_flat','stone_bricks','desert_strone_bricks'},
   *                 'stonebrick') */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"replace_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,2);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_cobble");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_cobble");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:cobble");
  lua_rawseti(L,-2,3);
  lua_createtable(L,3,0);
  lua_pushliteral(L,"stairs:stair_");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"stairs:slab_");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:");
  lua_rawseti(L,-2,3);
  lua_createtable(L,10,0);
  lua_pushliteral(L,"stonebrick");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"desert_stonebrick");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"sandstonebrick");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"sandstone");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"stone");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"desert_stone");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"stone_flat");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"desert_stone_flat");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"stone_bricks");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"desert_strone_bricks");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"stonebrick");
  lua_call(L,6,0);
  assert(lua_gettop(L) == 4);
  
  /* return replacements */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.get_replacement_ids
 * function( housetype, pr) */
static int lcf1_mg_villages_get_replacement_ids (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local replace = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 3);
  
  /* local replacements = mg_villages.get_replacement_list( housetype, pr ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_replacement_list");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 4);
  
  /* for i,v in ipairs( replacements ) do
   * internal: local f, s, var = explist */
  enum { lc283 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,4);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 8
     * internal: local v with idx 9 */
    
    
    /* if( v and #v == 2 ) then */
    enum { lc284 = 9 };
    lua_pushvalue(L,9);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      const double lc285 = lua_objlen(L,9);
      lua_pushnumber(L,lc285);
      lua_pushnumber(L,2);
      const int lc286 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc286);
    }
    const int lc287 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc287) {
      
      /* replace[ minetest.get_content_id( v[1] )] = minetest.get_content_id( v[2] ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lua_gettable(L,9);
      lua_call(L,1,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_gettable(L,9);
      lua_call(L,1,1);
      lua_insert(L,-2);
      lua_settable(L,3);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc284);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc283);
  assert(lua_gettop(L) == 4);
  
  /* return replace */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.get_replacement_table
 * function( housetype, pr, replacements) */
static int lcf1_mg_villages_get_replacement_table (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local rtable = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 4);
  
  /* local ids    = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* if( not( replacements )) then */
  enum { lc288 = 5 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc289 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc289) {
    
    /* replacements = mg_villages.get_replacement_list( housetype, pr ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"get_replacement_list");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_call(L,2,1);
    lua_replace(L,3);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc288);
  assert(lua_gettop(L) == 5);
  
  /* -- it is very problematic if the torches on houses melt snow and cause flooding; thus, we use a torch that is not hot
   * if( mg_villages.USE_DEFAULT_3D_TORCHES == false ) then */
  enum { lc290 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"USE_DEFAULT_3D_TORCHES");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,0);
  const int lc291 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc291);
  const int lc292 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc292) {
    
    /* table.insert( replacements, {'default:torch', 'mg_villages:torch'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:torch");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"mg_villages:torch");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc290);
  assert(lua_gettop(L) == 5);
  
  /* -- make charachoal villages safe from spreading fire
   * if( not( mg_villages.use_normal_unsafe_lava )) then */
  enum { lc293 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"use_normal_unsafe_lava");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc294 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc294) {
    
    /* table.insert( replacements, {'default:lava_source',  'mg_villages:lava_source_tamed'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:lava_source");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"mg_villages:lava_source_tamed");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* table.insert( replacements, {'default:lava_flowing', 'mg_villages:lava_flowing_tamed'}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"insert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,2,0);
    lua_pushliteral(L,"default:lava_flowing");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"mg_villages:lava_flowing_tamed");
    lua_rawseti(L,-2,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc293);
  assert(lua_gettop(L) == 5);
  
  /* for i,v in ipairs( replacements ) do
   * internal: local f, s, var = explist */
  enum { lc295 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 9
     * internal: local v with idx 10 */
    
    
    /* if( v and #v == 2 ) then */
    enum { lc296 = 10 };
    lua_pushvalue(L,10);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      const double lc297 = lua_objlen(L,10);
      lua_pushnumber(L,lc297);
      lua_pushnumber(L,2);
      const int lc298 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc298);
    }
    const int lc299 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc299) {
      
      /* rtable[ v[1] ] = v[2] */
      lua_pushnumber(L,2);
      lua_gettable(L,10);
      lua_pushnumber(L,1);
      lua_gettable(L,10);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 10);
      
      /* ids[ minetest.get_content_id( v[1] )] = minetest.get_content_id( v[2] ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lua_gettable(L,10);
      lua_call(L,1,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_gettable(L,10);
      lua_call(L,1,1);
      lua_insert(L,-2);
      lua_settable(L,5);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc296);
    assert(lua_gettop(L) == 10);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc295);
  assert(lua_gettop(L) == 5);
  
  /* return { table = rtable, list = replacements, ids = ids } */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"table");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"list");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"ids");
  lua_pushvalue(L,5);
  lua_rawset(L,-3);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: mg_villages.get_content_id_replaced
 * function( node_name, replacements) */
static int lcf1_mg_villages_get_content_id_replaced (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if( not( node_name ) or not( replacements ) or not(replacements.table )) then */
  enum { lc300 = 2 };
  lua_pushboolean(L,!(lua_toboolean(L,1)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,2)));
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"table");
    lua_gettable(L,2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc301 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc301) {
    
    /* return minetest.get_content_id( 'ignore' ) */
    const int lc302 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"ignore");
    lua_call(L,1,LUA_MULTRET);
    return (lua_gettop(L) - lc302);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc300);
  assert(lua_gettop(L) == 2);
  
  /* if( replacements.table[ node_name ]) then */
  enum { lc303 = 2 };
  lua_pushliteral(L,"table");
  lua_gettable(L,2);
  lua_pushvalue(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc304 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc304) {
    
    /* return minetest.get_content_id( replacements.table[ node_name ] ) */
    const int lc305 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"table");
    lua_gettable(L,2);
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,LUA_MULTRET);
    return (lua_gettop(L) - lc305);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* else
     * return minetest.get_content_id( node_name ) */
    const int lc306 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,LUA_MULTRET);
    return (lua_gettop(L) - lc306);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc303);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: mg_villages.get_fruit_replacements
 * function( replacements, fruit) */
static int lcf1_mg_villages_get_fruit_replacements (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if( not( fruit )) then */
  enum { lc307 = 2 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  const int lc308 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc308) {
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc307);
  assert(lua_gettop(L) == 2);
  
  /* for i=1,8 do */
  lua_pushnumber(L,1);
  lua_pushnumber(L,8);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc309_var = lua_tonumber(L,-2);
  const double lc310_limit = lua_tonumber(L,-1);
  const double lc311_step = 1;
  lua_pop(L,2);
  enum { lc312 = 2 };
  while ((((lc311_step > 0) && (lc309_var <= lc310_limit)) || ((lc311_step <= 0) && (lc309_var >= lc310_limit)))) {
    
    /* internal: local i at index 3 */
    lua_pushnumber(L,lc309_var);
    
    /* local old_name = '' */
    lua_pushliteral(L,"");
    assert(lua_gettop(L) == 4);
    
    /* local new_name = '' */
    lua_pushliteral(L,"");
    assert(lua_gettop(L) == 5);
    
    /* -- farming_plus plants sometimes come in 3 or 4 variants, but not in 8 as cotton does
     * if(     minetest.registered_nodes[ 'farming_plus:'..fruit..'_'..i ]) then */
    enum { lc313 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"farming_plus:");
    lua_pushvalue(L,2);
    lua_pushliteral(L,"_");
    lua_pushvalue(L,3);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc314 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc314) {
      
      /* old_name = "farming:cotton_"..i */
      lua_pushliteral(L,"farming:cotton_");
      lua_pushvalue(L,3);
      lua_concat(L,2);
      lua_replace(L,4);
      assert(lua_gettop(L) == 5);
      
      /* new_name = 'farming_plus:'..fruit..'_'..i */
      lua_pushliteral(L,"farming_plus:");
      lua_pushvalue(L,2);
      lua_pushliteral(L,"_");
      lua_pushvalue(L,3);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,5);
      assert(lua_gettop(L) == 5);
    }
    else {
      
      /* -- "surplus" cotton variants will be replaced with the full grown fruit
       * 		elseif( minetest.registered_nodes[ 'farming_plus:'..fruit ]) then */
      enum { lc315 = 5 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"farming_plus:");
      lua_pushvalue(L,2);
      lua_concat(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc316 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc316) {
        
        /* old_name = "farming:cotton_"..i */
        lua_pushliteral(L,"farming:cotton_");
        lua_pushvalue(L,3);
        lua_concat(L,2);
        lua_replace(L,4);
        assert(lua_gettop(L) == 5);
        
        /* new_name = 'farming_plus:'..fruit */
        lua_pushliteral(L,"farming_plus:");
        lua_pushvalue(L,2);
        lua_concat(L,2);
        lua_replace(L,5);
        assert(lua_gettop(L) == 5);
      }
      else {
        
        /* -- and plants from farming: are supported as well
         * 		elseif( minetest.registered_nodes[ 'farming:'..fruit..'_'..i ]) then */
        enum { lc317 = 5 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"registered_nodes");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"farming:");
        lua_pushvalue(L,2);
        lua_pushliteral(L,"_");
        lua_pushvalue(L,3);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc318 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc318) {
          
          /* old_name = "farming:cotton_"..i */
          lua_pushliteral(L,"farming:cotton_");
          lua_pushvalue(L,3);
          lua_concat(L,2);
          lua_replace(L,4);
          assert(lua_gettop(L) == 5);
          
          /* new_name = 'farming:'..fruit..'_'..i */
          lua_pushliteral(L,"farming:");
          lua_pushvalue(L,2);
          lua_pushliteral(L,"_");
          lua_pushvalue(L,3);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_replace(L,5);
          assert(lua_gettop(L) == 5);
        }
        else {
          
          /* elseif( minetest.registered_nodes[ 'farming:'..fruit ]) then */
          enum { lc319 = 5 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"farming:");
          lua_pushvalue(L,2);
          lua_concat(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc320 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc320) {
            
            /* old_name = "farming:cotton_"..i */
            lua_pushliteral(L,"farming:cotton_");
            lua_pushvalue(L,3);
            lua_concat(L,2);
            lua_replace(L,4);
            assert(lua_gettop(L) == 5);
            
            /* new_name = 'farming:'..fruit */
            lua_pushliteral(L,"farming:");
            lua_pushvalue(L,2);
            lua_concat(L,2);
            lua_replace(L,5);
            assert(lua_gettop(L) == 5);
          }
          lua_settop(L,lc319);
        }
        lua_settop(L,lc317);
      }
      lua_settop(L,lc315);
    }
    lua_settop(L,lc313);
    assert(lua_gettop(L) == 5);
    
    /* if( old_name ~= '' and new_name ~= '' ) then */
    enum { lc321 = 5 };
    lua_pushliteral(L,"");
    const int lc322 = lua_equal(L,4,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc322);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
      const int lc323 = lua_equal(L,5,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc323);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc324 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc324) {
      
      /* -- this is mostly used by the voxelmanip based spawning of .we files
       * replacements.ids[ minetest.get_content_id( old_name )] = minetest.get_content_id( new_name ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lua_call(L,1,1);
      lua_pushliteral(L,"ids");
      lua_gettable(L,1);
      lua_insert(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_call(L,1,1);
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 5);
      
      /* -- this is used by the place_schematic based spawning	
       * replacements.table[ old_name ] = new_name */
      lua_pushvalue(L,5);
      lua_pushliteral(L,"table");
      lua_gettable(L,1);
      lua_insert(L,-2);
      lua_pushvalue(L,4);
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc321);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
    lc309_var += lc311_step;
  }
  lua_settop(L,lc312);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- ethereal comes with some intresting trees
   * if( minetest.get_modpath( 'ethereal' )) then */
  enum { lc1 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal");
  lua_call(L,1,1);
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* mg_villages.ethereal_trees = {'acacia','willow','redwood','frost','mushroom','yellow','palm','banana'} */
    lua_createtable(L,8,0);
    lua_pushliteral(L,"acacia");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"willow");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"redwood");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"frost");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"mushroom");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"yellow");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"palm");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"banana");
    lua_rawseti(L,-2,8);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"ethereal_trees");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* if( minetest.get_modpath( 'forest' )) then */
  enum { lc3 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"forest");
  lua_call(L,1,1);
  const int lc4 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc4) {
    
    /* mg_villages.forest_trees = {'beech','birch','cherry','fir','ginkgo','lavender','mirabelle','oak','plum','willow'} */
    lua_createtable(L,10,0);
    lua_pushliteral(L,"beech");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"birch");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"cherry");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"fir");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"ginkgo");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"lavender");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"mirabelle");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"oak");
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"plum");
    lua_rawseti(L,-2,9);
    lua_pushliteral(L,"willow");
    lua_rawseti(L,-2,10);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"forest_trees");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc3 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- we are dealing with the TinyTrees mod from Bas080
   * if( minetest.get_modpath( 'trees' )
   *    and minetest.registered_nodes[ 'trees:wood_mangrove' ] ) then */
  enum { lc5 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"trees");
  lua_call(L,1,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"trees:wood_mangrove");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc6 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc6) {
    
    /* mg_villages.tinytrees_trees = {'mangrove','palm','conifer'} */
    lua_createtable(L,3,0);
    lua_pushliteral(L,"mangrove");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"palm");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"conifer");
    lua_rawseti(L,-2,3);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"tinytrees_trees");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc5 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- The trees modname is not unique; there are other mods which bear that name.
   * -- If all the other mods are present as well, it's a strong indication for realtest beeing the game.
   * if(	    minetest.get_modpath( 'trees' )
   * 	and minetest.get_modpath( 'anvil')
   * 	and minetest.get_modpath( 'joiner_table')
   * 	and minetest.get_modpath( 'scribing_table' )) then */
  enum { lc7 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"trees");
  lua_call(L,1,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_modpath");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"anvil");
    lua_call(L,1,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_modpath");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"joiner_table");
    lua_call(L,1,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_modpath");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"scribing_table");
    lua_call(L,1,1);
  }
  const int lc8 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc8) {
    
    /* mg_villages.realtest_trees = {'ash','aspen','birch','maple','chestnut','pine','spruce'} */
    lua_createtable(L,7,0);
    lua_pushliteral(L,"ash");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"aspen");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"birch");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"maple");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"chestnut");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"pine");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"spruce");
    lua_rawseti(L,-2,7);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"realtest_trees");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* --print('REALTEST trees will be used.'); else print( 'NO REALTEST trees');
     * -- realtest is very special as far as stairs are concerned
     * mg_villages.realtest_stairs = {'default:stone','default:stone_flat','default:stone_bricks',
     * 	                               'default:desert_stone_flat','default:desert_stone_bricks'} */
    lua_createtable(L,5,0);
    lua_pushliteral(L,"default:stone");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:stone_flat");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:stone_bricks");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"default:desert_stone_flat");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"default:desert_stone_bricks");
    lua_rawseti(L,-2,5);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"realtest_stairs");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* for i,v in ipairs(metals.list) do
     * internal: local f, s, var = explist */
    enum { lc9 = 0 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"metals");
    lua_pushliteral(L,"list");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local i with idx 4
       * internal: local v with idx 5 */
      
      
      /* table.insert( mg_villages.realtest_stairs, 'metals:'..v..'_block' ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"realtest_stairs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"metals:");
      lua_pushvalue(L,(5 + lc_nextra));
      lua_pushliteral(L,"_block");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) - lc_nextra == 5);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,(lc9 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc7 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- only the function mg_villages.get_replacement_table(..) is called from outside this file
   * mg_villages.replace_materials = function( replacements, pr, original_materials, prefixes, materials, old_material )
   * 	
   * 	local postfixes = {};
   * 	local use_realtest_stairs = false;
   * 	-- handle realtest stairs/slabs
   * 	if( mg_villages.realtest_trees 
   * 		and #prefixes==3
   * 		and prefixes[1]=='stairs:stair_' and prefixes[2]=='stairs:slab_' and prefixes[3]=='default:' ) then 
   * 
   * 		prefixes  = {''};
   * 		materials = mg_villages.realtest_stairs;
   * 		postfixes = {''};
   * 		use_realtest_stairs = true;	
   * 
   * 	elseif( mg_villages.realtest_trees 
   * 		and #prefixes==1 
   * 		and prefixes[1]=='stairs:stair_') then
   * 	
   * 		return;
   * 	else
   * 		for i,v in ipairs( prefixes ) do
   * 			postfixes[i] = '';
   * 		end
   * 	end
   * 
   * 	local known_materials = {};
   * 	local wood_found = false;
   * 	-- for all alternate materials
   * 	for i,m in ipairs( materials ) do
   * 		-- check if that material exists for each supplied prefix
   * 		for j,p in ipairs( prefixes ) do
   * 			-- if wood is present, later on try moretrees wood as well
   * 			if( 'default:wood' == m ) then
   * 				wood_found = true;
   * 			end
   * 			if( minetest.registered_nodes[ p..m..postfixes[j] ] ) then
   * 				table.insert( known_materials, m..postfixes[j] );
   * 			end
   * 		end	
   * 	end
   * 	
   * 	-- support wooden planks from moretrees
   * 	if( wood_found and mg_villages.moretrees_treelist ) then
   * 		for _,v in ipairs( mg_villages.moretrees_treelist ) do
   * 			if( minetest.registered_nodes[ "moretrees:"..v[1].."_planks"] ) then
   * 				table.insert( known_materials, "moretrees:"..v[1].."_planks" );
   * 			end	
   * 		end
   * 	end
   * 
   * --[[
   * 	-- deco is used by BigFreakingDig; as that one lacks default nodes, it doesn't work out here
   * 	if( wood_found and minetest.get_modpath('deco')) then
   * 		local bfd_treelist = {'birch', 'cherry', 'evergreen', 'oak' };
   * 		for _,v in ipairs( bfd_treelist ) do
   * 			if( minetest.registered_nodes[ "deco:"..v.."_plank"] ) then
   * 				table.insert( known_materials, "deco:"..v.."_plank" );
   * 			end	
   * 		end
   * 	end
   * --]]
   * 		
   * 	if( wood_found and mg_villages.ethereal_trees ) then
   * 		for _,v in ipairs( mg_villages.ethereal_trees ) do
   * 			-- mushroom in ethereal is a pretty decorative material; increase its probability
   * 			if( v == 'mushroom' ) then
   * 				table.insert( known_materials, "ethereal:mushroom_pore" );
   * 				table.insert( known_materials, "ethereal:mushroom_pore" );
   * 				table.insert( known_materials, "ethereal:mushroom_pore" );
   * 				-- also increase probability for the decorative blueish wood
   * 				table.insert( known_materials, "ethereal:frost_wood" );
   * 				table.insert( known_materials, "ethereal:frost_wood" );
   * 			elseif( minetest.registered_nodes[ "ethereal:"..v.."_wood"] ) then
   * 				table.insert( known_materials, "ethereal:"..v.."_wood" );
   * 			end	
   * 		end
   * 	end
   * 
   * 	if( wood_found and mg_villages.forest_trees ) then
   * 		for _,v in ipairs( mg_villages.forest_trees ) do
   * 			if( minetest.registered_nodes[ 'forest:'..v..'_wood'] ) then
   * 				table.insert( known_materials, 'forest:'..v..'_wood' );
   * 			end	
   * 		end
   * 	end
   * 
   * 	if( wood_found and mg_villages.tinytrees_trees ) then
   * 		for _,v in ipairs( mg_villages.tinytrees_trees ) do
   * 			if( minetest.registered_nodes[ 'trees:wood_'..v] ) then
   * 				table.insert( known_materials, 'trees:wood_'..v );
   * 			end	
   * 		end
   * 	end
   * 
   * 	if( wood_found and mg_villages.realtest_trees ) then
   * 		for _,v in ipairs( mg_villages.realtest_trees ) do
   * 			if( minetest.registered_nodes[ 'trees:'..v..'_planks'] ) then
   * 				table.insert( known_materials, 'trees:'..v..'_planks' );
   * 			end	
   * 		end
   * 	end
   * 
   * 
   * 	-- nothing found which could be used
   * 	if( #known_materials < 1 ) then
   * 		return;
   * 	end
   * 	local new_material  = known_materials[ pr:next( 1, #known_materials )]; 
   * 
   * 	if( use_realtest_stairs == true	) then
   * 		table.insert( replacements, { original_materials[ 1 ], new_material..'_stair' } );
   * 		table.insert( replacements, { original_materials[ 2 ], new_material..'_slab' } );
   * 		table.insert( replacements, { original_materials[ 3 ], new_material } );
   * 		table.insert( replacements, { original_materials[ 1 ]..'upside_down', new_material..'_stair_upside_down' } );
   * 		table.insert( replacements, { original_materials[ 2 ]..'upside_down', new_material..'_slab_upside_down' } );
   * 		return new_material;
   * 	end
   * 
   * 	-- no replacement necessary if we did choose the same material as before
   * 	if( new_material == old_material or old_material == (prefixes[1]..new_material)) then
   * 		return old_material;
   * 	end
   * 
   * 	for i,v in ipairs( prefixes ) do
   * 		table.insert( replacements, { original_materials[ i ], v..new_material } );
   * 	end
   * 	return new_material;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replace_materials);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replace_materials");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- replace the tree trunk as well so that it fits to the wood type
   * mg_villages.replace_tree_trunk = function( replacements, wood_type )
   * 	if(     wood_type == 'default:junglewood' ) then
   * 		table.insert( replacements, {'default:tree',  'default:jungletree'});
   * 	elseif( wood_type == 'default:pine_wood' ) then
   * 		table.insert( replacements, {'default:tree',  'default:pine_tree'});
   * 	elseif( wood_type == 'default:acacia_wood' ) then
   * 		table.insert( replacements, {'default:tree',  'default:acacia_tree'});
   * 	elseif( wood_type == 'default:aspen_wood' ) then
   * 		table.insert( replacements, {'default:tree',  'default:aspen_tree'});
   * 	elseif( wood_type == 'mg:savannawood' ) then
   * 		table.insert( replacements, {'default:tree',  'mg:savannatree'});
   * 	elseif( wood_type == 'mg:pinewood' ) then
   * 		table.insert( replacements, {'default:tree',  'mg:pinetree'});
   * 
   *  	elseif( mg_villages.moretrees_treelist ) then
   * 		for _,v in ipairs( mg_villages.moretrees_treelist ) do
   * 			if( wood_type == "moretrees:"..v[1].."_planks" ) then
   * 				table.insert( replacements, {'default:tree',   "moretrees:"..v[1].."_trunk"});
   * 				table.insert( replacements, {'default:leaves', "moretrees:"..v[1].."_leaves"});
   * 			end
   * 		end
   * 
   * 	elseif( wood_type == 'deco:birch_plank' ) then
   * 		table.insert( replacements, {'default:tree', "mapgen:birch_log"});
   * 	elseif( wood_type == 'deco:cherry_plank' ) then
   * 		table.insert( replacements, {'default:tree', "mapgen:cherry_log"});
   * 	elseif( wood_type == 'deco:evergreen_plank' ) then
   * 		table.insert( replacements, {'default:tree', "mapgen:evergreen_log"});
   * 	elseif( wood_type == 'deco:oak_plank' ) then
   * 		table.insert( replacements, {'default:tree', "mapgen:oak_log"});
   * 
   * 	elseif( wood_type == 'ethereal:frost_wood' ) then
   * 		table.insert( replacements, {'default:tree', "ethereal:frost_tree"});
   * 
   * 	elseif( wood_type == "ethereal:mushroom_pore" ) then
   * 		table.insert( replacements, {'default:tree', "ethereal:mushroom_trunk"});
   * 
   * 	elseif( mg_villages.ethereal_trees ) then
   * 		for _,v in ipairs( mg_villages.ethereal_trees ) do
   * 			if( wood_type == "ethereal:"..v.."_wood" ) then
   * 				table.insert( replacements, {'default:tree', "ethereal:"..v.."_trunk"});
   * 			end
   * 		end
   * 
   * 	elseif( mg_villages.forest_trees ) then
   * 		for _,v in ipairs( mg_villages.forest_trees ) do
   * 			if( wood_type == "forest:"..v.."_wood" ) then
   * 				table.insert( replacements, {'default:tree', "forest:"..v.."_tree"});
   * 			end
   * 		end
   * 
   * 	elseif( mg_villages.tinytrees_trees ) then
   * 		for _,v in ipairs( mg_villages.tinytrees_trees ) do
   * 			if( wood_type == "trees:wood_"..v ) then
   * 				table.insert( replacements, {'default:tree', "trees:tree_"..v});
   * 			end
   * 		end
   * 
   * 	elseif( mg_villages.realtest_trees ) then
   * 		for _,v in ipairs( mg_villages.realtest_trees ) do
   * 			if( wood_type == 'trees:'..v..'_planks' ) then
   * 				table.insert( replacements, {'default:tree', "trees:"..v..'_log'});
   * 				-- realtest does not have most of the nodes from default, so we need to replace them as well
   * 				table.insert( replacements, {'default:wood',         'trees:'..v..'_planks'});
   * 				table.insert( replacements, {'default:leaves',       'trees:'..v..'_leaves'});
   * 				table.insert( replacements, {'default:ladder',       'trees:'..v..'_ladder'});
   * 				table.insert( replacements, {'default:chest',        'trees:'..v..'_chest'});
   * 				table.insert( replacements, {'default:chest_locked', 'trees:'..v..'_chest_locked'});
   * 				table.insert( replacements, {'default:fence_wood',   'fences:'..v..'_fence'});
   * 				table.insert( replacements, {'default:bookshelf',    'decorations:bookshelf_'..v});
   * 				table.insert( replacements, {'doors:door_wood_t_1',  'doors:door_'..v..'_t_1'});
   * 				table.insert( replacements, {'doors:door_wood_b_1',  'doors:door_'..v..'_b_1'});
   * 				table.insert( replacements, {'doors:door_wood_t_2',  'doors:door_'..v..'_t_2'});
   * 				table.insert( replacements, {'doors:door_wood_b_2',  'doors:door_'..v..'_b_2'});
   * 				-- not really wood-realted, but needs to be replaced as well
   * 				table.insert( replacements, {'default:furnace',      'oven:oven'});
   * 				-- farming is also handled diffrently
   * 				table.insert( replacements, {'farming:soil_wet',     'farming:soil'});
   * 				table.insert( replacements, {'farming:cotton_1',     'farming:flax_1'});
   * 				table.insert( replacements, {'farming:cotton_2',     'farming:flax_1'});
   * 				table.insert( replacements, {'farming:cotton_3',     'farming:flax_2'});
   * 				table.insert( replacements, {'farming:cotton_4',     'farming:flax_2'});
   * 				table.insert( replacements, {'farming:cotton_5',     'farming:flax_3'});
   * 				table.insert( replacements, {'farming:cotton_6',     'farming:flax_3'});
   * 				table.insert( replacements, {'farming:cotton_7',     'farming:flax_4'});
   * 				table.insert( replacements, {'farming:cotton_8',     'farming:flax_4'});
   * 				-- stairs and slabs made out of default wood
   * 				table.insert( replacements, {'stairs:stair_wood',    'trees:'..v..'_planks_stair'});
   * 				table.insert( replacements, {'stairs:slab_wood',     'trees:'..v..'_planks_slab'});
   * 				table.insert( replacements, {'stairs:stair_woodupside_down','trees:'..v..'_planks_stair_upside_down' } );
   * 				table.insert( replacements, {'stairs:slab_woodupside_down', 'trees:'..v..'_planks_slab_upside_down' } );
   * 			end
   * 		end
   * 	else
   * 		return nil;
   * 	end
   * 	return wood_type;
   * -- TODO if minetest.get_modpath("moreblocks") and moretrees.enable_stairsplus the
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replace_tree_trunk);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replace_tree_trunk");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if buildings are made out of a certain wood type, people might expect trees of that type nearby
   * mg_villages.replace_saplings = function( replacements, wood_type )
   * 	if(     wood_type == 'default:junglewood' ) then
   * 		table.insert( replacements, {'default:sapling',  'default:junglesapling'});
   * 	elseif( wood_type == 'default:pine_wood' ) then
   * 		table.insert( replacements, {'default:sapling',  'default:pine_sapling'});
   * 	elseif( wood_type == 'default:acacia_wood' ) then
   * 		table.insert( replacements, {'default:sapling',  'default:acacia_sapling'});
   * 	elseif( wood_type == 'default:aspen_wood' ) then
   * 		table.insert( replacements, {'default:sapling',  'default:aspen_sapling'});
   * 	elseif( wood_type == 'mg:savannawood' ) then
   * 		table.insert( replacements, {'default:sapling',  'mg:savannasapling'});
   * 	elseif( wood_type == 'mg:pinewood' ) then
   * 		table.insert( replacements, {'default:sapling',  'mg:pinesapling'});
   *  	elseif( mg_villages.moretrees_treelist ) then
   * 		for _,v in ipairs( mg_villages.moretrees_treelist ) do
   * 			if( wood_type == "moretrees:"..v[1].."_planks" ) then
   * 				table.insert( replacements, {'default:sapling', "moretrees:"..v[1].."_sapling_ongen"});
   * 			end
   * 		end
   *  	elseif( mg_villages.ethereal_trees ) then
   * 		for _,v in ipairs( mg_villages.ethereal_trees ) do
   * 			if( wood_type == "ethereal:"..v.."_wood" ) then
   * 				table.insert( replacements, {'default:sapling', "ethereal:"..v.."_sapling"});
   * 			end
   * 		end
   * 
   *  	elseif( mg_villages.forest_trees ) then
   * 		for _,v in ipairs( mg_villages.forest_trees ) do
   * 			if( wood_type == "forest:"..v.."_wood" ) then
   * 				table.insert( replacements, {'default:sapling', "forest:"..v.."_sapling"});
   * 			end
   * 		end
   * 
   *  	elseif( mg_villages.tinytrees_trees ) then
   * 		for _,v in ipairs( mg_villages.tinytrees_trees ) do
   * 			if( wood_type == "trees:wood_"..v ) then
   * 				table.insert( replacements, {'default:sapling', "trees:sapling_"..v});
   * 			end
   * 
   * 		end
   *  	elseif( mg_villages.realtest_trees ) then
   * 		for _,v in ipairs( mg_villages.realtest_trees ) do
   * 			if( wood_type == 'trees:'..v..'_planks' ) then
   * 				table.insert( replacements, {'default:sapling', "trees:"..v.."_sapling"});
   * 				table.insert( replacements, {'default:junglesapling', "trees:"..v.."_sapling"});
   * 				table.insert( replacements, {'default:pine_sapling',  "trees:"..v.."_sapling"});
   * 				table.insert( replacements, {'default:aspen_sapling', "trees:"..v.."_sapling"});
   * 			end
   * 		end
   * 
   * 	elseif( wood_type == 'deco:birch_plank' ) then
   * 		table.insert( replacements, {'default:sapling', "mapgen:birch_sapling"});
   * 	elseif( wood_type == 'deco:cherry_plank' ) then
   * 		table.insert( replacements, {'default:sapling', "mapgen:cherry_sapling"});
   * 	elseif( wood_type == 'deco:evergreen_plank' ) then
   * 		table.insert( replacements, {'default:sapling', "mapgen:evergreen_sapling"});
   * 	elseif( wood_type == 'deco:oak_plank' ) then
   * 		table.insert( replacements, {'default:sapling', "mapgen:oak_sapling"});
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replace_saplings);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replace_saplings");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- Note: This function is taken from the villages mod (by Sokomine)
   * -- at least the cottages may come in a variety of building materials
   * -- IMPORTANT: don't add any nodes which have on_construct here UNLESS they where in the original file already
   * --            on_construct will only be called for known nodes that need that treatment (see villages.analyze_mts_file and on_constr)
   * mg_villages.get_replacement_list = function( housetype, pr )
   * 
   *    local replacements = {};
   * 
   *   -- else some grass would never (re)grow (if it's below a roof)
   * --   table.insert( replacements, {'default:dirt',            dirt_with_grass_replacement });
   * --   table.insert( replacements, {'default:dirt_with_grass', dirt_with_grass_replacement });
   *    table.insert( replacements, {'default:dirt',            'default:dirt_with_grass' });
   * 
   *    -- realtest lacks quite a lot from default
   *    if( mg_villages.realtest_trees ) then
   * 	for i=1,8 do
   *    		table.insert( replacements, {'farming:wheat_'..i,       'farming:spelt_'..tostring( (i+(i%2))/2) });
   *    		table.insert( replacements, {'farming:cotton_'..i,      'farming:flax_' ..tostring( (i+(i%2))/2) });
   * 	end
   * 	for i=1,5 do
   *    		table.insert( replacements, {'default:grass_'..i,       'air' });
   * 	end
   *   	table.insert(         replacements, {'default:apple',           'air' });
   *   	table.insert(         replacements, {'default:cobble',          'default:stone_macadam' });
   *   	table.insert(         replacements, {'default:obsidian_glass',  'default:glass' });
   * 
   *    -- the default doors from minetest game have been changed since the schematics where built
   *    -- TODO: the door replacement function needs to be more complex; doesn't really work this way
   *    else
   * 	table.insert( replacements, {'doors:door_wood_t_1',  'doors:hidden'});
   * 	table.insert( replacements, {'doors:door_wood_b_1',  'doors:door_wood_a'});
   * 	table.insert( replacements, {'doors:door_wood_t_2',  'doors:hidden'});
   * 	table.insert( replacements, {'doors:door_wood_b_2',  'doors:door_wood_b'});
   *    end
   * 
   *    if( housetype and mg_villages.village_type_data[ housetype ] and mg_villages.village_type_data[ housetype ].replacement_function ) then
   * 	return mg_villages.village_type_data[ housetype ].replacement_function( housetype, pr, replacements );
   *    end
   *    return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_replacement_list);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_replacement_list");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- Taokis houses from structure i/o
   * mg_villages.replacements_taoki = function( housetype, pr, replacements )
   *       local wood_type = 'default:wood';
   * 
   *       if( mg_villages.realtest_trees ) then
   *          wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{'default:wood'},
   *  		'default:wood');
   *          table.insert( replacements, {'stairs:stair_cobble', 'default:stone_bricks_stair' }); 
   *          table.insert( replacements, {'stairs:slab_cobble',  'default:stone_bricks_slab' }); 
   *          table.insert( replacements, {'stairs:stair_stone',  'default:stone_flat_stair' }); 
   *          table.insert( replacements, {'stairs:slab_stone',   'default:stone_flat_slab' }); 
   *       else    
   *       -- the main body of the houses in the .mts files is made out of wood
   *          wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:pinewood', 'mg:savannawood',
   * 		'default:clay', 'default:brick', 'default:sandstone', 
   * 		'default:stonebrick', 'default:desert_stonebrick','default:sandstonebrick', 'default:sandstone','default:stone','default:desert_stone',
   * 		'default:coalblock','default:steelblock','default:goldblock', 'default:bronzeblock', 'default:copperblock', 'wool:white',
   * 		'default:stone_flat', 'default:desert_stone_flat', -- realtest
   * 		'darkage:adobe', 'darkage:basalt', 'darkage:basalt_cobble', 'darkage:chalk',
   * 		'darkage:gneiss', 'darkage:gneiss_cobble', 'darkage:marble', 'darkage:marble_tile',
   * 		'darkage:mud', 'darkage:ors', 'darkage:ors_cobble',
   * 		'darkage:schist', 'darkage:serpentine', 'darkage:shale', 'darkage:silt', 'darkage:slate',
   * 		'mapgen:mese_stone', 'mapgen:soap_stone'},
   * 		'default:wood');
   *       end
   *       -- tree trunks are seldom used in these houses; let's change them anyway
   *       mg_villages.replace_tree_trunk( replacements, wood_type );
   * 		
   *       -- all this comes in variants for stairs and slabs as well
   *       mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_stonebrick',  'stairs:slab_stonebrick', 'default:stonebrick'},
   * 		{'stairs:stair_',            'stairs:slab_',           'default:'          },
   * 		{ 'stonebrick', 'stone', 'sandstone', 'cobble'},
   * 		'stonebrick');
   * 
   *       -- decorative slabs above doors etc.
   *       mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_wood'},
   * 		{'stairs:stair_'},
   * 		{'stonebrick', 'stone', 'sandstone', 'cobble', 'wood', 'junglewood', 'pine_wood', 'acaica_wood', 'aspen_wood' },
   * 		'wood');
   * 
   *       -- brick roofs are a bit odd; but then...
   *       -- all three shapes of roof parts have to fit together
   *       mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_brick',  'stairs:slab_brick', 'default:brick'},
   * 		{'stairs:stair_',       'stairs:slab_',      'default:'     },
   * 		{ 'brick', 'stone', 'cobble', 'stonebrick', 'wood', 'junglewood', 'pine_wood', 'acacia_wood', 'aspen_wood', 'sandstone' },
   * 		'brick' );
   * 
   *       return replacements;
   *  end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_taoki);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_taoki");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_nore = function( housetype, pr, replacements )
   * 
   *       mg_villages.replace_materials( replacements, pr,
   * --		{'default:stonebrick'},
   * --		{'default:'},
   * 		{'stairs:stair_stonebrick',  'stairs:slab_stonebrick', 'default:stonebrick'},
   * 		{'stairs:stair_',       'stairs:slab_',      'default:'     },
   * 		{'stonebrick', 'desert_stonebrick','sandstonebrick', 'sandstone','stone','desert_stone','stone_flat','desert_stone_flat','stone_bricks','desert_strone_bricks'},
   * 		'stonebrick');
   * 
   *       -- replace the wood as well
   *       local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:savannawood', 'mg:pinewood' },
   * 		'default:wood');
   *       mg_villages.replace_tree_trunk( replacements, wood_type );
   *       mg_villages.replace_saplings(   replacements, wood_type );
   * 
   *       if( pr:next(1,3)==1 and not( mg_villages.realtest_trees)) then
   *          table.insert( replacements, {'default:glass', 'default:obsidian_glass'});
   *       end
   * 
   *       if( mg_villages.realtest_trees ) then
   *          table.insert( replacements, {'stairs:stair_cobble', 'default:stone_bricks_stair' }); 
   *          table.insert( replacements, {'stairs:slab_cobble',  'default:stone_bricks_slab' }); 
   *       end
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_nore);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_nore");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_lumberjack = function( housetype, pr, replacements )
   *       -- replace the wood - those are lumberjacks after all
   *       local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:savannawood', 'mg:pinewood' },
   * 		'default:wood');
   *       mg_villages.replace_tree_trunk( replacements, wood_type );
   *       mg_villages.replace_saplings(   replacements, wood_type );
   * 
   *       if( not( minetest.get_modpath('bell' ))) then
   *          table.insert( replacements, {'bell:bell',               'default:goldblock' });
   *       end
   *       if( mg_villages.realtest_trees ) then
   *          table.insert( replacements, {'stairs:stair_cobble', 'default:stone_bricks_stair' }); 
   *          table.insert( replacements, {'stairs:slab_cobble',  'default:stone_bricks_slab' }); 
   *       end
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_lumberjack);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_lumberjack");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_logcabin = function( housetype, pr, replacements )
   * 
   *       -- for logcabins, wood is the most likely type of roof material
   *       local roof_type = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_cobble',      'stairs:slab_cobble' },
   * 		{'cottages:roof_connector_', 'cottages:roof_flat_' },
   * 		{'straw', 'wood',  'wood', 'wood', 'reet', 'slate', 'red', 'brown', 'black'},
   * 		'' );
   *       -- some houses have junglewood roofs
   *       if( roof_type ) then
   *          table.insert( replacements, {'stairs:stair_junglewood',          'cottages:roof_connector_'..roof_type });
   *          table.insert( replacements, {'stairs:slab_junglewood',           'cottages:roof_flat_'..roof_type });
   *          table.insert( replacements, {'cottages:roof_connector_wood',     'cottages:roof_connector_'..roof_type });
   *          table.insert( replacements, {'cottages:roof_flat_wood',          'cottages:roof_flat_'..roof_type });
   *       -- realtest does not have normal stairs
   *       elseif( mg_villages.realtest_trees ) then
   *          table.insert( replacements, {'stairs:stair_junglewood',          'trees:aspen_planks_stair' });
   *          table.insert( replacements, {'stairs:slab_junglewood',           'trees:aspen_planks_slab' });
   *       end
   * 
   *       if( mg_villages.realtest_trees ) then
   *          local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood' },
   * 		'default:wood');
   *          mg_villages.replace_tree_trunk( replacements, wood_type );
   *          mg_villages.replace_saplings(   replacements, wood_type );
   *          table.insert( replacements, {'default:stonebrick',      'default:stone_bricks' }); -- used for chimneys
   *          table.insert( replacements, {'stairs:stair_stonebrick', 'default:stone_bricks_stair' }); 
   *          -- table.insert( replacements, {'default:junglewood', wood_type }); -- replace the floor
   *          -- replace the floor with another type of wood (looks better than the same type as above)
   *          mg_villages.replace_materials( replacements, pr,
   * 		{'default:junglewood'},
   * 		{''},
   * 		{ 'default:wood' },
   * 		'default:junglewood');
   *       end
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_logcabin);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_logcabin");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_chateau = function( housetype, pr, replacements )
   * 
   *       if( minetest.get_modpath( 'cottages' )) then
   * 	       -- straw is the most likely building material for roofs for historical buildings
   *          mg_villages.replace_materials( replacements, pr,
   * 		-- all three shapes of roof parts have to fit together
   * 		{ 'cottages:roof_straw',    'cottages:roof_connector_straw',   'cottages:roof_flat_straw' },
   * 		{ 'cottages:roof_',         'cottages:roof_connector_',        'cottages:roof_flat_'},
   * 		{'straw', 'straw', 'straw', 'straw', 'straw',
   * 			   'reet', 'reet', 'reet',
   * 			   'slate', 'slate',
   *                            'wood',  'wood',  
   *                            'red',
   *                            'brown',
   *                            'black'},
   * 		'straw');
   *       else
   *          mg_villages.replace_materials( replacements, pr,
   * 		-- all three shapes of roof parts have to fit together
   * 		{ 'cottages:roof_straw',    'cottages:roof_connector_straw',   'cottages:roof_flat_straw' },
   * 		{ 'stairs:stair_',          'stairs:stair_',                   'stairs:slab_'},
   * 		{'cobble', 'stonebrick', 'desert_cobble', 'desert_stonebrick', 'stone'},
   * 		'stonebrick');
   *          table.insert( replacements, { 'cottages:glass_pane', 'default:glass' });
   *       end
   * 
   * 
   *       local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood', 'default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'mg:savannawood', 'mg:pinewood'}, --, 'default:brick', 'default:sandstone', 'default:desert_cobble' },
   * 		'default:wood');
   *       mg_villages.replace_tree_trunk( replacements, wood_type );
   *       mg_villages.replace_saplings(   replacements, wood_type );
   * 
   * 
   *       if( mg_villages.realtest_trees ) then
   *          -- replace the floor with another type of wood (looks better than the same type as above)
   *          mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_junglewood',  'stairs:slab_junglewood', 'default:junglewood'},
   * 		{'stairs:stair_',            'stairs:slab_',           'default:'     },
   * 		{ 'default:wood' },
   * 		'wood' );
   *       end
   * 
   * 
   *       local mfs2 = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
   * 		{'stairs:stair_',        'stairs:slab_',       'default:'      },
   * 		{ 'cobble', 'brick', 'clay', 'desert_cobble', 'desert_stone', 'desert_stonebrick', 'sandstone', 'sandstonebrick', 'stonebrick' },
   * 		'cobble');
   * 
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_chateau);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_chateau");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_tent = function( housetype, pr, replacements )
   *       table.insert( replacements, { "glasspanes:wool_pane",  "cottages:wool_tent" });
   *       table.insert( replacements, { "default:gravel",        "default:sand"       });
   *       -- realtest needs diffrent fence posts and doors
   *       if( mg_villages.realtest_trees ) then
   *          local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood' },
   * 		'default:wood');
   *          mg_villages.replace_tree_trunk( replacements, wood_type );
   *          mg_villages.replace_saplings(   replacements, wood_type );
   *       end
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_tent);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_tent");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_grasshut = function( housetype, pr, replacements )
   *       table.insert( replacements, {'moreblocks:fence_jungle_wood',     'default:fence' });
   *       if( pr:next( 1, 4) == 1 ) then
   *          table.insert( replacements, {'dryplants:reed_roof',              'cottages:roof_straw'});
   *          table.insert( replacements, {'dryplants:reed_slab',              'cottages:roof_flat_straw' });
   *          table.insert( replacements, {'dryplants:wetreed_roof',           'cottages:roof_reet' });
   *          table.insert( replacements, {'dryplants:wetreed_slab',           'cottages:roof_flat_reet' });
   *       else -- replace the straw and cobble one of the huts uses
   *          table.insert( replacements, {'cottages:straw',                   'dryplants:wetreed' });
   *          table.insert( replacements, {'stairs:slab_cobble',               'dryplants:reed_slab' });
   *       end
   *       if( pr:next( 1, 4) == 1 ) then
   *          table.insert( replacements, {'dryplants:wetreed_roof_corner',    'default:wood' });
   *          table.insert( replacements, {'dryplants:wetreed_roof_corner_2',  'default:junglewood' });
   *       end
   *       if( not( minetest.get_modpath( 'cavestuff' ))) then
   *          table.insert( replacements, {'cavestuff:desert_pebble_2',        'default:slab_cobble' });
   *       end
   *    
   *       table.insert( replacements, {'default:desert_sand', 'default:dirt_with_grass' });
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_grasshut);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_grasshut");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_claytrader = function( housetype, pr, replacements )
   *       -- the walls of the clay trader houses are made out of brick
   *       mg_villages.replace_materials( replacements, pr,
   * 		{ 'stairs:stair_brick', 'stairs:slab_brick', 'default:brick' }, -- default_materials
   * 		{ 'stairs:stair_',      'stairs:slab_',      'default:'      }, -- prefixes (for new materials)
   * 		{ 'brick', 'stone', 'sandstone', 'sandstonebrick', 'desert_stone', 'desert_cobble', 'desert_stonebrick' }, -- new materials
   * 		'brick' ); -- original material
   * 	
   *       -- material for the floor
   *       mg_villages.replace_materials( replacements, pr,
   * 		{'default:stone'},
   * 		{'default:'},
   * 		{ 'brick', 'stone', 'sandstone', 'sandstonebrick', 'clay', 'desert_stone', 'desert_cobble', 'desert_stonebrick',
   * 		'default:stone_flat', 'default:desert_stone_flat', -- realtest
   * 		},
   * 		'stone');
   * 
   *       -- the clay trader homes come with stone stair roofs; slabs are used in other places as well (but those replacements here are ok)
   *       mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_stone',       'stairs:slab_stone' },
   * 		{'cottages:roof_connector_', 'cottages:roof_flat_' },
   * 		{'straw', 'straw', 'straw', 'straw', 'straw',
   * 			   'reet', 'reet', 'reet',
   * 			   'slate', 'slate',
   *                            'wood',  'wood',  
   *                            'red',
   *                            'brown',
   *                            'black'},
   * 		'');
   * 
   *       -- hills and pits that contain the materials clay traders dig for
   *       mg_villages.replace_materials( replacements, pr,
   * 		{'default:stone_with_coal'},
   * 		{'default:'},
   * 		{'sand', 'sandstone', 'clay'},
   * 		'');
   * 
   *       if( mg_villages.realtest_trees ) then
   *          local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood' },
   * 		'default:wood');
   *          mg_villages.replace_tree_trunk( replacements, wood_type );
   *          mg_villages.replace_saplings(   replacements, wood_type );
   *          table.insert( replacements, {'default:clay', 'default:dirt_with_clay'});
   *          local mfs2 = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
   * 		{'stairs:stair_',        'stairs:slab_',       'default:'      },
   * 		{ 'stone' }, -- will be replaced by mg_villages.realtest_stairs
   * 		'sandstone');
   *       end
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_claytrader);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_claytrader");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_charachoal = function( housetype, pr, replacements )
   *       if( mg_villages.realtest_trees ) then
   *          local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood' },
   * 		'default:wood');
   *          mg_villages.replace_tree_trunk( replacements, wood_type );
   *          mg_villages.replace_saplings(   replacements, wood_type );
   * 
   *          table.insert( replacements, {'stairs:slab_loam',     'cottages:loam'});
   *          table.insert( replacements, {'stairs:stair_loam',    'cottages:loam'});
   *       end
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_charachoal);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_charachoal");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- wells can get the same replacements as the sourrounding village; they'll get a fitting roof that way
   * mg_villages.replacements_medieval = function( housetype, pr, replacements )
   * 
   *    if( not( minetest.get_modpath('bell' ))) then
   *       table.insert( replacements, {'bell:bell',               'default:goldblock' });
   *    end
   * 
   *    -- glass that served as a marker got copied accidently; there's usually no glass in cottages
   *    table.insert( replacements, {'default:glass',           'air'});
   *    -- some plants started growing while the buildings where saved - eliminate them
   *    table.insert( replacements, {'junglegrass:medium',      'air'});
   *    table.insert( replacements, {'junglegrass:short',       'air'});
   *    table.insert( replacements, {'poisonivy:seedling',      'air'});
   * 
   * -- TODO: sometimes, half_door/half_door_inverted gets rotated wrong
   * --   table.insert( replacements, {'cottages:half_door',      'cottages:half_door_inverted'});
   * --   table.insert( replacements, {'cottages:half_door_inverted', 'cottages:half_door'});
   * 
   *    -- some poor cottage owners cannot afford glass
   *    if( pr:next( 1, 2 ) == 2 ) then
   * --      table.insert( replacements, {'cottages:glass_pane',    'default:fence_wood'});
   *       local gp = mg_villages.replace_materials( replacements, pr,
   * 	{'cottages:glass_pane'},
   * 	{''},
   * 	{'xpanes:pane', 'default:glass', 'default:obsidian_glass', 'default:fence_wood',
   * 	 'darkage:medieval_glass', 'darkage:iron_bars', 'darkage:iron_grille', 'darkage:wood_bars',
   * 	 'darkage:wood_frame', 'darkage:wood_grille'},
   * 	'cottages:glass_pane');
   *    end
   * 
   *    -- 'glass' is admittedly debatable; yet it may represent modernized old houses where only the tree-part was left standing
   *    -- loam and clay are mentioned multiple times because those are the most likely building materials in reality
   *    local materials = {'cottages:loam', 'cottages:loam', 'cottages:loam', 'cottages:loam', 'cottages:loam', 
   *                       'default:clay',  'default:clay',  'default:clay',  'default:clay',  'default:clay',
   *                       'default:wood','default:junglewood', 'default:pine_wood', 'default:acacia_wood', 'default:aspen_wood', 'default:sandstone',
   *                       'default:desert_stone','default:brick','default:cobble','default:stonebrick',
   *                       'default:desert_stonebrick','default:sandstonebrick','default:stone',
   *                       'mg:savannawood', 'mg:savannawood', 'mg:savannawood', 'mg:savannawood',
   *                       'mg:pinewood',    'mg:pinewood',    'mg:pinewood',    'mg:pinewood',
   * 		'default:stone_flat', 'default:desert_stone_flat', -- realtest
   * 		'darkage:adobe', 'darkage:basalt', 'darkage:basalt_cobble', 'darkage:chalk',
   * 		'darkage:gneiss', 'darkage:gneiss_cobble', 'darkage:marble', 'darkage:marble_tile',
   * 		'darkage:mud', 'darkage:ors', 'darkage:ors_cobble', 'darkage:reinforced_chalk',
   * 		'darkage:reinforced_wood', 'darkage:reinforced_wood_left', 'darkage:reinforced_wood_right',
   * 		'darkage:schist', 'darkage:serpentine', 'darkage:shale', 'darkage:silt', 'darkage:slate',
   * 		'darkage:slate_cobble', 'darkage:slate_tile', 'darkage:stone_brick',
   * 		'mapgen:mese_stone', 'mapgen:soap_stone'};
   * 
   *    -- what is sandstone (the floor) may be turned into something else
   *    local mfs = mg_villages.replace_materials( replacements, pr,
   * 	{'default:sandstone'},
   * 	{''},
   * 	materials,
   * 	'default:sandstone');
   *    if( mg_villages.realtest_trees ) then
   *        table.insert( replacements, {'stairs:slab_sandstone',   'default:stone_slab'});
   *        local mfs2 = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_sandstone',  'stairs:slab_sandstone', 'default:sandstone'},
   * 		{'stairs:stair_',           'stairs:slab_',          'default:'         },
   * 		{ 'stone' }, -- will be replaced by mg_villages.realtest_stairs
   * 		'sandstone');
   *    elseif( mfs and mfs ~= 'default:sandstone' ) then
   * 
   *       if( mfs == 'cottages:loam' or mfs == 'default:clay' or mfs == 'mg:savannawood' or mfs == 'mg:pinewood') then
   *          mfs = 'default:wood';
   *       elseif( mfs =='default:sandstonebrick' or mfs == 'default:desert_stone' or mfs == 'default:desert_stonebrick'
   *               or not( minetest.registered_nodes[ 'stairs:slab_'..string.sub( mfs, 9 )] )) then
   *          mfs = '';
   *       end
   * 
   *       if( mfs and mfs ~= '' ) then      
   *          -- realtest needs special treatment
   *          table.insert( replacements, {'stairs:slab_sandstone',   'stairs:slab_'..string.sub( mfs, 9 )});
   *       end
   *    end
   *    -- except for the floor, everything else may be glass
   *    table.insert( materials, 'default:glass' );
   * 
   *    local uses_wood = false;
   *    -- bottom part of the house (usually ground floor from outside)
   *    local replace_clay = mg_villages.replace_materials( replacements, pr,
   * 	{'default:clay'},
   * 	{''},
   * 	materials,
   * 	'default:clay');
   *    if( replace_clay and replace_clay ~= 'default:clay' ) then
   *       uses_wood = mg_villages.replace_tree_trunk( replacements, replace_clay );
   *       mg_villages.replace_saplings(               replacements, replace_clay );
   *    end
   *  
   *    -- upper part of the house (may be the same as the material for the lower part)
   *    local replace_loam = mg_villages.replace_materials( replacements, pr,
   * 	{'cottages:loam'},
   * 	{''},
   * 	materials,
   * 	'cottages:loam');
   *    -- if the bottom was not replaced by wood, perhaps the top is
   *    if( not( uses_wood ) and replace_loam ) then
   *          mg_villages.replace_tree_trunk( replacements, replace_loam );
   *          mg_villages.replace_saplings(   replacements, replace_loam );
   *    elseif( mg_villages.realtest_trees ) then
   *       local wood_type = mg_villages.replace_materials( replacements, pr,
   * 		{'default:wood'},
   * 		{''},
   * 		{ 'default:wood' },
   * 		'default:wood');
   *       mg_villages.replace_tree_trunk( replacements, wood_type );
   *       mg_villages.replace_saplings(   replacements, wood_type );
   *    end
   * 
   * 
   *    -- replace cobble; for these nodes, a stony material is needed (used in wells as well)
   *    -- mossycobble is fine here as well
   *    local mcs = mg_villages.replace_materials( replacements, pr,
   * 		{'default:cobble'},
   * 		{'default:'},
   * 		{'sandstone', 'desert_stone', 'desert_cobble',
   *                       'cobble',      'cobble',
   *                       'stonebrick',  'stonebrick', 'stonebrick', -- more common than other materials
   *                       'mossycobble', 'mossycobble','mossycobble',
   *                       'stone',       'stone',
   *                       'desert_stonebrick','sandstonebrick'},
   * 		'cobble');
   *    -- set a fitting material for the slabs; mossycobble uses the default cobble slabs
   *    if( mg_villages.realtest_trees ) then
   *       local mcs2 = mg_villages.replace_materials( replacements, pr,
   * 		{'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
   * 		{'stairs:stair_',        'stairs:slab_',       'default:'          },
   * 		{ 'stone' }, -- will be replaced by mg_villages.realtest_stairs
   * 		'cobble');
   *       table.insert( replacements, {'moreblocks:slab_cobble',   'default:'..mcs..'_slab'});
   *    elseif( mcs ~= 'mossycobble' and mcs ~= 'cobble') then
   * 
   *       -- if no slab exists, use sandstone slabs
   *       if( not( mcs ) or not( minetest.registered_nodes[ 'stairs:slab_'..mcs ])) then
   *          mcs = 'sandstone';
   *       end
   *       table.insert( replacements, {'stairs:slab_cobble',      'stairs:slab_'..mcs});
   *       table.insert( replacements, {'moreblocks:slab_cobble',  'stairs:slab_'..mcs});
   *    else
   *       table.insert( replacements, {'moreblocks:slab_cobble',  'stairs:slab_'..mcs});
   *    end
   *  
   * 
   *    -- straw is the most likely building material for roofs for historical buildings
   *    mg_villages.replace_materials( replacements, pr,
   * 		-- all three shapes of roof parts have to fit together
   * 		{ 'cottages:roof_straw',    'cottages:roof_connector_straw',   'cottages:roof_flat_straw' },
   * 		{ 'cottages:roof_',         'cottages:roof_connector_',        'cottages:roof_flat_'},
   * 		{'straw', 'straw', 'straw', 'straw', 'straw',
   * 			   'reet', 'reet', 'reet',
   * 			   'slate', 'slate',
   *                            'wood',  'wood',  
   *                            'red',
   *                            'brown',
   *                            'black'},
   * 		'straw');
   * 
   * --print('REPLACEMENTS used: '..minetest.serialize( replacements )); 
   *    return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_medieval);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_medieval");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.replacements_tower = function( housetype, pr, replacements )
   *       -- replace the wood - this is needed in particular for the fences
   *       local wood_type = mg_villages.replace_materials( replacements, pr,
   *                 {'default:wood'},
   *                 {''},
   *                 { 'default:wood', 'default:junglewood', 'mg:savannawood', 'mg:pinewood' },
   *                 'default:wood');
   *       mg_villages.replace_tree_trunk( replacements, wood_type );
   *       mg_villages.replace_saplings(   replacements, wood_type );
   * 
   *       mg_villages.replace_materials( replacements, pr,
   *                 {'stairs:stair_cobble',  'stairs:slab_cobble', 'default:cobble'},
   *                 {'stairs:stair_',         'stairs:slab_',      'default:'     },
   *                 {'stonebrick', 'desert_stonebrick','sandstonebrick', 'sandstone','stone','desert_stone','stone_flat','desert_stone_flat','stone_bricks','desert_strone_bricks'},
   *                 'stonebrick');
   * 
   *       return replacements;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_replacements_tower);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements_tower");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- Translate replacement function from above (which aims at place_schematic) for the villages in Nores mapgen
   * mg_villages.get_replacement_ids = function( housetype, pr )
   * 
   * 	local replace = {};
   * 	local replacements = mg_villages.get_replacement_list( housetype, pr );
   * 	for i,v in ipairs( replacements ) do
   * 		if( v and #v == 2 ) then
   * 			replace[ minetest.get_content_id( v[1] )] = minetest.get_content_id( v[2] );
   * 		end
   * 	end
   * 	return replace;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_replacement_ids);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_replacement_ids");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- mapgen based replacements work best using a table, while minetest.place_schematic(..) based spawning needs a list
   * mg_villages.get_replacement_table = function( housetype, pr, replacements )
   * 
   * 	local rtable = {};
   * 	local ids    = {};
   * 	if( not( replacements )) then
   * 		replacements = mg_villages.get_replacement_list( housetype, pr );
   * 	end
   * 	-- it is very problematic if the torches on houses melt snow and cause flooding; thus, we use a torch that is not hot
   * 	if( mg_villages.USE_DEFAULT_3D_TORCHES == false ) then
   * 		table.insert( replacements, {'default:torch', 'mg_villages:torch'});
   * 	end
   * 
   * 	-- make charachoal villages safe from spreading fire
   * 	if( not( mg_villages.use_normal_unsafe_lava )) then
   * 		table.insert( replacements, {'default:lava_source',  'mg_villages:lava_source_tamed'});
   * 		table.insert( replacements, {'default:lava_flowing', 'mg_villages:lava_flowing_tamed'});
   * 	end
   * 
   * 	for i,v in ipairs( replacements ) do
   * 		if( v and #v == 2 ) then
   * 			rtable[ v[1] ] = v[2];
   * 			ids[ minetest.get_content_id( v[1] )] = minetest.get_content_id( v[2] );
   * 		end
   * 	end
   *         return { table = rtable, list = replacements, ids = ids };
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_replacement_table);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_replacement_table");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.get_content_id_replaced = function( node_name, replacements )
   * 	if( not( node_name ) or not( replacements ) or not(replacements.table )) then
   * 		return minetest.get_content_id( 'ignore' );
   * 	end
   * 	if( replacements.table[ node_name ]) then
   * 		return minetest.get_content_id( replacements.table[ node_name ] );
   * 	else
   * 		return minetest.get_content_id( node_name );
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_content_id_replaced);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_content_id_replaced");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- they don't all grow cotton; farming_plus fruits are far more intresting!
   * -- Note: This function modifies replacements.ids and replacements.table for each building
   * --       as far as fruits are concerned. It needs to be called before placing a building
   * --       which contains fruits.
   * -- The function might as well be a local one.
   * mg_villages.get_fruit_replacements = function( replacements, fruit)
   * 
   * 	if( not( fruit )) then
   * 		return;
   * 	end
   * 
   * 	for i=1,8 do
   * 		local old_name = '';
   * 		local new_name = '';
   * 		-- farming_plus plants sometimes come in 3 or 4 variants, but not in 8 as cotton does
   * 		if(     minetest.registered_nodes[ 'farming_plus:'..fruit..'_'..i ]) then
   * 			old_name = "farming:cotton_"..i;
   * 			new_name = 'farming_plus:'..fruit..'_'..i;
   * 	
   * 		-- "surplus" cotton variants will be replaced with the full grown fruit
   * 		elseif( minetest.registered_nodes[ 'farming_plus:'..fruit ]) then
   * 			old_name = "farming:cotton_"..i;
   * 			new_name = 'farming_plus:'..fruit;
   * 
   * 		-- and plants from farming: are supported as well
   * 		elseif( minetest.registered_nodes[ 'farming:'..fruit..'_'..i ]) then
   * 			old_name = "farming:cotton_"..i;
   * 			new_name = 'farming:'..fruit..'_'..i;
   * 
   * 		elseif( minetest.registered_nodes[ 'farming:'..fruit ]) then
   * 			old_name = "farming:cotton_"..i;
   * 			new_name = 'farming:'..fruit;
   * 		end
   * 
   * 		if( old_name ~= '' and new_name ~= '' ) then
   * 			-- this is mostly used by the voxelmanip based spawning of .we files
   * 			replacements.ids[ minetest.get_content_id( old_name )] = minetest.get_content_id( new_name );
   * 			-- this is used by the place_schematic based spawning	
   * 			replacements.table[ old_name ] = new_name;
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_fruit_replacements);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_fruit_replacements");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_replacements(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}



