/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <math.h>

/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: is_village_block
 * function(minp) */
static int lcf1_is_village_block (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local x, z = math.floor(minp.x/80), math.floor(minp.z/80) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,80);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,80);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* local vcc = mg_villages.VILLAGE_CHECK_COUNT */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"VILLAGE_CHECK_COUNT");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* return (x%vcc == 0) and (z%vcc == 0) */
  lc_mod(L,2,4);
  lua_pushnumber(L,0);
  const int lc2 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_mod(L,3,4);
    lua_pushnumber(L,0);
    const int lc3 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc3);
  }
  return 1;
  assert(lua_gettop(L) == 4);
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.villages_at_point
 * function(minp, noise1) */
static int lcf1_mg_villages_villages_at_point (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if not is_village_block(minp) then */
  enum { lc4 = 2 };
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* return {} */
    lua_newtable(L);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc4);
  assert(lua_gettop(L) == 2);
  
  /* local vcr, vcc = mg_villages.VILLAGE_CHECK_RADIUS, mg_villages.VILLAGE_CHECK_COUNT */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"VILLAGE_CHECK_RADIUS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"VILLAGE_CHECK_COUNT");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* -- Check if there's another village nearby
   * for xi = -vcr, vcr, vcc do */
  lc_unm(L,3);
  if (!(((lua_isnumber(L,-1) && lua_isnumber(L,3)) && lua_isnumber(L,4)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc6_var = lua_tonumber(L,-1);
  const double lc7_limit = lua_tonumber(L,3);
  const double lc8_step = lua_tonumber(L,4);
  lua_pop(L,1);
  enum { lc9 = 4 };
  while ((((lc8_step > 0) && (lc6_var <= lc7_limit)) || ((lc8_step <= 0) && (lc6_var >= lc7_limit)))) {
    
    /* internal: local xi at index 5 */
    lua_pushnumber(L,lc6_var);
    
    /* for zi = -vcr, 0, vcc do */
    lc_unm(L,3);
    lua_pushnumber(L,0);
    if (!(((lua_isnumber(L,-2) && lua_isnumber(L,-1)) && lua_isnumber(L,4)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc10_var = lua_tonumber(L,-2);
    const double lc11_limit = lua_tonumber(L,-1);
    const double lc12_step = lua_tonumber(L,4);
    lua_pop(L,2);
    enum { lc13 = 5 };
    while ((((lc12_step > 0) && (lc10_var <= lc11_limit)) || ((lc12_step <= 0) && (lc10_var >= lc11_limit)))) {
      
      /* internal: local zi at index 6 */
      lua_pushnumber(L,lc10_var);
      
      /* if xi ~= 0 or zi ~= 0 then */
      enum { lc14 = 6 };
      lua_pushnumber(L,0);
      const int lc15 = lua_equal(L,5,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc15);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushnumber(L,0);
        const int lc16 = lua_equal(L,6,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc16);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc17 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc17) {
        
        /* local mp = {x = minp.x + 80*xi, z = minp.z + 80*zi} */
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lua_pushnumber(L,80);
        lc_mul(L,-1,5);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lua_pushnumber(L,80);
        lc_mul(L,-1,6);
        lua_remove(L,-2);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 7);
        
        /* local pi = PseudoRandom(mg_villages.get_bseed(mp)) */
        lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
        const int lc18 = lua_gettop(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"get_bseed");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_call(L,1,LUA_MULTRET);
        lua_call(L,(lua_gettop(L) - lc18),1);
        assert(lua_gettop(L) == 8);
        
        /* local s = pi:next(1, 400) */
        lua_pushvalue(L,8);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushnumber(L,1);
        lua_pushnumber(L,400);
        lua_call(L,3,1);
        assert(lua_gettop(L) == 9);
        
        /* local x = pi:next(mp.x, mp.x + 79) */
        lua_pushvalue(L,8);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushliteral(L,"x");
        lua_gettable(L,7);
        lua_pushnumber(L,79);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,1);
        assert(lua_gettop(L) == 10);
        
        /* local z = pi:next(mp.z, mp.z + 79) */
        lua_pushvalue(L,8);
        lua_pushliteral(L,"next");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lua_pushliteral(L,"z");
        lua_gettable(L,7);
        lua_pushnumber(L,79);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,1);
        assert(lua_gettop(L) == 11);
        
        /* if s <= mg_villages.VILLAGE_CHANCE and noise1:get2d({x = x, y = z}) >= -0.3 then */
        enum { lc19 = 11 };
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"VILLAGE_CHANCE");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc20 = lc_le(L,9,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc20);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,-0.3);
          lua_pushvalue(L,2);
          lua_pushliteral(L,"get2d");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_createtable(L,0,2);
          lua_pushliteral(L,"x");
          lua_pushvalue(L,10);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushvalue(L,11);
          lua_rawset(L,-3);
          lua_call(L,2,1);
          const int lc21 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc21);
        }
        const int lc22 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc22) {
          
          /* return {} */
          lua_newtable(L);
          return 1;
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L,lc19);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L,lc14);
      assert(lua_gettop(L) == 6);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc10_var += lc12_step;
    }
    lua_settop(L,lc13);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc6_var += lc8_step;
  }
  lua_settop(L,lc9);
  assert(lua_gettop(L) == 4);
  
  /* local pr = PseudoRandom(mg_villages.get_bseed(minp)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc23 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_bseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc23),1);
  assert(lua_gettop(L) == 5);
  
  /* if pr:next(1, 400) > mg_villages.VILLAGE_CHANCE then */
  enum { lc24 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"VILLAGE_CHANCE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,400);
  lua_call(L,3,1);
  const int lc25 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc25);
  const int lc26 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc26) {
    
    /* return {} */
    lua_newtable(L);
    return 1;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc24);
  assert(lua_gettop(L) == 5);
  
  /* -- No village here
   * local x = pr:next(minp.x, minp.x + 79) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,79);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 6);
  
  /* local z = pr:next(minp.z, minp.z + 79) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,79);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 7);
  
  /* if noise1:get2d({x = x, y = z}) < -0.3 then */
  enum { lc27 = 7 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_pushnumber(L,-0.3);
  const int lc28 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc28);
  const int lc29 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc29) {
    
    /* return {} */
    lua_newtable(L);
    return 1;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc27);
  assert(lua_gettop(L) == 7);
  
  /* -- Deep in the ocean
   * -- fallback: type "nore" (that is what the mod originally came with)
   * local village_type = 'nore' */
  lua_pushliteral(L,"nore");
  assert(lua_gettop(L) == 8);
  
  /* village_type = mg_villages.village_types[ pr:next(1, #mg_villages.village_types )] */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc30 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc30);
  lua_call(L,3,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_replace(L,8);
  assert(lua_gettop(L) == 8);
  
  /* -- select a random type
   * -- if this is the first village for this world, take a medieval one
   * if( (not( mg_villages.all_villages ) or mg_villages.anz_villages < 1) and minetest.get_modpath("cottages") and mg_villages.FIRST_VILLAGE_TYPE) then */
  enum { lc31 = 8 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"anz_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    const int lc32 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc32);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_modpath");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"cottages");
    lua_call(L,1,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"FIRST_VILLAGE_TYPE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc33 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc33) {
    
    /* village_type = mg_villages.FIRST_VILLAGE_TYPE */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"FIRST_VILLAGE_TYPE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,8);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc31);
  assert(lua_gettop(L) == 8);
  
  /* if( not( mg_villages.village_type_data[ village_type ] )) then */
  enum { lc34 = 8 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,8);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc35 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc35) {
    
    /* mg_villages.village_type_data[  village_type ] = { min = mg_villages.VILLAGE_MIN_SIZE, max = mg_villages.VILLAGE_MAX_SIZE } */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"min");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"VILLAGE_MIN_SIZE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"max");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"VILLAGE_MAX_SIZE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,8);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc34);
  assert(lua_gettop(L) == 8);
  
  /* local size = pr:next(mg_villages.village_type_data[ village_type ].min, mg_villages.village_type_data[ village_type ].max) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,8);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"min");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,8);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 9);
  
  /* --	local height = pr:next(5, 20)
   * local height = pr:next(1, 5) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,5);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 10);
  
  /* -- villages of a size >= 40 are always placed at a height of 1
   * if(     size >= 40 ) then */
  enum { lc36 = 10 };
  lua_pushnumber(L,40);
  const int lc37 = lc_le(L,-1,9);
  lua_pop(L,1);
  lua_pushboolean(L,lc37);
  const int lc38 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc38) {
    
    /* height = 1 */
    lua_pushnumber(L,1);
    lua_replace(L,10);
    assert(lua_gettop(L) == 10);
  }
  else {
    
    /* -- slightly smaller but still relatively large villages have a deterministic height now as well
     * 	elseif( size >= 30 ) then */
    enum { lc39 = 10 };
    lua_pushnumber(L,30);
    const int lc40 = lc_le(L,-1,9);
    lua_pop(L,1);
    lua_pushboolean(L,lc40);
    const int lc41 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc41) {
      
      /* height = 40-height */
      lua_pushnumber(L,40);
      lc_sub(L,-1,10);
      lua_remove(L,-2);
      lua_replace(L,10);
      assert(lua_gettop(L) == 10);
    }
    else {
      
      /* elseif( size >= 25 ) then */
      enum { lc42 = 10 };
      lua_pushnumber(L,25);
      const int lc43 = lc_le(L,-1,9);
      lua_pop(L,1);
      lua_pushboolean(L,lc43);
      const int lc44 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc44) {
        
        /* height = 35-height */
        lua_pushnumber(L,35);
        lc_sub(L,-1,10);
        lua_remove(L,-2);
        lua_replace(L,10);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc42);
    }
    lua_settop(L,lc39);
  }
  lua_settop(L,lc36);
  assert(lua_gettop(L) == 10);
  
  /* --	print("A village of type \'"..tostring( village_type ).."\' of size "..tostring( size ).." spawned at: x = "..x..", z = "..z)
   * --print("A village spawned at: x = "..x..", z = "..z)
   * return {{vx = x, vz = z, vs = size, vh = height, village_type = village_type}} */
  lua_createtable(L,1,0);
  lua_createtable(L,0,5);
  lua_pushliteral(L,"vx");
  lua_pushvalue(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"vz");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_pushliteral(L,"vs");
  lua_pushvalue(L,9);
  lua_rawset(L,-3);
  lua_pushliteral(L,"vh");
  lua_pushvalue(L,10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"village_type");
  lua_pushvalue(L,8);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  return 1;
  assert(lua_gettop(L) == 10);
}


/* name: inside_village2
 * function(bx, sx, bz, sz, village, vnoise) */
static int lcf1_inside_village2 (lua_State * L) {
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* return mg_villages.inside_village(bx, bz, village, vnoise) and mg_villages.inside_village(bx+sx, bz, village, vnoise) and mg_villages.inside_village(bx, bz+sz, village, vnoise) and mg_villages.inside_village(bx+sx, bz+sz, village, vnoise) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"inside_village");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,3);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_call(L,4,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"inside_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_add(L,1,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_call(L,4,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"inside_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lc_add(L,3,4);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_call(L,4,1);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"inside_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_add(L,1,2);
    lc_add(L,3,4);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_call(L,4,1);
  }
  return 1;
  assert(lua_gettop(L) == 6);
}


/* name: choose_building
 * function(l, pr, village_type) */
static int lcf1_choose_building (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* --::choose::
   * local btype */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 4);
  
  /* while true do */
  enum { lc47 = 4 };
  while (1) {
    lua_pushboolean(L,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* local p = pr:next(1, 3000) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"next");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,3000);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 5);
    
    /* if(  not( mg_villages.village_type_data[ village_type ] )
     * 		  or not( mg_villages.village_type_data[ village_type ][ 'building_list'] )) then */
    enum { lc48 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_type_data");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"building_list");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc49 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc49) {
      
      /* mg_villages.print( mg_villages.DEBUG_LEVEL_INFO, 'Unsupported village type: '..tostring( village_type )..' for house at '..tostring(bx)..':'..tostring(bz)..'.') */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"print");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"DEBUG_LEVEL_INFO");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"Unsupported village type: ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushvalue(L,3);
      lua_call(L,1,1);
      lua_pushliteral(L," for house at ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_getfield(L,LUA_ENVIRONINDEX,"bx");
      lua_call(L,1,1);
      lua_pushliteral(L,":");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_getfield(L,LUA_ENVIRONINDEX,"bz");
      lua_call(L,1,1);
      lua_pushliteral(L,".");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc48);
    assert(lua_gettop(L) == 5);
    
    /* for _, b in ipairs( mg_villages.village_type_data[ village_type ][ 'building_list'] ) do
     * internal: local f, s, var = explist */
    enum { lc50 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"building_list");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 9
       * internal: local b with idx 10 */
      
      
      /* if (   mg_villages.BUILDINGS[ b ] and mg_villages.BUILDINGS[ b ].max_weight
       * 			   and mg_villages.BUILDINGS[ b ].max_weight[ village_type ] and  mg_villages.BUILDINGS[ b ].max_weight[ village_type ] >= p) then */
      enum { lc51 = 10 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,10);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"max_weight");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"max_weight");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,3);
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,10);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"max_weight");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,3);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc52 = lc_le(L,5,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc52);
      }
      const int lc53 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc53) {
        
        /* --		for b, i in ipairs(mg_villages.BUILDINGS) do
         * --			if i.weight[ village_type ] and i.weight[ village_type ] > 0 and i.max_weight and i.max_weight[ village_type ] and i.max_weight[ village_type ] >= p then
         * btype = b */
        lua_pushvalue(L,10);
        lua_replace(L,4);
        assert(lua_gettop(L) == 10);
        
        /* break */
        break;
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L,lc51);
      assert(lua_gettop(L) == 10);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc50);
    assert(lua_gettop(L) == 5);
    
    /* -- in case no building was found: take the last one that fits
     * if( not( btype )) then */
    enum { lc54 = 5 };
    lua_pushboolean(L,!(lua_toboolean(L,4)));
    const int lc55 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc55) {
      
      /* for i=#mg_villages.BUILDINGS,1,-1 do */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc59 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc59);
      lua_pushnumber(L,1);
      lua_pushnumber(L,-1);
      if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc56_var = lua_tonumber(L,-3);
      const double lc57_limit = lua_tonumber(L,-2);
      const double lc58_step = lua_tonumber(L,-1);
      lua_pop(L,3);
      enum { lc60 = 5 };
      while ((((lc58_step > 0) && (lc56_var <= lc57_limit)) || ((lc58_step <= 0) && (lc56_var >= lc57_limit)))) {
        
        /* internal: local i at index 6 */
        lua_pushnumber(L,lc56_var);
        
        /* if (  mg_villages.BUILDINGS[i] and mg_villages.BUILDINGS[i].weight
         * 				  and mg_villages.BUILDINGS[i].weight[ village_type ] and mg_villages.BUILDINGS[i].weight[ village_type ] > 0 ) then */
        enum { lc61 = 6 };
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"BUILDINGS");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"weight");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"BUILDINGS");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"weight");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,3);
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,0);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"BUILDINGS");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"weight");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,3);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc62 = lua_lessthan(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc62);
        }
        const int lc63 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc63) {
          
          /* btype = i */
          lua_pushvalue(L,6);
          lua_replace(L,4);
          assert(lua_gettop(L) == 6);
          
          /* i = 1 */
          lua_pushnumber(L,1);
          lua_replace(L,6);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc61);
        assert(lua_gettop(L) == 6);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc56_var += lc58_step;
      }
      lua_settop(L,lc60);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc54);
    assert(lua_gettop(L) == 5);
    
    /* if( not( btype )) then */
    enum { lc64 = 5 };
    lua_pushboolean(L,!(lua_toboolean(L,4)));
    const int lc65 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc65) {
      
      /* return 1 */
      lua_pushnumber(L,1);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc64);
    assert(lua_gettop(L) == 5);
    
    /* if( #l<1
     * 			or not( mg_villages.BUILDINGS[btype].avoid )
     * 			or mg_villages.BUILDINGS[btype].avoid==''
     * 			or not( mg_villages.BUILDINGS[ l[#l].btype ].avoid )
     * 			or mg_villages.BUILDINGS[btype].avoid ~= mg_villages.BUILDINGS[ l[#l].btype ].avoid) then */
    enum { lc66 = 5 };
    const double lc67 = lua_objlen(L,1);
    lua_pushnumber(L,lc67);
    lua_pushnumber(L,1);
    const int lc68 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc68);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"avoid");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"avoid");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"");
      const int lc69 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc69);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc70 = lua_objlen(L,1);
      lua_pushnumber(L,lc70);
      lua_gettable(L,1);
      lua_pushliteral(L,"btype");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"avoid");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"avoid");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc71 = lua_objlen(L,1);
      lua_pushnumber(L,lc71);
      lua_gettable(L,1);
      lua_pushliteral(L,"btype");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"avoid");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc72 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc72);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc73 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc73) {
      
      /* if mg_villages.BUILDINGS[btype].pervillage ~= nil then */
      enum { lc74 = 5 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"pervillage");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnil(L);
      const int lc75 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc75);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc76 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc76) {
        
        /* local n = 0 */
        lua_pushnumber(L,0);
        assert(lua_gettop(L) == 6);
        
        /* for j=1, #l do */
        lua_pushnumber(L,1);
        const double lc80 = lua_objlen(L,1);
        lua_pushnumber(L,lc80);
        if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
          luaL_error(L,"'for' limit must be a number");
        }
        double lc77_var = lua_tonumber(L,-2);
        const double lc78_limit = lua_tonumber(L,-1);
        const double lc79_step = 1;
        lua_pop(L,2);
        enum { lc81 = 6 };
        while ((((lc79_step > 0) && (lc77_var <= lc78_limit)) || ((lc79_step <= 0) && (lc77_var >= lc78_limit)))) {
          
          /* internal: local j at index 7 */
          lua_pushnumber(L,lc77_var);
          
          /* if( l[j].btype == btype or (mg_villages.BUILDINGS[btype].typ and mg_villages.BUILDINGS[btype].typ == mg_villages.BUILDINGS[ l[j].btype ].typ)) then */
          enum { lc82 = 7 };
          lua_pushvalue(L,7);
          lua_gettable(L,1);
          lua_pushliteral(L,"btype");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,4);
          const int lc83 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc83);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"BUILDINGS");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,4);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"typ");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"BUILDINGS");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,4);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"typ");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"BUILDINGS");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,7);
              lua_gettable(L,1);
              lua_pushliteral(L,"btype");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"typ");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc84 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc84);
            }
          }
          const int lc85 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc85) {
            
            /* n = n + 1 */
            lua_pushnumber(L,1);
            lc_add(L,6,-1);
            lua_remove(L,-2);
            lua_replace(L,6);
            assert(lua_gettop(L) == 7);
          }
          lua_settop(L,lc82);
          assert(lua_gettop(L) == 7);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
          lc77_var += lc79_step;
        }
        lua_settop(L,lc81);
        assert(lua_gettop(L) == 6);
        
        /* --if n >= mg_villages.BUILDINGS[btype].pervillage then
         * --	goto choose
         * --end
         * if n < mg_villages.BUILDINGS[btype].pervillage then */
        enum { lc86 = 6 };
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,4);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"pervillage");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc87 = lua_lessthan(L,6,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc87);
        const int lc88 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc88) {
          
          /* return btype */
          lua_pushvalue(L,4);
          return 1;
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc86);
        assert(lua_gettop(L) == 6);
      }
      else {
        
        /* else
         * return btype */
        lua_pushvalue(L,4);
        return 1;
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc74);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc66);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
  }
  lua_settop(L,lc47);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* name: choose_building_rot
 * function(l, pr, orient, village_type) */
static int lcf1_choose_building_rot (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local btype = choose_building(l, pr, village_type) */
  lc_getupvalue(L,lua_upvalueindex(1),1,3);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,4);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 5);
  
  /* local rotation */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 6);
  
  /* if mg_villages.BUILDINGS[btype].no_rotate then */
  enum { lc90 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"no_rotate");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc91 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc91) {
    
    /* rotation = 0 */
    lua_pushnumber(L,0);
    lua_replace(L,6);
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* else
     * if mg_villages.BUILDINGS[btype].orients == nil then */
    enum { lc92 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"orients");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnil(L);
    const int lc93 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc93);
    const int lc94 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc94) {
      
      /* mg_villages.BUILDINGS[btype].orients = {0,1,2,3} */
      lua_createtable(L,4,0);
      lua_pushnumber(L,0);
      lua_rawseti(L,-2,1);
      lua_pushnumber(L,1);
      lua_rawseti(L,-2,2);
      lua_pushnumber(L,2);
      lua_rawseti(L,-2,3);
      lua_pushnumber(L,3);
      lua_rawseti(L,-2,4);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"orients");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc92);
    assert(lua_gettop(L) == 6);
    
    /* rotation = (orient+mg_villages.BUILDINGS[btype].orients[pr:next(1, #mg_villages.BUILDINGS[btype].orients)])%4 */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"orients");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"next");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"orients");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc95 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc95);
    lua_call(L,3,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_add(L,3,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,4);
    lc_mod(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,6);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc90);
  assert(lua_gettop(L) == 6);
  
  /* local bsizex = mg_villages.BUILDINGS[btype].sizex */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sizex");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 7);
  
  /* local bsizez = mg_villages.BUILDINGS[btype].sizez */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sizez");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 8);
  
  /* if rotation%2 == 1 then */
  enum { lc96 = 8 };
  lua_pushnumber(L,2);
  lc_mod(L,6,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  const int lc97 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc97);
  const int lc98 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc98) {
    
    /* bsizex, bsizez = bsizez, bsizex */
    lua_pushvalue(L,8);
    lua_pushvalue(L,7);
    lua_replace(L,8);
    lua_replace(L,7);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc96);
  assert(lua_gettop(L) == 8);
  
  /* -- some buildings are mirrored
   * local mirror = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 9);
  
  /* -- some buildings may be too difficult for mirroring (=many nodebox-nodes that can't be mirrored well by rotation) or
   * -- be too symmetric to be worth the trouble
   * if( not(mg_villages.BUILDINGS[btype].nomirror) and pr:next( 1,2 )==1 ) then */
  enum { lc99 = 9 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nomirror");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"next");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,2);
    lua_call(L,3,1);
    lua_pushnumber(L,1);
    const int lc100 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc100);
  }
  const int lc101 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc101) {
    
    /* mirror = true */
    lua_pushboolean(L,1);
    lua_replace(L,9);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc99);
  assert(lua_gettop(L) == 9);
  
  /* return btype, rotation, bsizex, bsizez, mirror */
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,8);
  lua_pushvalue(L,9);
  return 5;
  assert(lua_gettop(L) == 9);
}


/* name: placeable
 * function(bx, bz, bsizex, bsizez, l, exclude_roads, orientation) */
static int lcf1_placeable (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* for _, a in ipairs(l) do
   * 		-- with < instead of <=, space_between_buildings can be zero (important for towns where houses are closely packed)
   * internal: local f, s, var = explist */
  enum { lc103 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,5);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 11
     * internal: local a with idx 12 */
    
    
    /* -- with < instead of <=, space_between_buildings can be zero (important for towns where houses are closely packed)
     * if (a.btype ~= "road" or not exclude_roads) and math.abs(bx+bsizex/2-a.x-a.bsizex/2)<(bsizex+a.bsizex)/2 and math.abs(bz+bsizez/2-a.z-a.bsizez/2)<(bsizez+a.bsizez)/2 then */
    enum { lc104 = 12 };
    lua_pushliteral(L,"btype");
    lua_gettable(L,12);
    lua_pushliteral(L,"road");
    const int lc105 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc105);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushboolean(L,!(lua_toboolean(L,6)));
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,3,-1);
      lua_remove(L,-2);
      lc_add(L,1,-1);
      lua_remove(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,12);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"bsizex");
      lua_gettable(L,12);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"bsizex");
      lua_gettable(L,12);
      lc_add(L,3,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      const int lc106 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc106);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,4,-1);
      lua_remove(L,-2);
      lc_add(L,2,-1);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,12);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,12);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,12);
      lc_add(L,4,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      const int lc107 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc107);
    }
    const int lc108 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc108) {
      
      /* -- dirt roads which go at a 90 degree angel to the current road are not a problem
       * if( not( orientation ) or a.o%2 == orientation%2 ) then */
      enum { lc109 = 12 };
      lua_pushboolean(L,!(lua_toboolean(L,7)));
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"o");
        lua_gettable(L,12);
        lua_pushnumber(L,2);
        lc_mod(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lc_mod(L,7,-1);
        lua_remove(L,-2);
        const int lc110 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc110);
      }
      const int lc111 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc111) {
        
        /* return false */
        lua_pushboolean(L,0);
        return 1;
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc109);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc104);
    assert(lua_gettop(L) == 12);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc103);
  assert(lua_gettop(L) == 7);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* name: road_in_building
 * function(rx, rz, rdx, rdz, roadsize, l) */
static int lcf1_road_in_building (lua_State * L) {
  enum { lc_nformalargs = 6 };
  lua_settop(L,6);
  
  /* if rdx == 0 then */
  enum { lc113 = 6 };
  lua_pushnumber(L,0);
  const int lc114 = lua_equal(L,3,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc114);
  const int lc115 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc115) {
    
    /* return not placeable(rx-roadsize+1, rz, 2*roadsize-2, 0, l, true) */
    lc_getupvalue(L,lua_upvalueindex(1),1,5);
    lc_sub(L,1,5);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_pushnumber(L,2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,0);
    lua_pushvalue(L,6);
    lua_pushboolean(L,1);
    lua_call(L,6,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* else
     * return not placeable(rx, rz-roadsize+1, 0, 2*roadsize-2, l, true) */
    lc_getupvalue(L,lua_upvalueindex(1),1,5);
    lua_pushvalue(L,1);
    lc_sub(L,2,5);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,0);
    lua_pushnumber(L,2);
    lc_mul(L,-1,5);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_pushboolean(L,1);
    lua_call(L,6,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc113);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* name: when
 * function(a, b, c) */
static int lcf1_when (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if a then */
  enum { lc117 = 3 };
  if (lua_toboolean(L,1)) {
    
    /* return b */
    lua_pushvalue(L,2);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * return c */
    lua_pushvalue(L,3);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc117);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: generate_road
 * function(village, l, pr, roadsize_list, road_materials, rx, rz, rdx, rdz, vnoise, space_between_buildings, iteration_depth) */
static int lcf1_generate_road (lua_State * L) {
  lua_checkstack(L,57);
  enum { lc_nformalargs = 12 };
  lua_settop(L,12);
  
  /* local roadsize = math.floor(roadsize_list[ iteration_depth ]/2) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,12);
  lua_gettable(L,4);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 13);
  
  /* if( not( roadsize ) or roadsize==0) then */
  enum { lc119 = 13 };
  lua_pushboolean(L,!(lua_toboolean(L,13)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,13);
    lua_pushnumber(L,0);
    const int lc120 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc120);
  }
  const int lc121 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc121) {
    
    /* roadsize = mg_villages.FIRST_ROADSIZE */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"FIRST_ROADSIZE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc119);
  assert(lua_gettop(L) == 13);
  
  /* local roadsize_a = roadsize */
  lua_pushvalue(L,13);
  assert(lua_gettop(L) == 14);
  
  /* local roadsize_b = roadsize */
  lua_pushvalue(L,13);
  assert(lua_gettop(L) == 15);
  
  /* if( roadsize_list[ iteration_depth ] % 2==1 ) then */
  enum { lc122 = 15 };
  lua_pushvalue(L,12);
  lua_gettable(L,4);
  lua_pushnumber(L,2);
  lc_mod(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  const int lc123 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc123);
  const int lc124 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc124) {
    
    /* roadsize_a = roadsize+1 */
    lua_pushnumber(L,1);
    lc_add(L,13,-1);
    lua_remove(L,-2);
    lua_replace(L,14);
    assert(lua_gettop(L) == 15);
  }
  lua_settop(L,lc122);
  assert(lua_gettop(L) == 15);
  
  /* local vx, vz, vh, vs = village.vx, village.vz, village.vh, village.vs */
  lua_pushliteral(L,"vx");
  lua_gettable(L,1);
  lua_pushliteral(L,"vz");
  lua_gettable(L,1);
  lua_pushliteral(L,"vh");
  lua_gettable(L,1);
  lua_pushliteral(L,"vs");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 19);
  
  /* local village_type   = village.village_type */
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 20);
  
  /* local calls_to_do = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 21);
  
  /* local rxx = rx */
  lua_pushvalue(L,6);
  assert(lua_gettop(L) == 22);
  
  /* local rzz = rz */
  lua_pushvalue(L,7);
  assert(lua_gettop(L) == 23);
  
  /* local mx, m2x, mz, m2z, mmx, mmz */
  lua_settop(L,(lua_gettop(L) + 6));
  assert(lua_gettop(L) == 29);
  
  /* mx, m2x, mz, m2z = rx, rx, rz, rz */
  lua_pushvalue(L,6);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,7);
  lua_replace(L,27);
  lua_replace(L,26);
  lua_replace(L,25);
  lua_replace(L,24);
  assert(lua_gettop(L) == 29);
  
  /* local orient1, orient2 */
  lua_settop(L,(lua_gettop(L) + 2));
  assert(lua_gettop(L) == 31);
  
  /* if rdx == 0 then */
  enum { lc125 = 31 };
  lua_pushnumber(L,0);
  const int lc126 = lua_equal(L,8,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc126);
  const int lc127 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc127) {
    
    /* orient1 = 0 */
    lua_pushnumber(L,0);
    lua_replace(L,30);
    assert(lua_gettop(L) == 31);
    
    /* orient2 = 2 */
    lua_pushnumber(L,2);
    lua_replace(L,31);
    assert(lua_gettop(L) == 31);
  }
  else {
    
    /* else
     * orient1 = 3 */
    lua_pushnumber(L,3);
    lua_replace(L,30);
    assert(lua_gettop(L) == 31);
    
    /* orient2 = 1 */
    lua_pushnumber(L,1);
    lua_replace(L,31);
    assert(lua_gettop(L) == 31);
  }
  lua_settop(L,lc125);
  assert(lua_gettop(L) == 31);
  
  /* local btype */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 32);
  
  /* local rotation */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 33);
  
  /* local bsizex */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 34);
  
  /* local bsizez */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 35);
  
  /* local mirror */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 36);
  
  /* -- we have one more road
   * mg_villages.road_nr = mg_villages.road_nr + 1 */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"road_nr");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"road_nr");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 36);
  
  /* local first_building_a = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 37);
  
  /* local first_building_b = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 38);
  
  /* while mg_villages.inside_village(rx, rz, village, vnoise) and not road_in_building(rx, rz, rdx, rdz, roadsize_a, l) do */
  enum { lc128 = 38 };
  while (1) {
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"inside_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_pushvalue(L,7);
    lua_pushvalue(L,1);
    lua_pushvalue(L,10);
    lua_call(L,4,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),2,6);
      lua_pushvalue(L,6);
      lua_pushvalue(L,7);
      lua_pushvalue(L,8);
      lua_pushvalue(L,9);
      lua_pushvalue(L,14);
      lua_pushvalue(L,2);
      lua_call(L,6,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* if iteration_depth > 1 and pr:next(1, 4) == 1 and first_building_a then */
    enum { lc129 = 38 };
    lua_pushnumber(L,1);
    const int lc130 = lua_lessthan(L,-1,12);
    lua_pop(L,1);
    lua_pushboolean(L,lc130);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,3);
      lua_pushliteral(L,"next");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,4);
      lua_call(L,3,1);
      lua_pushnumber(L,1);
      const int lc131 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc131);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,37);
    }
    const int lc132 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc132) {
      
      /* --generate_road(vx, vz, vs, vh, l, pr, roadsize-1, rx, rz, math.abs(rdz), math.abs(rdx))
       * calls_to_do[#calls_to_do+1] = {rx=rx+(roadsize_a - 0)*rdx, rz=rz+(roadsize_a - 0)*rdz, rdx=math.abs(rdz), rdz=math.abs(rdx)} */
      lua_createtable(L,0,4);
      lua_pushliteral(L,"rx");
      lua_pushnumber(L,0);
      lc_sub(L,14,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,8);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"rz");
      lua_pushnumber(L,0);
      lc_sub(L,14,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,9);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"rdx");
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_call(L,1,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"rdz");
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_call(L,1,1);
      lua_rawset(L,-3);
      const double lc133 = lua_objlen(L,21);
      lua_pushnumber(L,lc133);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,21);
      assert(lua_gettop(L) == 38);
      
      /* m2x = rx + (roadsize_a - 0)*rdx */
      lua_pushnumber(L,0);
      lc_sub(L,14,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,8);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lua_replace(L,25);
      assert(lua_gettop(L) == 38);
      
      /* m2z = rz + (roadsize_a - 0)*rdz */
      lua_pushnumber(L,0);
      lc_sub(L,14,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,9);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_replace(L,27);
      assert(lua_gettop(L) == 38);
      
      /* rx = rx + (2*roadsize_a - 0)*rdx */
      lua_pushnumber(L,2);
      lc_mul(L,-1,14);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-1,8);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lua_replace(L,6);
      assert(lua_gettop(L) == 38);
      
      /* rz = rz + (2*roadsize_a - 0)*rdz */
      lua_pushnumber(L,2);
      lc_mul(L,-1,14);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-1,9);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_replace(L,7);
      assert(lua_gettop(L) == 38);
    }
    lua_settop(L,lc129);
    assert(lua_gettop(L) == 38);
    
    /* --else
     * --::loop::
     * local exitloop = false */
    lua_pushboolean(L,0);
    assert(lua_gettop(L) == 39);
    
    /* local bx */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 40);
    
    /* local bz */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 41);
    
    /* local tries = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 42);
    
    /* while true do */
    enum { lc134 = 42 };
    while (1) {
      lua_pushboolean(L,1);
      if (!(lua_toboolean(L,-1))) {
        break;
      }
      lua_pop(L,1);
      
      /* if not mg_villages.inside_village(rx, rz, village, vnoise) or road_in_building(rx, rz, rdx, rdz, roadsize_a, l) then */
      enum { lc135 = 42 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"inside_village");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,6);
      lua_pushvalue(L,7);
      lua_pushvalue(L,1);
      lua_pushvalue(L,10);
      lua_call(L,4,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),2,6);
        lua_pushvalue(L,6);
        lua_pushvalue(L,7);
        lua_pushvalue(L,8);
        lua_pushvalue(L,9);
        lua_pushvalue(L,14);
        lua_pushvalue(L,2);
        lua_call(L,6,1);
      }
      const int lc136 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc136) {
        
        /* exitloop = true */
        lua_pushboolean(L,1);
        lua_replace(L,39);
        assert(lua_gettop(L) == 42);
        
        /* break */
        break;
        assert(lua_gettop(L) == 42);
      }
      lua_settop(L,lc135);
      assert(lua_gettop(L) == 42);
      
      /* local village_type_sub = village_type */
      lua_pushvalue(L,20);
      assert(lua_gettop(L) == 43);
      
      /* if( mg_villages.medieval_subtype and village_type_sub == 'medieval' and math.abs(village.vx-rx)>20 and math.abs(village.vz-rz)>20) then */
      enum { lc137 = 43 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"medieval_subtype");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,43);
        lua_pushliteral(L,"medieval");
        const int lc138 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc138);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,20);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"vx");
        lua_gettable(L,1);
        lc_sub(L,-1,6);
        lua_remove(L,-2);
        lua_call(L,1,1);
        const int lc139 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc139);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,20);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"vz");
        lua_gettable(L,1);
        lc_sub(L,-1,7);
        lua_remove(L,-2);
        lua_call(L,1,1);
        const int lc140 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc140);
      }
      const int lc141 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc141) {
        
        /* village_type_sub = 'fields' */
        lua_pushliteral(L,"fields");
        lua_replace(L,43);
        assert(lua_gettop(L) == 43);
      }
      lua_settop(L,lc137);
      assert(lua_gettop(L) == 43);
      
      /* btype, rotation, bsizex, bsizez, mirror = choose_building_rot(l, pr, orient1, village_type_sub) */
      lc_getupvalue(L,lua_upvalueindex(1),4,4);
      lua_pushvalue(L,2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,30);
      lua_pushvalue(L,43);
      lua_call(L,4,5);
      lua_replace(L,36);
      lua_replace(L,35);
      lua_replace(L,34);
      lua_replace(L,33);
      lua_replace(L,32);
      assert(lua_gettop(L) == 43);
      
      /* bx = rx + math.abs(rdz)*(roadsize_a+1) - when(rdx==-1, bsizex-1, 0) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_call(L,1,1);
      lua_pushnumber(L,1);
      lc_add(L,14,-1);
      lua_remove(L,-2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),1,7);
      lua_pushvalue(L,8);
      lua_pushnumber(L,-1);
      const int lc142 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc142);
      lua_pushnumber(L,1);
      lc_sub(L,34,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_call(L,3,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_replace(L,40);
      assert(lua_gettop(L) == 43);
      
      /* bz = rz + math.abs(rdx)*(roadsize_a+1) - when(rdz==-1, bsizez-1, 0) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_call(L,1,1);
      lua_pushnumber(L,1);
      lc_add(L,14,-1);
      lua_remove(L,-2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),1,7);
      lua_pushvalue(L,9);
      lua_pushnumber(L,-1);
      const int lc143 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc143);
      lua_pushnumber(L,1);
      lc_sub(L,35,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_call(L,3,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_replace(L,41);
      assert(lua_gettop(L) == 43);
      
      /* if placeable(bx, bz, bsizex, bsizez, l) and inside_village2(bx, bsizex, bz, bsizez, village, vnoise) then */
      enum { lc144 = 43 };
      lc_getupvalue(L,lua_upvalueindex(1),3,5);
      lua_pushvalue(L,40);
      lua_pushvalue(L,41);
      lua_pushvalue(L,34);
      lua_pushvalue(L,35);
      lua_pushvalue(L,2);
      lua_call(L,5,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),6,2);
        lua_pushvalue(L,40);
        lua_pushvalue(L,34);
        lua_pushvalue(L,41);
        lua_pushvalue(L,35);
        lua_pushvalue(L,1);
        lua_pushvalue(L,10);
        lua_call(L,6,1);
      }
      const int lc145 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc145) {
        
        /* break */
        break;
        assert(lua_gettop(L) == 43);
      }
      lua_settop(L,lc144);
      assert(lua_gettop(L) == 43);
      
      /* if tries > 5 then */
      enum { lc146 = 43 };
      lua_pushnumber(L,5);
      const int lc147 = lua_lessthan(L,-1,42);
      lua_pop(L,1);
      lua_pushboolean(L,lc147);
      const int lc148 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc148) {
        
        /* rx = rx + rdx */
        lc_add(L,6,8);
        lua_replace(L,6);
        assert(lua_gettop(L) == 43);
        
        /* rz = rz + rdz */
        lc_add(L,7,9);
        lua_replace(L,7);
        assert(lua_gettop(L) == 43);
        
        /* tries = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,42);
        assert(lua_gettop(L) == 43);
      }
      else {
        
        /* else
         * tries = tries + 1 */
        lua_pushnumber(L,1);
        lc_add(L,42,-1);
        lua_remove(L,-2);
        lua_replace(L,42);
        assert(lua_gettop(L) == 43);
      }
      lua_settop(L,lc146);
      assert(lua_gettop(L) == 43);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
    }
    lua_settop(L,lc134);
    assert(lua_gettop(L) == 42);
    
    /* if exitloop then */
    enum { lc149 = 42 };
    if (lua_toboolean(L,39)) {
      
      /* break */
      break;
      assert(lua_gettop(L) == 42);
    }
    lua_settop(L,lc149);
    assert(lua_gettop(L) == 42);
    
    /* rx = rx + (bsizex+space_between_buildings)*rdx */
    lc_add(L,34,11);
    lc_mul(L,-1,8);
    lua_remove(L,-2);
    lc_add(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,6);
    assert(lua_gettop(L) == 42);
    
    /* rz = rz + (bsizez+space_between_buildings)*rdz */
    lc_add(L,35,11);
    lc_mul(L,-1,9);
    lua_remove(L,-2);
    lc_add(L,7,-1);
    lua_remove(L,-2);
    lua_replace(L,7);
    assert(lua_gettop(L) == 42);
    
    /* mx = rx - 2*rdx */
    lua_pushnumber(L,2);
    lc_mul(L,-1,8);
    lua_remove(L,-2);
    lc_sub(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,24);
    assert(lua_gettop(L) == 42);
    
    /* mz = rz - 2*rdz */
    lua_pushnumber(L,2);
    lc_mul(L,-1,9);
    lua_remove(L,-2);
    lc_sub(L,7,-1);
    lua_remove(L,-2);
    lua_replace(L,26);
    assert(lua_gettop(L) == 42);
    
    /* l[#l+1] = {x=bx, y=vh, z=bz, btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation, road_nr = mg_villages.road_nr, side=1, o=orient1, mirror=mirror } */
    lua_createtable(L,0,11);
    lua_pushliteral(L,"x");
    lua_pushvalue(L,40);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushvalue(L,18);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushvalue(L,41);
    lua_rawset(L,-3);
    lua_pushliteral(L,"btype");
    lua_pushvalue(L,32);
    lua_rawset(L,-3);
    lua_pushliteral(L,"bsizex");
    lua_pushvalue(L,34);
    lua_rawset(L,-3);
    lua_pushliteral(L,"bsizez");
    lua_pushvalue(L,35);
    lua_rawset(L,-3);
    lua_pushliteral(L,"brotate");
    lua_pushvalue(L,33);
    lua_rawset(L,-3);
    lua_pushliteral(L,"road_nr");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"road_nr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"side");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"o");
    lua_pushvalue(L,30);
    lua_rawset(L,-3);
    lua_pushliteral(L,"mirror");
    lua_pushvalue(L,36);
    lua_rawset(L,-3);
    const double lc150 = lua_objlen(L,2);
    lua_pushnumber(L,lc150);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 42);
    
    /* first_building_a = true */
    lua_pushboolean(L,1);
    lua_replace(L,37);
    assert(lua_gettop(L) == 42);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
  }
  lua_settop(L,lc128);
  assert(lua_gettop(L) == 38);
  
  /* rx = rxx */
  lua_pushvalue(L,22);
  lua_replace(L,6);
  assert(lua_gettop(L) == 38);
  
  /* rz = rzz */
  lua_pushvalue(L,23);
  lua_replace(L,7);
  assert(lua_gettop(L) == 38);
  
  /* while mg_villages.inside_village(rx, rz, village, vnoise) and not road_in_building(rx, rz, rdx, rdz, roadsize_b, l) do */
  enum { lc151 = 38 };
  while (1) {
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"inside_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_pushvalue(L,7);
    lua_pushvalue(L,1);
    lua_pushvalue(L,10);
    lua_call(L,4,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),2,6);
      lua_pushvalue(L,6);
      lua_pushvalue(L,7);
      lua_pushvalue(L,8);
      lua_pushvalue(L,9);
      lua_pushvalue(L,15);
      lua_pushvalue(L,2);
      lua_call(L,6,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* if roadsize_b > 1 and pr:next(1, 4) == 1 and first_building_b then */
    enum { lc152 = 38 };
    lua_pushnumber(L,1);
    const int lc153 = lua_lessthan(L,-1,15);
    lua_pop(L,1);
    lua_pushboolean(L,lc153);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,3);
      lua_pushliteral(L,"next");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,4);
      lua_call(L,3,1);
      lua_pushnumber(L,1);
      const int lc154 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc154);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,38);
    }
    const int lc155 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc155) {
      
      /* --generate_road(vx, vz, vs, vh, l, pr, roadsize-1, rx, rz, -math.abs(rdz), -math.abs(rdx))
       * calls_to_do[#calls_to_do+1] = {rx=rx+(roadsize_b - 0)*rdx, rz=rz+(roadsize_b - 0)*rdz, rdx=-math.abs(rdz), rdz=-math.abs(rdx)} */
      lua_createtable(L,0,4);
      lua_pushliteral(L,"rx");
      lua_pushnumber(L,0);
      lc_sub(L,15,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,8);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"rz");
      lua_pushnumber(L,0);
      lc_sub(L,15,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,9);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"rdx");
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_call(L,1,1);
      lc_unm(L,-1);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"rdz");
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_call(L,1,1);
      lc_unm(L,-1);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      const double lc156 = lua_objlen(L,21);
      lua_pushnumber(L,lc156);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,21);
      assert(lua_gettop(L) == 38);
      
      /* m2x = rx + (roadsize_b - 0)*rdx */
      lua_pushnumber(L,0);
      lc_sub(L,15,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,8);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lua_replace(L,25);
      assert(lua_gettop(L) == 38);
      
      /* m2z = rz + (roadsize_b - 0)*rdz */
      lua_pushnumber(L,0);
      lc_sub(L,15,-1);
      lua_remove(L,-2);
      lc_mul(L,-1,9);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_replace(L,27);
      assert(lua_gettop(L) == 38);
      
      /* rx = rx + (2*roadsize_b - 0)*rdx */
      lua_pushnumber(L,2);
      lc_mul(L,-1,15);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-1,8);
      lua_remove(L,-2);
      lc_add(L,6,-1);
      lua_remove(L,-2);
      lua_replace(L,6);
      assert(lua_gettop(L) == 38);
      
      /* rz = rz + (2*roadsize_b - 0)*rdz */
      lua_pushnumber(L,2);
      lc_mul(L,-1,15);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-1,9);
      lua_remove(L,-2);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_replace(L,7);
      assert(lua_gettop(L) == 38);
    }
    lua_settop(L,lc152);
    assert(lua_gettop(L) == 38);
    
    /* --else
     * --::loop::
     * local exitloop = false */
    lua_pushboolean(L,0);
    assert(lua_gettop(L) == 39);
    
    /* local bx */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 40);
    
    /* local bz */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 41);
    
    /* local tries = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 42);
    
    /* while true do */
    enum { lc157 = 42 };
    while (1) {
      lua_pushboolean(L,1);
      if (!(lua_toboolean(L,-1))) {
        break;
      }
      lua_pop(L,1);
      
      /* if not mg_villages.inside_village(rx, rz, village, vnoise) or road_in_building(rx, rz, rdx, rdz, roadsize_b, l) then */
      enum { lc158 = 42 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"inside_village");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,6);
      lua_pushvalue(L,7);
      lua_pushvalue(L,1);
      lua_pushvalue(L,10);
      lua_call(L,4,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),2,6);
        lua_pushvalue(L,6);
        lua_pushvalue(L,7);
        lua_pushvalue(L,8);
        lua_pushvalue(L,9);
        lua_pushvalue(L,15);
        lua_pushvalue(L,2);
        lua_call(L,6,1);
      }
      const int lc159 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc159) {
        
        /* exitloop = true */
        lua_pushboolean(L,1);
        lua_replace(L,39);
        assert(lua_gettop(L) == 42);
        
        /* break */
        break;
        assert(lua_gettop(L) == 42);
      }
      lua_settop(L,lc158);
      assert(lua_gettop(L) == 42);
      
      /* local village_type_sub = village_type */
      lua_pushvalue(L,20);
      assert(lua_gettop(L) == 43);
      
      /* if( mg_villages.medieval_subtype and village_type_sub == 'medieval' and math.abs(village.vx-rx)>(village.vs/3) and math.abs(village.vz-rz)>(village.vs/3)) then */
      enum { lc160 = 43 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"medieval_subtype");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,43);
        lua_pushliteral(L,"medieval");
        const int lc161 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc161);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"vs");
        lua_gettable(L,1);
        lua_pushnumber(L,3);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"vx");
        lua_gettable(L,1);
        lc_sub(L,-1,6);
        lua_remove(L,-2);
        lua_call(L,1,1);
        const int lc162 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc162);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"vs");
        lua_gettable(L,1);
        lua_pushnumber(L,3);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"vz");
        lua_gettable(L,1);
        lc_sub(L,-1,7);
        lua_remove(L,-2);
        lua_call(L,1,1);
        const int lc163 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc163);
      }
      const int lc164 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc164) {
        
        /* village_type_sub = 'fields' */
        lua_pushliteral(L,"fields");
        lua_replace(L,43);
        assert(lua_gettop(L) == 43);
      }
      lua_settop(L,lc160);
      assert(lua_gettop(L) == 43);
      
      /* btype, rotation, bsizex, bsizez, mirror = choose_building_rot(l, pr, orient2, village_type_sub) */
      lc_getupvalue(L,lua_upvalueindex(1),4,4);
      lua_pushvalue(L,2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,31);
      lua_pushvalue(L,43);
      lua_call(L,4,5);
      lua_replace(L,36);
      lua_replace(L,35);
      lua_replace(L,34);
      lua_replace(L,33);
      lua_replace(L,32);
      assert(lua_gettop(L) == 43);
      
      /* bx = rx - math.abs(rdz)*(bsizex+roadsize_b) - when(rdx==-1, bsizex-1, 0) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_call(L,1,1);
      lc_add(L,34,15);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,6,-1);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),1,7);
      lua_pushvalue(L,8);
      lua_pushnumber(L,-1);
      const int lc165 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc165);
      lua_pushnumber(L,1);
      lc_sub(L,34,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_call(L,3,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_replace(L,40);
      assert(lua_gettop(L) == 43);
      
      /* bz = rz - math.abs(rdx)*(bsizez+roadsize_b) - when(rdz==-1, bsizez-1, 0) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_call(L,1,1);
      lc_add(L,35,15);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,7,-1);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),1,7);
      lua_pushvalue(L,9);
      lua_pushnumber(L,-1);
      const int lc166 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc166);
      lua_pushnumber(L,1);
      lc_sub(L,35,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_call(L,3,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_replace(L,41);
      assert(lua_gettop(L) == 43);
      
      /* if placeable(bx, bz, bsizex, bsizez, l) and inside_village2(bx, bsizex, bz, bsizez, village, vnoise) then */
      enum { lc167 = 43 };
      lc_getupvalue(L,lua_upvalueindex(1),3,5);
      lua_pushvalue(L,40);
      lua_pushvalue(L,41);
      lua_pushvalue(L,34);
      lua_pushvalue(L,35);
      lua_pushvalue(L,2);
      lua_call(L,5,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),6,2);
        lua_pushvalue(L,40);
        lua_pushvalue(L,34);
        lua_pushvalue(L,41);
        lua_pushvalue(L,35);
        lua_pushvalue(L,1);
        lua_pushvalue(L,10);
        lua_call(L,6,1);
      }
      const int lc168 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc168) {
        
        /* break */
        break;
        assert(lua_gettop(L) == 43);
      }
      lua_settop(L,lc167);
      assert(lua_gettop(L) == 43);
      
      /* if tries > 5 then */
      enum { lc169 = 43 };
      lua_pushnumber(L,5);
      const int lc170 = lua_lessthan(L,-1,42);
      lua_pop(L,1);
      lua_pushboolean(L,lc170);
      const int lc171 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc171) {
        
        /* rx = rx + rdx */
        lc_add(L,6,8);
        lua_replace(L,6);
        assert(lua_gettop(L) == 43);
        
        /* rz = rz + rdz */
        lc_add(L,7,9);
        lua_replace(L,7);
        assert(lua_gettop(L) == 43);
        
        /* tries = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,42);
        assert(lua_gettop(L) == 43);
      }
      else {
        
        /* else
         * tries = tries + 1 */
        lua_pushnumber(L,1);
        lc_add(L,42,-1);
        lua_remove(L,-2);
        lua_replace(L,42);
        assert(lua_gettop(L) == 43);
      }
      lua_settop(L,lc169);
      assert(lua_gettop(L) == 43);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
    }
    lua_settop(L,lc157);
    assert(lua_gettop(L) == 42);
    
    /* if exitloop then */
    enum { lc172 = 42 };
    if (lua_toboolean(L,39)) {
      
      /* break */
      break;
      assert(lua_gettop(L) == 42);
    }
    lua_settop(L,lc172);
    assert(lua_gettop(L) == 42);
    
    /* rx = rx + (bsizex+space_between_buildings)*rdx */
    lc_add(L,34,11);
    lc_mul(L,-1,8);
    lua_remove(L,-2);
    lc_add(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,6);
    assert(lua_gettop(L) == 42);
    
    /* rz = rz + (bsizez+space_between_buildings)*rdz */
    lc_add(L,35,11);
    lc_mul(L,-1,9);
    lua_remove(L,-2);
    lc_add(L,7,-1);
    lua_remove(L,-2);
    lua_replace(L,7);
    assert(lua_gettop(L) == 42);
    
    /* m2x = rx - 2*rdx */
    lua_pushnumber(L,2);
    lc_mul(L,-1,8);
    lua_remove(L,-2);
    lc_sub(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,25);
    assert(lua_gettop(L) == 42);
    
    /* m2z = rz - 2*rdz */
    lua_pushnumber(L,2);
    lc_mul(L,-1,9);
    lua_remove(L,-2);
    lc_sub(L,7,-1);
    lua_remove(L,-2);
    lua_replace(L,27);
    assert(lua_gettop(L) == 42);
    
    /* l[#l+1] = {x=bx, y=vh, z=bz, btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation, road_nr = mg_villages.road_nr, side=2, o=orient2, mirror=mirror} */
    lua_createtable(L,0,11);
    lua_pushliteral(L,"x");
    lua_pushvalue(L,40);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushvalue(L,18);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushvalue(L,41);
    lua_rawset(L,-3);
    lua_pushliteral(L,"btype");
    lua_pushvalue(L,32);
    lua_rawset(L,-3);
    lua_pushliteral(L,"bsizex");
    lua_pushvalue(L,34);
    lua_rawset(L,-3);
    lua_pushliteral(L,"bsizez");
    lua_pushvalue(L,35);
    lua_rawset(L,-3);
    lua_pushliteral(L,"brotate");
    lua_pushvalue(L,33);
    lua_rawset(L,-3);
    lua_pushliteral(L,"road_nr");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"road_nr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"side");
    lua_pushnumber(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"o");
    lua_pushvalue(L,31);
    lua_rawset(L,-3);
    lua_pushliteral(L,"mirror");
    lua_pushvalue(L,36);
    lua_rawset(L,-3);
    const double lc173 = lua_objlen(L,2);
    lua_pushnumber(L,lc173);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 42);
    
    /* first_building_b = true */
    lua_pushboolean(L,1);
    lua_replace(L,38);
    assert(lua_gettop(L) == 42);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
  }
  lua_settop(L,lc151);
  assert(lua_gettop(L) == 38);
  
  /* if road_in_building(rx, rz, rdx, rdz, roadsize, l) then */
  enum { lc174 = 38 };
  lc_getupvalue(L,lua_upvalueindex(1),2,6);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,8);
  lua_pushvalue(L,9);
  lua_pushvalue(L,13);
  lua_pushvalue(L,2);
  lua_call(L,6,1);
  const int lc175 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc175) {
    
    /* mmx = rx - 2*rdx */
    lua_pushnumber(L,2);
    lc_mul(L,-1,8);
    lua_remove(L,-2);
    lc_sub(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,28);
    assert(lua_gettop(L) == 38);
    
    /* mmz = rz - 2*rdz */
    lua_pushnumber(L,2);
    lc_mul(L,-1,9);
    lua_remove(L,-2);
    lc_sub(L,7,-1);
    lua_remove(L,-2);
    lua_replace(L,29);
    assert(lua_gettop(L) == 38);
  }
  lua_settop(L,lc174);
  assert(lua_gettop(L) == 38);
  
  /* mx = mmx or rdx*math.max(rdx*mx, rdx*m2x) */
  lua_pushvalue(L,28);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_mul(L,8,24);
    lc_mul(L,8,25);
    lua_call(L,2,1);
    lc_mul(L,8,-1);
    lua_remove(L,-2);
  }
  lua_replace(L,24);
  assert(lua_gettop(L) == 38);
  
  /* mz = mmz or rdz*math.max(rdz*mz, rdz*m2z) */
  lua_pushvalue(L,29);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_mul(L,9,26);
    lc_mul(L,9,27);
    lua_call(L,2,1);
    lc_mul(L,9,-1);
    lua_remove(L,-2);
  }
  lua_replace(L,26);
  assert(lua_gettop(L) == 38);
  
  /* local rxmin */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 39);
  
  /* local rxmax */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 40);
  
  /* local rzmin */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 41);
  
  /* local rzmax */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 42);
  
  /* if rdx == 0 then */
  enum { lc176 = 42 };
  lua_pushnumber(L,0);
  const int lc177 = lua_equal(L,8,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc177);
  const int lc178 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc178) {
    
    /* rxmin = rx - roadsize_a + 1 */
    lc_sub(L,6,14);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,39);
    assert(lua_gettop(L) == 42);
    
    /* rxmax = rx + roadsize_b - 1 */
    lc_add(L,6,15);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,40);
    assert(lua_gettop(L) == 42);
    
    /* rzmin = math.min(rzz, mz) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,23);
    lua_pushvalue(L,26);
    lua_call(L,2,1);
    lua_replace(L,41);
    assert(lua_gettop(L) == 42);
    
    /* rzmax = math.max(rzz, mz) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,23);
    lua_pushvalue(L,26);
    lua_call(L,2,1);
    lua_replace(L,42);
    assert(lua_gettop(L) == 42);
    
    /* -- prolong the main road to the borders of the village
     * if( mg_villages.road_nr == 1 ) then */
    enum { lc179 = 42 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"road_nr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    const int lc180 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc180);
    const int lc181 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc181) {
      
      /* while( mg_villages.inside_village_area(rxmin, rzmin, village, vnoise)) do */
      enum { lc182 = 42 };
      while (1) {
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,39);
        lua_pushvalue(L,41);
        lua_pushvalue(L,1);
        lua_pushvalue(L,10);
        lua_call(L,4,1);
        if (!(lua_toboolean(L,-1))) {
          break;
        }
        lua_pop(L,1);
        
        /* rzmin = rzmin-1 */
        lua_pushnumber(L,1);
        lc_sub(L,41,-1);
        lua_remove(L,-2);
        lua_replace(L,41);
        assert(lua_gettop(L) == 42);
        
        /* rzmax = rzmax+1 */
        lua_pushnumber(L,1);
        lc_add(L,42,-1);
        lua_remove(L,-2);
        lua_replace(L,42);
        assert(lua_gettop(L) == 42);
      }
      lua_settop(L,lc182);
      assert(lua_gettop(L) == 42);
      
      /* rzmin = rzmin-1 */
      lua_pushnumber(L,1);
      lc_sub(L,41,-1);
      lua_remove(L,-2);
      lua_replace(L,41);
      assert(lua_gettop(L) == 42);
      
      /* rzmax = rzmax+1 */
      lua_pushnumber(L,1);
      lc_add(L,42,-1);
      lua_remove(L,-2);
      lua_replace(L,42);
      assert(lua_gettop(L) == 42);
      
      /* while( mg_villages.inside_village_area(rxmax, rzmax, village, vnoise)) do */
      enum { lc183 = 42 };
      while (1) {
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,40);
        lua_pushvalue(L,42);
        lua_pushvalue(L,1);
        lua_pushvalue(L,10);
        lua_call(L,4,1);
        if (!(lua_toboolean(L,-1))) {
          break;
        }
        lua_pop(L,1);
        
        /* rzmax = rzmax+1 */
        lua_pushnumber(L,1);
        lc_add(L,42,-1);
        lua_remove(L,-2);
        lua_replace(L,42);
        assert(lua_gettop(L) == 42);
      }
      lua_settop(L,lc183);
      assert(lua_gettop(L) == 42);
      
      /* rzmax = rzmax+1 */
      lua_pushnumber(L,1);
      lc_add(L,42,-1);
      lua_remove(L,-2);
      lua_replace(L,42);
      assert(lua_gettop(L) == 42);
    }
    lua_settop(L,lc179);
    assert(lua_gettop(L) == 42);
  }
  else {
    
    /* else
     * rzmin = rz - roadsize_a + 1 */
    lc_sub(L,7,14);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,41);
    assert(lua_gettop(L) == 42);
    
    /* rzmax = rz + roadsize_b - 1 */
    lc_add(L,7,15);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,42);
    assert(lua_gettop(L) == 42);
    
    /* rxmin = math.min(rxx, mx) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_pushvalue(L,24);
    lua_call(L,2,1);
    lua_replace(L,39);
    assert(lua_gettop(L) == 42);
    
    /* rxmax = math.max(rxx, mx) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_pushvalue(L,24);
    lua_call(L,2,1);
    lua_replace(L,40);
    assert(lua_gettop(L) == 42);
    
    /* -- prolong the main road to the borders of the village
     * if( mg_villages.road_nr == 1 ) then */
    enum { lc184 = 42 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"road_nr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    const int lc185 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc185);
    const int lc186 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc186) {
      
      /* while( mg_villages.inside_village_area(rxmin, rzmin, village, vnoise)) do */
      enum { lc187 = 42 };
      while (1) {
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,39);
        lua_pushvalue(L,41);
        lua_pushvalue(L,1);
        lua_pushvalue(L,10);
        lua_call(L,4,1);
        if (!(lua_toboolean(L,-1))) {
          break;
        }
        lua_pop(L,1);
        
        /* rxmin = rxmin-1 */
        lua_pushnumber(L,1);
        lc_sub(L,39,-1);
        lua_remove(L,-2);
        lua_replace(L,39);
        assert(lua_gettop(L) == 42);
        
        /* rxmax = rxmax+1 */
        lua_pushnumber(L,1);
        lc_add(L,40,-1);
        lua_remove(L,-2);
        lua_replace(L,40);
        assert(lua_gettop(L) == 42);
      }
      lua_settop(L,lc187);
      assert(lua_gettop(L) == 42);
      
      /* rxmin = rxmin-1 */
      lua_pushnumber(L,1);
      lc_sub(L,39,-1);
      lua_remove(L,-2);
      lua_replace(L,39);
      assert(lua_gettop(L) == 42);
      
      /* rxmax = rxmax+1 */
      lua_pushnumber(L,1);
      lc_add(L,40,-1);
      lua_remove(L,-2);
      lua_replace(L,40);
      assert(lua_gettop(L) == 42);
      
      /* while( mg_villages.inside_village_area(rxmax, rzmax, village, vnoise)) do */
      enum { lc188 = 42 };
      while (1) {
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,40);
        lua_pushvalue(L,42);
        lua_pushvalue(L,1);
        lua_pushvalue(L,10);
        lua_call(L,4,1);
        if (!(lua_toboolean(L,-1))) {
          break;
        }
        lua_pop(L,1);
        
        /* rxmax = rxmax+1 */
        lua_pushnumber(L,1);
        lc_add(L,40,-1);
        lua_remove(L,-2);
        lua_replace(L,40);
        assert(lua_gettop(L) == 42);
      }
      lua_settop(L,lc188);
      assert(lua_gettop(L) == 42);
      
      /* rxmax = rxmax+1 */
      lua_pushnumber(L,1);
      lc_add(L,40,-1);
      lua_remove(L,-2);
      lua_replace(L,40);
      assert(lua_gettop(L) == 42);
    }
    lua_settop(L,lc184);
    assert(lua_gettop(L) == 42);
  }
  lua_settop(L,lc176);
  assert(lua_gettop(L) == 42);
  
  /* l[#l+1] = {x = rxmin+1, y = vh, z = rzmin, btype = "road",
   * 		bsizex = rxmax - rxmin + 1, bsizez = rzmax - rzmin + 1, brotate = 0, road_nr = mg_villages.road_nr} */
  lua_createtable(L,0,8);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,1);
  lc_add(L,39,-1);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,18);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushvalue(L,41);
  lua_rawset(L,-3);
  lua_pushliteral(L,"btype");
  lua_pushliteral(L,"road");
  lua_rawset(L,-3);
  lua_pushliteral(L,"bsizex");
  lc_sub(L,40,39);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"bsizez");
  lc_sub(L,42,41);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"brotate");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"road_nr");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"road_nr");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  const double lc189 = lua_objlen(L,2);
  lua_pushnumber(L,lc189);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 42);
  
  /* if( road_materials and road_materials[ iteration_depth ] and minetest.registered_nodes[ road_materials[ iteration_depth ]] ) then */
  enum { lc190 = 42 };
  lua_pushvalue(L,5);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,12);
    lua_gettable(L,5);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,12);
    lua_gettable(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc191 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc191) {
    
    /* l[#l].road_material = minetest.get_content_id( road_materials[ iteration_depth ] ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,12);
    lua_gettable(L,5);
    lua_call(L,1,1);
    const double lc192 = lua_objlen(L,2);
    lua_pushnumber(L,lc192);
    lua_gettable(L,2);
    lua_insert(L,-2);
    lua_pushliteral(L,"road_material");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 42);
  }
  lua_settop(L,lc190);
  assert(lua_gettop(L) == 42);
  
  /* for _, i in ipairs(calls_to_do) do
   * --		local new_roadsize = roadsize -- - 1
   * internal: local f, s, var = explist */
  enum { lc193 = 42 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,21);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 46
     * internal: local i with idx 47 */
    
    
    /* --		local new_roadsize = roadsize -- - 1
     * if pr:next(1, 100) <= mg_villages.BIG_ROAD_CHANCE then */
    enum { lc194 = 47 };
    lua_pushvalue(L,3);
    lua_pushliteral(L,"next");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,100);
    lua_call(L,3,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BIG_ROAD_CHANCE");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc195 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc195);
    const int lc196 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc196) {
      
      /* --new_roadsize = roadsize
       * iteration_depth = iteration_depth + 1 */
      lua_pushnumber(L,1);
      lc_add(L,12,-1);
      lua_remove(L,-2);
      lua_replace(L,12);
      assert(lua_gettop(L) == 47);
    }
    lua_settop(L,lc194);
    assert(lua_gettop(L) == 47);
    
    /* --generate_road(vx, vz, vs, vh, l, pr, new_roadsize, i.rx, i.rz, i.rdx, i.rdz, vnoise)
     * calls[calls.index] = {village, l, pr, roadsize_list, road_materials, i.rx, i.rz, i.rdx, i.rdz, vnoise, space_between_buildings, iteration_depth-1} */
    lua_createtable(L,12,0);
    lua_pushvalue(L,1);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,2);
    lua_rawseti(L,-2,2);
    lua_pushvalue(L,3);
    lua_rawseti(L,-2,3);
    lua_pushvalue(L,4);
    lua_rawseti(L,-2,4);
    lua_pushvalue(L,5);
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"rx");
    lua_gettable(L,47);
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"rz");
    lua_gettable(L,47);
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"rdx");
    lua_gettable(L,47);
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"rdz");
    lua_gettable(L,47);
    lua_rawseti(L,-2,9);
    lua_pushvalue(L,10);
    lua_rawseti(L,-2,10);
    lua_pushvalue(L,11);
    lua_rawseti(L,-2,11);
    lua_pushnumber(L,1);
    lc_sub(L,12,-1);
    lua_remove(L,-2);
    lua_rawseti(L,-2,12);
    lua_getfield(L,LUA_ENVIRONINDEX,"calls");
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"calls");
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 47);
    
    /* calls.index = calls.index+1 */
    lua_getfield(L,LUA_ENVIRONINDEX,"calls");
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"calls");
    lua_insert(L,-2);
    lua_pushliteral(L,"index");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 47);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc193);
  assert(lua_gettop(L) == 42);
  return 0;
}


/* name: generate_bpos
 * function(village, pr, vnoise, space_between_buildings) */
static int lcf1_generate_bpos (lua_State * L) {
  lua_checkstack(L,23);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local vx, vz, vh, vs = village.vx, village.vz, village.vh, village.vs */
  lua_pushliteral(L,"vx");
  lua_gettable(L,1);
  lua_pushliteral(L,"vz");
  lua_gettable(L,1);
  lua_pushliteral(L,"vh");
  lua_gettable(L,1);
  lua_pushliteral(L,"vs");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 8);
  
  /* local l = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 9);
  
  /* local rx = vx - vs */
  lc_sub(L,5,8);
  assert(lua_gettop(L) == 10);
  
  /* --[=[local l={}
   * 	local total_weight = 0
   * 	for _, i in ipairs(mg_villages.BUILDINGS) do
   * 		if i.weight == nil then i.weight = 1 end
   * 		total_weight = total_weight+i.weight
   * 		i.max_weight = total_weight
   * 	end
   * 	local multiplier = 3000/total_weight
   * 	for _,i in ipairs(mg_villages.BUILDINGS) do
   * 		i.max_weight = i.max_weight*multiplier
   * 	end
   * 	for i=1, 2000 do
   * 		bx = pr:next(vx-vs, vx+vs)
   * 		bz = pr:next(vz-vs, vz+vs)
   * 		::choose::
   * 		--[[btype = pr:next(1, #mg_villages.BUILDINGS)
   * 		if mg_villages.BUILDINGS[btype].chance ~= nil then
   * 			if pr:next(1, mg_villages.BUILDINGS[btype].chance) ~= 1 then
   * 				goto choose
   * 			end
   * 		end]]
   * 		p = pr:next(1, 3000)
   * 		for b, i in ipairs(mg_villages.BUILDINGS) do
   * 			if i.max_weight > p then
   * 				btype = b
   * 				break
   * 			end
   * 		end
   * 		if mg_villages.BUILDINGS[btype].pervillage ~= nil then
   * 			local n = 0
   * 			for j=1, #l do
   * 				if l[j].btype == btype then
   * 					n = n + 1
   * 				end
   * 			end
   * 			if n >= mg_villages.BUILDINGS[btype].pervillage then
   * 				goto choose
   * 			end
   * 		end
   * 		local rotation
   * 		if mg_villages.BUILDINGS[btype].no_rotate then
   * 			rotation = 0
   * 		else
   * 			rotation = pr:next(0, 3)
   * 		end
   * 		bsizex = mg_villages.BUILDINGS[btype].sizex
   * 		bsizez = mg_villages.BUILDINGS[btype].sizez
   * 		if rotation%2 == 1 then
   * 			bsizex, bsizez = bsizez, bsizex
   * 		end
   * 		if dist_center2(bx-vx, bsizex, bz-vz, bsizez)>vs*vs then goto out end
   * 		for _, a in ipairs(l) do
   * 			if math.abs(bx-a.x)<=(bsizex+a.bsizex)/2+2 and math.abs(bz-a.z)<=(bsizez+a.bsizez)/2+2 then goto out end
   * 		end
   * 		l[#l+1] = {x=bx, y=vh, z=bz, btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation}
   * 		::out::
   * 	end
   * 	return l]=]-
   * --
   * local rz = vz */
  lua_pushvalue(L,6);
  assert(lua_gettop(L) == 11);
  
  /* while mg_villages.inside_village(rx, rz, village, vnoise) do */
  enum { lc198 = 11 };
  while (1) {
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"inside_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,10);
    lua_pushvalue(L,11);
    lua_pushvalue(L,1);
    lua_pushvalue(L,3);
    lua_call(L,4,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* rx = rx - 1 */
    lua_pushnumber(L,1);
    lc_sub(L,10,-1);
    lua_remove(L,-2);
    lua_replace(L,10);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc198);
  assert(lua_gettop(L) == 11);
  
  /* rx = rx + 5 */
  lua_pushnumber(L,5);
  lc_add(L,10,-1);
  lua_remove(L,-2);
  lua_replace(L,10);
  assert(lua_gettop(L) == 11);
  
  /* calls = {index = 1} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"index");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_setfield(L,LUA_ENVIRONINDEX,"calls");
  assert(lua_gettop(L) == 11);
  
  /* -- the function below is recursive; we need a way to count roads
   * mg_villages.road_nr = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"road_nr");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 11);
  
  /* local roadsize_list = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 12);
  
  /* for i=1,mg_villages.FIRST_ROADSIZE*2 do */
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"FIRST_ROADSIZE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc199_var = lua_tonumber(L,-2);
  const double lc200_limit = lua_tonumber(L,-1);
  const double lc201_step = 1;
  lua_pop(L,2);
  enum { lc202 = 12 };
  while ((((lc201_step > 0) && (lc199_var <= lc200_limit)) || ((lc201_step <= 0) && (lc199_var >= lc200_limit)))) {
    
    /* internal: local i at index 13 */
    lua_pushnumber(L,lc199_var);
    
    /* roadsize_list[i] = i */
    lua_pushvalue(L,13);
    lua_pushvalue(L,13);
    lua_insert(L,-2);
    lua_settable(L,12);
    assert(lua_gettop(L) == 13);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc199_var += lc201_step;
  }
  lua_settop(L,lc202);
  assert(lua_gettop(L) == 12);
  
  /* if( mg_villages.village_type_data[ village.village_type ].roadsize_list ) then */
  enum { lc203 = 12 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"roadsize_list");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc204 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc204) {
    
    /* roadsize_list = mg_villages.village_type_data[ village.village_type ].roadsize_list */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"village_type");
    lua_gettable(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"roadsize_list");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,12);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc203);
  assert(lua_gettop(L) == 12);
  
  /* generate_road(village, l, pr, roadsize_list, mg_villages.village_type_data[ village.village_type ].road_materials, rx, rz, 1, 0, vnoise, space_between_buildings, #roadsize_list) */
  lc_getupvalue(L,lua_upvalueindex(1),1,8);
  lua_pushvalue(L,1);
  lua_pushvalue(L,9);
  lua_pushvalue(L,2);
  lua_pushvalue(L,12);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"road_materials");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,10);
  lua_pushvalue(L,11);
  lua_pushnumber(L,1);
  lua_pushnumber(L,0);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  const double lc205 = lua_objlen(L,12);
  lua_pushnumber(L,lc205);
  lua_call(L,12,0);
  assert(lua_gettop(L) == 12);
  
  /* local i = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 13);
  
  /* while i < calls.index do */
  enum { lc206 = 13 };
  while (1) {
    lua_getfield(L,LUA_ENVIRONINDEX,"calls");
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc207 = lua_lessthan(L,13,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc207);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* generate_road(unpack(calls[i])) */
    lc_getupvalue(L,lua_upvalueindex(1),1,8);
    const int lc208 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"unpack");
    lua_getfield(L,LUA_ENVIRONINDEX,"calls");
    lua_pushvalue(L,13);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc208),0);
    assert(lua_gettop(L) == 13);
    
    /* i = i+1 */
    lua_pushnumber(L,1);
    lc_add(L,13,-1);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc206);
  assert(lua_gettop(L) == 13);
  
  /* mg_villages.road_nr = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"road_nr");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 13);
  
  /* return l */
  lua_pushvalue(L,9);
  return 1;
  assert(lua_gettop(L) == 13);
}


/* name: generate_dirt_roads
 * function( village, vnoise, bpos, secondary_dirt_roads) */
static int lcf1_generate_dirt_roads (lua_State * L) {
  lua_checkstack(L,29);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local dirt_roads = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* if( not( secondary_dirt_roads)) then */
  enum { lc210 = 5 };
  lua_pushboolean(L,!(lua_toboolean(L,4)));
  const int lc211 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc211) {
    
    /* return dirt_roads */
    lua_pushvalue(L,5);
    return 1;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc210);
  assert(lua_gettop(L) == 5);
  
  /* for _, pos in ipairs( bpos ) do
   * internal: local f, s, var = explist */
  enum { lc212 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 9
     * internal: local pos with idx 10 */
    
    
    /* local x = pos.x */
    lua_pushliteral(L,"x");
    lua_gettable(L,10);
    assert(lua_gettop(L) == 11);
    
    /* local z = pos.z */
    lua_pushliteral(L,"z");
    lua_gettable(L,10);
    assert(lua_gettop(L) == 12);
    
    /* local sizex = pos.bsizex */
    lua_pushliteral(L,"bsizex");
    lua_gettable(L,10);
    assert(lua_gettop(L) == 13);
    
    /* local sizez = 2 */
    lua_pushnumber(L,2);
    assert(lua_gettop(L) == 14);
    
    /* local orientation = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 15);
    
    /* local vx */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 16);
    
    /* local vz */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 17);
    
    /* local vsx */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 18);
    
    /* local vsz */
    lua_settop(L,(lua_gettop(L) + 1));
    assert(lua_gettop(L) == 19);
    
    /* -- prolong the roads; start with a 3x2 piece of road for testing
     * if( pos.btype == 'road' ) then */
    enum { lc213 = 19 };
    lua_pushliteral(L,"btype");
    lua_gettable(L,10);
    lua_pushliteral(L,"road");
    const int lc214 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc214);
    const int lc215 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc215) {
      
      /* -- the road streches in x direction
       * if( pos.bsizex > pos.bsizez ) then */
      enum { lc216 = 19 };
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,10);
      lua_pushliteral(L,"bsizex");
      lua_gettable(L,10);
      const int lc217 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc217);
      const int lc218 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc218) {
        
        /* sizex = 3 */
        lua_pushnumber(L,3);
        lua_replace(L,13);
        assert(lua_gettop(L) == 19);
        
        /* -- start with a road of length 3
         * sizez = 2 */
        lua_pushnumber(L,2);
        lua_replace(L,14);
        assert(lua_gettop(L) == 19);
        
        /* vx    = -1 */
        lua_pushnumber(L,-1);
        lua_replace(L,16);
        assert(lua_gettop(L) == 19);
        
        /* vz    = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,17);
        assert(lua_gettop(L) == 19);
        
        /* vsx   = 1 */
        lua_pushnumber(L,1);
        lua_replace(L,18);
        assert(lua_gettop(L) == 19);
        
        /* vsz   = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,19);
        assert(lua_gettop(L) == 19);
        
        /* x     = pos.x - sizex */
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lc_sub(L,-1,13);
        lua_remove(L,-2);
        lua_replace(L,11);
        assert(lua_gettop(L) == 19);
        
        /* z     = pos.z + math.floor((pos.bsizez-2)/2) */
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"floor");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"bsizez");
        lua_gettable(L,10);
        lua_pushnumber(L,2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,12);
        assert(lua_gettop(L) == 19);
        
        /* -- aim for the middle of the road
         * orientation = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,15);
        assert(lua_gettop(L) == 19);
        
        /* -- if it is not possible to prolong the road at one end, then try the other
         * if( not( placeable( x, z, sizex, sizez, bpos,       false, nil))) then */
        enum { lc219 = 19 };
        lc_getupvalue(L,lua_upvalueindex(1),5,5);
        lua_pushvalue(L,11);
        lua_pushvalue(L,12);
        lua_pushvalue(L,13);
        lua_pushvalue(L,14);
        lua_pushvalue(L,3);
        lua_pushboolean(L,0);
        lua_pushnil(L);
        lua_call(L,7,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc220 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc220) {
          
          /* x = pos.x + pos.bsizex */
          lua_pushliteral(L,"x");
          lua_gettable(L,10);
          lua_pushliteral(L,"bsizex");
          lua_gettable(L,10);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,11);
          assert(lua_gettop(L) == 19);
          
          /* vx = 0 */
          lua_pushnumber(L,0);
          lua_replace(L,16);
          assert(lua_gettop(L) == 19);
          
          /* orientation = 2 */
          lua_pushnumber(L,2);
          lua_replace(L,15);
          assert(lua_gettop(L) == 19);
        }
        lua_settop(L,lc219);
        assert(lua_gettop(L) == 19);
      }
      else {
        
        /* else
         * sizex = 2 */
        lua_pushnumber(L,2);
        lua_replace(L,13);
        assert(lua_gettop(L) == 19);
        
        /* sizez = 3 */
        lua_pushnumber(L,3);
        lua_replace(L,14);
        assert(lua_gettop(L) == 19);
        
        /* vx    = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,16);
        assert(lua_gettop(L) == 19);
        
        /* vz = -1 */
        lua_pushnumber(L,-1);
        lua_replace(L,17);
        assert(lua_gettop(L) == 19);
        
        /* vsx   = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,18);
        assert(lua_gettop(L) == 19);
        
        /* vsz   = 1 */
        lua_pushnumber(L,1);
        lua_replace(L,19);
        assert(lua_gettop(L) == 19);
        
        /* x     = pos.x + math.floor((pos.bsizex-2)/2) */
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"floor");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"bsizex");
        lua_gettable(L,10);
        lua_pushnumber(L,2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,11);
        assert(lua_gettop(L) == 19);
        
        /* -- aim for the middle of the road
         * z     = pos.z - sizez */
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
        lc_sub(L,-1,14);
        lua_remove(L,-2);
        lua_replace(L,12);
        assert(lua_gettop(L) == 19);
        
        /* orientation = 1 */
        lua_pushnumber(L,1);
        lua_replace(L,15);
        assert(lua_gettop(L) == 19);
        
        /* if( not( placeable( x, z, sizex, sizez, bpos,       false, nil))) then */
        enum { lc221 = 19 };
        lc_getupvalue(L,lua_upvalueindex(1),5,5);
        lua_pushvalue(L,11);
        lua_pushvalue(L,12);
        lua_pushvalue(L,13);
        lua_pushvalue(L,14);
        lua_pushvalue(L,3);
        lua_pushboolean(L,0);
        lua_pushnil(L);
        lua_call(L,7,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc222 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc222) {
          
          /* z = pos.z + pos.bsizez */
          lua_pushliteral(L,"z");
          lua_gettable(L,10);
          lua_pushliteral(L,"bsizez");
          lua_gettable(L,10);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,12);
          assert(lua_gettop(L) == 19);
          
          /* vz = 0 */
          lua_pushnumber(L,0);
          lua_replace(L,17);
          assert(lua_gettop(L) == 19);
          
          /* orientation = 3 */
          lua_pushnumber(L,3);
          lua_replace(L,15);
          assert(lua_gettop(L) == 19);
        }
        lua_settop(L,lc221);
        assert(lua_gettop(L) == 19);
      }
      lua_settop(L,lc216);
      assert(lua_gettop(L) == 19);
    }
    else {
      
      /* else
       * if(     pos.o == 0 ) then */
      enum { lc223 = 19 };
      lua_pushliteral(L,"o");
      lua_gettable(L,10);
      lua_pushnumber(L,0);
      const int lc224 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc224);
      const int lc225 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc225) {
        
        /* x = pos.x-pos.side */
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lua_pushliteral(L,"side");
        lua_gettable(L,10);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,11);
        assert(lua_gettop(L) == 19);
        
        /* z = pos.z-2 */
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
        lua_pushnumber(L,2);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,12);
        assert(lua_gettop(L) == 19);
        
        /* sizex = pos.bsizex+1 */
        lua_pushliteral(L,"bsizex");
        lua_gettable(L,10);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,13);
        assert(lua_gettop(L) == 19);
        
        /* sizez = 2 */
        lua_pushnumber(L,2);
        lua_replace(L,14);
        assert(lua_gettop(L) == 19);
        
        /* vx = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,16);
        assert(lua_gettop(L) == 19);
        
        /* vz = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,17);
        assert(lua_gettop(L) == 19);
        
        /* vsx = 1 */
        lua_pushnumber(L,1);
        lua_replace(L,18);
        assert(lua_gettop(L) == 19);
        
        /* vsz = 0 */
        lua_pushnumber(L,0);
        lua_replace(L,19);
        assert(lua_gettop(L) == 19);
      }
      else {
        
        /* elseif( pos.o == 2 ) then */
        enum { lc226 = 19 };
        lua_pushliteral(L,"o");
        lua_gettable(L,10);
        lua_pushnumber(L,2);
        const int lc227 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc227);
        const int lc228 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc228) {
          
          /* x = pos.x-pos.side+2 */
          lua_pushliteral(L,"x");
          lua_gettable(L,10);
          lua_pushliteral(L,"side");
          lua_gettable(L,10);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,11);
          assert(lua_gettop(L) == 19);
          
          /* z = pos.z-2 */
          lua_pushliteral(L,"z");
          lua_gettable(L,10);
          lua_pushnumber(L,2);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,12);
          assert(lua_gettop(L) == 19);
          
          /* sizex = pos.bsizex+1 */
          lua_pushliteral(L,"bsizex");
          lua_gettable(L,10);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,13);
          assert(lua_gettop(L) == 19);
          
          /* sizez = 2 */
          lua_pushnumber(L,2);
          lua_replace(L,14);
          assert(lua_gettop(L) == 19);
          
          /* vx = -1 */
          lua_pushnumber(L,-1);
          lua_replace(L,16);
          assert(lua_gettop(L) == 19);
          
          /* vz = 0 */
          lua_pushnumber(L,0);
          lua_replace(L,17);
          assert(lua_gettop(L) == 19);
          
          /* vsx = 1 */
          lua_pushnumber(L,1);
          lua_replace(L,18);
          assert(lua_gettop(L) == 19);
          
          /* vsz = 0 */
          lua_pushnumber(L,0);
          lua_replace(L,19);
          assert(lua_gettop(L) == 19);
        }
        else {
          
          /* elseif( pos.o == 1 ) then */
          enum { lc229 = 19 };
          lua_pushliteral(L,"o");
          lua_gettable(L,10);
          lua_pushnumber(L,1);
          const int lc230 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc230);
          const int lc231 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc231) {
            
            /* x = pos.x-2 */
            lua_pushliteral(L,"x");
            lua_gettable(L,10);
            lua_pushnumber(L,2);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,11);
            assert(lua_gettop(L) == 19);
            
            /* z = pos.z-pos.side+2 */
            lua_pushliteral(L,"z");
            lua_gettable(L,10);
            lua_pushliteral(L,"side");
            lua_gettable(L,10);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,2);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,12);
            assert(lua_gettop(L) == 19);
            
            /* sizex = 2 */
            lua_pushnumber(L,2);
            lua_replace(L,13);
            assert(lua_gettop(L) == 19);
            
            /* sizez = pos.bsizez+1 */
            lua_pushliteral(L,"bsizez");
            lua_gettable(L,10);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,14);
            assert(lua_gettop(L) == 19);
            
            /* vx = 0 */
            lua_pushnumber(L,0);
            lua_replace(L,16);
            assert(lua_gettop(L) == 19);
            
            /* vz = -1 */
            lua_pushnumber(L,-1);
            lua_replace(L,17);
            assert(lua_gettop(L) == 19);
            
            /* vsx = 0 */
            lua_pushnumber(L,0);
            lua_replace(L,18);
            assert(lua_gettop(L) == 19);
            
            /* vsz = 1 */
            lua_pushnumber(L,1);
            lua_replace(L,19);
            assert(lua_gettop(L) == 19);
          }
          else {
            
            /* else
             * --if( pos.o == 3 ) then
             * x = pos.x-2 */
            lua_pushliteral(L,"x");
            lua_gettable(L,10);
            lua_pushnumber(L,2);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,11);
            assert(lua_gettop(L) == 19);
            
            /* z = pos.z-pos.side */
            lua_pushliteral(L,"z");
            lua_gettable(L,10);
            lua_pushliteral(L,"side");
            lua_gettable(L,10);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,12);
            assert(lua_gettop(L) == 19);
            
            /* sizex = 2 */
            lua_pushnumber(L,2);
            lua_replace(L,13);
            assert(lua_gettop(L) == 19);
            
            /* sizez = pos.bsizez+1 */
            lua_pushliteral(L,"bsizez");
            lua_gettable(L,10);
            lua_pushnumber(L,1);
            lc_add(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,14);
            assert(lua_gettop(L) == 19);
            
            /* vx = 0 */
            lua_pushnumber(L,0);
            lua_replace(L,16);
            assert(lua_gettop(L) == 19);
            
            /* vz = 0 */
            lua_pushnumber(L,0);
            lua_replace(L,17);
            assert(lua_gettop(L) == 19);
            
            /* vsx = 0 */
            lua_pushnumber(L,0);
            lua_replace(L,18);
            assert(lua_gettop(L) == 19);
            
            /* vsz = 1 */
            lua_pushnumber(L,1);
            lua_replace(L,19);
            assert(lua_gettop(L) == 19);
          }
          lua_settop(L,lc229);
        }
        lua_settop(L,lc226);
      }
      lua_settop(L,lc223);
      assert(lua_gettop(L) == 19);
      
      /* orientation = pos.o */
      lua_pushliteral(L,"o");
      lua_gettable(L,10);
      lua_replace(L,15);
      assert(lua_gettop(L) == 19);
    }
    lua_settop(L,lc213);
    assert(lua_gettop(L) == 19);
    
    /* -- prolong the dirt road by 1
     * while( placeable( x, z, sizex, sizez, bpos,       false, nil)
     * 		   and placeable( x, z, sizex, sizez, dirt_roads, false, orientation)
     *  		   and mg_villages.inside_village_area(x, z, village, vnoise)
     *  		   and mg_villages.inside_village_area(x+sizex, z+sizez, village, vnoise)) do */
    enum { lc232 = 19 };
    while (1) {
      lc_getupvalue(L,lua_upvalueindex(1),5,5);
      lua_pushvalue(L,11);
      lua_pushvalue(L,12);
      lua_pushvalue(L,13);
      lua_pushvalue(L,14);
      lua_pushvalue(L,3);
      lua_pushboolean(L,0);
      lua_pushnil(L);
      lua_call(L,7,1);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),5,5);
        lua_pushvalue(L,11);
        lua_pushvalue(L,12);
        lua_pushvalue(L,13);
        lua_pushvalue(L,14);
        lua_pushvalue(L,5);
        lua_pushboolean(L,0);
        lua_pushvalue(L,15);
        lua_call(L,7,1);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,11);
        lua_pushvalue(L,12);
        lua_pushvalue(L,1);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,11,13);
        lc_add(L,12,14);
        lua_pushvalue(L,1);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
      }
      if (!(lua_toboolean(L,-1))) {
        break;
      }
      lua_pop(L,1);
      
      /* sizex = sizex + vsx */
      lc_add(L,13,18);
      lua_replace(L,13);
      assert(lua_gettop(L) == 19);
      
      /* sizez = sizez + vsz */
      lc_add(L,14,19);
      lua_replace(L,14);
      assert(lua_gettop(L) == 19);
      
      /* x     = x + vx */
      lc_add(L,11,16);
      lua_replace(L,11);
      assert(lua_gettop(L) == 19);
      
      /* z     = z + vz */
      lc_add(L,12,17);
      lua_replace(L,12);
      assert(lua_gettop(L) == 19);
    }
    lua_settop(L,lc232);
    assert(lua_gettop(L) == 19);
    
    /* -- the dirt road may exceed the village boundaries slightly, but it may not interfere with other buildings
     * if(   not( placeable( x, z, sizex, sizez, bpos,       false, nil))
     * 		   or not( placeable( x, z, sizex, sizez, dirt_roads, false, orientation))) then */
    enum { lc233 = 19 };
    lc_getupvalue(L,lua_upvalueindex(1),5,5);
    lua_pushvalue(L,11);
    lua_pushvalue(L,12);
    lua_pushvalue(L,13);
    lua_pushvalue(L,14);
    lua_pushvalue(L,3);
    lua_pushboolean(L,0);
    lua_pushnil(L);
    lua_call(L,7,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),5,5);
      lua_pushvalue(L,11);
      lua_pushvalue(L,12);
      lua_pushvalue(L,13);
      lua_pushvalue(L,14);
      lua_pushvalue(L,5);
      lua_pushboolean(L,0);
      lua_pushvalue(L,15);
      lua_call(L,7,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc234 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc234) {
      
      /* sizex = sizex - vsx */
      lc_sub(L,13,18);
      lua_replace(L,13);
      assert(lua_gettop(L) == 19);
      
      /* sizez = sizez - vsz */
      lc_sub(L,14,19);
      lua_replace(L,14);
      assert(lua_gettop(L) == 19);
      
      /* x     = x - vx */
      lc_sub(L,11,16);
      lua_replace(L,11);
      assert(lua_gettop(L) == 19);
      
      /* z     = z - vz */
      lc_sub(L,12,17);
      lua_replace(L,12);
      assert(lua_gettop(L) == 19);
    }
    lua_settop(L,lc233);
    assert(lua_gettop(L) == 19);
    
    /* if(    placeable( x, z, sizex, sizez, bpos,       false, nil)  
     * 		   and placeable( x, z, sizex, sizez, dirt_roads, false, orientation)) then */
    enum { lc235 = 19 };
    lc_getupvalue(L,lua_upvalueindex(1),5,5);
    lua_pushvalue(L,11);
    lua_pushvalue(L,12);
    lua_pushvalue(L,13);
    lua_pushvalue(L,14);
    lua_pushvalue(L,3);
    lua_pushboolean(L,0);
    lua_pushnil(L);
    lua_call(L,7,1);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),5,5);
      lua_pushvalue(L,11);
      lua_pushvalue(L,12);
      lua_pushvalue(L,13);
      lua_pushvalue(L,14);
      lua_pushvalue(L,5);
      lua_pushboolean(L,0);
      lua_pushvalue(L,15);
      lua_call(L,7,1);
    }
    const int lc236 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc236) {
      
      /* dirt_roads[#dirt_roads+1] = {x=x, y=village.vh, z=z, btype="dirt_road", bsizex=sizex, bsizez=sizez, brotate = 0, o=orientation} */
      lua_createtable(L,0,8);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,11);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"vh");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushvalue(L,12);
      lua_rawset(L,-3);
      lua_pushliteral(L,"btype");
      lua_pushliteral(L,"dirt_road");
      lua_rawset(L,-3);
      lua_pushliteral(L,"bsizex");
      lua_pushvalue(L,13);
      lua_rawset(L,-3);
      lua_pushliteral(L,"bsizez");
      lua_pushvalue(L,14);
      lua_rawset(L,-3);
      lua_pushliteral(L,"brotate");
      lua_pushnumber(L,0);
      lua_rawset(L,-3);
      lua_pushliteral(L,"o");
      lua_pushvalue(L,15);
      lua_rawset(L,-3);
      const double lc237 = lua_objlen(L,5);
      lua_pushnumber(L,lc237);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,5);
      assert(lua_gettop(L) == 19);
    }
    lua_settop(L,lc235);
    assert(lua_gettop(L) == 19);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,11);
  }
  lua_settop(L,lc212);
  assert(lua_gettop(L) == 5);
  
  /* return dirt_roads */
  lua_pushvalue(L,5);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: pos_far_buildings
 * function(x, z, l) */
static int lcf1_pos_far_buildings (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* for _, a in ipairs(l) do
   * internal: local f, s, var = explist */
  enum { lc239 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 7
     * internal: local a with idx 8 */
    
    
    /* if a.x - MIN_DIST <= x and x <= a.x + a.bsizex + MIN_DIST and
     * 		   a.z - MIN_DIST <= z and z <= a.z + a.bsizez + MIN_DIST then */
    enum { lc240 = 8 };
    lua_pushliteral(L,"x");
    lua_gettable(L,8);
    lc_getupvalue(L,lua_upvalueindex(1),0,11);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    const int lc241 = lc_le(L,-1,1);
    lua_pop(L,1);
    lua_pushboolean(L,lc241);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"x");
      lua_gettable(L,8);
      lua_pushliteral(L,"bsizex");
      lua_gettable(L,8);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,11);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      const int lc242 = lc_le(L,1,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc242);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"z");
      lua_gettable(L,8);
      lc_getupvalue(L,lua_upvalueindex(1),0,11);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      const int lc243 = lc_le(L,-1,2);
      lua_pop(L,1);
      lua_pushboolean(L,lc243);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"z");
      lua_gettable(L,8);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,8);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),0,11);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      const int lc244 = lc_le(L,2,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc244);
    }
    const int lc245 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc245) {
      
      /* return false */
      lua_pushboolean(L,0);
      return 1;
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc240);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc239);
  assert(lua_gettop(L) == 3);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: generate_walls
 * function(bpos, data, a, minp, maxp, vh, vx, vz, vs, vnoise) */
static int lcf1_generate_walls (lua_State * L) {
  lua_checkstack(L,23);
  enum { lc_nformalargs = 10 };
  lua_settop(L,10);
  
  /* for x = minp.x, maxp.x do */
  lua_pushliteral(L,"x");
  lua_gettable(L,4);
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc246_var = lua_tonumber(L,-2);
  const double lc247_limit = lua_tonumber(L,-1);
  const double lc248_step = 1;
  lua_pop(L,2);
  enum { lc249 = 10 };
  while ((((lc248_step > 0) && (lc246_var <= lc247_limit)) || ((lc248_step <= 0) && (lc246_var >= lc247_limit)))) {
    
    /* internal: local x at index 11 */
    lua_pushnumber(L,lc246_var);
    
    /* for z = minp.z, maxp.z do */
    lua_pushliteral(L,"z");
    lua_gettable(L,4);
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc250_var = lua_tonumber(L,-2);
    const double lc251_limit = lua_tonumber(L,-1);
    const double lc252_step = 1;
    lua_pop(L,2);
    enum { lc253 = 11 };
    while ((((lc252_step > 0) && (lc250_var <= lc251_limit)) || ((lc252_step <= 0) && (lc250_var >= lc251_limit)))) {
      
      /* internal: local z at index 12 */
      lua_pushnumber(L,lc250_var);
      
      /* local xx = (vnoise:get2d({x=x, y=z})-2)*20+(40/(vs*vs))*((x-vx)*(x-vx)+(z-vz)*(z-vz)) */
      lua_pushvalue(L,10);
      lua_pushliteral(L,"get2d");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"x");
      lua_pushvalue(L,11);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushvalue(L,12);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_pushnumber(L,2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,20);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,40);
      lc_mul(L,9,9);
      lc_div(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,11,7);
      lc_sub(L,11,7);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_sub(L,12,8);
      lc_sub(L,12,8);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 13);
      
      /* if xx>=40 and xx <= 44 then */
      enum { lc254 = 13 };
      lua_pushnumber(L,40);
      const int lc255 = lc_le(L,-1,13);
      lua_pop(L,1);
      lua_pushboolean(L,lc255);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,44);
        const int lc256 = lc_le(L,13,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc256);
      }
      const int lc257 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc257) {
        
        /* bpos[#bpos+1] = {x=x, z=z, y=vh, btype="wall", bsizex=1, bsizez=1, brotate=0} */
        lua_createtable(L,0,7);
        lua_pushliteral(L,"x");
        lua_pushvalue(L,11);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushvalue(L,12);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushvalue(L,6);
        lua_rawset(L,-3);
        lua_pushliteral(L,"btype");
        lua_pushliteral(L,"wall");
        lua_rawset(L,-3);
        lua_pushliteral(L,"bsizex");
        lua_pushnumber(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"bsizez");
        lua_pushnumber(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"brotate");
        lua_pushnumber(L,0);
        lua_rawset(L,-3);
        const double lc258 = lua_objlen(L,1);
        lua_pushnumber(L,lc258);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 13);
      }
      lua_settop(L,lc254);
      assert(lua_gettop(L) == 13);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc250_var += lc252_step;
    }
    lua_settop(L,lc253);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc246_var += lc248_step;
  }
  lua_settop(L,lc249);
  assert(lua_gettop(L) == 10);
  return 0;
}


/* name: mg_villages.generate_village
 * function(village, vnoise) */
static int lcf1_mg_villages_generate_village (lua_State * L) {
  lua_checkstack(L,30);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local vx, vz, vs, vh = village.vx, village.vz, village.vs, village.vh */
  lua_pushliteral(L,"vx");
  lua_gettable(L,1);
  lua_pushliteral(L,"vz");
  lua_gettable(L,1);
  lua_pushliteral(L,"vs");
  lua_gettable(L,1);
  lua_pushliteral(L,"vh");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 6);
  
  /* local village_type = village.village_type */
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 7);
  
  /* local seed = mg_villages.get_bseed({x=vx, z=vz}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_bseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* local pr_village = PseudoRandom(seed) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  lua_pushvalue(L,8);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* -- generate a name for the village
   * village.name = namegen.generate_village_name_with_prefix( pr_village, village ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"namegen");
  lua_pushliteral(L,"generate_village_name_with_prefix");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,9);
  lua_pushvalue(L,1);
  lua_call(L,2,1);
  lua_pushliteral(L,"name");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 9);
  
  /* -- only generate a new village if the data is not already stored
   * -- (the algorithm is fast, but village types and houses which are available may change later on,
   * -- and that might easily cause chaos if the village is generated again with diffrent input)
   * if( village.to_add_data and village.to_add_data.bpos and village.to_add_data.replacements and village.to_add_data.plantlist) then */
  enum { lc259 = 9 };
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,1);
    lua_pushliteral(L,"bpos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,1);
    lua_pushliteral(L,"replacements");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,1);
    lua_pushliteral(L,"plantlist");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc260 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc260) {
    
    /* --print('VILLAGE GENREATION: USING ALREADY GENERATED VILLAGE: Nr. '..tostring( village.nr )); 
     * return; */
    return 0;
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc259);
  assert(lua_gettop(L) == 9);
  
  /* -- in the case of medieval villages, we later on want to add wheat fields with dirt roads; 1 wide dirt roads look odd
   * local space_between_buildings = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 10);
  
  /* if( mg_villages.village_type_data[ village_type ] and mg_villages.village_type_data[ village_type ].space_between_buildings) then */
  enum { lc261 = 10 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,7);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,7);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"space_between_buildings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc262 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc262) {
    
    /* space_between_buildings = mg_villages.village_type_data[ village_type ].space_between_buildings */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"village_type_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,7);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"space_between_buildings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,10);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc261);
  assert(lua_gettop(L) == 10);
  
  /* local bpos = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 11);
  
  /* local dirt_roads = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 12);
  
  /* local secondary_dirt_roads = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 13);
  
  /* if( village.to_add_data and village.to_add_data.bpos ) then */
  enum { lc263 = 13 };
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,1);
    lua_pushliteral(L,"bpos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc264 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc264) {
    
    /* -- If it is a single building instead of a full village, then village.to_add_data.bpos will
     * -- already have been generated (but not the replacements and other data structures which still need to be generated here)
     * bpos = village.to_add_data.bpos */
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,1);
    lua_pushliteral(L,"bpos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,11);
    assert(lua_gettop(L) == 13);
  }
  else {
    
    /* else
     * -- actually generate the village structure
     * bpos = generate_bpos( village, pr_village, vnoise, space_between_buildings) */
    lc_getupvalue(L,lua_upvalueindex(1),2,9);
    lua_pushvalue(L,1);
    lua_pushvalue(L,9);
    lua_pushvalue(L,2);
    lua_pushvalue(L,10);
    lua_call(L,4,1);
    lua_replace(L,11);
    assert(lua_gettop(L) == 13);
    
    /* -- if there is enough space, add dirt roads between the buildings (those will later be prolonged so that they reach the fields)
     * -- only add dirt roads if there are at least 3 buildings in the village
     * if( space_between_buildings >= 2 and village_type == 'medieval' and #bpos>3) then */
    enum { lc265 = 13 };
    lua_pushnumber(L,2);
    const int lc266 = lc_le(L,-1,10);
    lua_pop(L,1);
    lua_pushboolean(L,lc266);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,7);
      lua_pushliteral(L,"medieval");
      const int lc267 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc267);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,3);
      const double lc268 = lua_objlen(L,11);
      lua_pushnumber(L,lc268);
      const int lc269 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc269);
    }
    const int lc270 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc270) {
      
      /* secondary_dirt_roads = "dirt_road" */
      lua_pushliteral(L,"dirt_road");
      lua_replace(L,13);
      assert(lua_gettop(L) == 13);
    }
    lua_settop(L,lc265);
    assert(lua_gettop(L) == 13);
    
    /* dirt_roads = generate_dirt_roads( village, vnoise, bpos, secondary_dirt_roads ) */
    lc_getupvalue(L,lua_upvalueindex(1),1,10);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushvalue(L,11);
    lua_pushvalue(L,13);
    lua_call(L,4,1);
    lua_replace(L,12);
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc263);
  assert(lua_gettop(L) == 13);
  
  /* -- set fruits for all buildings in the village that need it - regardless weather they will be spawned
   * -- now or later; after the first call to this function here, the village data will be final
   * for _, pos in ipairs( bpos ) do
   * internal: local f, s, var = explist */
  enum { lc271 = 13 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,11);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 17
     * internal: local pos with idx 18 */
    
    
    /* local binfo = mg_villages.BUILDINGS[pos.btype] */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"btype");
    lua_gettable(L,18);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 19);
    
    /* if( binfo.farming_plus and binfo.farming_plus == 1 and mg_villages.fruit_list and not pos.furit) then */
    enum { lc272 = 19 };
    lua_pushliteral(L,"farming_plus");
    lua_gettable(L,19);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"farming_plus");
      lua_gettable(L,19);
      lua_pushnumber(L,1);
      const int lc273 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc273);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"fruit_list");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"furit");
      lua_gettable(L,18);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc274 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc274) {
      
      /* pos.fruit = mg_villages.fruit_list[ pr_village:next( 1, #mg_villages.fruit_list )] */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"fruit_list");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_pushliteral(L,"next");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushnumber(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"fruit_list");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc275 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc275);
      lua_call(L,3,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"fruit");
      lua_insert(L,-2);
      lua_settable(L,18);
      assert(lua_gettop(L) == 19);
    }
    lua_settop(L,lc272);
    assert(lua_gettop(L) == 19);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc271);
  assert(lua_gettop(L) == 13);
  
  /* -- a changing replacement list would also be pretty confusing
   * local p = PseudoRandom(seed) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  lua_pushvalue(L,8);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 14);
  
  /* -- if the village is new, replacement_list is nil and a new replacement list will be created
   * local replacements = mg_villages.get_replacement_table( village.village_type, p, nil ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_replacement_table");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  lua_pushvalue(L,14);
  lua_pushnil(L);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 15);
  
  /* local sapling_id = mg_villages.get_content_id_replaced( 'default:sapling', replacements ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_content_id_replaced");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:sapling");
  lua_pushvalue(L,15);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 16);
  
  /* -- 1/sapling_p = probability of a sapling beeing placed
   * local sapling_p  = 25 */
  lua_pushnumber(L,25);
  assert(lua_gettop(L) == 17);
  
  /* if( mg_villages.sapling_probability[ sapling_id ] ) then */
  enum { lc276 = 17 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"sapling_probability");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,16);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc277 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc277) {
    
    /* sapling_p = mg_villages.sapling_probability[ sapling_id ] */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,16);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,17);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc276);
  assert(lua_gettop(L) == 17);
  
  /* local c_plant = mg_villages.get_content_id_replaced( mg_villages.village_type_data[ village.village_type ].plant_type, replacements) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_content_id_replaced");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"plant_type");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,15);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 18);
  
  /* local plantlist = {
   * 		{ id=sapling_id, p=sapling_p * mg_villages.village_type_data[ village.village_type ].sapling_divisor }, -- only few trees
   * 		{ id=c_plant,    p=            mg_villages.village_type_data[ village.village_type ].plant_frequency }} */
  lua_createtable(L,2,0);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"id");
  lua_pushvalue(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"p");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sapling_divisor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_mul(L,17,-1);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"id");
  lua_pushvalue(L,18);
  lua_rawset(L,-3);
  lua_pushliteral(L,"p");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"village_type");
  lua_gettable(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"plant_frequency");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  assert(lua_gettop(L) == 19);
  
  /* if( village.is_single_house and plantlist and #plantlist>0 ) then */
  enum { lc278 = 19 };
  lua_pushliteral(L,"is_single_house");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,19);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
    const double lc279 = lua_objlen(L,19);
    lua_pushnumber(L,lc279);
    const int lc280 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc280);
  }
  const int lc281 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc281) {
    
    /* local c_grass = mg_villages.get_content_id_replaced( 'default:grass_5', replacements) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"get_content_id_replaced");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:grass_5");
    lua_pushvalue(L,15);
    lua_call(L,2,1);
    assert(lua_gettop(L) == 20);
    
    /* plantlist[2] = { id=c_grass,    p=10        } */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"id");
    lua_pushvalue(L,20);
    lua_rawset(L,-3);
    lua_pushliteral(L,"p");
    lua_pushnumber(L,10);
    lua_rawset(L,-3);
    lua_pushnumber(L,2);
    lua_insert(L,-2);
    lua_settable(L,19);
    assert(lua_gettop(L) == 20);
    
    /* -- reduce the amount of plants grown so that the area stands out less from the sourroundings
     * plantlist[2].p = plantlist[2].p*3 */
    lua_pushnumber(L,2);
    lua_gettable(L,19);
    lua_pushliteral(L,"p");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,3);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lua_gettable(L,19);
    lua_insert(L,-2);
    lua_pushliteral(L,"p");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 20);
  }
  lua_settop(L,lc278);
  assert(lua_gettop(L) == 19);
  
  /* -- store the generated data in the village table 
   * village.to_add_data               = {} */
  lua_newtable(L);
  lua_pushliteral(L,"to_add_data");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 19);
  
  /* village.to_add_data.bpos          = bpos */
  lua_pushvalue(L,11);
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"bpos");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 19);
  
  /* village.to_add_data.replacements  = replacements.list */
  lua_pushliteral(L,"list");
  lua_gettable(L,15);
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"replacements");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 19);
  
  /* village.to_add_data.dirt_roads    = dirt_roads */
  lua_pushvalue(L,12);
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"dirt_roads");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 19);
  
  /* village.to_add_data.plantlist     = plantlist */
  lua_pushvalue(L,19);
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"plantlist");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 19);
  return 0;
}


/* name: mg_villages.count_inhabitated_buildings
 * function(village) */
static int lcf1_mg_villages_count_inhabitated_buildings (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local bpos             = village.to_add_data.bpos */
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 2);
  
  /* -- count the buildings
   * local anz_buildings = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 3);
  
  /* for i, pos in ipairs(bpos) do
   * internal: local f, s, var = explist */
  enum { lc282 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 7
     * internal: local pos with idx 8 */
    
    
    /* if( pos.btype and not(pos.btype == 'road' )) then */
    enum { lc283 = 8 };
    lua_pushliteral(L,"btype");
    lua_gettable(L,8);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"btype");
      lua_gettable(L,8);
      lua_pushliteral(L,"road");
      const int lc284 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc284);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc285 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc285) {
      
      /* local binfo = mg_villages.BUILDINGS[pos.btype] */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"btype");
      lua_gettable(L,8);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 9);
      
      /* -- count buildings which can house inhabitants as well as those requiring workers
       * if( binfo and binfo.inh and binfo.inh ~= 0 ) then */
      enum { lc286 = 9 };
      lua_pushvalue(L,9);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"inh");
        lua_gettable(L,9);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"inh");
        lua_gettable(L,9);
        lua_pushnumber(L,0);
        const int lc287 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc287);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc288 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc288) {
        
        /* anz_buildings = anz_buildings + 1 */
        lua_pushnumber(L,1);
        lc_add(L,3,-1);
        lua_remove(L,-2);
        lua_replace(L,3);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc286);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc283);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc282);
  assert(lua_gettop(L) == 3);
  
  /* return anz_buildings */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: mg_villages.house_in_one_mapchunk
 * function( minp, mapchunk_size, vnoise) */
static int lcf1_mg_villages_house_in_one_mapchunk (lua_State * L) {
  lua_checkstack(L,32);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local pr = PseudoRandom(mg_villages.get_bseed(minp)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc289 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_bseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc289),1);
  assert(lua_gettop(L) == 4);
  
  /* -- only each mg_villages.INVERSE_HOUSE_DENSITY th mapchunk gets a building
   * if( pr:next(1,mg_villages.INVERSE_HOUSE_DENSITY) > 1 ) then */
  enum { lc290 = 4 };
  lua_pushnumber(L,1);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"INVERSE_HOUSE_DENSITY");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  const int lc291 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc291);
  const int lc292 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc292) {
    
    /* return {} */
    lua_newtable(L);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc290);
  assert(lua_gettop(L) == 4);
  
  /* -- pseudorandom orientation
   * local orient1 = pr:next(0,3) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushnumber(L,0);
  lua_pushnumber(L,3);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 5);
  
  /* -- determine which kind of building to use
   * -- TODO: select only types fitting to that particular place
   * -- TODO: select only types that exist
   * -- the village type is "single" here - since not all houses which might fit into a village might do for lone standing houses
   * -- (i.e. church, forge, wagon, ..)
   * local btype, rotation, bsizex, bsizez, mirror = choose_building_rot({}, pr, orient1, 'single') */
  lc_getupvalue(L,lua_upvalueindex(1),7,4);
  lua_newtable(L);
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushliteral(L,"single");
  lua_call(L,4,5);
  assert(lua_gettop(L) == 10);
  
  /* if( not( bsizex )) then */
  enum { lc293 = 10 };
  lua_pushboolean(L,!(lua_toboolean(L,8)));
  const int lc294 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc294) {
    
    /* mg_villages.print( mg_villages.DEBUG_LEVEL_INFO, 'FAILURE to generate a building.') */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"DEBUG_LEVEL_INFO");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"FAILURE to generate a building.");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 10);
    
    /* btype, rotation, bsizex, bsizez, mirror = choose_building_rot({}, pr, orient1, 'nore') */
    lc_getupvalue(L,lua_upvalueindex(1),7,4);
    lua_newtable(L);
    lua_pushvalue(L,4);
    lua_pushvalue(L,5);
    lua_pushliteral(L,"nore");
    lua_call(L,4,5);
    lua_replace(L,10);
    lua_replace(L,9);
    lua_replace(L,8);
    lua_replace(L,7);
    lua_replace(L,6);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc293);
  assert(lua_gettop(L) == 10);
  
  /* -- if no building was found, give up
   * if( not( bsizex ) or not(mg_villages.BUILDINGS[ btype ].weight)) then */
  enum { lc295 = 10 };
  lua_pushboolean(L,!(lua_toboolean(L,8)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"weight");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc296 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc296) {
    
    /* return {} */
    lua_newtable(L);
    return 1;
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc295);
  assert(lua_gettop(L) == 10);
  
  /* local village = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 11);
  
  /* -- store that this is not a village but a lone house
   * village.is_single_house = 1 */
  lua_pushnumber(L,1);
  lua_pushliteral(L,"is_single_house");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* -- village height will be set to a value fitting the terrain later on
   * village.vh = 10 */
  lua_pushnumber(L,10);
  lua_pushliteral(L,"vh");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* -- this will force re-calculation of height
   * village.vs = 5 */
  lua_pushnumber(L,5);
  lua_pushliteral(L,"vs");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* -- find out the real village type of this house (which is necessary for the replacements);
   * -- the "single" type only indicates that this building may be used for one-house-villages such as this one
   * for k, _ in pairs( mg_villages.BUILDINGS[ btype ].weight ) do
   * internal: local f, s, var = explist */
  enum { lc297 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,6);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"weight");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local k with idx 15
     * internal: local _ with idx 16 */
    
    
    /* if( k and k ~= 'single' ) then */
    enum { lc298 = 16 };
    lua_pushvalue(L,15);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"single");
      const int lc299 = lua_equal(L,15,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc299);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc300 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc300) {
      
      /* village.village_type = k */
      lua_pushvalue(L,15);
      lua_pushliteral(L,"village_type");
      lua_insert(L,-2);
      lua_settable(L,11);
      assert(lua_gettop(L) == 16);
    }
    lua_settop(L,lc298);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc297);
  assert(lua_gettop(L) == 11);
  
  /* -- taken from paramats terrain blending code for single houses
   * local FFAPROP = 0.5 */
  lua_pushnumber(L,0.5);
  assert(lua_gettop(L) == 12);
  
  /* -- front flat area proportion of dimension
   * local xdim, zdim */
  lua_settop(L,(lua_gettop(L) + 2));
  assert(lua_gettop(L) == 14);
  
  /* -- dimensions of house plus front flat area
   * if rotation == 0 or rotation == 2 then */
  enum { lc301 = 14 };
  lua_pushvalue(L,7);
  lua_pushnumber(L,0);
  const int lc302 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc302);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushnumber(L,2);
    const int lc303 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc303);
  }
  const int lc304 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc304) {
    
    /* xdim = bsizex */
    lua_pushvalue(L,8);
    lua_replace(L,13);
    assert(lua_gettop(L) == 14);
    
    /* zdim = bsizez + math.floor(FFAPROP * bsizez) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_mul(L,12,9);
    lua_call(L,1,1);
    lc_add(L,9,-1);
    lua_remove(L,-2);
    lua_replace(L,14);
    assert(lua_gettop(L) == 14);
  }
  else {
    
    /* else
     * xdim = bsizex + math.floor(FFAPROP * bsizex) */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_mul(L,12,8);
    lua_call(L,1,1);
    lc_add(L,8,-1);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 14);
    
    /* zdim = bsizez */
    lua_pushvalue(L,9);
    lua_replace(L,14);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc301);
  assert(lua_gettop(L) == 14);
  
  /* local blenrad = math.floor((math.max(xdim, zdim) + 16) / 2)+2 */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,13);
  lua_pushvalue(L,14);
  lua_call(L,2,1);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushnumber(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 15);
  
  /* -- radius of blend area
   * --[[
   * 	if( blenrad >= math.ceil(mapchunk_size/2)-2 ) then
   * 		blenrad = math.floor(mapchunk_size/2)-2;
   * 	end
   * 	local blencenx = pr:next(minp.x + blenrad, minp.x + mapchunk_size - blenrad - 1) -- blend area centre point
   * 	local blencenz = pr:next(minp.z + blenrad, minp.z + mapchunk_size - blenrad - 1)
   * --]]
   * local blencenx = pr:next(minp.x, minp.x + mapchunk_size - 1) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 16);
  
  /* -- blend area centre point
   * local blencenz = pr:next(minp.z, minp.z + mapchunk_size - 1) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"next");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 17);
  
  /* local minx = blencenx - math.ceil(xdim / 2) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"ceil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,13,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_sub(L,16,-1);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 18);
  
  /* -- minimum point of house plus front flat area
   * local minz = blencenz - math.ceil(zdim / 2) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"ceil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,14,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_sub(L,17,-1);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 19);
  
  /* local bx, bz */
  lua_settop(L,(lua_gettop(L) + 2));
  assert(lua_gettop(L) == 21);
  
  /* -- house minimum point
   * if rotation == 2 or rotation == 3 then */
  enum { lc305 = 21 };
  lua_pushvalue(L,7);
  lua_pushnumber(L,2);
  const int lc306 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc306);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushnumber(L,3);
    const int lc307 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc307);
  }
  const int lc308 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc308) {
    
    /* -- N, E
     * bx = minx */
    lua_pushvalue(L,18);
    lua_replace(L,20);
    assert(lua_gettop(L) == 21);
    
    /* bz = minz */
    lua_pushvalue(L,19);
    lua_replace(L,21);
    assert(lua_gettop(L) == 21);
  }
  else {
    
    /* elseif rotation == 1 then */
    enum { lc309 = 21 };
    lua_pushnumber(L,1);
    const int lc310 = lua_equal(L,7,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc310);
    const int lc311 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc311) {
      
      /* -- W
       * bx = minx + math.floor(FFAPROP * bsizex) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"floor");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_mul(L,12,8);
      lua_call(L,1,1);
      lc_add(L,18,-1);
      lua_remove(L,-2);
      lua_replace(L,20);
      assert(lua_gettop(L) == 21);
      
      /* bz = minz */
      lua_pushvalue(L,19);
      lua_replace(L,21);
      assert(lua_gettop(L) == 21);
    }
    else {
      
      /* else
       * -- rotation = 2, S
       * bx = minx */
      lua_pushvalue(L,18);
      lua_replace(L,20);
      assert(lua_gettop(L) == 21);
      
      /* bz = minz + math.floor(FFAPROP * bsizez) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"floor");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_mul(L,12,9);
      lua_call(L,1,1);
      lc_add(L,19,-1);
      lua_remove(L,-2);
      lua_replace(L,21);
      assert(lua_gettop(L) == 21);
    }
    lua_settop(L,lc309);
  }
  lua_settop(L,lc305);
  assert(lua_gettop(L) == 21);
  
  /* village.vx = blencenx */
  lua_pushvalue(L,16);
  lua_pushliteral(L,"vx");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 21);
  
  /* village.vz = blencenz */
  lua_pushvalue(L,17);
  lua_pushliteral(L,"vz");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 21);
  
  /* village.vs = blenrad */
  lua_pushvalue(L,15);
  lua_pushliteral(L,"vs");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 21);
  
  /* local village_id = tostring( village.vx )..':'..tostring( village.vz ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushliteral(L,"vx");
  lua_gettable(L,11);
  lua_call(L,1,1);
  lua_pushliteral(L,":");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushliteral(L,"vz");
  lua_gettable(L,11);
  lua_call(L,1,1);
  lua_concat(L,2);
  lua_concat(L,2);
  assert(lua_gettop(L) == 22);
  
  /* -- these values have to be determined once per village; afterwards, they need to be fixed
   * -- if a village has been generated already, it will continue to exist
   * --	if( mg_villages.all_villages[ village_id ] ) then
   * --		return village;
   * --	end
   * if( mg_villages.all_villages  and mg_villages.all_villages[ village_id ] and mg_villages.all_villages[ village_id ].optimal_height) then */
  enum { lc312 = 22 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"optimal_height");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc313 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc313) {
    
    /* village.optimal_height  = mg_villages.all_villages[ village_id ].optimal_height */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"optimal_height");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"optimal_height");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 22);
    
    /* village.vh              = mg_villages.all_villages[ village_id ].optimal_height */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"optimal_height");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"vh");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 22);
    
    /* village.artificial_snow = mg_villages.all_villages[ village_id ].artificial_snow */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,22);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"artificial_snow");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"artificial_snow");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 22);
  }
  lua_settop(L,lc312);
  assert(lua_gettop(L) == 22);
  
  /* village.to_add_data = {} */
  lua_newtable(L);
  lua_pushliteral(L,"to_add_data");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 22);
  
  /* village.to_add_data.bpos = { {x=bx, y=village.vh, z=bz,  btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation, road_nr = 0, side=1, o=orient1, mirror=mirror }} */
  lua_createtable(L,1,0);
  lua_createtable(L,0,11);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,20);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"vh");
  lua_gettable(L,11);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushvalue(L,21);
  lua_rawset(L,-3);
  lua_pushliteral(L,"btype");
  lua_pushvalue(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"bsizex");
  lua_pushvalue(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"bsizez");
  lua_pushvalue(L,9);
  lua_rawset(L,-3);
  lua_pushliteral(L,"brotate");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_pushliteral(L,"road_nr");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"side");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"o");
  lua_pushvalue(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"mirror");
  lua_pushvalue(L,10);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,11);
  lua_insert(L,-2);
  lua_pushliteral(L,"bpos");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 22);
  
  /* return village */
  lua_pushvalue(L,11);
  return 1;
  assert(lua_gettop(L) == 22);
}


/* name: mg_villages.house_in_mapchunk_mark_intersection
 * function( villages, c, vnoise) */
static int lcf1_mg_villages_house_in_mapchunk_mark_intersection (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- c: candidate for a new one-house-village
   * -- now check if this village can be placed here or if it intersects with another village in any critical manner;
   * -- the village area may intersect (=unproblematic; may even look nice), but the actual building must not be inside another village
   * -- exclude misconfigured villages
   * if( not( c ) or not( c.to_add_data )) then */
  enum { lc314 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc315 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc315) {
    
    /* --print('WRONG DATA: '..minetest.serialize( c ));
     * c.areas_intersect = 1 */
    lua_pushnumber(L,1);
    lua_pushliteral(L,"areas_intersect");
    lua_insert(L,-2);
    lua_settable(L,2);
    assert(lua_gettop(L) == 3);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc314);
  assert(lua_gettop(L) == 3);
  
  /* local bx     = c.to_add_data.bpos[1].x */
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,2);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* local bz     = c.to_add_data.bpos[1].z */
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,2);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* local bsizex = c.to_add_data.bpos[1].bsizex */
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,2);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"bsizex");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 6);
  
  /* local bsizez = c.to_add_data.bpos[1].bsizez */
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,2);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"bsizez");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 7);
  
  /* -- make sure that the house does not intersect with the area of a village
   * for _,v in ipairs( villages ) do
   * internal: local f, s, var = explist */
  enum { lc316 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 11
     * internal: local v with idx 12 */
    
    
    /* local id = v.vx..':'..v.vz */
    lua_pushliteral(L,"vx");
    lua_gettable(L,12);
    lua_pushliteral(L,":");
    lua_pushliteral(L,"vz");
    lua_gettable(L,12);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 13);
    
    /* if( id and mg_villages.all_villages and mg_villages.all_villages[ id ] ) then */
    enum { lc317 = 13 };
    lua_pushvalue(L,13);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,13);
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc318 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc318) {
      
      /* v = mg_villages.all_villages[ id ] */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,13);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_replace(L,12);
      assert(lua_gettop(L) == 13);
    }
    lua_settop(L,lc317);
    assert(lua_gettop(L) == 13);
    
    /* if( v.vx ~= c.vx and v.vz ~= c.vz ) then */
    enum { lc319 = 13 };
    lua_pushliteral(L,"vx");
    lua_gettable(L,12);
    lua_pushliteral(L,"vx");
    lua_gettable(L,2);
    const int lc320 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc320);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"vz");
      lua_gettable(L,12);
      lua_pushliteral(L,"vz");
      lua_gettable(L,2);
      const int lc321 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc321);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc322 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc322) {
      
      /* local dist = math.sqrt(  ( c.vx - v.vx ) * ( c.vx - v.vx )
       * 			                       + ( c.vz - v.vz ) * ( c.vz - v.vz )) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"sqrt");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"vx");
      lua_gettable(L,2);
      lua_pushliteral(L,"vx");
      lua_gettable(L,12);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"vx");
      lua_gettable(L,2);
      lua_pushliteral(L,"vx");
      lua_gettable(L,12);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"vz");
      lua_gettable(L,2);
      lua_pushliteral(L,"vz");
      lua_gettable(L,12);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"vz");
      lua_gettable(L,2);
      lua_pushliteral(L,"vz");
      lua_gettable(L,12);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 14);
      
      /* if( dist < ( c.vs + v.vs )*1.1 ) then */
      enum { lc323 = 14 };
      lua_pushliteral(L,"vs");
      lua_gettable(L,2);
      lua_pushliteral(L,"vs");
      lua_gettable(L,12);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1.1);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      const int lc324 = lua_lessthan(L,14,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc324);
      const int lc325 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc325) {
        
        /* mg_villages.print( mg_villages.DEBUG_LEVEL_WARNING, 'DROPPING house at '..c.vx..':'..c.vz..' because it is too close to '..v.vx..':'..c.vx) */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"print");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"DEBUG_LEVEL_WARNING");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"DROPPING house at ");
        lua_pushliteral(L,"vx");
        lua_gettable(L,2);
        lua_pushliteral(L,":");
        lua_pushliteral(L,"vz");
        lua_gettable(L,2);
        lua_pushliteral(L," because it is too close to ");
        lua_pushliteral(L,"vx");
        lua_gettable(L,12);
        lua_pushliteral(L,":");
        lua_pushliteral(L,"vx");
        lua_gettable(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 14);
        
        /* c.areas_intersect = 1 */
        lua_pushnumber(L,1);
        lua_pushliteral(L,"areas_intersect");
        lua_insert(L,-2);
        lua_settable(L,2);
        assert(lua_gettop(L) == 14);
        
        /* -- the other village can't be spawned either as we don't know which one will be loaded first
         * if( v.is_single_house ) then */
        enum { lc326 = 14 };
        lua_pushliteral(L,"is_single_house");
        lua_gettable(L,12);
        const int lc327 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc327) {
          
          /* v.areas_intersect = 1 */
          lua_pushnumber(L,1);
          lua_pushliteral(L,"areas_intersect");
          lua_insert(L,-2);
          lua_settable(L,12);
          assert(lua_gettop(L) == 14);
        }
        lua_settop(L,lc326);
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L,lc323);
      assert(lua_gettop(L) == 14);
      
      /* if( not( v.is_single_house ) and
       * 			   ( mg_villages.inside_village_terrain_blend_area( c.vx,       c.vz,        v, vnoise)
       * 			  or mg_villages.inside_village_terrain_blend_area( bx,         bz,          v, vnoise)
       * 			  or mg_villages.inside_village_terrain_blend_area((bx+bsizex), bz,          v, vnoise)
       * 			  or mg_villages.inside_village_terrain_blend_area((bx+bsizex), (bz+bsizez), v, vnoise)
       * 			  or mg_villages.inside_village_terrain_blend_area( bx,         (bz+bsizez), v, vnoise))) then */
      enum { lc328 = 14 };
      lua_pushliteral(L,"is_single_house");
      lua_gettable(L,12);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"inside_village_terrain_blend_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"vx");
        lua_gettable(L,2);
        lua_pushliteral(L,"vz");
        lua_gettable(L,2);
        lua_pushvalue(L,12);
        lua_pushvalue(L,3);
        lua_call(L,4,1);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"inside_village_terrain_blend_area");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,4);
          lua_pushvalue(L,5);
          lua_pushvalue(L,12);
          lua_pushvalue(L,3);
          lua_call(L,4,1);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"inside_village_terrain_blend_area");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lc_add(L,4,6);
          lua_pushvalue(L,5);
          lua_pushvalue(L,12);
          lua_pushvalue(L,3);
          lua_call(L,4,1);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"inside_village_terrain_blend_area");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lc_add(L,4,6);
          lc_add(L,5,7);
          lua_pushvalue(L,12);
          lua_pushvalue(L,3);
          lua_call(L,4,1);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"inside_village_terrain_blend_area");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,4);
          lc_add(L,5,7);
          lua_pushvalue(L,12);
          lua_pushvalue(L,3);
          lua_call(L,4,1);
        }
      }
      const int lc329 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc329) {
        
        /* mg_villages.print( mg_villages.DEBUG_LEVEL_WARNING, 'DROPPING house at '..c.vx..':'..c.vz..' due to intersection with village at '..id) */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"print");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"DEBUG_LEVEL_WARNING");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"DROPPING house at ");
        lua_pushliteral(L,"vx");
        lua_gettable(L,2);
        lua_pushliteral(L,":");
        lua_pushliteral(L,"vz");
        lua_gettable(L,2);
        lua_pushliteral(L," due to intersection with village at ");
        lua_pushvalue(L,13);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 14);
        
        /* c.areas_intersect = 1 */
        lua_pushnumber(L,1);
        lua_pushliteral(L,"areas_intersect");
        lua_insert(L,-2);
        lua_settable(L,2);
        assert(lua_gettop(L) == 14);
        
        /* -- the other village can't be spawned either as we don't know which one will be loaded first
         * if( v.is_single_house ) then */
        enum { lc330 = 14 };
        lua_pushliteral(L,"is_single_house");
        lua_gettable(L,12);
        const int lc331 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc331) {
          
          /* v.areas_intersect = 1 */
          lua_pushnumber(L,1);
          lua_pushliteral(L,"areas_intersect");
          lua_insert(L,-2);
          lua_settable(L,12);
          assert(lua_gettop(L) == 14);
        }
        lua_settop(L,lc330);
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L,lc328);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc319);
    assert(lua_gettop(L) == 13);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc316);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: mg_villages.houses_in_mapchunk
 * function( minp, mapchunk_size, villages) */
static int lcf1_mg_villages_houses_in_mapchunk (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local village_noise = minetest.get_perlin(7635, 3, 0.5, 16) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,7635);
  lua_pushnumber(L,3);
  lua_pushnumber(L,0.5);
  lua_pushnumber(L,16);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 4);
  
  /* local village_candidates = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* local vcr = 2 */
  lua_pushnumber(L,2);
  assert(lua_gettop(L) == 6);
  
  /* --mg_villages.VILLAGE_CHECK_RADIUS
   * for xi = -vcr, vcr do */
  lc_unm(L,6);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,6)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc332_var = lua_tonumber(L,-1);
  const double lc333_limit = lua_tonumber(L,6);
  const double lc334_step = 1;
  lua_pop(L,1);
  enum { lc335 = 6 };
  while ((((lc334_step > 0) && (lc332_var <= lc333_limit)) || ((lc334_step <= 0) && (lc332_var >= lc333_limit)))) {
    
    /* internal: local xi at index 7 */
    lua_pushnumber(L,lc332_var);
    
    /* for zi = -vcr, vcr do */
    lc_unm(L,6);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,6)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc336_var = lua_tonumber(L,-1);
    const double lc337_limit = lua_tonumber(L,6);
    const double lc338_step = 1;
    lua_pop(L,1);
    enum { lc339 = 7 };
    while ((((lc338_step > 0) && (lc336_var <= lc337_limit)) || ((lc338_step <= 0) && (lc336_var >= lc337_limit)))) {
      
      /* internal: local zi at index 8 */
      lua_pushnumber(L,lc336_var);
      
      /* local new_village = mg_villages.house_in_one_mapchunk(
       * 					{x=minp.x+(xi*mapchunk_size), y=minp.y, z=minp.z+(zi*mapchunk_size)},
       * 					mapchunk_size,
       * 					village_noise ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"house_in_one_mapchunk");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lc_mul(L,7,2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lc_mul(L,8,2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushvalue(L,2);
      lua_pushvalue(L,4);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 9);
      
      /* if( new_village and new_village.vs and new_village.vx and new_village.vz ) then */
      enum { lc340 = 9 };
      lua_pushvalue(L,9);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"vs");
        lua_gettable(L,9);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"vx");
        lua_gettable(L,9);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"vz");
        lua_gettable(L,9);
      }
      const int lc341 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc341) {
        
        /* table.insert( village_candidates, new_village ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,5);
        lua_pushvalue(L,9);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc340);
      assert(lua_gettop(L) == 9);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc336_var += lc338_step;
    }
    lua_settop(L,lc339);
    assert(lua_gettop(L) == 7);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc332_var += lc334_step;
  }
  lua_settop(L,lc335);
  assert(lua_gettop(L) == 6);
  
  /* for _,candidate in ipairs(village_candidates) do
   * 		-- mark all one-house-village-candidates that intersect with villages in this mapchunk
   * internal: local f, s, var = explist */
  enum { lc342 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,5);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 10
     * internal: local candidate with idx 11 */
    
    
    /* -- mark all one-house-village-candidates that intersect with villages in this mapchunk
     * mg_villages.house_in_mapchunk_mark_intersection( villages,           candidate, village_noise ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"house_in_mapchunk_mark_intersection");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,11);
    lua_pushvalue(L,4);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 11);
    
    /* -- mark all one-house-village-candidates that intersect with other candidates in this mapchunk
     * mg_villages.house_in_mapchunk_mark_intersection( village_candidates, candidate, village_noise ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"house_in_mapchunk_mark_intersection");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_pushvalue(L,11);
    lua_pushvalue(L,4);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc342);
  assert(lua_gettop(L) == 6);
  
  /* -- now add those villages that do not intersect with others and which *may* at least be part of this mapchunk
   * local d = math.ceil( mapchunk_size / 2 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"ceil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lc_div(L,2,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* for _,candidate in ipairs(village_candidates) do
   * internal: local f, s, var = explist */
  enum { lc343 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,5);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 11
     * internal: local candidate with idx 12 */
    
    
    /* if( not( candidate.areas_intersect )
     * 		    and (candidate.vx > minp.x - d or candidate.vx < (mapchunk_size+d) )
     * 		    and (candidate.vz > minp.z - d or candidate.vz < (mapchunk_size+d) )) then */
    enum { lc344 = 12 };
    lua_pushliteral(L,"areas_intersect");
    lua_gettable(L,12);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lc_sub(L,-1,7);
      lua_remove(L,-2);
      lua_pushliteral(L,"vx");
      lua_gettable(L,12);
      const int lc345 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc345);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"vx");
        lua_gettable(L,12);
        lc_add(L,2,7);
        const int lc346 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc346);
      }
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lc_sub(L,-1,7);
      lua_remove(L,-2);
      lua_pushliteral(L,"vz");
      lua_gettable(L,12);
      const int lc347 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc347);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushliteral(L,"vz");
        lua_gettable(L,12);
        lc_add(L,2,7);
        const int lc348 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc348);
      }
    }
    const int lc349 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc349) {
      
      /* table.insert( villages, candidate ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,12);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 12);
      
      /* -- there may be quite a lot of single houses added; plus they are less intresting than entire villages. Thus, logfile spam is reduced
       * mg_villages.print( mg_villages.DEBUG_LEVEL_WARNING, 'adding SINGLE HOUSE of type '..tostring( candidate.village_type )..
       * 				' to map at '..tostring( candidate.vx )..':'..tostring( candidate.vz )..'.') */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"print");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"DEBUG_LEVEL_WARNING");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"adding SINGLE HOUSE of type ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"village_type");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L," to map at ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vx");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,":");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vz");
      lua_gettable(L,12);
      lua_call(L,1,1);
      lua_pushliteral(L,".");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc344);
    assert(lua_gettop(L) == 12);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc343);
  assert(lua_gettop(L) == 7);
  
  /* return villages */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,23);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- this contains the functions to actually generate the village structure in a table;
   * -- said table will hold information about which building will be placed where,
   * -- how the buildings are rotated, where the roads will be, which replacement materials
   * -- will be used etc.
   * local function is_village_block(minp)
   * 	local x, z = math.floor(minp.x/80), math.floor(minp.z/80)
   * 	local vcc = mg_villages.VILLAGE_CHECK_COUNT
   * 	return (x%vcc == 0) and (z%vcc == 0)
   * end */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_pushcfunction(L,lcf1_is_village_block);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- called by mapgen.lua and spawn_player.lua
   * mg_villages.villages_at_point = function(minp, noise1)
   * 	if not is_village_block(minp) then return {} end
   * 	local vcr, vcc = mg_villages.VILLAGE_CHECK_RADIUS, mg_villages.VILLAGE_CHECK_COUNT
   * 	-- Check if there's another village nearby
   * 	for xi = -vcr, vcr, vcc do
   * 	for zi = -vcr, 0, vcc do
   * 		if xi ~= 0 or zi ~= 0 then
   * 			local mp = {x = minp.x + 80*xi, z = minp.z + 80*zi}
   * 			local pi = PseudoRandom(mg_villages.get_bseed(mp))
   * 			local s = pi:next(1, 400)
   * 			local x = pi:next(mp.x, mp.x + 79)
   * 			local z = pi:next(mp.z, mp.z + 79)
   * 			if s <= mg_villages.VILLAGE_CHANCE and noise1:get2d({x = x, y = z}) >= -0.3 then return {} end
   * 		end
   * 	end
   * 	end
   * 	local pr = PseudoRandom(mg_villages.get_bseed(minp))
   * 	if pr:next(1, 400) > mg_villages.VILLAGE_CHANCE then return {} end -- No village here
   * 	local x = pr:next(minp.x, minp.x + 79)
   * 	local z = pr:next(minp.z, minp.z + 79)
   * 	if noise1:get2d({x = x, y = z}) < -0.3 then return {} end -- Deep in the ocean
   * 
   * 	-- fallback: type "nore" (that is what the mod originally came with)
   * 	local village_type = 'nore';
   * 	village_type = mg_villages.village_types[ pr:next(1, #mg_villages.village_types )]; -- select a random type
   * 	-- if this is the first village for this world, take a medieval one
   * 	if( (not( mg_villages.all_villages ) or mg_villages.anz_villages < 1) and minetest.get_modpath("cottages") and mg_villages.FIRST_VILLAGE_TYPE) then
   * 		village_type = mg_villages.FIRST_VILLAGE_TYPE;
   * 	end
   * 
   * 	if( not( mg_villages.village_type_data[ village_type ] )) then
   * 		mg_villages.village_type_data[  village_type ] = { min = mg_villages.VILLAGE_MIN_SIZE, max = mg_villages.VILLAGE_MAX_SIZE };
   * 	end
   * 	local size = pr:next(mg_villages.village_type_data[ village_type ].min, mg_villages.village_type_data[ village_type ].max) 
   * --	local height = pr:next(5, 20)
   * 	local height = pr:next(1, 5)
   * 	-- villages of a size >= 40 are always placed at a height of 1
   * 	if(     size >= 40 ) then
   * 		height = 1;
   * 	-- slightly smaller but still relatively large villages have a deterministic height now as well
   * 	elseif( size >= 30 ) then
   * 		height = 40-height;
   * 	elseif( size >= 25 ) then
   * 		height = 35-height;
   * 	-- even smaller villages need to have a height depending on their sourroundings (at least they're pretty small!)
   * 	end
   * 
   * --	print("A village of type \'"..tostring( village_type ).."\' of size "..tostring( size ).." spawned at: x = "..x..", z = "..z)
   * 	--print("A village spawned at: x = "..x..", z = "..z)
   * 	return {{vx = x, vz = z, vs = size, vh = height, village_type = village_type}}
   * end */
  lua_pushvalue(L,(lc1 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_villages_at_point,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"villages_at_point");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* --local function dist_center2(ax, bsizex, az, bsizez)
   * --	return math.max((ax+bsizex)*(ax+bsizex),ax*ax)+math.max((az+bsizez)*(az+bsizez),az*az)
   * --end
   * local function inside_village2(bx, sx, bz, sz, village, vnoise)
   * 	return mg_villages.inside_village(bx, bz, village, vnoise) and mg_villages.inside_village(bx+sx, bz, village, vnoise) and mg_villages.inside_village(bx, bz+sz, village, vnoise) and mg_villages.inside_village(bx+sx, bz+sz, village, vnoise)
   * end */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc45 = 2 };
  assert((lua_gettop(L) == (lc45 + lc_nextra)));
  lua_pushcfunction(L,lcf1_inside_village2);
  lua_rawseti(L,(lc45 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local function choose_building(l, pr, village_type)
   * 	--::choose::
   * 	local btype
   * 	while true do
   * 		local p = pr:next(1, 3000)
   * 		
   * 		if(  not( mg_villages.village_type_data[ village_type ] )
   * 		  or not( mg_villages.village_type_data[ village_type ][ 'building_list'] )) then
   * 			mg_villages.print( mg_villages.DEBUG_LEVEL_INFO, 'Unsupported village type: '..tostring( village_type )..' for house at '..tostring(bx)..':'..tostring(bz)..'.');
   * 			-- ...and crash in the next few lines (because there is no real solution for this problem)
   * 		end
   * 
   * 		for _, b in ipairs( mg_villages.village_type_data[ village_type ][ 'building_list'] ) do
   * 			if (   mg_villages.BUILDINGS[ b ] and mg_villages.BUILDINGS[ b ].max_weight
   * 			   and mg_villages.BUILDINGS[ b ].max_weight[ village_type ] and  mg_villages.BUILDINGS[ b ].max_weight[ village_type ] >= p) then
   * 
   * --		for b, i in ipairs(mg_villages.BUILDINGS) do
   * --			if i.weight[ village_type ] and i.weight[ village_type ] > 0 and i.max_weight and i.max_weight[ village_type ] and i.max_weight[ village_type ] >= p then
   * 				btype = b
   * 				break
   * 			end
   * 		end
   * 		-- in case no building was found: take the last one that fits
   * 		if( not( btype )) then
   * 			for i=#mg_villages.BUILDINGS,1,-1 do
   * 				if (  mg_villages.BUILDINGS[i] and mg_villages.BUILDINGS[i].weight
   * 				  and mg_villages.BUILDINGS[i].weight[ village_type ] and mg_villages.BUILDINGS[i].weight[ village_type ] > 0 ) then
   * 					btype = i;
   * 					i = 1;
   * 				end
   * 			end
   * 		end
   * 		if( not( btype )) then
   * 			return 1;
   * 		end
   * 		if( #l<1
   * 			or not( mg_villages.BUILDINGS[btype].avoid )
   * 			or mg_villages.BUILDINGS[btype].avoid==''
   * 			or not( mg_villages.BUILDINGS[ l[#l].btype ].avoid )
   * 			or mg_villages.BUILDINGS[btype].avoid ~= mg_villages.BUILDINGS[ l[#l].btype ].avoid) then
   * 
   * 			if mg_villages.BUILDINGS[btype].pervillage ~= nil then
   * 				local n = 0
   * 				for j=1, #l do
   * 					if( l[j].btype == btype or (mg_villages.BUILDINGS[btype].typ and mg_villages.BUILDINGS[btype].typ == mg_villages.BUILDINGS[ l[j].btype ].typ)) then
   * 						n = n + 1
   * 					end
   * 				end
   * 				--if n >= mg_villages.BUILDINGS[btype].pervillage then
   * 				--	goto choose
   * 				--end
   * 				if n < mg_villages.BUILDINGS[btype].pervillage then
   * 					return btype
   * 				end
   * 			else
   * 				return btype
   * 			end
   * 		end
   * 	end
   * 	--return btype
   * end */
  lc_newclosuretable(L,(lc45 + lc_nextra));
  enum { lc46 = 3 };
  assert((lua_gettop(L) == (lc46 + lc_nextra)));
  lua_pushcfunction(L,lcf1_choose_building);
  lua_rawseti(L,(lc46 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local function choose_building_rot(l, pr, orient, village_type)
   * 	local btype = choose_building(l, pr, village_type)
   * 	local rotation
   * 	if mg_villages.BUILDINGS[btype].no_rotate then
   * 		rotation = 0
   * 	else
   * 		if mg_villages.BUILDINGS[btype].orients == nil then
   * 			mg_villages.BUILDINGS[btype].orients = {0,1,2,3}
   * 		end
   * 		rotation = (orient+mg_villages.BUILDINGS[btype].orients[pr:next(1, #mg_villages.BUILDINGS[btype].orients)])%4
   * 	end
   * 	local bsizex = mg_villages.BUILDINGS[btype].sizex
   * 	local bsizez = mg_villages.BUILDINGS[btype].sizez
   * 	if rotation%2 == 1 then
   * 		bsizex, bsizez = bsizez, bsizex
   * 	end
   * 	-- some buildings are mirrored
   * 	local mirror = nil;
   * 	-- some buildings may be too difficult for mirroring (=many nodebox-nodes that can't be mirrored well by rotation) or
   * 	-- be too symmetric to be worth the trouble
   * 	if( not(mg_villages.BUILDINGS[btype].nomirror) and pr:next( 1,2 )==1 ) then
   * 		mirror = true;
   * 	end
   * 	return btype, rotation, bsizex, bsizez, mirror
   * end */
  lc_newclosuretable(L,(lc46 + lc_nextra));
  enum { lc89 = 4 };
  assert((lua_gettop(L) == (lc89 + lc_nextra)));
  lua_pushvalue(L,(lc89 + lc_nextra));
  lua_pushcclosure(L,lcf1_choose_building_rot,1);
  lua_rawseti(L,(lc89 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local function placeable(bx, bz, bsizex, bsizez, l, exclude_roads, orientation)
   * 	for _, a in ipairs(l) do
   * 		-- with < instead of <=, space_between_buildings can be zero (important for towns where houses are closely packed)
   * 		if (a.btype ~= "road" or not exclude_roads) and math.abs(bx+bsizex/2-a.x-a.bsizex/2)<(bsizex+a.bsizex)/2 and math.abs(bz+bsizez/2-a.z-a.bsizez/2)<(bsizez+a.bsizez)/2 then
   * 			-- dirt roads which go at a 90 degree angel to the current road are not a problem
   * 			if( not( orientation ) or a.o%2 == orientation%2 ) then
   * 				return false
   * 			end
   * 		end
   * 	end
   * 	return true
   * end */
  lc_newclosuretable(L,(lc89 + lc_nextra));
  enum { lc102 = 5 };
  assert((lua_gettop(L) == (lc102 + lc_nextra)));
  lua_pushcfunction(L,lcf1_placeable);
  lua_rawseti(L,(lc102 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local function road_in_building(rx, rz, rdx, rdz, roadsize, l)
   * 	if rdx == 0 then
   * 		return not placeable(rx-roadsize+1, rz, 2*roadsize-2, 0, l, true)
   * 	else
   * 		return not placeable(rx, rz-roadsize+1, 0, 2*roadsize-2, l, true)
   * 	end
   * end */
  lc_newclosuretable(L,(lc102 + lc_nextra));
  enum { lc112 = 6 };
  assert((lua_gettop(L) == (lc112 + lc_nextra)));
  lua_pushvalue(L,(lc112 + lc_nextra));
  lua_pushcclosure(L,lcf1_road_in_building,1);
  lua_rawseti(L,(lc112 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local function when(a, b, c)
   * 	if a then return b else return c end
   * end */
  lc_newclosuretable(L,(lc112 + lc_nextra));
  enum { lc116 = 7 };
  assert((lua_gettop(L) == (lc116 + lc_nextra)));
  lua_pushcfunction(L,lcf1_when);
  lua_rawseti(L,(lc116 + lc_nextra),7);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* mg_villages.road_nr = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"road_nr");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* local function generate_road(village, l, pr, roadsize_list, road_materials, rx, rz, rdx, rdz, vnoise, space_between_buildings, iteration_depth)
   * 	local roadsize = math.floor(roadsize_list[ iteration_depth ]/2);
   * 	if( not( roadsize ) or roadsize==0) then
   * 		roadsize = mg_villages.FIRST_ROADSIZE;
   * 	end
   * 	local roadsize_a = roadsize;
   * 	local roadsize_b = roadsize;
   * 	if( roadsize_list[ iteration_depth ] % 2==1 ) then
   * 		roadsize_a = roadsize+1;
   * 	end	
   * 	local vx, vz, vh, vs = village.vx, village.vz, village.vh, village.vs
   * 	local village_type   = village.village_type;
   * 	local calls_to_do = {}
   * 	local rxx = rx
   * 	local rzz = rz
   * 	local mx, m2x, mz, m2z, mmx, mmz
   * 	mx, m2x, mz, m2z = rx, rx, rz, rz
   * 	local orient1, orient2
   * 	if rdx == 0 then
   * 		orient1 = 0
   * 		orient2 = 2
   * 	else
   * 		orient1 = 3
   * 		orient2 = 1
   * 	end
   * 	local btype;
   * 	local rotation;
   * 	local bsizex;
   * 	local bsizez;
   * 	local mirror;
   * 	-- we have one more road
   * 	mg_villages.road_nr = mg_villages.road_nr + 1;
   * 	local first_building_a = false;
   * 	local first_building_b = false;
   * 	while mg_villages.inside_village(rx, rz, village, vnoise) and not road_in_building(rx, rz, rdx, rdz, roadsize_a, l) do
   * 		if iteration_depth > 1 and pr:next(1, 4) == 1 and first_building_a then
   * 			--generate_road(vx, vz, vs, vh, l, pr, roadsize-1, rx, rz, math.abs(rdz), math.abs(rdx))
   * 			calls_to_do[#calls_to_do+1] = {rx=rx+(roadsize_a - 0)*rdx, rz=rz+(roadsize_a - 0)*rdz, rdx=math.abs(rdz), rdz=math.abs(rdx)}
   * 			m2x = rx + (roadsize_a - 0)*rdx
   * 			m2z = rz + (roadsize_a - 0)*rdz
   * 			rx = rx + (2*roadsize_a - 0)*rdx
   * 			rz = rz + (2*roadsize_a - 0)*rdz
   * 		end
   * 		--else
   * 			--::loop::
   * 			local exitloop = false
   * 			local bx
   * 			local bz
   * 			local tries = 0
   * 			while true do
   * 				if not mg_villages.inside_village(rx, rz, village, vnoise) or road_in_building(rx, rz, rdx, rdz, roadsize_a, l) then
   * 					exitloop = true
   * 					break
   * 				end
   * 				local village_type_sub = village_type;
   * 				if( mg_villages.medieval_subtype and village_type_sub == 'medieval' and math.abs(village.vx-rx)>20 and math.abs(village.vz-rz)>20) then
   * 					village_type_sub = 'fields';
   * 				end
   * 				btype, rotation, bsizex, bsizez, mirror = choose_building_rot(l, pr, orient1, village_type_sub)
   * 				bx = rx + math.abs(rdz)*(roadsize_a+1) - when(rdx==-1, bsizex-1, 0)
   * 				bz = rz + math.abs(rdx)*(roadsize_a+1) - when(rdz==-1, bsizez-1, 0)
   * 				if placeable(bx, bz, bsizex, bsizez, l) and inside_village2(bx, bsizex, bz, bsizez, village, vnoise) then
   * 					break
   * 				end
   * 				if tries > 5 then
   * 					rx = rx + rdx
   * 					rz = rz + rdz
   * 					tries = 0
   * 				else
   * 					tries = tries + 1
   * 				end
   * 				--goto loop
   * 			end
   * 			if exitloop then break end
   * 			rx = rx + (bsizex+space_between_buildings)*rdx
   * 			rz = rz + (bsizez+space_between_buildings)*rdz
   * 			mx = rx - 2*rdx
   * 			mz = rz - 2*rdz
   * 			l[#l+1] = {x=bx, y=vh, z=bz, btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation, road_nr = mg_villages.road_nr, side=1, o=orient1, mirror=mirror }
   * 			first_building_a = true;
   * 		--end
   * 	end
   * 	rx = rxx
   * 	rz = rzz
   * 	while mg_villages.inside_village(rx, rz, village, vnoise) and not road_in_building(rx, rz, rdx, rdz, roadsize_b, l) do
   * 		if roadsize_b > 1 and pr:next(1, 4) == 1 and first_building_b then
   * 			--generate_road(vx, vz, vs, vh, l, pr, roadsize-1, rx, rz, -math.abs(rdz), -math.abs(rdx))
   * 			calls_to_do[#calls_to_do+1] = {rx=rx+(roadsize_b - 0)*rdx, rz=rz+(roadsize_b - 0)*rdz, rdx=-math.abs(rdz), rdz=-math.abs(rdx)}
   * 			m2x = rx + (roadsize_b - 0)*rdx
   * 			m2z = rz + (roadsize_b - 0)*rdz
   * 			rx = rx + (2*roadsize_b - 0)*rdx
   * 			rz = rz + (2*roadsize_b - 0)*rdz
   * 		end
   * 		--else
   * 			--::loop::
   * 			local exitloop = false
   * 			local bx
   * 			local bz
   * 			local tries = 0
   * 			while true do
   * 				if not mg_villages.inside_village(rx, rz, village, vnoise) or road_in_building(rx, rz, rdx, rdz, roadsize_b, l) then
   * 					exitloop = true
   * 					break
   * 				end
   * 				local village_type_sub = village_type;
   * 				if( mg_villages.medieval_subtype and village_type_sub == 'medieval' and math.abs(village.vx-rx)>(village.vs/3) and math.abs(village.vz-rz)>(village.vs/3)) then
   * 					village_type_sub = 'fields';
   * 				end
   * 				btype, rotation, bsizex, bsizez, mirror = choose_building_rot(l, pr, orient2, village_type_sub)
   * 				bx = rx - math.abs(rdz)*(bsizex+roadsize_b) - when(rdx==-1, bsizex-1, 0)
   * 				bz = rz - math.abs(rdx)*(bsizez+roadsize_b) - when(rdz==-1, bsizez-1, 0)
   * 				if placeable(bx, bz, bsizex, bsizez, l) and inside_village2(bx, bsizex, bz, bsizez, village, vnoise) then
   * 					break
   * 				end
   * 				if tries > 5 then
   * 					rx = rx + rdx
   * 					rz = rz + rdz
   * 					tries = 0
   * 				else
   * 					tries = tries + 1
   * 				end
   * 				--goto loop
   * 			end
   * 			if exitloop then break end
   * 			rx = rx + (bsizex+space_between_buildings)*rdx
   * 			rz = rz + (bsizez+space_between_buildings)*rdz
   * 			m2x = rx - 2*rdx
   * 			m2z = rz - 2*rdz
   * 			l[#l+1] = {x=bx, y=vh, z=bz, btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation, road_nr = mg_villages.road_nr, side=2, o=orient2, mirror=mirror}
   * 			first_building_b = true;
   * 		--end
   * 	end
   * 	if road_in_building(rx, rz, rdx, rdz, roadsize, l) then
   * 		mmx = rx - 2*rdx
   * 		mmz = rz - 2*rdz
   * 	end
   * 	mx = mmx or rdx*math.max(rdx*mx, rdx*m2x)
   * 	mz = mmz or rdz*math.max(rdz*mz, rdz*m2z)
   * 	local rxmin;
   * 	local rxmax;
   * 	local rzmin;
   * 	local rzmax;
   * 	if rdx == 0 then
   * 		rxmin = rx - roadsize_a + 1
   * 		rxmax = rx + roadsize_b - 1
   * 		rzmin = math.min(rzz, mz)
   * 		rzmax = math.max(rzz, mz)
   * 		-- prolong the main road to the borders of the village
   * 		if( mg_villages.road_nr == 1 ) then	
   * 			while( mg_villages.inside_village_area(rxmin, rzmin, village, vnoise)) do
   * 				rzmin = rzmin-1;
   * 				rzmax = rzmax+1;
   * 			end
   * 			rzmin = rzmin-1;
   * 			rzmax = rzmax+1;
   * 			while( mg_villages.inside_village_area(rxmax, rzmax, village, vnoise)) do
   * 				rzmax = rzmax+1;
   * 			end
   * 			rzmax = rzmax+1;
   * 		end
   * 	else
   * 		rzmin = rz - roadsize_a + 1
   * 		rzmax = rz + roadsize_b - 1
   * 		rxmin = math.min(rxx, mx)
   * 		rxmax = math.max(rxx, mx)
   * 		-- prolong the main road to the borders of the village
   * 		if( mg_villages.road_nr == 1 ) then	
   * 			while( mg_villages.inside_village_area(rxmin, rzmin, village, vnoise)) do
   * 				rxmin = rxmin-1;
   * 				rxmax = rxmax+1;
   * 			end
   * 			rxmin = rxmin-1;
   * 			rxmax = rxmax+1;
   * 			while( mg_villages.inside_village_area(rxmax, rzmax, village, vnoise)) do
   * 				rxmax = rxmax+1;
   * 			end
   * 			rxmax = rxmax+1;
   * 		end
   * 	end
   * 	l[#l+1] = {x = rxmin+1, y = vh, z = rzmin, btype = "road",
   * 		bsizex = rxmax - rxmin + 1, bsizez = rzmax - rzmin + 1, brotate = 0, road_nr = mg_villages.road_nr}
   * 	if( road_materials and road_materials[ iteration_depth ] and minetest.registered_nodes[ road_materials[ iteration_depth ]] ) then
   * 		l[#l].road_material = minetest.get_content_id( road_materials[ iteration_depth ] );
   * 	end
   * 	
   * 	for _, i in ipairs(calls_to_do) do
   * --		local new_roadsize = roadsize -- - 1
   * 		if pr:next(1, 100) <= mg_villages.BIG_ROAD_CHANCE then
   * 			--new_roadsize = roadsize
   * 			iteration_depth = iteration_depth + 1;
   * 		end
   * 
   * 		--generate_road(vx, vz, vs, vh, l, pr, new_roadsize, i.rx, i.rz, i.rdx, i.rdz, vnoise)
   * 		calls[calls.index] = {village, l, pr, roadsize_list, road_materials, i.rx, i.rz, i.rdx, i.rdz, vnoise, space_between_buildings, iteration_depth-1}
   * 		calls.index = calls.index+1
   * 	end
   * end */
  lc_newclosuretable(L,(lc116 + lc_nextra));
  enum { lc118 = 8 };
  assert((lua_gettop(L) == (lc118 + lc_nextra)));
  lua_pushvalue(L,(lc118 + lc_nextra));
  lua_pushcclosure(L,lcf1_generate_road,1);
  lua_rawseti(L,(lc118 + lc_nextra),8);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local function generate_bpos(village, pr, vnoise, space_between_buildings)
   * 	local vx, vz, vh, vs = village.vx, village.vz, village.vh, village.vs
   * 	local l = {}
   * 	local rx = vx - vs
   * 	--[=[local l={}
   * 	local total_weight = 0
   * 	for _, i in ipairs(mg_villages.BUILDINGS) do
   * 		if i.weight == nil then i.weight = 1 end
   * 		total_weight = total_weight+i.weight
   * 		i.max_weight = total_weight
   * 	end
   * 	local multiplier = 3000/total_weight
   * 	for _,i in ipairs(mg_villages.BUILDINGS) do
   * 		i.max_weight = i.max_weight*multiplier
   * 	end
   * 	for i=1, 2000 do
   * 		bx = pr:next(vx-vs, vx+vs)
   * 		bz = pr:next(vz-vs, vz+vs)
   * 		::choose::
   * 		--[[btype = pr:next(1, #mg_villages.BUILDINGS)
   * 		if mg_villages.BUILDINGS[btype].chance ~= nil then
   * 			if pr:next(1, mg_villages.BUILDINGS[btype].chance) ~= 1 then
   * 				goto choose
   * 			end
   * 		end]]
   * 		p = pr:next(1, 3000)
   * 		for b, i in ipairs(mg_villages.BUILDINGS) do
   * 			if i.max_weight > p then
   * 				btype = b
   * 				break
   * 			end
   * 		end
   * 		if mg_villages.BUILDINGS[btype].pervillage ~= nil then
   * 			local n = 0
   * 			for j=1, #l do
   * 				if l[j].btype == btype then
   * 					n = n + 1
   * 				end
   * 			end
   * 			if n >= mg_villages.BUILDINGS[btype].pervillage then
   * 				goto choose
   * 			end
   * 		end
   * 		local rotation
   * 		if mg_villages.BUILDINGS[btype].no_rotate then
   * 			rotation = 0
   * 		else
   * 			rotation = pr:next(0, 3)
   * 		end
   * 		bsizex = mg_villages.BUILDINGS[btype].sizex
   * 		bsizez = mg_villages.BUILDINGS[btype].sizez
   * 		if rotation%2 == 1 then
   * 			bsizex, bsizez = bsizez, bsizex
   * 		end
   * 		if dist_center2(bx-vx, bsizex, bz-vz, bsizez)>vs*vs then goto out end
   * 		for _, a in ipairs(l) do
   * 			if math.abs(bx-a.x)<=(bsizex+a.bsizex)/2+2 and math.abs(bz-a.z)<=(bsizez+a.bsizez)/2+2 then goto out end
   * 		end
   * 		l[#l+1] = {x=bx, y=vh, z=bz, btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation}
   * 		::out::
   * 	end
   * 	return l]=]--
   * 	local rz = vz
   * 	while mg_villages.inside_village(rx, rz, village, vnoise) do
   * 		rx = rx - 1
   * 	end
   * 	rx = rx + 5
   * 	calls = {index = 1}
   * 	-- the function below is recursive; we need a way to count roads
   * 	mg_villages.road_nr = 0;
   * 	local roadsize_list = {};
   * 	for i=1,mg_villages.FIRST_ROADSIZE*2 do
   * 		roadsize_list[i] = i;
   * 	end
   * 	if( mg_villages.village_type_data[ village.village_type ].roadsize_list ) then
   * 		roadsize_list = mg_villages.village_type_data[ village.village_type ].roadsize_list;
   * 	end
   * 	generate_road(village, l, pr, roadsize_list, mg_villages.village_type_data[ village.village_type ].road_materials, rx, rz, 1, 0, vnoise, space_between_buildings, #roadsize_list)
   * 	local i = 1
   * 	while i < calls.index do
   * 		generate_road(unpack(calls[i]))
   * 		i = i+1
   * 	end
   * 	mg_villages.road_nr = 0;
   * 	return l
   * end */
  lc_newclosuretable(L,(lc118 + lc_nextra));
  enum { lc197 = 9 };
  assert((lua_gettop(L) == (lc197 + lc_nextra)));
  lua_pushvalue(L,(lc197 + lc_nextra));
  lua_pushcclosure(L,lcf1_generate_bpos,1);
  lua_rawseti(L,(lc197 + lc_nextra),9);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* -- dirt roads seperate the wheat area around medieval villages into seperate fields and make it look better
   * local function generate_dirt_roads( village, vnoise, bpos, secondary_dirt_roads )
   * 	local dirt_roads = {};
   * 	if( not( secondary_dirt_roads)) then
   * 		return dirt_roads;
   * 	end
   * 	for _, pos in ipairs( bpos ) do
   * 
   * 		local x = pos.x;
   * 		local z = pos.z; 
   * 		local sizex = pos.bsizex;
   * 		local sizez = 2;
   * 		local orientation = 0;
   * 		local vx;
   * 		local vz;
   * 		local vsx;
   * 		local vsz;
   * 		-- prolong the roads; start with a 3x2 piece of road for testing
   * 		if( pos.btype == 'road' ) then
   * 			-- the road streches in x direction
   * 			if( pos.bsizex > pos.bsizez ) then
   * 				sizex = 3; -- start with a road of length 3
   * 				sizez = 2;
   * 				vx    = -1; vz    = 0; vsx   = 1; vsz   = 0;
   * 				x     = pos.x - sizex;
   * 				z     = pos.z + math.floor((pos.bsizez-2)/2); -- aim for the middle of the road
   * 				orientation = 0;
   * 				-- if it is not possible to prolong the road at one end, then try the other
   * 				if( not( placeable( x, z, sizex, sizez, bpos,       false, nil))) then
   * 					x = pos.x + pos.bsizex;
   * 					vx = 0;
   * 					orientation = 2;
   * 				end
   * 			-- the road stretches in z direction
   * 			else
   * 				sizex = 2;
   * 				sizez = 3;
   * 				vx    = 0;  vz = -1; vsx   = 0; vsz   = 1;
   * 				x     = pos.x + math.floor((pos.bsizex-2)/2); -- aim for the middle of the road
   * 				z     = pos.z - sizez;
   * 				orientation = 1;
   * 				if( not( placeable( x, z, sizex, sizez, bpos,       false, nil))) then
   * 					z = pos.z + pos.bsizez;
   * 					vz = 0;
   * 					orientation = 3;
   * 				end
   * 			end
   * 				
   * 		else
   * 			if(     pos.o == 0 ) then
   * 				x = pos.x-pos.side;
   * 				z = pos.z-2; 
   * 				sizex = pos.bsizex+1;
   * 				sizez = 2;
   * 				vx = 0; vz = 0;  vsx = 1; vsz = 0;
   * 
   * 			elseif( pos.o == 2 ) then
   * 				x = pos.x-pos.side+2;
   * 				z = pos.z-2; 
   * 				sizex = pos.bsizex+1;
   * 				sizez = 2;
   * 				vx = -1; vz = 0;  vsx = 1; vsz = 0;
   * 
   * 			elseif( pos.o == 1 ) then
   * 				x = pos.x-2;
   * 				z = pos.z-pos.side+2; 
   * 				sizex = 2;
   * 				sizez = pos.bsizez+1;
   * 				vx = 0;  vz = -1; vsx = 0; vsz = 1;
   * 
   * 			else --if( pos.o == 3 ) then
   * 				x = pos.x-2;
   * 				z = pos.z-pos.side; 
   * 				sizex = 2;
   * 				sizez = pos.bsizez+1;
   * 				vx = 0;  vz = 0;  vsx = 0; vsz = 1;
   * 			end
   * 			orientation = pos.o;
   * 
   * 		end
   * 
   * 		-- prolong the dirt road by 1
   * 		while( placeable( x, z, sizex, sizez, bpos,       false, nil)
   * 		   and placeable( x, z, sizex, sizez, dirt_roads, false, orientation)
   *  		   and mg_villages.inside_village_area(x, z, village, vnoise)
   *  		   and mg_villages.inside_village_area(x+sizex, z+sizez, village, vnoise)) do
   * 			sizex = sizex + vsx;
   * 			sizez = sizez + vsz;
   * 			x     = x + vx;
   * 			z     = z + vz;
   * 		end
   * 
   * 		-- the dirt road may exceed the village boundaries slightly, but it may not interfere with other buildings
   * 		if(   not( placeable( x, z, sizex, sizez, bpos,       false, nil))
   * 		   or not( placeable( x, z, sizex, sizez, dirt_roads, false, orientation))) then
   * 			sizex = sizex - vsx;
   * 			sizez = sizez - vsz;
   * 			x     = x - vx;
   * 			z     = z - vz;
   * 		end
   * 
   * 		if(    placeable( x, z, sizex, sizez, bpos,       false, nil)  
   * 		   and placeable( x, z, sizex, sizez, dirt_roads, false, orientation)) then 
   * 			dirt_roads[#dirt_roads+1] = {x=x, y=village.vh, z=z, btype="dirt_road", bsizex=sizex, bsizez=sizez, brotate = 0, o=orientation}
   * 		end
   * 	end
   * 	return dirt_roads;
   * end */
  lc_newclosuretable(L,(lc197 + lc_nextra));
  enum { lc209 = 10 };
  assert((lua_gettop(L) == (lc209 + lc_nextra)));
  lua_pushvalue(L,(lc209 + lc_nextra));
  lua_pushcclosure(L,lcf1_generate_dirt_roads,1);
  lua_rawseti(L,(lc209 + lc_nextra),10);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* local MIN_DIST = 1 */
  lc_newclosuretable(L,(lc209 + lc_nextra));
  enum { lc238 = 11 };
  assert((lua_gettop(L) == (lc238 + lc_nextra)));
  lua_pushnumber(L,1);
  lua_rawseti(L,(lc238 + lc_nextra),11);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local function pos_far_buildings(x, z, l)
   * 	for _, a in ipairs(l) do
   * 		if a.x - MIN_DIST <= x and x <= a.x + a.bsizex + MIN_DIST and
   * 		   a.z - MIN_DIST <= z and z <= a.z + a.bsizez + MIN_DIST then
   * 			return false
   * 		end
   * 	end
   * 	return true
   * end */
  lua_pushvalue(L,(lc238 + lc_nextra));
  lua_pushcclosure(L,lcf1_pos_far_buildings,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* local function generate_walls(bpos, data, a, minp, maxp, vh, vx, vz, vs, vnoise)
   * 	for x = minp.x, maxp.x do
   * 	for z = minp.z, maxp.z do
   * 		local xx = (vnoise:get2d({x=x, y=z})-2)*20+(40/(vs*vs))*((x-vx)*(x-vx)+(z-vz)*(z-vz))
   * 		if xx>=40 and xx <= 44 then
   * 			bpos[#bpos+1] = {x=x, z=z, y=vh, btype="wall", bsizex=1, bsizez=1, brotate=0}
   * 		end
   * 	end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_generate_walls);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- determine which building is to be placed where
   * -- also choose which blocks to replace with which other blocks (to make villages more intresting)
   * mg_villages.generate_village = function(village, vnoise)
   * 	local vx, vz, vs, vh = village.vx, village.vz, village.vs, village.vh
   * 	local village_type = village.village_type;
   * 	local seed = mg_villages.get_bseed({x=vx, z=vz})
   * 	local pr_village = PseudoRandom(seed)
   * 
   * 	-- generate a name for the village
   * 	village.name = namegen.generate_village_name_with_prefix( pr_village, village );
   * 
   * 	-- only generate a new village if the data is not already stored
   * 	-- (the algorithm is fast, but village types and houses which are available may change later on,
   *   	-- and that might easily cause chaos if the village is generated again with diffrent input)
   * 	if( village.to_add_data and village.to_add_data.bpos and village.to_add_data.replacements and village.to_add_data.plantlist) then
   * 		--print('VILLAGE GENREATION: USING ALREADY GENERATED VILLAGE: Nr. '..tostring( village.nr )); 
   * 		return;
   * 	end
   * 
   * 	-- in the case of medieval villages, we later on want to add wheat fields with dirt roads; 1 wide dirt roads look odd
   * 	local space_between_buildings = 1;
   * 	if( mg_villages.village_type_data[ village_type ] and mg_villages.village_type_data[ village_type ].space_between_buildings) then
   * 		space_between_buildings = mg_villages.village_type_data[ village_type ].space_between_buildings;
   * 	end
   * 
   * 	local bpos = {};
   * 	local dirt_roads = {};
   * 	local secondary_dirt_roads = nil; 
   * 	if( village.to_add_data and village.to_add_data.bpos ) then
   * 		-- If it is a single building instead of a full village, then village.to_add_data.bpos will
   * 		-- already have been generated (but not the replacements and other data structures which still need to be generated here)
   * 		bpos = village.to_add_data.bpos;
   * 	else
   * 		-- actually generate the village structure
   * 		bpos = generate_bpos( village, pr_village, vnoise, space_between_buildings)
   * 
   * 		-- if there is enough space, add dirt roads between the buildings (those will later be prolonged so that they reach the fields)
   * 		-- only add dirt roads if there are at least 3 buildings in the village
   * 		if( space_between_buildings >= 2 and village_type == 'medieval' and #bpos>3) then
   * 			secondary_dirt_roads = "dirt_road";
   * 		end
   * 
   * 		dirt_roads = generate_dirt_roads( village, vnoise, bpos, secondary_dirt_roads );
   * 	end
   * 
   * 	-- set fruits for all buildings in the village that need it - regardless weather they will be spawned
   * 	-- now or later; after the first call to this function here, the village data will be final
   * 	for _, pos in ipairs( bpos ) do
   * 		local binfo = mg_villages.BUILDINGS[pos.btype];
   * 		if( binfo.farming_plus and binfo.farming_plus == 1 and mg_villages.fruit_list and not pos.furit) then
   *  			pos.fruit = mg_villages.fruit_list[ pr_village:next( 1, #mg_villages.fruit_list )];
   * 		end
   * 	end
   * 
   * 	-- a changing replacement list would also be pretty confusing
   * 	local p = PseudoRandom(seed);
   * 	-- if the village is new, replacement_list is nil and a new replacement list will be created
   * 	local replacements = mg_villages.get_replacement_table( village.village_type, p, nil );
   * 	
   * 	local sapling_id = mg_villages.get_content_id_replaced( 'default:sapling', replacements );
   * 	-- 1/sapling_p = probability of a sapling beeing placed
   * 	local sapling_p  = 25;
   * 	if( mg_villages.sapling_probability[ sapling_id ] ) then
   * 		sapling_p = mg_villages.sapling_probability[ sapling_id ];
   * 	end
   * 
   * 	local c_plant = mg_villages.get_content_id_replaced( mg_villages.village_type_data[ village.village_type ].plant_type, replacements);
   * 	local plantlist = {
   * 		{ id=sapling_id, p=sapling_p * mg_villages.village_type_data[ village.village_type ].sapling_divisor }, -- only few trees
   * 		{ id=c_plant,    p=            mg_villages.village_type_data[ village.village_type ].plant_frequency }};
   * 
   * 	if( village.is_single_house and plantlist and #plantlist>0 ) then
   * 		local c_grass = mg_villages.get_content_id_replaced( 'default:grass_5', replacements);
   * 		plantlist[2] = { id=c_grass,    p=10        };
   * 		-- reduce the amount of plants grown so that the area stands out less from the sourroundings
   * 		plantlist[2].p = plantlist[2].p*3;
   * 	end
   * 
   * 	-- store the generated data in the village table 
   * 	village.to_add_data               = {};
   * 	village.to_add_data.bpos          = bpos;
   * 	village.to_add_data.replacements  = replacements.list;
   * 	village.to_add_data.dirt_roads    = dirt_roads;
   * 	village.to_add_data.plantlist     = plantlist;
   * 
   * 	--print('VILLAGE GENREATION: GENERATING NEW VILLAGE Nr. '..tostring( village.nr ));
   * end */
  lua_pushvalue(L,(lc238 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_generate_village,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"generate_village");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- not all buildings contain beds so that mobs could live inside; some are just workplaces;
   * -- roads get only placed if there are enough inhabitants
   * mg_villages.count_inhabitated_buildings = function(village)
   * 	local bpos             = village.to_add_data.bpos;
   * 	-- count the buildings
   * 	local anz_buildings = 0;
   * 	for i, pos in ipairs(bpos) do
   * 		if( pos.btype and not(pos.btype == 'road' )) then 
   * 			local binfo = mg_villages.BUILDINGS[pos.btype];
   * 			-- count buildings which can house inhabitants as well as those requiring workers
   * 			if( binfo and binfo.inh and binfo.inh ~= 0 ) then
   * 				anz_buildings = anz_buildings + 1;
   * 			end
   * 		end
   * 	end
   * 	return anz_buildings;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_count_inhabitated_buildings);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"count_inhabitated_buildings");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- creates individual buildings outside of villages;
   * -- the data structure is like that of a village, except that bpos (=buildings to be placed) is already set;
   * -- Note: one building per mapchunk is more than enough (else it would look too crowded);
   * mg_villages.house_in_one_mapchunk = function( minp, mapchunk_size, vnoise )
   * 
   * 	local pr = PseudoRandom(mg_villages.get_bseed(minp))
   * 	-- only each mg_villages.INVERSE_HOUSE_DENSITY th mapchunk gets a building
   * 	if( pr:next(1,mg_villages.INVERSE_HOUSE_DENSITY) > 1 ) then
   * 		return {};
   * 	end
   * 
   * 
   * 	-- pseudorandom orientation
   * 	local orient1 = pr:next(0,3);
   * 	-- determine which kind of building to use
   * 	-- TODO: select only types fitting to that particular place
   * 	-- TODO: select only types that exist
   * 	-- the village type is "single" here - since not all houses which might fit into a village might do for lone standing houses
   * 	-- (i.e. church, forge, wagon, ..)
   * 	local btype, rotation, bsizex, bsizez, mirror = choose_building_rot({}, pr, orient1, 'single');
   * 	if( not( bsizex )) then
   * 		mg_villages.print( mg_villages.DEBUG_LEVEL_INFO, 'FAILURE to generate a building.');
   * 		btype, rotation, bsizex, bsizez, mirror = choose_building_rot({}, pr, orient1, 'nore');
   * 	end
   * 	-- if no building was found, give up
   * 	if( not( bsizex ) or not(mg_villages.BUILDINGS[ btype ].weight)) then
   * 		return {};
   * 	end
   * 
   * 
   * 	local village = {};
   * 	-- store that this is not a village but a lone house
   * 	village.is_single_house = 1;
   * 	-- village height will be set to a value fitting the terrain later on
   * 	village.vh = 10;
   * 	-- this will force re-calculation of height
   * 	village.vs = 5;
   * 	-- find out the real village type of this house (which is necessary for the replacements);
   * 	-- the "single" type only indicates that this building may be used for one-house-villages such as this one
   * 	for k, _ in pairs( mg_villages.BUILDINGS[ btype ].weight ) do
   * 		if( k and k ~= 'single' ) then
   * 			village.village_type = k;
   * 		end
   * 	end
   * 
   * 
   * 	-- taken from paramats terrain blending code for single houses
   * 	local FFAPROP = 0.5 -- front flat area proportion of dimension
   * 
   * 	local xdim, zdim -- dimensions of house plus front flat area
   * 	if rotation == 0 or rotation == 2 then
   * 		xdim = bsizex
   * 		zdim = bsizez + math.floor(FFAPROP * bsizez)
   * 	else
   * 		xdim = bsizex + math.floor(FFAPROP * bsizex)
   * 		zdim = bsizez
   * 	end
   * 	local blenrad = math.floor((math.max(xdim, zdim) + 16) / 2)+2 -- radius of blend area
   * --[[
   * 	if( blenrad >= math.ceil(mapchunk_size/2)-2 ) then
   * 		blenrad = math.floor(mapchunk_size/2)-2;
   * 	end
   * 	local blencenx = pr:next(minp.x + blenrad, minp.x + mapchunk_size - blenrad - 1) -- blend area centre point
   * 	local blencenz = pr:next(minp.z + blenrad, minp.z + mapchunk_size - blenrad - 1)
   * --]]
   * 	local blencenx = pr:next(minp.x, minp.x + mapchunk_size - 1) -- blend area centre point
   * 	local blencenz = pr:next(minp.z, minp.z + mapchunk_size - 1)
   * 
   * 	local minx = blencenx - math.ceil(xdim / 2) -- minimum point of house plus front flat area
   * 	local minz = blencenz - math.ceil(zdim / 2)
   * 	local bx, bz -- house minimum point
   * 	if rotation == 2 or rotation == 3 then -- N, E
   * 		bx = minx
   * 		bz = minz
   * 	elseif rotation == 1 then -- W
   * 		bx = minx + math.floor(FFAPROP * bsizex)
   * 		bz = minz
   * 	else -- rotation = 2, S
   * 		bx = minx
   * 		bz = minz + math.floor(FFAPROP * bsizez)
   * 	end
   * 
   * 	village.vx = blencenx;
   * 	village.vz = blencenz;
   * 	village.vs = blenrad;
   * 	local village_id = tostring( village.vx )..':'..tostring( village.vz );
   * 
   * 	-- these values have to be determined once per village; afterwards, they need to be fixed
   * 	-- if a village has been generated already, it will continue to exist
   * --	if( mg_villages.all_villages[ village_id ] ) then
   * --		return village;
   * --	end
   * 
   * 	if( mg_villages.all_villages  and mg_villages.all_villages[ village_id ] and mg_villages.all_villages[ village_id ].optimal_height) then
   * 		village.optimal_height  = mg_villages.all_villages[ village_id ].optimal_height;
   * 		village.vh              = mg_villages.all_villages[ village_id ].optimal_height;
   * 		village.artificial_snow = mg_villages.all_villages[ village_id ].artificial_snow;
   * 	end
   * 
   * 	village.to_add_data = {};
   * 	village.to_add_data.bpos = { {x=bx, y=village.vh, z=bz,  btype=btype, bsizex=bsizex, bsizez=bsizez, brotate = rotation, road_nr = 0, side=1, o=orient1, mirror=mirror }}
   * 	return village;
   * end */
  lua_pushvalue(L,(lc238 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_house_in_one_mapchunk,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"house_in_one_mapchunk");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* mg_villages.house_in_mapchunk_mark_intersection = function( villages, c, vnoise ) -- c: candidate for a new one-house-village
   * 	-- now check if this village can be placed here or if it intersects with another village in any critical manner;
   * 	-- the village area may intersect (=unproblematic; may even look nice), but the actual building must not be inside another village
   * 
   * 	-- exclude misconfigured villages
   * 	if( not( c ) or not( c.to_add_data )) then
   * 		--print('WRONG DATA: '..minetest.serialize( c ));
   * 		c.areas_intersect = 1;
   * 		return;
   * 	end
   * 
   * 	local bx     = c.to_add_data.bpos[1].x;
   * 	local bz     = c.to_add_data.bpos[1].z;
   * 	local bsizex = c.to_add_data.bpos[1].bsizex;
   * 	local bsizez = c.to_add_data.bpos[1].bsizez;
   * 
   * 	-- make sure that the house does not intersect with the area of a village
   * 	for _,v in ipairs( villages ) do
   * 		local id = v.vx..':'..v.vz;
   * 		if( id and mg_villages.all_villages and mg_villages.all_villages[ id ] ) then
   * 			v = mg_villages.all_villages[ id ];
   * 		end
   * 
   * 		if( v.vx ~= c.vx and v.vz ~= c.vz ) then
   * 			local dist = math.sqrt(  ( c.vx - v.vx ) * ( c.vx - v.vx )
   * 			                       + ( c.vz - v.vz ) * ( c.vz - v.vz ));
   * 			if( dist < ( c.vs + v.vs )*1.1 ) then
   * 				mg_villages.print( mg_villages.DEBUG_LEVEL_WARNING, 'DROPPING house at '..c.vx..':'..c.vz..' because it is too close to '..v.vx..':'..c.vx);
   * 				c.areas_intersect = 1;
   * 				-- the other village can't be spawned either as we don't know which one will be loaded first
   * 				if( v.is_single_house ) then
   * 					v.areas_intersect = 1;
   * 				end
   * 			end
   * 	
   * 			if( not( v.is_single_house ) and
   * 			   ( mg_villages.inside_village_terrain_blend_area( c.vx,       c.vz,        v, vnoise)
   * 			  or mg_villages.inside_village_terrain_blend_area( bx,         bz,          v, vnoise)
   * 			  or mg_villages.inside_village_terrain_blend_area((bx+bsizex), bz,          v, vnoise)
   * 			  or mg_villages.inside_village_terrain_blend_area((bx+bsizex), (bz+bsizez), v, vnoise)
   * 			  or mg_villages.inside_village_terrain_blend_area( bx,         (bz+bsizez), v, vnoise))) then
   * 	
   * 				mg_villages.print( mg_villages.DEBUG_LEVEL_WARNING, 'DROPPING house at '..c.vx..':'..c.vz..' due to intersection with village at '..id);
   * 				c.areas_intersect = 1;
   * 				-- the other village can't be spawned either as we don't know which one will be loaded first
   * 				if( v.is_single_house ) then
   * 					v.areas_intersect = 1;
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_house_in_mapchunk_mark_intersection);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"house_in_mapchunk_mark_intersection");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* -- we need to determine where single houses will be placed in neighbouring mapchunks as well because
   * -- they may be so close to the border that they will affect this mapchunk
   * mg_villages.houses_in_mapchunk = function( minp, mapchunk_size, villages )
   * 	local village_noise = minetest.get_perlin(7635, 3, 0.5, 16);
   * 
   * 	local village_candidates = {};
   * 	local vcr = 2; --mg_villages.VILLAGE_CHECK_RADIUS
   *         for xi = -vcr, vcr do
   *         for zi = -vcr, vcr do
   * 			local new_village = mg_villages.house_in_one_mapchunk(
   * 					{x=minp.x+(xi*mapchunk_size), y=minp.y, z=minp.z+(zi*mapchunk_size)},
   * 					mapchunk_size,
   * 					village_noise );
   * 			if( new_village and new_village.vs and new_village.vx and new_village.vz ) then
   * 				table.insert( village_candidates, new_village );
   * 			end
   * 		end
   * 	end
   * 
   * 	for _,candidate in ipairs(village_candidates) do
   * 		-- mark all one-house-village-candidates that intersect with villages in this mapchunk
   * 		mg_villages.house_in_mapchunk_mark_intersection( villages,           candidate, village_noise );
   * 		-- mark all one-house-village-candidates that intersect with other candidates in this mapchunk
   * 		mg_villages.house_in_mapchunk_mark_intersection( village_candidates, candidate, village_noise );
   * 	end
   * 
   * 	-- now add those villages that do not intersect with others and which *may* at least be part of this mapchunk
   * 	local d = math.ceil( mapchunk_size / 2 );
   * 	for _,candidate in ipairs(village_candidates) do
   * 		if( not( candidate.areas_intersect )
   * 		    and (candidate.vx > minp.x - d or candidate.vx < (mapchunk_size+d) )
   * 		    and (candidate.vz > minp.z - d or candidate.vz < (mapchunk_size+d) )) then
   * 			table.insert( villages, candidate );
   * 
   * 			-- there may be quite a lot of single houses added; plus they are less intresting than entire villages. Thus, logfile spam is reduced
   * 			mg_villages.print( mg_villages.DEBUG_LEVEL_WARNING, 'adding SINGLE HOUSE of type '..tostring( candidate.village_type )..
   * 				' to map at '..tostring( candidate.vx )..':'..tostring( candidate.vz )..'.');
   * 		end
   * 	end
   * 	return villages;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_houses_in_mapchunk);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"houses_in_mapchunk");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_villages(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


