/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.init_weights
 * function() */
static int lcf1_mg_villages_init_weights (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* -- create a list of all used village types
   * mg_villages.village_types = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_types");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* for k,v in pairs( mg_villages.village_type_data ) do
   * internal: local f, s, var = explist */
  enum { lc1 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_type_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local k with idx 4
     * internal: local v with idx 5 */
    
    
    /* if( not( v.only_single ) and v.supported and v.building_list ) then */
    enum { lc2 = 5 };
    lua_pushliteral(L,"only_single");
    lua_gettable(L,5);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"supported");
      lua_gettable(L,5);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"building_list");
      lua_gettable(L,5);
    }
    const int lc3 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc3) {
      
      /* table.insert( mg_villages.village_types, k ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"table");
      lua_pushliteral(L,"insert");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_types");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc2);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 0);
  
  /* mg_villages.print(mg_villages.DEBUG_LEVEL_NORMAL,'Will create villages of the following types: '..minetest.serialize( mg_villages.village_types )) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"print");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"DEBUG_LEVEL_NORMAL");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"Will create villages of the following types: ");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"serialize");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 0);
  
  /* mg_villages.village_types[ #mg_villages.village_types+1 ] = 'single' */
  lua_pushliteral(L,"single");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc4 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc4);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* mg_villages.village_types[ #mg_villages.village_types+1 ] = 'fields' */
  lua_pushliteral(L,"fields");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc5 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc5);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* mg_villages.village_types[ #mg_villages.village_types+1 ] = 'tower' */
  lua_pushliteral(L,"tower");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc6 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc6);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* for j,v in ipairs( mg_villages.village_types ) do
   * internal: local f, s, var = explist */
  enum { lc7 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local j with idx 4
     * internal: local v with idx 5 */
    
    
    /* local total_weight = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 6);
    
    /* for _, i in ipairs(mg_villages.BUILDINGS) do
     * internal: local f, s, var = explist */
    enum { lc8 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 10
       * internal: local i with idx 11 */
      
      
      /* if( not( i.max_weight )) then */
      enum { lc9 = 11 };
      lua_pushliteral(L,"max_weight");
      lua_gettable(L,11);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc10 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc10) {
        
        /* i.max_weight = {} */
        lua_newtable(L);
        lua_pushliteral(L,"max_weight");
        lua_insert(L,-2);
        lua_settable(L,11);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L,lc9);
      assert(lua_gettop(L) == 11);
      
      /* if( i.weight and i.weight[ v ] and i.weight[ v ]>0 ) then */
      enum { lc11 = 11 };
      lua_pushliteral(L,"weight");
      lua_gettable(L,11);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"weight");
        lua_gettable(L,11);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,0);
        lua_pushliteral(L,"weight");
        lua_gettable(L,11);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc12 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc12);
      }
      const int lc13 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc13) {
        
        /* total_weight = total_weight+i.weight[ v ] */
        lua_pushliteral(L,"weight");
        lua_gettable(L,11);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_add(L,6,-1);
        lua_remove(L,-2);
        lua_replace(L,6);
        assert(lua_gettop(L) == 11);
        
        /* i.max_weight[v] = total_weight */
        lua_pushvalue(L,6);
        lua_pushliteral(L,"max_weight");
        lua_gettable(L,11);
        lua_insert(L,-2);
        lua_pushvalue(L,5);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L,lc11);
      assert(lua_gettop(L) == 11);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc8);
    assert(lua_gettop(L) == 6);
    
    /* local multiplier = 3000/total_weight */
    lua_pushnumber(L,3000);
    lc_div(L,-1,6);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 7);
    
    /* for _,i in ipairs(mg_villages.BUILDINGS) do
     * internal: local f, s, var = explist */
    enum { lc14 = 7 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 11
       * internal: local i with idx 12 */
      
      
      /* if( i.weight and i.weight[ v ] and i.weight[ v ]>0 ) then */
      enum { lc15 = 12 };
      lua_pushliteral(L,"weight");
      lua_gettable(L,12);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"weight");
        lua_gettable(L,12);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,0);
        lua_pushliteral(L,"weight");
        lua_gettable(L,12);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc16 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc16);
      }
      const int lc17 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc17) {
        
        /* i.max_weight[v] = i.max_weight[ v ]*multiplier */
        lua_pushliteral(L,"max_weight");
        lua_gettable(L,12);
        lua_pushvalue(L,5);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lc_mul(L,-1,7);
        lua_remove(L,-2);
        lua_pushliteral(L,"max_weight");
        lua_gettable(L,12);
        lua_insert(L,-2);
        lua_pushvalue(L,5);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc15);
      assert(lua_gettop(L) == 12);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc14);
    assert(lua_gettop(L) == 7);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,4);
  }
  lua_settop(L,lc7);
  assert(lua_gettop(L) == 0);
  
  /* -- the fields do not exist as an independent type
   * mg_villages.village_types[ #mg_villages.village_types ] = nil */
  lua_pushnil(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc18 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc18);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* -- neither does the tower type
   * mg_villages.village_types[ #mg_villages.village_types ] = nil */
  lua_pushnil(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc19 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc19);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* -- and neither does the "single" type (==lone houses outside villages)
   * mg_villages.village_types[ #mg_villages.village_types ] = nil */
  lua_pushnil(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc20 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc20);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* -- this functions needs to be called once after *all* village types and buildings have been added
   * mg_villages.init_weights = function()
   * 
   * 	-- create a list of all used village types
   * 	mg_villages.village_types = {};
   * 	for k,v in pairs( mg_villages.village_type_data ) do
   * 		if( not( v.only_single ) and v.supported and v.building_list ) then
   * 			table.insert( mg_villages.village_types, k );
   * 		end
   * 	end
   * 	mg_villages.print(mg_villages.DEBUG_LEVEL_NORMAL,'Will create villages of the following types: '..minetest.serialize( mg_villages.village_types ));
   * 
   * 
   * 
   * 	mg_villages.village_types[ #mg_villages.village_types+1 ] = 'single';
   * 	mg_villages.village_types[ #mg_villages.village_types+1 ] = 'fields';
   * 	mg_villages.village_types[ #mg_villages.village_types+1 ] = 'tower';
   * 	for j,v in ipairs( mg_villages.village_types ) do
   * 	
   * 		local total_weight = 0
   * 		for _, i in ipairs(mg_villages.BUILDINGS) do
   * 			if( not( i.max_weight )) then
   * 				i.max_weight = {};
   * 			end
   * 			if( i.weight and i.weight[ v ] and i.weight[ v ]>0 ) then
   * 				total_weight = total_weight+i.weight[ v ]
   * 				i.max_weight[v] = total_weight
   * 			end
   * 		end
   * 		local multiplier = 3000/total_weight
   * 		for _,i in ipairs(mg_villages.BUILDINGS) do
   * 			if( i.weight and i.weight[ v ] and i.weight[ v ]>0 ) then
   * 				i.max_weight[v] = i.max_weight[ v ]*multiplier
   * 			end
   * 		end
   * 	end
   * 	-- the fields do not exist as an independent type
   * 	mg_villages.village_types[ #mg_villages.village_types ] = nil;
   * 	-- neither does the tower type
   * 	mg_villages.village_types[ #mg_villages.village_types ] = nil;
   * 	-- and neither does the "single" type (==lone houses outside villages)
   * 	mg_villages.village_types[ #mg_villages.village_types ] = nil;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_init_weights);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"init_weights");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_init_weights(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}



