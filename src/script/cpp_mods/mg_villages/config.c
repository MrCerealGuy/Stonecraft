/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -----------------------------------------------------------------------------
   * -- configuration values which you can adjust according to your liking
   * -----------------------------------------------------------------------------
   * -- set to false if you do not want to have any villages spawning
   * mg_villages.ENABLE_VILLAGES = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"ENABLE_VILLAGES");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- generate one random building for each mg_villages.INVERSE_HOUSE_DENSITY th mapchunk;
   * -- set to 0 in order to disable spawning of these lone buildings outside villages
   * mg_villages.INVERSE_HOUSE_DENSITY = 4 */
  lua_pushnumber(L,4);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"INVERSE_HOUSE_DENSITY");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- cover some villages with artificial snow; probability: 1/mg_villages.artificial_snow_probability
   * mg_villages.artificial_snow_probability = 10 */
  lua_pushnumber(L,10);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"artificial_snow_probability");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if set to true, soil around villaes will get special soil-snow instead of plant + snow cover
   * mg_villages.use_soil_snow = false */
  lua_pushboolean(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"use_soil_snow");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- only place roads if there are at least that many buildings in the village
   * mg_villages.MINIMAL_BUILDUNGS_FOR_ROAD_PLACEMENT = 4 */
  lua_pushnumber(L,4);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"MINIMAL_BUILDUNGS_FOR_ROAD_PLACEMENT");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- players without the mg_villages priv can only see villages which are less than that many blocks away
   * -- from them when using the /vmap command
   * mg_villages.VILLAGE_DETECT_RANGE = 400 */
  lua_pushnumber(L,400);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"VILLAGE_DETECT_RANGE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if set to true, only players which have the mg_villages priv can use the "/visit <village nr>"
   * -- command which allows teleporting to the village with the given number
   * mg_villages.REQUIRE_PRIV_FOR_TELEPORT = false */
  lua_pushboolean(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"REQUIRE_PRIV_FOR_TELEPORT");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if set to true, players cannot modify spawned villages without buying the house from the village first
   * mg_villages.ENABLE_PROTECTION = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"ENABLE_PROTECTION");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- the first village - the one the player spawns in - will be of this type
   * mg_villages.FIRST_VILLAGE_TYPE = 'medieval' */
  lua_pushliteral(L,"medieval");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"FIRST_VILLAGE_TYPE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- the mapgen will disregard mapchunks where min.y > mg_villages.MAX_HEIGHT_TREATED;
   * -- you can set this value to 64 if you have a slow machine and a mapgen which does not create extreme mountains
   * -- (or if you don't care if extreme mountains may create burried villages occasionally)
   * mg_villages.MAX_HEIGHT_TREATED = 200 */
  lua_pushnumber(L,200);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"MAX_HEIGHT_TREATED");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- choose the debug level you want
   * mg_villages.DEBUG_LEVEL = mg_villages.DEBUG_LEVEL_NORMAL */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"DEBUG_LEVEL_NORMAL");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"DEBUG_LEVEL");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if set to true (or anything else but nil or false), highlandpools by paramat (see
   * -- https://forum.minetest.net/viewtopic.php?t=8400) will be created
   * mg_villages.CREATE_HIGHLANDPOOLS = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"CREATE_HIGHLANDPOOLS");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- Torches are replaced by mg_villages:torch - which does not melt snow. If you want to use the normal
   * -- torches from minetest_game, set this to true.:w!
   * mg_villages.USE_DEFAULT_3D_TORCHES = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"USE_DEFAULT_3D_TORCHES");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- background image for the /vmap command
   * -- RealTest comes with a diffrent texture
   * if(     minetest.get_modpath('grounds') and minetest.get_modpath('joiner_table')) then */
  enum { lc1 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"grounds");
  lua_call(L,1,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_modpath");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"joiner_table");
    lua_call(L,1,1);
  }
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* mg_villages.MAP_BACKGROUND_IMAGE = "default_dirt_grass.png" */
    lua_pushliteral(L,"default_dirt_grass.png");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"MAP_BACKGROUND_IMAGE");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  else {
    
    /* elseif( minetest.registered_nodes[ 'default:dirt_with_grass'] ) then */
    enum { lc3 = 0 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc4 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc4) {
      
      /* mg_villages.MAP_BACKGROUND_IMAGE = "default_grass.png" */
      lua_pushliteral(L,"default_grass.png");
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_insert(L,-2);
      lua_pushliteral(L,"MAP_BACKGROUND_IMAGE");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 0);
    }
    else {
      
      /* else
       * mg_villages.MAP_BACKGROUND_IMAGE = "" */
      lua_pushliteral(L,"");
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_insert(L,-2);
      lua_pushliteral(L,"MAP_BACKGROUND_IMAGE");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) - lc_nextra == 0);
    }
    lua_settop(L,(lc3 + lc_nextra));
  }
  lua_settop(L,(lc1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if set to true, the outer buildings in medieval villages will be fields; this is not very convincing yet
   * -- currently not really used; does not look as good as expected
   * mg_villages.medieval_subtype = false */
  lua_pushboolean(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"medieval_subtype");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- set this to true if you want to use normal lava - but beware: charachoal villages may cause bushfires!
   * --mg_villages.use_normal_unsafe_lava = false;
   * -----------------------------------------------------------------------------
   * -- decrese these values slightly if you want MORE trees around your villages;
   * -- increase it if you want to DECREASE the amount of trees around villages
   * -----------------------------------------------------------------------------
   * -- on average, every n.th node inside a village area may be one of these trees - and it will be a relatively dense packed forrest
   * mg_villages.sapling_probability = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"sapling_probability");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.sapling_probability[ minetest.get_content_id( 'default:sapling' )       ] = 25 */
  lua_pushnumber(L,25);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"sapling_probability");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:sapling");
  lua_call(L,1,1);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- suitable for a relatively dense forrest of normal trees
   * mg_villages.sapling_probability[ minetest.get_content_id( 'default:junglesapling' ) ] = 40 */
  lua_pushnumber(L,40);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"sapling_probability");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:junglesapling");
  lua_call(L,1,1);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- jungletrees are a bit bigger and need more space
   * mg_villages.sapling_probability[ minetest.get_content_id( 'default:pinesapling' )   ] = 30 */
  lua_pushnumber(L,30);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"sapling_probability");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:pinesapling");
  lua_call(L,1,1);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* if( minetest.get_modpath( 'mg' )) then */
  enum { lc5 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg");
  lua_call(L,1,1);
  const int lc6 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc6) {
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'mg:savannasapling'     ) ] = 30 */
    lua_pushnumber(L,30);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"mg:savannasapling");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'mg:pinesapling'        ) ] = 35 */
    lua_pushnumber(L,35);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"mg:pinesapling");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc5 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.moretrees_treelist = nil */
  lua_pushnil(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"moretrees_treelist");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* if( minetest.get_modpath( 'moretrees' )) then */
  enum { lc7 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moretrees");
  lua_call(L,1,1);
  const int lc8 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc8) {
    
    /* mg_villages.moretrees_treelist = moretrees.treelist */
    lua_getfield(L,LUA_ENVIRONINDEX,"moretrees");
    lua_pushliteral(L,"treelist");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"moretrees_treelist");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:birch_sapling_ongen'       ) ] = 200 */
    lua_pushnumber(L,200);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:birch_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:spruce_sapling_ongen'      ) ] = 200 */
    lua_pushnumber(L,200);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:spruce_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:fir_sapling_ongen'         ) ] =  90 */
    lua_pushnumber(L,90);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:fir_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:jungletree_sapling_ongen'  ) ] = 200 */
    lua_pushnumber(L,200);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:jungletree_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:beech_sapling_ongen'       ) ] =  30 */
    lua_pushnumber(L,30);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:beech_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:apple_sapling_ongen'       ) ] = 380 */
    lua_pushnumber(L,380);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:apple_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:oak_sapling_ongen'         ) ] = 380 */
    lua_pushnumber(L,380);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:oak_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* -- ca 20x20; height: 10
     * mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:sequoia_sapling_ongen'     ) ] =  90 */
    lua_pushnumber(L,90);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:sequoia_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* -- ca 10x10
     * mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:palm_sapling_ongen'        ) ] =  90 */
    lua_pushnumber(L,90);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:palm_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:pine_sapling_ongen'        ) ] = 200 */
    lua_pushnumber(L,200);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:pine_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:willow_sapling_ongen'      ) ] = 380 */
    lua_pushnumber(L,380);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:willow_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
    
    /* mg_villages.sapling_probability[ minetest.get_content_id( 'moretrees:rubber_tree_sapling_ongen' ) ] = 380 */
    lua_pushnumber(L,380);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"sapling_probability");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"moretrees:rubber_tree_sapling_ongen");
    lua_call(L,1,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc7 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -----------------------------------------------------------------------------
   * -- no need to change this, unless you add new farming_plus fruits
   * -----------------------------------------------------------------------------
   * -- the schematics for buildings of type 'farm_tiny' grow cotton; the farming_plus fruits would be far more fitting
   * mg_villages.fruit_list = {'carrot','potatoe','orange','rhubarb','strawberry','tomato','cotton'} */
  lua_createtable(L,7,0);
  lua_pushliteral(L,"carrot");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"potatoe");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"orange");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"rhubarb");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"strawberry");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"tomato");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"cotton");
  lua_rawseti(L,-2,7);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"fruit_list");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- is farming_plus available? If not, we can't use this
   * if( not( minetest.get_modpath("farming_plus"))) then */
  enum { lc9 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"farming_plus");
  lua_call(L,1,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc10 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc10) {
    
    /* mg_villages.fruit_list = nil */
    lua_pushnil(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"fruit_list");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 0);
  }
  lua_settop(L,(lc9 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -----------------------------------------------------------------------------
   * -- players can buy plots in villages with houses on for this  price;
   * -- set according to your liking
   * -----------------------------------------------------------------------------
   * -- how much does the player have to pay for a plot with a building?
   * mg_villages.prices = {
   * 	empty          = "default:copper_ingot 1", -- plot to build on 
   * 
   * 	-- building types which usually have inhabitants (and thus allow the player
   * 	-- who bought the building to modifiy the entire village area minus other
   * 	-- buildings)
   * 	tent           = "default:copper_ingot 1",
   * 	hut            = "default:copper_ingot 1",
   * 	farm_full      = "default:gold_ingot 4",
   * 	farm_tiny      = "default:gold_ingot 2",
   * 	lumberjack     = "default:gold_ingot 2",
   * 	house          = "default:gold_ingot 2",
   * 	house_large    = "default:gold_ingot 4",
   * 	tavern         = "default:gold_ingot 12",
   * 	trader         = "default:gold_ingot 2",
   * 
   * 	-- more or less community buildings
   * 	well           = "default:gold_ingot 1",
   * 	village_square = "default:goldblock 1",
   * 	secular        = "default:goldblock 2", -- secular buildings, such as libraries ec.
   * 	church         = "default:goldblock 10",
   * 
   * 	-- places for mobs to work at; usually without inhabitants
   * 	tower          = "default:copper_ingot 1",
   * 	shed           = "default:copper_ingot 2",
   * 	pit            = "default:copper_ingot 3", -- claytrader pit
   * 	mill           = "default:gold_ingot 10",
   * 	forge          = "default:gold_ingot 10",
   * 	bakery         = "default:gold_ingot 10",
   * 	shop           = "default:gold_ingot 20",
   * 	sawmill        = "default:gold_ingot 30",
   * 
   * 	-- decoration
   * 	wagon          = "default:tree 10",
   * 	bench          = "default:tree 4",
   * 
   * 	-- seperate fields
   * 	pasture        = "default:copper_ingot 2",
   * 	field          = "default:copper_ingot 2",
   * 
   * 	-- chateaus are expensive
   * 	chateau        = "default:diamondblock 5",
   * 
   * 	-- one mese crystal per square meter in the spawn town :-)
   * 	empty6x12      = "default:mese_crystal 72",
   * 	empty8x8       = "default:mese_crystal 64",
   * 	-- a large plot costs mese blocks
   * 	empty16x16     = "default:mese 56",
   * 	-- this is just enough space to grow a tree
   *         empty5x5       = "default:mese_crystal 12",
   * 	-- nobody is supposed to buy the spawn building...except for the admin
   * 	spawn          = "nyancat:nyancat 99",
   * } */
  lua_createtable(L,0,32);
  lua_pushliteral(L,"empty");
  lua_pushliteral(L,"default:copper_ingot 1");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tent");
  lua_pushliteral(L,"default:copper_ingot 1");
  lua_rawset(L,-3);
  lua_pushliteral(L,"hut");
  lua_pushliteral(L,"default:copper_ingot 1");
  lua_rawset(L,-3);
  lua_pushliteral(L,"farm_full");
  lua_pushliteral(L,"default:gold_ingot 4");
  lua_rawset(L,-3);
  lua_pushliteral(L,"farm_tiny");
  lua_pushliteral(L,"default:gold_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"lumberjack");
  lua_pushliteral(L,"default:gold_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"house");
  lua_pushliteral(L,"default:gold_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"house_large");
  lua_pushliteral(L,"default:gold_ingot 4");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tavern");
  lua_pushliteral(L,"default:gold_ingot 12");
  lua_rawset(L,-3);
  lua_pushliteral(L,"trader");
  lua_pushliteral(L,"default:gold_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"well");
  lua_pushliteral(L,"default:gold_ingot 1");
  lua_rawset(L,-3);
  lua_pushliteral(L,"village_square");
  lua_pushliteral(L,"default:goldblock 1");
  lua_rawset(L,-3);
  lua_pushliteral(L,"secular");
  lua_pushliteral(L,"default:goldblock 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"church");
  lua_pushliteral(L,"default:goldblock 10");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tower");
  lua_pushliteral(L,"default:copper_ingot 1");
  lua_rawset(L,-3);
  lua_pushliteral(L,"shed");
  lua_pushliteral(L,"default:copper_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"pit");
  lua_pushliteral(L,"default:copper_ingot 3");
  lua_rawset(L,-3);
  lua_pushliteral(L,"mill");
  lua_pushliteral(L,"default:gold_ingot 10");
  lua_rawset(L,-3);
  lua_pushliteral(L,"forge");
  lua_pushliteral(L,"default:gold_ingot 10");
  lua_rawset(L,-3);
  lua_pushliteral(L,"bakery");
  lua_pushliteral(L,"default:gold_ingot 10");
  lua_rawset(L,-3);
  lua_pushliteral(L,"shop");
  lua_pushliteral(L,"default:gold_ingot 20");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sawmill");
  lua_pushliteral(L,"default:gold_ingot 30");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wagon");
  lua_pushliteral(L,"default:tree 10");
  lua_rawset(L,-3);
  lua_pushliteral(L,"bench");
  lua_pushliteral(L,"default:tree 4");
  lua_rawset(L,-3);
  lua_pushliteral(L,"pasture");
  lua_pushliteral(L,"default:copper_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"field");
  lua_pushliteral(L,"default:copper_ingot 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"chateau");
  lua_pushliteral(L,"default:diamondblock 5");
  lua_rawset(L,-3);
  lua_pushliteral(L,"empty6x12");
  lua_pushliteral(L,"default:mese_crystal 72");
  lua_rawset(L,-3);
  lua_pushliteral(L,"empty8x8");
  lua_pushliteral(L,"default:mese_crystal 64");
  lua_rawset(L,-3);
  lua_pushliteral(L,"empty16x16");
  lua_pushliteral(L,"default:mese 56");
  lua_rawset(L,-3);
  lua_pushliteral(L,"empty5x5");
  lua_pushliteral(L,"default:mese_crystal 12");
  lua_rawset(L,-3);
  lua_pushliteral(L,"spawn");
  lua_pushliteral(L,"nyancat:nyancat 99");
  lua_rawset(L,-3);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"prices");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -----------------------------------------------------------------------------
   * -- The values below seldom need adjustment; don't change them unless you
   * -- know exactly what you are doing.
   * -----------------------------------------------------------------------------
   * -- if set to false, villages will not be integrated into the terrain - which looks very bad
   * mg_villages.ENABLE_TERRAIN_BLEND = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"ENABLE_TERRAIN_BLEND");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if set to false, holes digged by cavegen and mudflow inside the village will not be repaired; houses will be destroyed
   * mg_villages.UNDO_CAVEGEN_AND_MUDFLOW = true */
  lua_pushboolean(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"UNDO_CAVEGEN_AND_MUDFLOW");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- internal variables for village generation
   * mg_villages.VILLAGE_CHECK_RADIUS = 2 */
  lua_pushnumber(L,2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"VILLAGE_CHECK_RADIUS");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.VILLAGE_CHECK_COUNT = 1 */
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"VILLAGE_CHECK_COUNT");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* --mg_villages.VILLAGE_CHANCE = 28
   * --mg_villages.VILLAGE_MIN_SIZE = 20
   * --mg_villages.VILLAGE_MAX_SIZE = 40
   * mg_villages.VILLAGE_CHANCE = 28 */
  lua_pushnumber(L,28);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"VILLAGE_CHANCE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- min and max size are only used in case of them beeing not provided by the village type (see buildings.lua)
   * mg_villages.VILLAGE_MIN_SIZE = 25 */
  lua_pushnumber(L,25);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"VILLAGE_MIN_SIZE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.VILLAGE_MAX_SIZE = 90 */
  lua_pushnumber(L,90);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"VILLAGE_MAX_SIZE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* --55
   * mg_villages.FIRST_ROADSIZE = 3 */
  lua_pushnumber(L,3);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"FIRST_ROADSIZE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.BIG_ROAD_CHANCE = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"BIG_ROAD_CHANCE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_config(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}

