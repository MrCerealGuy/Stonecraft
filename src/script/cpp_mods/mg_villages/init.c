/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

#include "cpp_mods/cpp_mods_init.h"

/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: mg_villages.print
 * function( level, msg) */
static int lcf1_mg_villages_print (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if( level <= mg_villages.DEBUG_LEVEL ) then */
  enum { lc1 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"DEBUG_LEVEL");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc2 = lc_le(L,1,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc2);
  const int lc3 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc3) {
    
    /* print( "[mg_villages] "..msg ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    lua_pushliteral(L,"[mg_villages] ");
    lua_pushvalue(L,2);
    lua_concat(L,2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* -- reserve namespace for the villages
   * mg_villages = {} */
  lua_newtable(L);
  lua_setfield(L,LUA_ENVIRONINDEX,"mg_villages");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.all_villages  = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"all_villages");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.mg_generated_map = {} */
  lua_newtable(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"mg_generated_map");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.anz_villages = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"anz_villages");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.modpath = minetest.get_modpath( "mg_villages") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages");
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"modpath");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.DEBUG_LEVEL_NONE    = -1 */
  lua_pushnumber(L,-1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"DEBUG_LEVEL_NONE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- -1: disable all printed messages
   * mg_villages.DEBUG_LEVEL_NORMAL  =  0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"DEBUG_LEVEL_NORMAL");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- 0: print information about which village spawned where plus important errors
   * mg_villages.DEBUG_LEVEL_WARNING =  1 */
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"DEBUG_LEVEL_WARNING");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- 1: warnings/errors which may not be particulary helpful for non-developers
   * mg_villages.DEBUG_LEVEL_INFO    =  2 */
  lua_pushnumber(L,2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"DEBUG_LEVEL_INFO");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- 2: print even less important warnings
   * mg_villages.DEBUG_LEVEL_TIMING  =  3 */
  lua_pushnumber(L,3);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"DEBUG_LEVEL_TIMING");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- 3: detailled performance information
   * mg_villages.print = function( level, msg )
   * 	if( level <= mg_villages.DEBUG_LEVEL ) then
   * 		print( "[mg_villages] "..msg );
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_print);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"print");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- save_restore is now part of handle_schematics
   * --dofile(mg_villages.modpath.."/save_restore.lua")
   * mg_villages.all_villages     = save_restore.restore_data( 'mg_all_villages.data' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"save_restore");
  lua_pushliteral(L,"restore_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_all_villages.data");
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"all_villages");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- read mg_villages.all_villages data saved for this world from previous runs
   * mg_villages.mg_generated_map = save_restore.restore_data( 'mg_generated_map.data' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"save_restore");
  lua_pushliteral(L,"restore_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_generated_map.data");
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"mg_generated_map");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* dofile(mg_villages.modpath.."/config.lua") */
  lc_pmain_mod_mg_villages_config(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/config.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- adds a special gravel node which will neither fall nor be griefed by mapgen
   * dofile(mg_villages.modpath.."/nodes.lua") */
  lc_pmain_mod_mg_villages_nodes(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/nodes.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- the default game no longer provides helpful tree growing code
   * dofile(mg_villages.modpath.."/trees.lua") */
  lc_pmain_mod_mg_villages_trees(L);
  /*lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/trees.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(mg_villages.modpath.."/replacements.lua") */
  lc_pmain_mod_mg_villages_replacements(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/replacements.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  
  /* -- multiple diffrent village types with their own sets of houses are supported
   * -- The function mg_villages.add_village_type( village_type_name, village_type_data )
   * --   allows other mods to add new village types.
   * dofile(mg_villages.modpath.."/village_types.lua") */
  lc_pmain_mod_mg_villages_village_types(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/village_types.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- Note: the "buildings" talbe is not in the mg_villages.* namespace
   * -- The function mg_villages.add_building( building_data ) allows other mods to add buildings.
   * dofile(mg_villages.modpath.."/buildings.lua") */
  lc_pmain_mod_mg_villages_buildings(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/buildings.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- mg_villages.init_weights() has to be called AFTER all village types and buildings have
   * -- been added using the functions above
   * dofile(mg_villages.modpath.."/init_weights.lua") */
  lc_pmain_mod_mg_villages_init_weights(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/init_weights.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  
  /* -- generate village names
   * dofile(mg_villages.modpath.."/name_gen.lua") */
  lc_pmain_mod_mg_villages_name_gen(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/name_gen.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  
  /* dofile(mg_villages.modpath.."/villages.lua") */
  lc_pmain_mod_mg_villages_villages(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/villages.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  
  /* -- adds a command that allows to teleport to a known village
   * dofile(mg_villages.modpath.."/chat_commands.lua") */
  lc_pmain_mod_mg_villages_chat_commands(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/chat_commands.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- protect villages from griefing
   * dofile(mg_villages.modpath.."/protection.lua") */
  lc_pmain_mod_mg_villages_protection(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/protection.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- create and show a map of the world
   * dofile(mg_villages.modpath.."/map_of_world.lua") */
  lc_pmain_mod_mg_villages_map_of_world(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/map_of_world.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  
  /* dofile(mg_villages.modpath.."/fill_chest.lua") */
  lc_pmain_mod_mg_villages_fill_chest(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/fill_chest.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  
  /* -- terrain blending for individual houses
   * dofile(mg_villages.modpath.."/terrain_blend.lua") */
  lc_pmain_mod_mg_villages_terrain_blend(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/terrain_blend.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- highlandpools
   * dofile(mg_villages.modpath.."/highlandpools.lua") */
  lc_pmain_mod_mg_villages_highlandpools(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/highlandpools.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* -- the interface for the mapgen;
   * -- also takes care of spawning the player
   * dofile(mg_villages.modpath.."/mapgen.lua") */
  lc_pmain_mod_mg_villages_mapgen(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/mapgen.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);*/
  
  /* dofile(mg_villages.modpath.."/spawn_player.lua") */
  lc_pmain_mod_mg_villages_spawn_player(L);
  /*
  lua_getfield(L,LUA_ENVIRONINDEX,"dofile");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"/spawn_player.lua");
  lua_concat(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  */
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_init(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


