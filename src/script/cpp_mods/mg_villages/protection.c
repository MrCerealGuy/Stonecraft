/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <assert.h>

/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.get_town_id_at_pos
 * function( pos) */
static int lcf1_mg_villages_get_town_id_at_pos (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* for id, v in pairs( mg_villages.all_villages ) do
   * internal: local f, s, var = explist */
  enum { lc1 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local id with idx 5
     * internal: local v with idx 6 */
    
    
    /* local size = v.vs * 3 */
    lua_pushliteral(L,"vs");
    lua_gettable(L,6);
    lua_pushnumber(L,3);
    lc_mul(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 7);
    
    /* if(   ( math.abs( pos.x - v.vx ) < size )
     * 		  and ( math.abs( pos.z - v.vz ) < size )
     * 		  and ( pos.y - v.vh < 40 and v.vh - pos.y < 10 )) then */
    enum { lc2 = 7 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_pushliteral(L,"vx");
    lua_gettable(L,6);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    const int lc3 = lua_lessthan(L,-1,7);
    lua_pop(L,1);
    lua_pushboolean(L,lc3);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lua_pushliteral(L,"vz");
      lua_gettable(L,6);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      const int lc4 = lua_lessthan(L,-1,7);
      lua_pop(L,1);
      lua_pushboolean(L,lc4);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      lua_pushliteral(L,"vh");
      lua_gettable(L,6);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,40);
      const int lc5 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc5);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"vh");
        lua_gettable(L,6);
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,10);
        const int lc6 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc6);
      }
    }
    const int lc7 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc7) {
      
      /* local village_noise = minetest.get_perlin(7635, 3, 0.5, 16) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_perlin");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,7635);
      lua_pushnumber(L,3);
      lua_pushnumber(L,0.5);
      lua_pushnumber(L,16);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 8);
      
      /* if( mg_villages.inside_village_area( pos.x,  pos.z, v, village_noise)) then */
      enum { lc8 = 8 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"inside_village_area");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lua_pushvalue(L,6);
      lua_pushvalue(L,8);
      lua_call(L,4,1);
      const int lc9 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc9) {
        
        /* local node = minetest.get_node( pos ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        assert(lua_gettop(L) == 9);
        
        /* -- leaves can be digged in villages
         * if( node and node.name ) then */
        enum { lc10 = 9 };
        lua_pushvalue(L,9);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"name");
          lua_gettable(L,9);
        }
        const int lc11 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc11) {
          
          /* if(    minetest.registered_nodes[ node.name ]
           * 					   and minetest.registered_nodes[ node.name ].groups
           * 				           and minetest.registered_nodes[ node.name ].groups.leaves ) then */
          enum { lc12 = 9 };
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"name");
          lua_gettable(L,9);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"registered_nodes");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"name");
            lua_gettable(L,9);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"groups");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"registered_nodes");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"name");
            lua_gettable(L,9);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"groups");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"leaves");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          const int lc13 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc13) {
            
            /* return nil */
            lua_pushnil(L);
            return 1;
            assert(lua_gettop(L) == 9);
          }
          else {
            
            /* elseif( node.name=='default:snow' ) then */
            enum { lc14 = 9 };
            lua_pushliteral(L,"name");
            lua_gettable(L,9);
            lua_pushliteral(L,"default:snow");
            const int lc15 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc15);
            const int lc16 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc16) {
              
              /* return nil */
              lua_pushnil(L);
              return 1;
              assert(lua_gettop(L) == 9);
            }
            else {
              
              /* -- bones can be digged in villages
               * 					elseif( node.name == 'bones:bones' ) then */
              enum { lc17 = 9 };
              lua_pushliteral(L,"name");
              lua_gettable(L,9);
              lua_pushliteral(L,"bones:bones");
              const int lc18 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc18);
              const int lc19 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc19) {
                
                /* return nil */
                lua_pushnil(L);
                return 1;
                assert(lua_gettop(L) == 9);
              }
              else {
                
                /* else
                 * return id */
                lua_pushvalue(L,5);
                return 1;
                assert(lua_gettop(L) == 9);
              }
              lua_settop(L,lc17);
            }
            lua_settop(L,lc14);
          }
          lua_settop(L,lc12);
          assert(lua_gettop(L) == 9);
        }
        else {
          
          /* else
           * return id */
          lua_pushvalue(L,5);
          return 1;
          assert(lua_gettop(L) == 9);
        }
        lua_settop(L,lc10);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc8);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L,lc2);
    assert(lua_gettop(L) == 7);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 1);
  
  /* return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: mg_villages.plotmarker_search_trader
 * function( trader, height) */
static int lcf1_mg_villages_plotmarker_search_trader (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local obj_list = minetest.get_objects_inside_radius({x=trader.x, y=height, z=trader.z}, 10 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_objects_inside_radius");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushnumber(L,10);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 3);
  
  /* for i,obj in ipairs( obj_list ) do
   * internal: local f, s, var = explist */
  enum { lc20 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 7
     * internal: local obj with idx 8 */
    
    
    /* local e = obj:get_luaentity() */
    lua_pushvalue(L,8);
    lua_pushliteral(L,"get_luaentity");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 9);
    
    /* if( e and e.object ) then */
    enum { lc21 = 9 };
    lua_pushvalue(L,9);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"object");
      lua_gettable(L,9);
    }
    const int lc22 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc22) {
      
      /* local p = e.object:getpos() */
      lua_pushliteral(L,"object");
      lua_gettable(L,9);
      lua_pushliteral(L,"getpos");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 10);
      
      /* if( p and p.x and math.abs(p.x-trader.x)<1.5
       * 			      and p.z and math.abs(p.z-trader.z)<1.5
       * 			      and e.name and e.name=="mobf_trader:trader"
       * 			      and e.trader_typ and e.trader_typ==trader.typ) then */
      enum { lc23 = 10 };
      lua_pushvalue(L,10);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"x");
        lua_gettable(L,10);
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_pushnumber(L,1.5);
        const int lc24 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc24);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"abs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,10);
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_pushnumber(L,1.5);
        const int lc25 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc25);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,9);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,9);
        lua_pushliteral(L,"mobf_trader:trader");
        const int lc26 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc26);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"trader_typ");
        lua_gettable(L,9);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"trader_typ");
        lua_gettable(L,9);
        lua_pushliteral(L,"typ");
        lua_gettable(L,1);
        const int lc27 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc27);
      }
      const int lc28 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc28) {
      }
      lua_settop(L,lc23);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc21);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc20);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.check_plot_marker
 * function( p, plot_nr, village_id) */
static int lcf1_mg_villages_check_plot_marker (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- roads cannot be bought
   * if( p.btype and p.btype=="road" ) then */
  enum { lc29 = 3 };
  lua_pushliteral(L,"btype");
  lua_gettable(L,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"btype");
    lua_gettable(L,1);
    lua_pushliteral(L,"road");
    const int lc30 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc30);
  }
  const int lc31 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc31) {
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc29);
  assert(lua_gettop(L) == 3);
  
  /* local plot_pos = { x=p.x, y=p.y, z=p.z } */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 4);
  
  /* if(      p.o==3 ) then */
  enum { lc32 = 4 };
  lua_pushliteral(L,"o");
  lua_gettable(L,1);
  lua_pushnumber(L,3);
  const int lc33 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc33);
  const int lc34 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc34) {
    
    /* plot_pos = { x=p.x,            y=p.y+1, z=p.z-1          } */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* elseif(  p.o==1 ) then */
    enum { lc35 = 4 };
    lua_pushliteral(L,"o");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    const int lc36 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc36);
    const int lc37 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc37) {
      
      /* plot_pos = { x=p.x+p.bsizex-1, y=p.y+1, z=p.z+p.bsizez   } */
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lua_pushliteral(L,"bsizex");
      lua_gettable(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_replace(L,4);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* elseif ( p.o==2 ) then */
      enum { lc38 = 4 };
      lua_pushliteral(L,"o");
      lua_gettable(L,1);
      lua_pushnumber(L,2);
      const int lc39 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc39);
      const int lc40 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc40) {
        
        /* plot_pos = { x=p.x+p.bsizex,   y=p.y+1, z=p.z            } */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lua_pushliteral(L,"bsizex");
        lua_gettable(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lua_rawset(L,-3);
        lua_replace(L,4);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* elseif ( p.o==0 ) then */
        enum { lc41 = 4 };
        lua_pushliteral(L,"o");
        lua_gettable(L,1);
        lua_pushnumber(L,0);
        const int lc42 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc42);
        const int lc43 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc43) {
          
          /* plot_pos = { x=p.x-1,          y=p.y+1, z=p.z+p.bsizez-1 } */
          lua_createtable(L,0,3);
          lua_pushliteral(L,"x");
          lua_pushliteral(L,"x");
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushliteral(L,"y");
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushliteral(L,"z");
          lua_gettable(L,1);
          lua_pushliteral(L,"bsizez");
          lua_gettable(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_replace(L,4);
          assert(lua_gettop(L) == 4);
        }
        lua_settop(L,lc41);
      }
      lua_settop(L,lc38);
    }
    lua_settop(L,lc35);
  }
  lua_settop(L,lc32);
  assert(lua_gettop(L) == 4);
  
  /* -- is the plotmarker still present?
   * local node = minetest.get_node( plot_pos ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* if( not(node) or not(node.name) or node.name ~= "mg_villages:plotmarker" ) then */
  enum { lc44 = 5 };
  lua_pushboolean(L,!(lua_toboolean(L,5)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,5);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,5);
    lua_pushliteral(L,"mg_villages:plotmarker");
    const int lc45 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc45);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc46 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc46) {
    
    /* -- place a new one if needed
     * minetest.set_node( plot_pos, {name="mg_villages:plotmarker", param2=p.o}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"set_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"mg_villages:plotmarker");
    lua_rawset(L,-3);
    lua_pushliteral(L,"param2");
    lua_pushliteral(L,"o");
    lua_gettable(L,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* local meta = minetest.get_meta( plot_pos ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_meta");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 6);
    
    /* -- strange error happend; maybe we're more lucky next time...
     * if( not( meta )) then */
    enum { lc47 = 6 };
    lua_pushboolean(L,!(lua_toboolean(L,6)));
    const int lc48 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc48) {
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc47);
    assert(lua_gettop(L) == 6);
    
    /* meta:set_string('village_id', village_id ) */
    lua_pushvalue(L,6);
    lua_pushliteral(L,"set_string");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"village_id");
    lua_pushvalue(L,3);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 6);
    
    /* meta:set_int(   'plot_nr',    plot_nr ) */
    lua_pushvalue(L,6);
    lua_pushliteral(L,"set_int");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"plot_nr");
    lua_pushvalue(L,2);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc44);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: minetest.is_protected
 * function(pos, name) */
static int lcf1_minetest_is_protected (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if( not( mg_villages.ENABLE_PROTECTION )) then */
  enum { lc50 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"ENABLE_PROTECTION");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc51 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc51) {
    
    /* return old_is_protected( pos, name ) */
    const int lc52 = lua_gettop(L);
    lc_getupvalue(L,lua_upvalueindex(1),0,1);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_call(L,2,LUA_MULTRET);
    return (lua_gettop(L) - lc52);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc50);
  assert(lua_gettop(L) == 2);
  
  /* local village_id = mg_villages.get_town_id_at_pos( pos ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_town_id_at_pos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if( village_id ) then */
  enum { lc53 = 3 };
  if (lua_toboolean(L,3)) {
    
    /* local is_houseowner = false */
    lua_pushboolean(L,0);
    assert(lua_gettop(L) == 4);
    
    /* for nr, p in ipairs( mg_villages.all_villages[ village_id ].to_add_data.bpos ) do
     * internal: local f, s, var = explist */
    enum { lc54 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bpos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local nr with idx 8
       * internal: local p with idx 9 */
      
      
      /* trustedusers = p.can_edit */
      lua_pushliteral(L,"can_edit");
      lua_gettable(L,9);
      lua_setfield(L,LUA_ENVIRONINDEX,"trustedusers");
      assert(lua_gettop(L) == 9);
      
      /* trustedUser = false */
      lua_pushboolean(L,0);
      lua_setfield(L,LUA_ENVIRONINDEX,"trustedUser");
      assert(lua_gettop(L) == 9);
      
      /* if trustedusers ~= nil then */
      enum { lc55 = 9 };
      lua_getfield(L,LUA_ENVIRONINDEX,"trustedusers");
      lua_pushnil(L);
      const int lc56 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc56);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc57 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc57) {
        
        /* for _,trusted in ipairs(trustedusers) do
         * internal: local f, s, var = explist */
        enum { lc58 = 9 };
        lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
        lua_getfield(L,LUA_ENVIRONINDEX,"trustedusers");
        lua_call(L,1,3);
        while (1) {
          
          /* internal: local var_1, ..., var_n = f(s, var)
           *           if var_1 == nil then break end
           *           var = var_1 */
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_call(L,2,2);
          if (lua_isnil(L,-2)) {
            break;
          }
          lua_pushvalue(L,-2);
          lua_replace(L,-4);
          
          /* internal: local _ with idx 13
           * internal: local trusted with idx 14 */
          
          
          /* if trusted == name then */
          enum { lc59 = 14 };
          const int lc60 = lua_equal(L,14,2);
          lua_pushboolean(L,lc60);
          const int lc61 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc61) {
            
            /* trustedUser = true */
            lua_pushboolean(L,1);
            lua_setfield(L,LUA_ENVIRONINDEX,"trustedUser");
            assert(lua_gettop(L) == 14);
          }
          lua_settop(L,lc59);
          assert(lua_gettop(L) == 14);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,2);
        }
        lua_settop(L,lc58);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc55);
      assert(lua_gettop(L) == 9);
      
      /* -- we have located the right plot; the player can build here if he owns this particular plot
       * if(   p.x <= pos.x and (p.x + p.bsizex) >= pos.x
       * 			  and p.z <= pos.z and (p.z + p.bsizez) >= pos.z) then */
      enum { lc62 = 9 };
      lua_pushliteral(L,"x");
      lua_gettable(L,9);
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      const int lc63 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc63);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"x");
        lua_gettable(L,1);
        lua_pushliteral(L,"x");
        lua_gettable(L,9);
        lua_pushliteral(L,"bsizex");
        lua_gettable(L,9);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc64 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc64);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        const int lc65 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc65);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"z");
        lua_gettable(L,1);
        lua_pushliteral(L,"z");
        lua_gettable(L,9);
        lua_pushliteral(L,"bsizez");
        lua_gettable(L,9);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc66 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc66);
      }
      const int lc67 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc67) {
        
        /* -- place a new plot marker if necessary
         * mg_villages.check_plot_marker( p, nr, village_id ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"check_plot_marker");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,9);
        lua_pushvalue(L,8);
        lua_pushvalue(L,3);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 9);
        
        /* -- If player has been trusted by owner, can build
         * if (trustedUser) then */
        enum { lc68 = 9 };
        lua_getfield(L,LUA_ENVIRONINDEX,"trustedUser");
        const int lc69 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc69) {
          
          /* return false */
          lua_pushboolean(L,0);
          return 1;
          assert(lua_gettop(L) == 9);
        }
        else {
          
          /* -- If player is owner, can build
           * 				elseif( p.owner and p.owner == name ) then */
          enum { lc70 = 9 };
          lua_pushliteral(L,"owner");
          lua_gettable(L,9);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"owner");
            lua_gettable(L,9);
            lua_pushvalue(L,2);
            const int lc71 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc71);
          }
          const int lc72 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc72) {
            
            /* return false */
            lua_pushboolean(L,0);
            return 1;
            assert(lua_gettop(L) == 9);
          }
          else {
            
            /* -- the allmende can be used by all
             * 				elseif( mg_villages.BUILDINGS[p.btype] and mg_villages.BUILDINGS[p.btype].typ=="allmende" ) then */
            enum { lc73 = 9 };
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"BUILDINGS");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"btype");
            lua_gettable(L,9);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"BUILDINGS");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"btype");
              lua_gettable(L,9);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"typ");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushliteral(L,"allmende");
              const int lc74 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc74);
            }
            const int lc75 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc75) {
              
              /* return false */
              lua_pushboolean(L,0);
              return 1;
              assert(lua_gettop(L) == 9);
            }
            else {
              
              /* else
               * return true */
              lua_pushboolean(L,1);
              return 1;
              assert(lua_gettop(L) == 9);
            }
            lua_settop(L,lc73);
          }
          lua_settop(L,lc70);
        }
        lua_settop(L,lc68);
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* -- if the player just owns another plot in the village, check if it's one where villagers may live
         * 			elseif( p.owner and p.owner == name or trustedUser) then */
        enum { lc76 = 9 };
        lua_pushliteral(L,"owner");
        lua_gettable(L,9);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"owner");
          lua_gettable(L,9);
          lua_pushvalue(L,2);
          const int lc77 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc77);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"trustedUser");
        }
        const int lc78 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc78) {
          
          /* local btype = mg_villages.all_villages[ village_id ].to_add_data.bpos[ nr ].btype */
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"all_villages");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,3);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"to_add_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"bpos");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,8);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"btype");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          assert(lua_gettop(L) == 10);
          
          /* if(   btype ~= 'road'
           * 				  and mg_villages.BUILDINGS[btype]
           * 				  and mg_villages.BUILDINGS[btype].inh
           * 				  and mg_villages.BUILDINGS[btype].inh > 0 ) then */
          enum { lc79 = 10 };
          lua_pushliteral(L,"road");
          const int lc80 = lua_equal(L,10,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc80);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"BUILDINGS");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,10);
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"BUILDINGS");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,10);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"inh");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushnumber(L,0);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"BUILDINGS");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,10);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"inh");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            const int lc81 = lua_lessthan(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc81);
          }
          const int lc82 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc82) {
            
            /* is_houseowner = true */
            lua_pushboolean(L,1);
            lua_replace(L,4);
            assert(lua_gettop(L) == 10);
            
            /* -- check the node below
             * local node = minetest.get_node( {x=pos.x, y=pos.y-1, z=pos.z}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"get_node");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_createtable(L,0,3);
            lua_pushliteral(L,"x");
            lua_pushliteral(L,"x");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushliteral(L,"y");
            lua_gettable(L,1);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushliteral(L,"z");
            lua_gettable(L,1);
            lua_rawset(L,-3);
            lua_call(L,1,1);
            assert(lua_gettop(L) == 11);
            
            /* -- replace the fake, inaktive village soil with real farming soil if a player diggs the plant above
             * if( node and node.name and node.name=="mg_villages:soil" ) then */
            enum { lc83 = 11 };
            lua_pushvalue(L,11);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,11);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"name");
              lua_gettable(L,11);
              lua_pushliteral(L,"mg_villages:soil");
              const int lc84 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc84);
            }
            const int lc85 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc85) {
              
              /* minetest.swap_node( {x=pos.x, y=pos.y-1, z=pos.z}, {name="farming:soil_wet"}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"swap_node");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_createtable(L,0,3);
              lua_pushliteral(L,"x");
              lua_pushliteral(L,"x");
              lua_gettable(L,1);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushliteral(L,"y");
              lua_gettable(L,1);
              lua_pushnumber(L,1);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushliteral(L,"z");
              lua_gettable(L,1);
              lua_rawset(L,-3);
              lua_createtable(L,0,1);
              lua_pushliteral(L,"name");
              lua_pushliteral(L,"farming:soil_wet");
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 11);
            }
            lua_settop(L,lc83);
            assert(lua_gettop(L) == 11);
          }
          lua_settop(L,lc79);
          assert(lua_gettop(L) == 10);
        }
        lua_settop(L,lc76);
      }
      lua_settop(L,lc62);
      assert(lua_gettop(L) == 9);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc54);
    assert(lua_gettop(L) == 4);
    
    /* -- players who own a house in town where villagers may live (not only work!)
     * --  are allowed to modify common ground
     * if( is_houseowner ) then */
    enum { lc86 = 4 };
    if (lua_toboolean(L,4)) {
      
      /* return false */
      lua_pushboolean(L,0);
      return 1;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc86);
    assert(lua_gettop(L) == 4);
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc53);
  assert(lua_gettop(L) == 3);
  
  /* return old_is_protected(pos, name) */
  const int lc87 = lua_gettop(L);
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,LUA_MULTRET);
  return (lua_gettop(L) - lc87);
  assert(lua_gettop(L) == 3);
}


/* function(pos, name) */
static int lcf92 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if( not( mg_villages.ENABLE_PROTECTION )) then */
  enum { lc88 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"ENABLE_PROTECTION");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc89 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc89) {
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc88);
  assert(lua_gettop(L) == 2);
  
  /* local found = mg_villages.get_town_id_at_pos( pos ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_town_id_at_pos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if( not( found ) or not( mg_villages.all_villages[ found ])) then */
  enum { lc90 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc91 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc91) {
    
    /* minetest.chat_send_player( name, 'Error: This area does not belong to a village.') */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"chat_send_player");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"Error: This area does not belong to a village.");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc90);
  assert(lua_gettop(L) == 3);
  
  /* minetest.chat_send_player( name, "You are inside of the area of the village "..
   * 		tostring( mg_villages.all_villages[ found ].name )..
   * 		". The inhabitants do not allow you any modifications.") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"chat_send_player");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"You are inside of the area of the village ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,". The inhabitants do not allow you any modifications.");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: mg_villages.plotmarker_formspec
 * function( pos, formname, fields, player) */
static int lcf1_mg_villages_plotmarker_formspec (lua_State * L) {
  lua_checkstack(L,40);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* --	if( not( mg_villages.ENABLE_PROTECTION )) then
   * --		return;
   * --	end
   * local meta = minetest.get_meta( pos ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_meta");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* if( not( meta )) then */
  enum { lc93 = 5 };
  lua_pushboolean(L,!(lua_toboolean(L,5)));
  const int lc94 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc94) {
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc93);
  assert(lua_gettop(L) == 5);
  
  /* local village_id = meta:get_string('village_id') */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"get_string");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"village_id");
  lua_call(L,2,1);
  assert(lua_gettop(L) == 6);
  
  /* local plot_nr    = meta:get_int(   'plot_nr') */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"get_int");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"plot_nr");
  lua_call(L,2,1);
  assert(lua_gettop(L) == 7);
  
  /* local pname      = player:get_player_name() */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get_player_name");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 8);
  
  /* if( not( village_id )
   * 		or not( mg_villages.all_villages )
   * 		or not( mg_villages.all_villages[ village_id ] )
   * 		or not( plot_nr )
   * 		or not( mg_villages.all_villages[ village_id ].to_add_data )
   * 		or not( mg_villages.all_villages[ village_id ].to_add_data.bpos )
   * 		or not( mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ] )) then */
  enum { lc95 = 8 };
  lua_pushboolean(L,!(lua_toboolean(L,6)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,7)));
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bpos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,6);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bpos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,7);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc96 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc96) {
    
    /* minetest.chat_send_player( pname, 'Error. This plot marker is not configured correctly.'..minetest.serialize({village_id,plot_nr })) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"chat_send_player");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,8);
    lua_pushliteral(L,"Error. This plot marker is not configured correctly.");
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"serialize");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,2,0);
    lua_pushvalue(L,6);
    lua_rawseti(L,-2,1);
    lua_pushvalue(L,7);
    lua_rawseti(L,-2,2);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 8);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc95);
  assert(lua_gettop(L) == 8);
  
  /* local village    = mg_villages.all_villages[ village_id ] */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,6);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 9);
  
  /* local plot       = mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ] */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,6);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,7);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 10);
  
  /* local owner_name = plot.owner */
  lua_pushliteral(L,"owner");
  lua_gettable(L,10);
  assert(lua_gettop(L) == 11);
  
  /* if( not( owner_name ) or owner_name == "" ) then */
  enum { lc97 = 11 };
  lua_pushboolean(L,!(lua_toboolean(L,11)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"");
    const int lc98 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc98);
  }
  const int lc99 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc99) {
    
    /* if( plot.btype=="road" ) then */
    enum { lc100 = 11 };
    lua_pushliteral(L,"btype");
    lua_gettable(L,10);
    lua_pushliteral(L,"road");
    const int lc101 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc101);
    const int lc102 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc102) {
      
      /* owner_name = "- the village community -" */
      lua_pushliteral(L,"- the village community -");
      lua_replace(L,11);
      assert(lua_gettop(L) == 11);
    }
    else {
      
      /* else
       * owner_name = "- for sale -" */
      lua_pushliteral(L,"- for sale -");
      lua_replace(L,11);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc100);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc97);
  assert(lua_gettop(L) == 11);
  
  /* local building_name = mg_villages.BUILDINGS[ plot.btype ].mts_path..mg_villages.BUILDINGS[ plot.btype ].scm */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"btype");
  lua_gettable(L,10);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mts_path");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"btype");
  lua_gettable(L,10);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"scm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_concat(L,2);
  assert(lua_gettop(L) == 12);
  
  /* -- show coordinates of the village center to the player
   * local village_pos = minetest.pos_to_string( {x=village.vx, y=village.vh, z=village.vz}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"pos_to_string");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"vx");
  lua_gettable(L,9);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"vh");
  lua_gettable(L,9);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"vz");
  lua_gettable(L,9);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 13);
  
  /* -- distance from village center
   * local distance = math.floor( math.sqrt( (village.vx - pos.x ) * (village.vx - pos.x )
   * 					      + (village.vh - pos.y ) * (village.vh - pos.y )
   * 					      + (village.vz - pos.z ) * (village.vz - pos.z ) )) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc103 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"sqrt");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vx");
  lua_gettable(L,9);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vx");
  lua_gettable(L,9);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vh");
  lua_gettable(L,9);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vh");
  lua_gettable(L,9);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vz");
  lua_gettable(L,9);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vz");
  lua_gettable(L,9);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc103),1);
  assert(lua_gettop(L) == 14);
  
  /* -- create the header
   * local formspec = "size[13,10]"..
   * 		"label[3.3,0.0;Plot No.: "..tostring( plot_nr )..", with "..tostring( mg_villages.BUILDINGS[ plot.btype ].scm ).."]"..
   * 		"label[0.3,0.4;Located at:]"      .."label[3.3,0.4;"..(minetest.pos_to_string( pos ) or '?')..", which is "..tostring( distance ).." m away]"
   * 		                                  .."label[7.3,0.4;from the village center]"..
   * 		"label[0.3,0.8;Part of village:]" .."label[3.3,0.8;"..(village.name or "- name unknown -").."]"
   * 		                                  .."label[7.3,0.8;located at "..(village_pos).."]"..
   * 		"label[0.3,1.2;Owned by:]"        .."label[3.3,1.2;"..(owner_name).."]"..
   * 		"label[3.3,1.6;Click on a menu entry to select it:]"..
   * 		"field[20,20;0.1,0.1;pos2str;Pos;"..minetest.pos_to_string( pos ).."]" */
  lua_pushliteral(L,"size[13,10]");
  lua_pushliteral(L,"label[3.3,0.0;Plot No.: ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,7);
  lua_call(L,1,1);
  lua_pushliteral(L,", with ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"btype");
  lua_gettable(L,10);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"scm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"label[0.3,0.4;Located at:]");
  lua_pushliteral(L,"label[3.3,0.4;");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"pos_to_string");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"?");
  }
  lua_pushliteral(L,", which is ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,14);
  lua_call(L,1,1);
  lua_pushliteral(L," m away]");
  lua_pushliteral(L,"label[7.3,0.4;from the village center]");
  lua_pushliteral(L,"label[0.3,0.8;Part of village:]");
  lua_pushliteral(L,"label[3.3,0.8;");
  lua_pushliteral(L,"name");
  lua_gettable(L,9);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"- name unknown -");
  }
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"label[7.3,0.8;located at ");
  lua_pushvalue(L,13);
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"label[0.3,1.2;Owned by:]");
  lua_pushliteral(L,"label[3.3,1.2;");
  lua_pushvalue(L,11);
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"label[3.3,1.6;Click on a menu entry to select it:]");
  lua_pushliteral(L,"field[20,20;0.1,0.1;pos2str;Pos;");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"pos_to_string");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"]");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  assert(lua_gettop(L) == 15);
  
  /* build_chest.show_size_data( building_name ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
  lua_pushliteral(L,"show_size_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,12);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 15);
  
  /* if( plot and plot.traders ) then */
  enum { lc104 = 15 };
  lua_pushvalue(L,10);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"traders");
    lua_gettable(L,10);
  }
  const int lc105 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc105) {
    
    /* if( #plot.traders > 1 ) then */
    enum { lc106 = 15 };
    lua_pushnumber(L,1);
    lua_pushliteral(L,"traders");
    lua_gettable(L,10);
    const double lc107 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc107);
    const int lc108 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc108);
    const int lc109 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc109) {
      
      /* formspec = formspec.."label[0.3,7.0;Some traders live here. One works as a "..tostring(plot.traders[1].typ)..".]" */
      lua_pushvalue(L,15);
      lua_pushliteral(L,"label[0.3,7.0;Some traders live here. One works as a ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"traders");
      lua_gettable(L,10);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"typ");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_pushliteral(L,".]");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,15);
      assert(lua_gettop(L) == 15);
      
      /* for i=2,#plot.traders do */
      lua_pushnumber(L,2);
      lua_pushliteral(L,"traders");
      lua_gettable(L,10);
      const double lc113 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc113);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc110_var = lua_tonumber(L,-2);
      const double lc111_limit = lua_tonumber(L,-1);
      const double lc112_step = 1;
      lua_pop(L,2);
      enum { lc114 = 15 };
      while ((((lc112_step > 0) && (lc110_var <= lc111_limit)) || ((lc112_step <= 0) && (lc110_var >= lc111_limit)))) {
        
        /* internal: local i at index 16 */
        lua_pushnumber(L,lc110_var);
        
        /* formspec = formspec.."label[0.3,"..(6.0+i)..";Another trader works as a "..tostring(plot.traders[i].typ)..".]" */
        lua_pushvalue(L,15);
        lua_pushliteral(L,"label[0.3,");
        lua_pushnumber(L,6);
        lc_add(L,-1,16);
        lua_remove(L,-2);
        lua_pushliteral(L,";Another trader works as a ");
        lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
        lua_pushliteral(L,"traders");
        lua_gettable(L,10);
        lua_pushvalue(L,16);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"typ");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,".]");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 16);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc110_var += lc112_step;
      }
      lua_settop(L,lc114);
      assert(lua_gettop(L) == 15);
    }
    else {
      
      /* elseif( plot.traders[1] and plot.traders[1].typ) then */
      enum { lc115 = 15 };
      lua_pushliteral(L,"traders");
      lua_gettable(L,10);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"traders");
        lua_gettable(L,10);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"typ");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      const int lc116 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc116) {
        
        /* formspec = formspec..
         * 				"label[0.3,7.0;A trader lives here. He works as a "..tostring( plot.traders[1].typ )..".]" */
        lua_pushvalue(L,15);
        lua_pushliteral(L,"label[0.3,7.0;A trader lives here. He works as a ");
        lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
        lua_pushliteral(L,"traders");
        lua_gettable(L,10);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"typ");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_pushliteral(L,".]");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 15);
      }
      else {
        
        /* else
         * formspec = formspec..
         * 				"label[0.3,7.0;No trader currently works at this place.]" */
        lua_pushvalue(L,15);
        lua_pushliteral(L,"label[0.3,7.0;No trader currently works at this place.]");
        lua_concat(L,2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc115);
    }
    lua_settop(L,lc106);
    assert(lua_gettop(L) == 15);
    
    /* -- add buttons for visiting (teleport to trader), calling (teleporting trader to plot) and firing the trader
     * for i,trader in ipairs(plot.traders) do
     * internal: local f, s, var = explist */
    enum { lc117 = 15 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushliteral(L,"traders");
    lua_gettable(L,10);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local i with idx 19
       * internal: local trader with idx 20 */
      
      
      /* local trader_entity = mg_villages.plotmarker_search_trader( trader, village.vh ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"plotmarker_search_trader");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,20);
      lua_pushliteral(L,"vh");
      lua_gettable(L,9);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 21);
      
      /* formspec = formspec..
       * 					"button[6.0,"..(6.0+i)..";1.2,0.5;visit_trader_"..i..";visit]"..
       * 					"button[7.4,"..(6.0+i)..";1.2,0.5;call_trader_"..i..";call]"..
       * 					"button[8.8,"..(6.0+i)..";1.2,0.5;fire_trader_"..i..";fire]" */
      lua_pushvalue(L,15);
      lua_pushliteral(L,"button[6.0,");
      lua_pushnumber(L,6);
      lc_add(L,-1,19);
      lua_remove(L,-2);
      lua_pushliteral(L,";1.2,0.5;visit_trader_");
      lua_pushvalue(L,19);
      lua_pushliteral(L,";visit]");
      lua_pushliteral(L,"button[7.4,");
      lua_pushnumber(L,6);
      lc_add(L,-1,19);
      lua_remove(L,-2);
      lua_pushliteral(L,";1.2,0.5;call_trader_");
      lua_pushvalue(L,19);
      lua_pushliteral(L,";call]");
      lua_pushliteral(L,"button[8.8,");
      lua_pushnumber(L,6);
      lc_add(L,-1,19);
      lua_remove(L,-2);
      lua_pushliteral(L,";1.2,0.5;fire_trader_");
      lua_pushvalue(L,19);
      lua_pushliteral(L,";fire]");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,15);
      assert(lua_gettop(L) == 21);
      
      /* if( fields[ "visit_trader_"..i ] ) then */
      enum { lc118 = 21 };
      lua_pushliteral(L,"visit_trader_");
      lua_pushvalue(L,19);
      lua_concat(L,2);
      lua_gettable(L,3);
      const int lc119 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc119) {
        
        /* player:moveto( {x=trader.x, y=(village.vh+1), z=trader.z} ) */
        lua_pushvalue(L,4);
        lua_pushliteral(L,"moveto");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,20);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"vh");
        lua_gettable(L,9);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,20);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 21);
        
        /* minetest.chat_send_player( pname, "You are visiting the "..tostring( trader.typ )..
         * 					" trader, who is supposed to be somewhere here. He might also be on a floor above you.") */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"chat_send_player");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"You are visiting the ");
        lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
        lua_pushliteral(L,"typ");
        lua_gettable(L,20);
        lua_call(L,1,1);
        lua_pushliteral(L," trader, who is supposed to be somewhere here. He might also be on a floor above you.");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 21);
        
        /* return; */
        return 0;
        assert(lua_gettop(L) == 21);
      }
      lua_settop(L,lc118);
      assert(lua_gettop(L) == 21);
      
      /* if( fields[ "visit_call_"..i ] ) then */
      enum { lc120 = 21 };
      lua_pushliteral(L,"visit_call_");
      lua_pushvalue(L,19);
      lua_concat(L,2);
      lua_gettable(L,3);
      const int lc121 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc121) {
      }
      lua_settop(L,lc120);
      assert(lua_gettop(L) == 21);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
    }
    lua_settop(L,lc117);
    assert(lua_gettop(L) == 15);
    
    /* formspec = formspec.."button[3.75,"..(7.0+math.max(1,#plot.traders))..";3.5,0.5;hire_trader;Hire a new random trader]" */
    lua_pushvalue(L,15);
    lua_pushliteral(L,"button[3.75,");
    lua_pushnumber(L,7);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushliteral(L,"traders");
    lua_gettable(L,10);
    const double lc122 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc122);
    lua_call(L,2,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,";3.5,0.5;hire_trader;Hire a new random trader]");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_replace(L,15);
    assert(lua_gettop(L) == 15);
  }
  lua_settop(L,lc104);
  assert(lua_gettop(L) == 15);
  
  /* local replace_row = -1 */
  lua_pushnumber(L,-1);
  assert(lua_gettop(L) == 16);
  
  /* -- the player selected a material which ought to be replaced
   * if(     fields.build_chest_replacements ) then */
  enum { lc123 = 16 };
  lua_pushliteral(L,"build_chest_replacements");
  lua_gettable(L,3);
  const int lc124 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc124) {
    
    /* local event = minetest.explode_table_event( fields.build_chest_replacements ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"explode_table_event");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"build_chest_replacements");
    lua_gettable(L,3);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 17);
    
    /* if( event and event.row and event.row > 0 ) then */
    enum { lc125 = 17 };
    lua_pushvalue(L,17);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"row");
      lua_gettable(L,17);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
      lua_pushliteral(L,"row");
      lua_gettable(L,17);
      const int lc126 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc126);
    }
    const int lc127 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc127) {
      
      /* replace_row = event.row */
      lua_pushliteral(L,"row");
      lua_gettable(L,17);
      lua_replace(L,16);
      assert(lua_gettop(L) == 17);
      
      /* fields.show_materials = "show_materials" */
      lua_pushliteral(L,"show_materials");
      lua_pushliteral(L,"show_materials");
      lua_insert(L,-2);
      lua_settable(L,3);
      assert(lua_gettop(L) == 17);
    }
    lua_settop(L,lc125);
    assert(lua_gettop(L) == 17);
  }
  else {
    
    /* -- the player provided the name of the material for the replacement of the currently selected
     * 	elseif( fields.store_replacement    and fields.store_repalcement    ~= ""
     * 	    and fields.replace_row_with     and fields.replace_row_with     ~= ""
     * 	    and fields.replace_row_material and fields.replace_row_material ~= "") then */
    enum { lc128 = 16 };
    lua_pushliteral(L,"store_replacement");
    lua_gettable(L,3);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"store_repalcement");
      lua_gettable(L,3);
      lua_pushliteral(L,"");
      const int lc129 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc129);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_row_with");
      lua_gettable(L,3);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_row_with");
      lua_gettable(L,3);
      lua_pushliteral(L,"");
      const int lc130 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc130);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_row_material");
      lua_gettable(L,3);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_row_material");
      lua_gettable(L,3);
      lua_pushliteral(L,"");
      const int lc131 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc131);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc132 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc132) {
      
      /* build_chest.replacements_apply( pos, meta, fields.replace_row_material, fields.replace_row_with, village_id ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
      lua_pushliteral(L,"replacements_apply");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"replace_row_material");
      lua_gettable(L,3);
      lua_pushliteral(L,"replace_row_with");
      lua_gettable(L,3);
      lua_pushvalue(L,6);
      lua_call(L,5,0);
      assert(lua_gettop(L) == 16);
      
      /* fields.show_materials = "show_materials" */
      lua_pushliteral(L,"show_materials");
      lua_pushliteral(L,"show_materials");
      lua_insert(L,-2);
      lua_settable(L,3);
      assert(lua_gettop(L) == 16);
    }
    else {
      
      /* -- group selections for easily changing several nodes at once
       * 	elseif( fields.wood_selection ) then */
      enum { lc133 = 16 };
      lua_pushliteral(L,"wood_selection");
      lua_gettable(L,3);
      const int lc134 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc134) {
        
        /* build_chest.replacements_apply_for_group( pos, meta, 'wood',    fields.wood_selection,    fields.set_wood,    village_id ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
        lua_pushliteral(L,"replacements_apply_for_group");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,5);
        lua_pushliteral(L,"wood");
        lua_pushliteral(L,"wood_selection");
        lua_gettable(L,3);
        lua_pushliteral(L,"set_wood");
        lua_gettable(L,3);
        lua_pushvalue(L,6);
        lua_call(L,6,0);
        assert(lua_gettop(L) == 16);
        
        /* fields.set_wood    = nil */
        lua_pushnil(L);
        lua_pushliteral(L,"set_wood");
        lua_insert(L,-2);
        lua_settable(L,3);
        assert(lua_gettop(L) == 16);
        
        /* fields.show_materials = "show_materials" */
        lua_pushliteral(L,"show_materials");
        lua_pushliteral(L,"show_materials");
        lua_insert(L,-2);
        lua_settable(L,3);
        assert(lua_gettop(L) == 16);
      }
      else {
        
        /* elseif( fields.farming_selection ) then */
        enum { lc135 = 16 };
        lua_pushliteral(L,"farming_selection");
        lua_gettable(L,3);
        const int lc136 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc136) {
          
          /* build_chest.replacements_apply_for_group( pos, meta, 'farming', fields.farming_selection, fields.set_farming, village_id ) */
          lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
          lua_pushliteral(L,"replacements_apply_for_group");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_pushvalue(L,5);
          lua_pushliteral(L,"farming");
          lua_pushliteral(L,"farming_selection");
          lua_gettable(L,3);
          lua_pushliteral(L,"set_farming");
          lua_gettable(L,3);
          lua_pushvalue(L,6);
          lua_call(L,6,0);
          assert(lua_gettop(L) == 16);
          
          /* fields.set_farming = nil */
          lua_pushnil(L);
          lua_pushliteral(L,"set_farming");
          lua_insert(L,-2);
          lua_settable(L,3);
          assert(lua_gettop(L) == 16);
          
          /* fields.show_materials = "show_materials" */
          lua_pushliteral(L,"show_materials");
          lua_pushliteral(L,"show_materials");
          lua_insert(L,-2);
          lua_settable(L,3);
          assert(lua_gettop(L) == 16);
        }
        else {
          
          /* elseif( fields.roof_selection ) then */
          enum { lc137 = 16 };
          lua_pushliteral(L,"roof_selection");
          lua_gettable(L,3);
          const int lc138 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc138) {
            
            /* build_chest.replacements_apply_for_group( pos, meta, 'roof',    fields.roof_selection,    fields.set_roof,    village_id ) */
            lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
            lua_pushliteral(L,"replacements_apply_for_group");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_pushvalue(L,5);
            lua_pushliteral(L,"roof");
            lua_pushliteral(L,"roof_selection");
            lua_gettable(L,3);
            lua_pushliteral(L,"set_roof");
            lua_gettable(L,3);
            lua_pushvalue(L,6);
            lua_call(L,6,0);
            assert(lua_gettop(L) == 16);
            
            /* fields.set_roof    = nil */
            lua_pushnil(L);
            lua_pushliteral(L,"set_roof");
            lua_insert(L,-2);
            lua_settable(L,3);
            assert(lua_gettop(L) == 16);
            
            /* fields.show_materials = "show_materials" */
            lua_pushliteral(L,"show_materials");
            lua_pushliteral(L,"show_materials");
            lua_insert(L,-2);
            lua_settable(L,3);
            assert(lua_gettop(L) == 16);
          }
          else {
            
            /* -- actually store the new group replacement
             * 	elseif(  (fields.set_wood    and fields.set_wood     ~= "")
             * 	      or (fields.set_farming and fields.set_farming ~= "" )
             * 	      or (fields.set_roof    and fields.set_roof    ~= "" )) then */
            enum { lc139 = 16 };
            lua_pushliteral(L,"set_wood");
            lua_gettable(L,3);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushliteral(L,"set_wood");
              lua_gettable(L,3);
              lua_pushliteral(L,"");
              const int lc140 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc140);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushliteral(L,"set_farming");
              lua_gettable(L,3);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"set_farming");
                lua_gettable(L,3);
                lua_pushliteral(L,"");
                const int lc141 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc141);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
              }
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushliteral(L,"set_roof");
              lua_gettable(L,3);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"set_roof");
                lua_gettable(L,3);
                lua_pushliteral(L,"");
                const int lc142 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc142);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
              }
            }
            const int lc143 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc143) {
              
              /* minetest.show_formspec( pname, "mg_villages:plotmarker",
               * 				handle_schematics.get_formspec_group_replacement( pos, fields, formspec )) */
              lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
              lua_pushliteral(L,"show_formspec");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              const int lc144 = lua_gettop(L);
              lua_pushvalue(L,8);
              lua_pushliteral(L,"mg_villages:plotmarker");
              lua_getfield(L,LUA_ENVIRONINDEX,"handle_schematics");
              lua_pushliteral(L,"get_formspec_group_replacement");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,1);
              lua_pushvalue(L,3);
              lua_pushvalue(L,15);
              lua_call(L,3,LUA_MULTRET);
              lua_call(L,(lua_gettop(L) - lc144),0);
              assert(lua_gettop(L) == 16);
              
              /* return; */
              return 0;
              assert(lua_gettop(L) == 16);
            }
            lua_settop(L,lc139);
          }
          lua_settop(L,lc137);
        }
        lua_settop(L,lc135);
      }
      lua_settop(L,lc133);
    }
    lua_settop(L,lc128);
  }
  lua_settop(L,lc123);
  assert(lua_gettop(L) == 16);
  
  /* -- show which materials (and replacements!) where used for the building
   * if( (fields.show_materials       and fields.show_materials ~= "" )
   * 	 or (fields.replace_row_with     and fields.replace_row_with ~= "")
   * 	 or (fields.replace_row_material and fields.replace_row_material ~= "")) then */
  enum { lc145 = 16 };
  lua_pushliteral(L,"show_materials");
  lua_gettable(L,3);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"show_materials");
    lua_gettable(L,3);
    lua_pushliteral(L,"");
    const int lc146 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc146);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"replace_row_with");
    lua_gettable(L,3);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_row_with");
      lua_gettable(L,3);
      lua_pushliteral(L,"");
      const int lc147 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc147);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"replace_row_material");
    lua_gettable(L,3);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"replace_row_material");
      lua_gettable(L,3);
      lua_pushliteral(L,"");
      const int lc148 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc148);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
  }
  const int lc149 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc149) {
    
    /* formspec = formspec.."button[9.9,0.4;2,0.5;info;Back]" */
    lua_pushvalue(L,15);
    lua_pushliteral(L,"button[9.9,0.4;2,0.5;info;Back]");
    lua_concat(L,2);
    lua_replace(L,15);
    assert(lua_gettop(L) == 16);
    
    /* if( not( minetest.check_player_privs( pname, {protection_bypass=true}))) then */
    enum { lc150 = 16 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"check_player_privs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,8);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"protection_bypass");
    lua_pushboolean(L,1);
    lua_rawset(L,-3);
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc151 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc151) {
      
      /* -- do not allow any changes; just show the materials and their replacements
       * minetest.show_formspec( pname, "mg_villages:plotmarker",
       * 				formspec..build_chest.replacements_get_list_formspec( pos, nil, 0, meta, village_id, building_name, replace_row )) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"show_formspec");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_pushliteral(L,"mg_villages:plotmarker");
      lua_pushvalue(L,15);
      lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
      lua_pushliteral(L,"replacements_get_list_formspec");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_pushnil(L);
      lua_pushnumber(L,0);
      lua_pushvalue(L,5);
      lua_pushvalue(L,6);
      lua_pushvalue(L,12);
      lua_pushvalue(L,16);
      lua_call(L,7,1);
      lua_concat(L,2);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 16);
    }
    else {
      
      /* else
       * minetest.show_formspec( pname, "mg_villages:plotmarker",
       * 				formspec..build_chest.replacements_get_list_formspec( pos, nil, 1, nil,  village_id, building_name, replace_row )) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"show_formspec");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_pushliteral(L,"mg_villages:plotmarker");
      lua_pushvalue(L,15);
      lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
      lua_pushliteral(L,"replacements_get_list_formspec");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_pushnil(L);
      lua_pushnumber(L,1);
      lua_pushnil(L);
      lua_pushvalue(L,6);
      lua_pushvalue(L,12);
      lua_pushvalue(L,16);
      lua_call(L,7,1);
      lua_concat(L,2);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 16);
    }
    lua_settop(L,lc150);
    assert(lua_gettop(L) == 16);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 16);
  }
  else {
    
    /* -- place the building again
     * 	elseif(   (fields.reset_building  and fields.reset_building  ~= "")
     *            or (fields.remove_building and fields.remove_building ~= "")) then */
    enum { lc152 = 16 };
    lua_pushliteral(L,"reset_building");
    lua_gettable(L,3);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"reset_building");
      lua_gettable(L,3);
      lua_pushliteral(L,"");
      const int lc153 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc153);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"remove_building");
      lua_gettable(L,3);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"remove_building");
        lua_gettable(L,3);
        lua_pushliteral(L,"");
        const int lc154 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc154);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
    }
    const int lc155 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc155) {
      
      /* formspec = formspec.."button[9.9,0.4;2,0.5;back;Back]" */
      lua_pushvalue(L,15);
      lua_pushliteral(L,"button[9.9,0.4;2,0.5;back;Back]");
      lua_concat(L,2);
      lua_replace(L,15);
      assert(lua_gettop(L) == 16);
      
      /* if( not( minetest.check_player_privs( pname, {protection_bypass=true}))) then */
      enum { lc156 = 16 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"check_player_privs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"protection_bypass");
      lua_pushboolean(L,1);
      lua_rawset(L,-3);
      lua_call(L,2,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc157 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc157) {
        
        /* minetest.show_formspec( pname, "mg_villages:plotmarker", formspec..
         * 				"label[3,3;You need the protection_bypass priv in order to use this functin.]" ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"show_formspec");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"mg_villages:plotmarker");
        lua_pushvalue(L,15);
        lua_pushliteral(L,"label[3,3;You need the protection_bypass priv in order to use this functin.]");
        lua_concat(L,2);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 16);
        
        /* return; */
        return 0;
        assert(lua_gettop(L) == 16);
      }
      lua_settop(L,lc156);
      assert(lua_gettop(L) == 16);
      
      /* local selected_building = build_chest.building[ building_name ] */
      lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
      lua_pushliteral(L,"building");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,12);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 17);
      
      /* local start_pos = {x=plot.x, y=plot.y, z=plot.z, brotate=plot.brotate} */
      lua_createtable(L,0,4);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,10);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,10);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,10);
      lua_rawset(L,-3);
      lua_pushliteral(L,"brotate");
      lua_pushliteral(L,"brotate");
      lua_gettable(L,10);
      lua_rawset(L,-3);
      assert(lua_gettop(L) == 18);
      
      /* if( selected_building.yoff ) then */
      enum { lc158 = 18 };
      lua_pushliteral(L,"yoff");
      lua_gettable(L,17);
      const int lc159 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc159) {
        
        /* start_pos.y = start_pos.y + selected_building.yoff */
        lua_pushliteral(L,"y");
        lua_gettable(L,18);
        lua_pushliteral(L,"yoff");
        lua_gettable(L,17);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,18);
        assert(lua_gettop(L) == 18);
      }
      lua_settop(L,lc158);
      assert(lua_gettop(L) == 18);
      
      /* local end_pos = {x=plot.x+plot.bsizex-1,
       * 				 y=plot.y+selected_building.yoff-1+selected_building.ysize,
       * 				 z=plot.z+plot.bsizez-1} */
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,10);
      lua_pushliteral(L,"bsizex");
      lua_gettable(L,10);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushliteral(L,"y");
      lua_gettable(L,10);
      lua_pushliteral(L,"yoff");
      lua_gettable(L,17);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"ysize");
      lua_gettable(L,17);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,10);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,10);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      assert(lua_gettop(L) == 19);
      
      /* local replacements = build_chest.replacements_get_current( meta, village_id ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
      lua_pushliteral(L,"replacements_get_current");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lua_pushvalue(L,6);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 20);
      
      /* if( fields.remove_building and fields.remove_building ~= "" ) then */
      enum { lc160 = 20 };
      lua_pushliteral(L,"remove_building");
      lua_gettable(L,3);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"remove_building");
        lua_gettable(L,3);
        lua_pushliteral(L,"");
        const int lc161 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc161);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc162 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc162) {
        
        /* -- clear the space above ground, put dirt below ground, but keep the
         * -- surface intact
         * handle_schematics.clear_area( start_pos, end_pos, pos.y-1) */
        lua_getfield(L,LUA_ENVIRONINDEX,"handle_schematics");
        lua_pushliteral(L,"clear_area");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_pushvalue(L,19);
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 20);
        
        /* -- also clear the meta data to avoid strange effects
         * handle_schematics.clear_meta( start_pos, end_pos ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"handle_schematics");
        lua_pushliteral(L,"clear_meta");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_pushvalue(L,19);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 20);
        
        /* formspec = formspec.."label[3,3;The plot has been cleared.]" */
        lua_pushvalue(L,15);
        lua_pushliteral(L,"label[3,3;The plot has been cleared.]");
        lua_concat(L,2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 20);
      }
      else {
        
        /* else
         * -- actually place it (disregarding mirroring)
         * local error_msg = handle_schematics.place_building_from_file(
         * 						start_pos,
         * 						end_pos,
         * 						building_name,
         * 						replacements,
         * 						plot.o,
         * 						build_chest.building[ building_name ].axis, plot.mirror, 1, true ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"handle_schematics");
        lua_pushliteral(L,"place_building_from_file");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_pushvalue(L,19);
        lua_pushvalue(L,12);
        lua_pushvalue(L,20);
        lua_pushliteral(L,"o");
        lua_gettable(L,10);
        lua_getfield(L,LUA_ENVIRONINDEX,"build_chest");
        lua_pushliteral(L,"building");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,12);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"axis");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"mirror");
        lua_gettable(L,10);
        lua_pushnumber(L,1);
        lua_pushboolean(L,1);
        lua_call(L,9,1);
        assert(lua_gettop(L) == 21);
        
        /* formspec = formspec.."label[3,3;The building has been reset.]" */
        lua_pushvalue(L,15);
        lua_pushliteral(L,"label[3,3;The building has been reset.]");
        lua_concat(L,2);
        lua_replace(L,15);
        assert(lua_gettop(L) == 21);
        
        /* if( error_msg ) then */
        enum { lc163 = 21 };
        if (lua_toboolean(L,21)) {
          
          /* formspec = formspec..'label[4,3;Error: '..tostring( fields.error_msg ).."]" */
          lua_pushvalue(L,15);
          lua_pushliteral(L,"label[4,3;Error: ");
          lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
          lua_pushliteral(L,"error_msg");
          lua_gettable(L,3);
          lua_call(L,1,1);
          lua_pushliteral(L,"]");
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_replace(L,15);
          assert(lua_gettop(L) == 21);
        }
        lua_settop(L,lc163);
        assert(lua_gettop(L) == 21);
      }
      lua_settop(L,lc160);
      assert(lua_gettop(L) == 20);
      
      /* minetest.show_formspec( pname, "mg_villages:plotmarker", formspec ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"show_formspec");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_pushliteral(L,"mg_villages:plotmarker");
      lua_pushvalue(L,15);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 20);
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 20);
    }
    else {
      
      /* elseif( fields.info and fields.info ~= "" ) then */
      enum { lc164 = 16 };
      lua_pushliteral(L,"info");
      lua_gettable(L,3);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"info");
        lua_gettable(L,3);
        lua_pushliteral(L,"");
        const int lc165 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc165);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc166 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc166) {
        
        /* local show_material_text = "Change materials used" */
        lua_pushliteral(L,"Change materials used");
        assert(lua_gettop(L) == 17);
        
        /* if( not( minetest.check_player_privs( pname, {protection_bypass=true}))) then */
        enum { lc167 = 17 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"check_player_privs");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,8);
        lua_createtable(L,0,1);
        lua_pushliteral(L,"protection_bypass");
        lua_pushboolean(L,1);
        lua_rawset(L,-3);
        lua_call(L,2,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc168 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc168) {
          
          /* show_material_text = "Show materials used" */
          lua_pushliteral(L,"Show materials used");
          lua_replace(L,17);
          assert(lua_gettop(L) == 17);
        }
        lua_settop(L,lc167);
        assert(lua_gettop(L) == 17);
        
        /* minetest.show_formspec( pname, "mg_villages:plotmarker",
         * 			formspec..
         * 				"button[9.9,0.4;2,0.5;back;Back]"..
         * 				"button[3,3;5,0.5;create_backup;Create backup of current stage]"..
         * 				"button[4,4;3,0.5;show_materials;"..show_material_text.."]"..
         * 				"button[4,5;3,0.5;reset_building;Reset building]"..
         * 				"button[4,6;3,0.5;remove_building;Remove building]") */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"show_formspec");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,8);
        lua_pushliteral(L,"mg_villages:plotmarker");
        lua_pushvalue(L,15);
        lua_pushliteral(L,"button[9.9,0.4;2,0.5;back;Back]");
        lua_pushliteral(L,"button[3,3;5,0.5;create_backup;Create backup of current stage]");
        lua_pushliteral(L,"button[4,4;3,0.5;show_materials;");
        lua_pushvalue(L,17);
        lua_pushliteral(L,"]");
        lua_pushliteral(L,"button[4,5;3,0.5;reset_building;Reset building]");
        lua_pushliteral(L,"button[4,6;3,0.5;remove_building;Remove building]");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 17);
        
        /* return; */
        return 0;
        assert(lua_gettop(L) == 17);
      }
      lua_settop(L,lc164);
    }
    lua_settop(L,lc152);
  }
  lua_settop(L,lc145);
  assert(lua_gettop(L) == 16);
  
  /* local owner      = plot.owner */
  lua_pushliteral(L,"owner");
  lua_gettable(L,10);
  assert(lua_gettop(L) == 17);
  
  /* local btype      = plot.btype */
  lua_pushliteral(L,"btype");
  lua_gettable(L,10);
  assert(lua_gettop(L) == 18);
  
  /* local original_formspec = "size[8,3]"..
   * 		"button[7.0,0.0;1.0,0.5;info;Info]"..
   * 		"label[1.0,0.5;Plot No.: "..tostring( plot_nr ).."]"..
   * 		"label[2.5,0.5;Building:]"..
   * 		"label[3.5,0.5;"..tostring( mg_villages.BUILDINGS[btype].scm ).."]"..
   * 		"field[20,20;0.1,0.1;pos2str;Pos;"..minetest.pos_to_string( pos ).."]" */
  lua_pushliteral(L,"size[8,3]");
  lua_pushliteral(L,"button[7.0,0.0;1.0,0.5;info;Info]");
  lua_pushliteral(L,"label[1.0,0.5;Plot No.: ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,7);
  lua_call(L,1,1);
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"label[2.5,0.5;Building:]");
  lua_pushliteral(L,"label[3.5,0.5;");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"BUILDINGS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,18);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"scm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L,"]");
  lua_pushliteral(L,"field[20,20;0.1,0.1;pos2str;Pos;");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"pos_to_string");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"]");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  assert(lua_gettop(L) == 19);
  
  /* local formspec = "" */
  lua_pushliteral(L,"");
  assert(lua_gettop(L) == 20);
  
  /* local ifinhabit = "" */
  lua_pushliteral(L,"");
  assert(lua_gettop(L) == 21);
  
  /* -- Get Price
   * local price = "default:gold_ingot 2" */
  lua_pushliteral(L,"default:gold_ingot 2");
  assert(lua_gettop(L) == 22);
  
  /* if (btype ~= 'road' and mg_villages.BUILDINGS[btype]) then */
  enum { lc169 = 22 };
  lua_pushliteral(L,"road");
  const int lc170 = lua_equal(L,18,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc170);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,18);
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc171 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc171) {
    
    /* local plot_descr = 'Plot No. '..tostring( plot_nr ).. ' with '..tostring( mg_villages.BUILDINGS[btype].scm) */
    lua_pushliteral(L,"Plot No. ");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushvalue(L,7);
    lua_call(L,1,1);
    lua_pushliteral(L," with ");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,18);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"scm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 23);
    
    /* if (mg_villages.BUILDINGS[btype].price) then */
    enum { lc172 = 23 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,18);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"price");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc173 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc173) {
      
      /* price = mg_villages.BUILDINGS[btype].price */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,18);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"price");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_replace(L,22);
      assert(lua_gettop(L) == 23);
    }
    else {
      
      /* elseif (mg_villages.BUILDINGS[btype].typ and mg_villages.prices[ mg_villages.BUILDINGS[btype].typ ]) then */
      enum { lc174 = 23 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,18);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"typ");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"prices");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"typ");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      const int lc175 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc175) {
        
        /* price = mg_villages.prices[ mg_villages.BUILDINGS[btype].typ ] */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"prices");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"typ");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_replace(L,22);
        assert(lua_gettop(L) == 23);
      }
      lua_settop(L,lc174);
    }
    lua_settop(L,lc172);
    assert(lua_gettop(L) == 23);
    
    /* -- Get if is inhabitant house
     * if (mg_villages.BUILDINGS[btype].inh and mg_villages.BUILDINGS[btype].inh > 0 ) then */
    enum { lc176 = 23 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"BUILDINGS");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,18);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"inh");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,18);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"inh");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc177 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc177);
    }
    const int lc178 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc178) {
      
      /* ifinhabit = "label[1,1.5;Owners of this plot count as village inhabitants.]" */
      lua_pushliteral(L,"label[1,1.5;Owners of this plot count as village inhabitants.]");
      lua_replace(L,21);
      assert(lua_gettop(L) == 23);
    }
    lua_settop(L,lc176);
    assert(lua_gettop(L) == 23);
  }
  lua_settop(L,lc169);
  assert(lua_gettop(L) == 22);
  
  /* -- Determine price depending on building type
   * local price_stack= ItemStack( price ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ItemStack");
  lua_pushvalue(L,22);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 23);
  
  /* -- If nobody owns the plot
   * if (not(owner) or owner=='') then */
  enum { lc179 = 23 };
  lua_pushboolean(L,!(lua_toboolean(L,17)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,17);
    lua_pushliteral(L,"");
    const int lc180 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc180);
  }
  const int lc181 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc181) {
    
    /* formspec = original_formspec ..
     * 			"label[1,1;You can buy this plot for]".. 
     * 			"label[3.8,1;"..tostring( price_stack:get_count() ).." x ]"..
     * 			"item_image[4.3,0.8;1,1;"..(  price_stack:get_name() ).."]"..
     * 			ifinhabit..
     * 			"button[2,2.5;1.5,0.5;buy;Buy plot]"..
     * 			"button_exit[4,2.5;1.5,0.5;abort;Exit]" */
    lua_pushvalue(L,19);
    lua_pushliteral(L,"label[1,1;You can buy this plot for]");
    lua_pushliteral(L,"label[3.8,1;");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    const int lc182 = lua_gettop(L);
    lua_pushvalue(L,23);
    lua_pushliteral(L,"get_count");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc182),1);
    lua_pushliteral(L," x ]");
    lua_pushliteral(L,"item_image[4.3,0.8;1,1;");
    lua_pushvalue(L,23);
    lua_pushliteral(L,"get_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    lua_pushliteral(L,"]");
    lua_pushvalue(L,21);
    lua_pushliteral(L,"button[2,2.5;1.5,0.5;buy;Buy plot]");
    lua_pushliteral(L,"button_exit[4,2.5;1.5,0.5;abort;Exit]");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_concat(L,2);
    lua_replace(L,20);
    assert(lua_gettop(L) == 23);
    
    /* -- On Press buy button
     * if (fields['buy']) then */
    enum { lc183 = 23 };
    lua_pushliteral(L,"buy");
    lua_gettable(L,3);
    const int lc184 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc184) {
      
      /* local inv = player:get_inventory() */
      lua_pushvalue(L,4);
      lua_pushliteral(L,"get_inventory");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 24);
      
      /* if not mg_villages.all_villages[village_id].ownerlist then */
      enum { lc185 = 24 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,6);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"ownerlist");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc186 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc186) {
        
        /* mg_villages.all_villages[village_id].ownerlist = {} */
        lua_newtable(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"all_villages");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"ownerlist");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc185);
      assert(lua_gettop(L) == 24);
      
      /* -- Check if player already has a house in the village
       * if mg_villages.all_villages[village_id].ownerlist[pname] then */
      enum { lc187 = 24 };
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,6);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"ownerlist");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc188 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc188) {
        
        /* formspec = formspec.."label[1,1.9;Sorry. You already have a plot in this village.]" */
        lua_pushvalue(L,20);
        lua_pushliteral(L,"label[1,1.9;Sorry. You already have a plot in this village.]");
        lua_concat(L,2);
        lua_replace(L,20);
        assert(lua_gettop(L) == 24);
      }
      else {
        
        /* -- Check if the price can be paid
         * 			elseif( inv and inv:contains_item( 'main', price_stack )) then */
        enum { lc189 = 24 };
        lua_pushvalue(L,24);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,24);
          lua_pushliteral(L,"contains_item");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"main");
          lua_pushvalue(L,23);
          lua_call(L,3,1);
        }
        const int lc190 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc190) {
          
          /* formspec = original_formspec..
           * 					"label[1,1;Congratulations! You have bought this plot.]"..
           * 					"button_exit[5.75,2.5;1.5,0.5;abort;Exit]" */
          lua_pushvalue(L,19);
          lua_pushliteral(L,"label[1,1;Congratulations! You have bought this plot.]");
          lua_pushliteral(L,"button_exit[5.75,2.5;1.5,0.5;abort;Exit]");
          lua_concat(L,2);
          lua_concat(L,2);
          lua_replace(L,20);
          assert(lua_gettop(L) == 24);
          
          /* mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].owner = pname */
          lua_pushvalue(L,8);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"all_villages");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"to_add_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"bpos");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,7);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"owner");
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 24);
          
          /* if mg_villages.all_villages[village_id].ownerlist then */
          enum { lc191 = 24 };
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"all_villages");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"ownerlist");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc192 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc192) {
            
            /* mg_villages.all_villages[village_id].ownerlist[pname] = true */
            lua_pushboolean(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"all_villages");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,6);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"ownerlist");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,8);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 24);
          }
          else {
            
            /* else
             * mg_villages.all_villages[village_id].ownerlist[pname] = true */
            lua_pushboolean(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"all_villages");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,6);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"ownerlist");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,8);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 24);
          }
          lua_settop(L,lc191);
          assert(lua_gettop(L) == 24);
          
          /* meta:set_string('infotext', 'Plot No. '..tostring( plot_nr ).. ' with '..tostring( mg_villages.BUILDINGS[btype].scm)..' (owned by '..tostring( pname )..')') */
          lua_pushvalue(L,5);
          lua_pushliteral(L,"set_string");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"infotext");
          lua_pushliteral(L,"Plot No. ");
          lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
          lua_pushvalue(L,7);
          lua_call(L,1,1);
          lua_pushliteral(L," with ");
          lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"BUILDINGS");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,18);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"scm");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lua_pushliteral(L," (owned by ");
          lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
          lua_pushvalue(L,8);
          lua_call(L,1,1);
          lua_pushliteral(L,")");
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_concat(L,2);
          lua_call(L,3,0);
          assert(lua_gettop(L) == 24);
          
          /* -- save the data so that it survives server restart
           * mg_villages.save_data() */
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"save_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,0,0);
          assert(lua_gettop(L) == 24);
          
          /* -- substract the price from the players inventory
           * inv:remove_item( 'main', price_stack ) */
          lua_pushvalue(L,24);
          lua_pushliteral(L,"remove_item");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"main");
          lua_pushvalue(L,23);
          lua_call(L,3,0);
          assert(lua_gettop(L) == 24);
        }
        else {
          
          /* else
           * formspec = formspec.."label[1,1.9;Sorry. You are not able to pay the price.]" */
          lua_pushvalue(L,20);
          lua_pushliteral(L,"label[1,1.9;Sorry. You are not able to pay the price.]");
          lua_concat(L,2);
          lua_replace(L,20);
          assert(lua_gettop(L) == 24);
        }
        lua_settop(L,lc189);
      }
      lua_settop(L,lc187);
      assert(lua_gettop(L) == 24);
    }
    lua_settop(L,lc183);
    assert(lua_gettop(L) == 23);
  }
  else {
    
    /* -- If player is the owner of the plot
     * 	elseif (owner==pname) then */
    enum { lc193 = 23 };
    const int lc194 = lua_equal(L,17,8);
    lua_pushboolean(L,lc194);
    const int lc195 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc195) {
      
      /* -- Check if inhabitant house
       * if(btype ~= 'road'
       * 			and mg_villages.BUILDINGS[btype]
       * 			and mg_villages.BUILDINGS[btype].inh
       * 			and mg_villages.BUILDINGS[btype].inh > 0 ) then */
      enum { lc196 = 23 };
      lua_pushliteral(L,"road");
      const int lc197 = lua_equal(L,18,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc197);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"inh");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,0);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"inh");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc198 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc198);
      }
      const int lc199 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc199) {
        
        /* ifinhabit = "label[1,1.5;You are allowed to modify the common village area.]" */
        lua_pushliteral(L,"label[1,1.5;You are allowed to modify the common village area.]");
        lua_replace(L,21);
        assert(lua_gettop(L) == 23);
      }
      lua_settop(L,lc196);
      assert(lua_gettop(L) == 23);
      
      /* formspec = original_formspec.."size[8,3]"..
       * 			"label[1,1;This is your plot. You have bought it.]"..
       * 			"button[0.75,2.5;3,0.5;add_remove;Add/Remove Players]"..
       * 			ifinhabit..
       * 			"button_exit[3.75,2.5;2.0,0.5;abandon;Abandon plot]"..
       * 			"button_exit[5.75,2.5;1.5,0.5;abort;Exit]" */
      lua_pushvalue(L,19);
      lua_pushliteral(L,"size[8,3]");
      lua_pushliteral(L,"label[1,1;This is your plot. You have bought it.]");
      lua_pushliteral(L,"button[0.75,2.5;3,0.5;add_remove;Add/Remove Players]");
      lua_pushvalue(L,21);
      lua_pushliteral(L,"button_exit[3.75,2.5;2.0,0.5;abandon;Abandon plot]");
      lua_pushliteral(L,"button_exit[5.75,2.5;1.5,0.5;abort;Exit]");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,20);
      assert(lua_gettop(L) == 23);
      
      /* -- If Player wants to abandon plot
       * if(fields['abandon'] ) then */
      enum { lc200 = 23 };
      lua_pushliteral(L,"abandon");
      lua_gettable(L,3);
      const int lc201 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc201) {
        
        /* formspec = original_formspec..
         * 				"label[1,1;You have abandoned this plot.]"..
         * 				"button_exit[5.75,2.5;1.5,0.5;abort;Exit]" */
        lua_pushvalue(L,19);
        lua_pushliteral(L,"label[1,1;You have abandoned this plot.]");
        lua_pushliteral(L,"button_exit[5.75,2.5;1.5,0.5;abort;Exit]");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_replace(L,20);
        assert(lua_gettop(L) == 23);
        
        /* mg_villages.all_villages[village_id].ownerlist[pname] = nil */
        lua_pushnil(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"all_villages");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"ownerlist");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,8);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 23);
        
        /* mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit = {} */
        lua_newtable(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"all_villages");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"to_add_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"bpos");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"can_edit");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 23);
        
        /* mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].owner = nil */
        lua_pushnil(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"all_villages");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"to_add_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"bpos");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"owner");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 23);
        
        /* -- Return price to player
         * local inv = player:get_inventory() */
        lua_pushvalue(L,4);
        lua_pushliteral(L,"get_inventory");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_call(L,1,1);
        assert(lua_gettop(L) == 24);
        
        /* inv:add_item( 'main', price_stack ) */
        lua_pushvalue(L,24);
        lua_pushliteral(L,"add_item");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"main");
        lua_pushvalue(L,23);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 24);
        
        /* meta:set_string('infotext', 'Plot No. '..tostring( plot_nr ).. ' with '..tostring( mg_villages.BUILDINGS[btype].scm) ) */
        lua_pushvalue(L,5);
        lua_pushliteral(L,"set_string");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"infotext");
        lua_pushliteral(L,"Plot No. ");
        lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
        lua_pushvalue(L,7);
        lua_call(L,1,1);
        lua_pushliteral(L," with ");
        lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"BUILDINGS");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,18);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"scm");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 24);
        
        /* mg_villages.save_data() */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"save_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,0);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc200);
      assert(lua_gettop(L) == 23);
      
      /* -- If Player wants to add/remove trusted players
       * if (fields['add_remove']) then */
      enum { lc202 = 23 };
      lua_pushliteral(L,"add_remove");
      lua_gettable(L,3);
      const int lc203 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc203) {
        
        /* local previousTrustees = mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"all_villages");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"to_add_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"bpos");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"can_edit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 24);
        
        /* local output = "" */
        lua_pushliteral(L,"");
        assert(lua_gettop(L) == 25);
        
        /* if previousTrustees == nil then */
        enum { lc204 = 25 };
        lua_pushnil(L);
        const int lc205 = lua_equal(L,24,-1);
        lua_pop(L,1);
        lua_pushboolean(L,lc205);
        const int lc206 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc206) {
          
          /* previousTrustees = {} */
          lua_newtable(L);
          lua_replace(L,24);
          assert(lua_gettop(L) == 25);
        }
        else {
          
          /* else
           * for _, player in ipairs(previousTrustees) do
           * internal: local f, s, var = explist */
          enum { lc207 = 25 };
          lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
          lua_pushvalue(L,24);
          lua_call(L,1,3);
          while (1) {
            
            /* internal: local var_1, ..., var_n = f(s, var)
             *           if var_1 == nil then break end
             *           var = var_1 */
            lua_pushvalue(L,-3);
            lua_pushvalue(L,-3);
            lua_pushvalue(L,-3);
            lua_call(L,2,2);
            if (lua_isnil(L,-2)) {
              break;
            }
            lua_pushvalue(L,-2);
            lua_replace(L,-4);
            
            /* internal: local _ with idx 29
             * internal: local player with idx 30 */
            
            
            /* output = output..player.."\n" */
            lua_pushvalue(L,25);
            lua_pushvalue(L,30);
            lua_pushliteral(L,"\n");
            lua_concat(L,2);
            lua_concat(L,2);
            lua_replace(L,25);
            assert(lua_gettop(L) == 30);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,2);
          }
          lua_settop(L,lc207);
          assert(lua_gettop(L) == 25);
        }
        lua_settop(L,lc204);
        assert(lua_gettop(L) == 25);
        
        /* formspec = "size[8,3]"..
         * 				"field[20,20;0.1,0.1;pos2str;Pos;"..minetest.pos_to_string( pos ).."]"..
         * 				"textarea[0.3,0.2;8,2.5;ownerplayers;Trusted Players;"..output.."]"..
         * 				"button[3.25,2.5;1.5,0.5;savetrustees;Save]" */
        lua_pushliteral(L,"size[8,3]");
        lua_pushliteral(L,"field[20,20;0.1,0.1;pos2str;Pos;");
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"pos_to_string");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        lua_pushliteral(L,"]");
        lua_pushliteral(L,"textarea[0.3,0.2;8,2.5;ownerplayers;Trusted Players;");
        lua_pushvalue(L,25);
        lua_pushliteral(L,"]");
        lua_pushliteral(L,"button[3.25,2.5;1.5,0.5;savetrustees;Save]");
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_concat(L,2);
        lua_replace(L,20);
        assert(lua_gettop(L) == 25);
        
        /* mg_villages.save_data() */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"save_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,0);
        assert(lua_gettop(L) == 25);
      }
      lua_settop(L,lc202);
      assert(lua_gettop(L) == 23);
      
      /* -- Save trusted players
       * if (fields["savetrustees"] == "Save") then */
      enum { lc208 = 23 };
      lua_pushliteral(L,"savetrustees");
      lua_gettable(L,3);
      lua_pushliteral(L,"Save");
      const int lc209 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc209);
      const int lc210 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc210) {
        
        /* if not mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit then */
        enum { lc211 = 23 };
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"all_villages");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,6);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"to_add_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"bpos");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"can_edit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc212 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc212) {
          
          /* mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit = {} */
          lua_newtable(L);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"all_villages");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"to_add_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"bpos");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,7);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"can_edit");
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 23);
        }
        lua_settop(L,lc211);
        assert(lua_gettop(L) == 23);
        
        /* local x = 1 */
        lua_pushnumber(L,1);
        assert(lua_gettop(L) == 24);
        
        /* for _, player in ipairs(fields.ownerplayers:split("\n")) do
         * internal: local f, s, var = explist */
        enum { lc213 = 24 };
        lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
        const int lc214 = lua_gettop(L);
        lua_pushliteral(L,"ownerplayers");
        lua_gettable(L,3);
        lua_pushliteral(L,"split");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"\n");
        lua_call(L,2,LUA_MULTRET);
        lua_call(L,(lua_gettop(L) - lc214),3);
        while (1) {
          
          /* internal: local var_1, ..., var_n = f(s, var)
           *           if var_1 == nil then break end
           *           var = var_1 */
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_call(L,2,2);
          if (lua_isnil(L,-2)) {
            break;
          }
          lua_pushvalue(L,-2);
          lua_replace(L,-4);
          
          /* internal: local _ with idx 28
           * internal: local player with idx 29 */
          
          
          /* mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit[x] = player */
          lua_pushvalue(L,29);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"all_villages");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"to_add_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"bpos");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,7);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"can_edit");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,24);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 29);
          
          /* x = x + 1 */
          lua_pushnumber(L,1);
          lc_add(L,24,-1);
          lua_remove(L,-2);
          lua_replace(L,24);
          assert(lua_gettop(L) == 29);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,2);
        }
        lua_settop(L,lc213);
        assert(lua_gettop(L) == 24);
        
        /* mg_villages.save_data() */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"save_data");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,0);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc208);
      assert(lua_gettop(L) == 23);
    }
    else {
      
      /* else
       * formspec = original_formspec.."label[1,1;"..tostring( owner ).." owns this plot.]"..
       * 					"button_exit[3,2.5;1.5,0.5;abort;Exit]" */
      lua_pushvalue(L,19);
      lua_pushliteral(L,"label[1,1;");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushvalue(L,17);
      lua_call(L,1,1);
      lua_pushliteral(L," owns this plot.]");
      lua_pushliteral(L,"button_exit[3,2.5;1.5,0.5;abort;Exit]");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_replace(L,20);
      assert(lua_gettop(L) == 23);
    }
    lua_settop(L,lc193);
  }
  lua_settop(L,lc179);
  assert(lua_gettop(L) == 23);
  
  /* minetest.show_formspec( pname, "mg_villages:plotmarker", formspec ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"show_formspec");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,8);
  lua_pushliteral(L,"mg_villages:plotmarker");
  lua_pushvalue(L,20);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 23);
  return 0;
}


/* name: mg_villages.form_input_handler
 * function( player, formname, fields) */
static int lcf1_mg_villages_form_input_handler (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* --	mg_villages.print(mg_villages.DEBUG_LEVEL_NORMAL,minetest.serialize(fields));
   * if( not( mg_villages.ENABLE_PROTECTION )) then */
  enum { lc215 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"ENABLE_PROTECTION");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc216 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc216) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc215);
  assert(lua_gettop(L) == 3);
  
  /* if( (formname == "mg_villages:plotmarker") and fields.pos2str and not( fields.abort )) then */
  enum { lc217 = 3 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"mg_villages:plotmarker");
  const int lc218 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc218);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"pos2str");
    lua_gettable(L,3);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"abort");
    lua_gettable(L,3);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc219 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc219) {
    
    /* local pos = minetest.string_to_pos( fields.pos2str ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"string_to_pos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"pos2str");
    lua_gettable(L,3);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 4);
    
    /* mg_villages.plotmarker_formspec( pos, formname, fields, player ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"plotmarker_formspec");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,1);
    lua_call(L,4,0);
    assert(lua_gettop(L) == 4);
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc217);
  assert(lua_gettop(L) == 3);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- get the id of the village pos lies in (or nil if outside of villages)
   * mg_villages.get_town_id_at_pos = function( pos )
   * 	for id, v in pairs( mg_villages.all_villages ) do
   * 		local size = v.vs * 3;
   * 		if(   ( math.abs( pos.x - v.vx ) < size )
   * 		  and ( math.abs( pos.z - v.vz ) < size )
   * 		  and ( pos.y - v.vh < 40 and v.vh - pos.y < 10 )) then
   * 			local village_noise = minetest.get_perlin(7635, 3, 0.5, 16);
   * 			if( mg_villages.inside_village_area( pos.x,  pos.z, v, village_noise)) then
   * 
   * 				local node = minetest.get_node( pos );
   * 				-- leaves can be digged in villages
   * 				if( node and node.name ) then
   * 					if(    minetest.registered_nodes[ node.name ]
   * 					   and minetest.registered_nodes[ node.name ].groups
   * 				           and minetest.registered_nodes[ node.name ].groups.leaves ) then
   * 						return nil;
   * 					elseif( node.name=='default:snow' ) then
   * 						return nil;
   * 					-- bones can be digged in villages
   * 					elseif( node.name == 'bones:bones' ) then
   * 						return nil;
   * 					else
   * 						return id;
   * 					end
   * 				else
   * 					return id;
   * 				end
   * 			end
   * 		end
   * 	end
   * 	return nil;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_town_id_at_pos);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_town_id_at_pos");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- search the trader (who is supposed to be at the given position) and
   * -- spawn a new one in case he went missing
   * mg_villages.plotmarker_search_trader = function( trader, height )
   * 
   * 	local obj_list = minetest.get_objects_inside_radius({x=trader.x, y=height, z=trader.z}, 10 );
   * 	for i,obj in ipairs( obj_list ) do
   * 		local e = obj:get_luaentity();
   * 		if( e and e.object ) then
   * 			local p = e.object:getpos();
   * 			if( p and p.x and math.abs(p.x-trader.x)<1.5
   * 			      and p.z and math.abs(p.z-trader.z)<1.5
   * 			      and e.name and e.name=="mobf_trader:trader"
   * 			      and e.trader_typ and e.trader_typ==trader.typ) then
   * --				minetest.chat_send_player( "singleplayer", "FOUND trader "..tostring( e.trader_typ)); --TODO
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_plotmarker_search_trader);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"plotmarker_search_trader");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- checks if the plot marker is still present; places a new one if needed
   * -- p: plot data (position, size, orientation, owner, ..)
   * mg_villages.check_plot_marker = function( p, plot_nr, village_id )
   * 	-- roads cannot be bought
   * 	if( p.btype and p.btype=="road" ) then
   * 		return;
   * 	end
   * 	local plot_pos = { x=p.x, y=p.y, z=p.z };
   * 	if(      p.o==3 ) then
   * 		plot_pos = { x=p.x,            y=p.y+1, z=p.z-1          };
   * 	elseif(  p.o==1 ) then
   * 		plot_pos = { x=p.x+p.bsizex-1, y=p.y+1, z=p.z+p.bsizez   };
   * 	elseif ( p.o==2 ) then
   * 		plot_pos = { x=p.x+p.bsizex,   y=p.y+1, z=p.z            };
   * 	elseif ( p.o==0 ) then
   * 		plot_pos = { x=p.x-1,          y=p.y+1, z=p.z+p.bsizez-1 };
   * 	end
   * 	-- is the plotmarker still present?
   * 	local node = minetest.get_node( plot_pos );
   * 	if( not(node) or not(node.name) or node.name ~= "mg_villages:plotmarker" ) then
   * 		-- place a new one if needed
   * 		minetest.set_node( plot_pos, {name="mg_villages:plotmarker", param2=p.o});
   * 		local meta = minetest.get_meta( plot_pos );
   * 		-- strange error happend; maybe we're more lucky next time...
   * 		if( not( meta )) then
   * 			return;
   * 		end
   * 		meta:set_string('village_id', village_id );
   * 		meta:set_int(   'plot_nr',    plot_nr );
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_check_plot_marker);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"check_plot_marker");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* local old_is_protected = minetest.is_protected */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc49 = 1 };
  assert((lua_gettop(L) == (lc49 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"is_protected");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc49 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.is_protected = function(pos, name)
   * 
   * 	if( not( mg_villages.ENABLE_PROTECTION )) then
   * 		return old_is_protected( pos, name );
   * 	end
   * 
   * 	local village_id = mg_villages.get_town_id_at_pos( pos );
   * 	if( village_id ) then
   * 		local is_houseowner = false;
   * 		for nr, p in ipairs( mg_villages.all_villages[ village_id ].to_add_data.bpos ) do
   * 
   * 			trustedusers = p.can_edit
   * 			trustedUser = false
   * 			if trustedusers ~= nil then
   * 				for _,trusted in ipairs(trustedusers) do
   * 					if trusted == name then
   * 						trustedUser = true
   * 					end
   * 				end
   * 			end
   * 
   * 			-- we have located the right plot; the player can build here if he owns this particular plot
   * 			if(   p.x <= pos.x and (p.x + p.bsizex) >= pos.x
   * 			  and p.z <= pos.z and (p.z + p.bsizez) >= pos.z) then
   * 
   * 				-- place a new plot marker if necessary
   * 				mg_villages.check_plot_marker( p, nr, village_id );
   * 
   * 				-- If player has been trusted by owner, can build
   * 				if (trustedUser) then
   * 					return false;
   * 				-- If player is owner, can build
   * 				elseif( p.owner and p.owner == name ) then
   * 					return false;
   * 				-- the allmende can be used by all
   * 				elseif( mg_villages.BUILDINGS[p.btype] and mg_villages.BUILDINGS[p.btype].typ=="allmende" ) then
   * 					return false;
   * 				-- the player cannot modify other plots, even though he may be house owner of another house and be allowed to modify common ground
   * 				else
   * 					return true;
   * 				end
   * 			-- if the player just owns another plot in the village, check if it's one where villagers may live
   * 			elseif( p.owner and p.owner == name or trustedUser) then
   * 				local btype = mg_villages.all_villages[ village_id ].to_add_data.bpos[ nr ].btype;
   * 				if(   btype ~= 'road'
   * 				  and mg_villages.BUILDINGS[btype]
   * 				  and mg_villages.BUILDINGS[btype].inh
   * 				  and mg_villages.BUILDINGS[btype].inh > 0 ) then
   * 					is_houseowner = true;
   * 					-- check the node below
   * 					local node = minetest.get_node( {x=pos.x, y=pos.y-1, z=pos.z});
   * 					-- replace the fake, inaktive village soil with real farming soil if a player diggs the plant above
   * 					if( node and node.name and node.name=="mg_villages:soil" ) then
   * 						minetest.swap_node( {x=pos.x, y=pos.y-1, z=pos.z}, {name="farming:soil_wet"});
   * 					end
   * 				end
   * 			end
   * 		end
   * 		-- players who own a house in town where villagers may live (not only work!)
   * 		--  are allowed to modify common ground
   * 		if( is_houseowner ) then
   * 			return false;
   * 		end
   * 		return true;
   * 	end
   * 	return old_is_protected(pos, name);
   * end */
  lua_pushvalue(L,(lc49 + lc_nextra));
  lua_pushcclosure(L,lcf1_minetest_is_protected,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_insert(L,-2);
  lua_pushliteral(L,"is_protected");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_on_protection_violation( function(pos, name)
   * 
   * 	if( not( mg_villages.ENABLE_PROTECTION )) then
   * 		return;
   * 	end
   * 
   * 	local found = mg_villages.get_town_id_at_pos( pos );
   * 	if( not( found ) or not( mg_villages.all_villages[ found ]))  then
   * 		minetest.chat_send_player( name, 'Error: This area does not belong to a village.');
   * 		return;
   * 	end
   * 
   * 	minetest.chat_send_player( name, "You are inside of the area of the village "..
   * 		tostring( mg_villages.all_villages[ found ].name )..
   * 		". The inhabitants do not allow you any modifications.");
   * end ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_protection_violation");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf92);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.plotmarker_formspec = function( pos, formname, fields, player )
   * 
   * --	if( not( mg_villages.ENABLE_PROTECTION )) then
   * --		return;
   * --	end
   * 	local meta = minetest.get_meta( pos );
   * 	if( not( meta )) then
   * 		return;
   * 	end
   * 	local village_id = meta:get_string('village_id');
   * 	local plot_nr    = meta:get_int(   'plot_nr');
   * 	local pname      = player:get_player_name();
   * 
   * 	if( not( village_id )
   * 		or not( mg_villages.all_villages )
   * 		or not( mg_villages.all_villages[ village_id ] )
   * 		or not( plot_nr )
   * 		or not( mg_villages.all_villages[ village_id ].to_add_data )
   * 		or not( mg_villages.all_villages[ village_id ].to_add_data.bpos )
   * 		or not( mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ] )) then
   * 		minetest.chat_send_player( pname, 'Error. This plot marker is not configured correctly.'..minetest.serialize({village_id,plot_nr }));
   * 		return;
   * 	end
   * 
   * 	local village    = mg_villages.all_villages[ village_id ];
   * 	local plot       = mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ];
   * 
   * 	local owner_name = plot.owner;
   * 	if( not( owner_name ) or owner_name == "" ) then
   * 		if( plot.btype=="road" ) then
   * 			owner_name = "- the village community -";
   * 		else
   * 			owner_name = "- for sale -";
   * 		end
   * 	end
   * 
   * 	local building_name = mg_villages.BUILDINGS[ plot.btype ].mts_path..mg_villages.BUILDINGS[ plot.btype ].scm;
   * 
   * 	-- show coordinates of the village center to the player
   * 	local village_pos = minetest.pos_to_string( {x=village.vx, y=village.vh, z=village.vz});
   * 	-- distance from village center
   * 	local distance = math.floor( math.sqrt( (village.vx - pos.x ) * (village.vx - pos.x )
   * 					      + (village.vh - pos.y ) * (village.vh - pos.y )
   * 					      + (village.vz - pos.z ) * (village.vz - pos.z ) ));
   * 
   * 	-- create the header
   * 	local formspec = "size[13,10]"..
   * 		"label[3.3,0.0;Plot No.: "..tostring( plot_nr )..", with "..tostring( mg_villages.BUILDINGS[ plot.btype ].scm ).."]"..
   * 		"label[0.3,0.4;Located at:]"      .."label[3.3,0.4;"..(minetest.pos_to_string( pos ) or '?')..", which is "..tostring( distance ).." m away]"
   * 		                                  .."label[7.3,0.4;from the village center]"..
   * 		"label[0.3,0.8;Part of village:]" .."label[3.3,0.8;"..(village.name or "- name unknown -").."]"
   * 		                                  .."label[7.3,0.8;located at "..(village_pos).."]"..
   * 		"label[0.3,1.2;Owned by:]"        .."label[3.3,1.2;"..(owner_name).."]"..
   * 		"label[3.3,1.6;Click on a menu entry to select it:]"..
   * 		"field[20,20;0.1,0.1;pos2str;Pos;"..minetest.pos_to_string( pos ).."]";
   *                             build_chest.show_size_data( building_name );
   * 
   * 	if( plot and plot.traders ) then
   * 		if( #plot.traders > 1 ) then
   * 			formspec = formspec.."label[0.3,7.0;Some traders live here. One works as a "..tostring(plot.traders[1].typ)..".]";
   * 			for i=2,#plot.traders do
   * 				formspec = formspec.."label[0.3,"..(6.0+i)..";Another trader works as a "..tostring(plot.traders[i].typ)..".]";
   * 			end
   * 		elseif( plot.traders[1] and plot.traders[1].typ) then
   * 			formspec = formspec..
   * 				"label[0.3,7.0;A trader lives here. He works as a "..tostring( plot.traders[1].typ )..".]";
   * 		else
   * 			formspec = formspec..
   * 				"label[0.3,7.0;No trader currently works at this place.]";
   * 		end
   * 		-- add buttons for visiting (teleport to trader), calling (teleporting trader to plot) and firing the trader
   * 		for i,trader in ipairs(plot.traders) do
   * 			local trader_entity = mg_villages.plotmarker_search_trader( trader, village.vh );
   * 
   * 			formspec = formspec..
   * 					"button[6.0,"..(6.0+i)..";1.2,0.5;visit_trader_"..i..";visit]"..
   * 					"button[7.4,"..(6.0+i)..";1.2,0.5;call_trader_"..i..";call]"..
   * 					"button[8.8,"..(6.0+i)..";1.2,0.5;fire_trader_"..i..";fire]";
   * 
   * 			if( fields[ "visit_trader_"..i ] ) then
   * 
   * 				player:moveto( {x=trader.x, y=(village.vh+1), z=trader.z} );
   * 				minetest.chat_send_player( pname, "You are visiting the "..tostring( trader.typ )..
   * 					" trader, who is supposed to be somewhere here. He might also be on a floor above you.");
   * 				return;
   * 			end
   * 			if( fields[ "visit_call_"..i ] ) then
   * 				-- TODO: spawning: mob_basics.spawn_mob( {x=v.x, y=v.y, z=v.z}, v.typ, nil, nil, nil, nil, true );
   * 			end
   * 			-- TODO: fire mob
   * 		end
   * 		formspec = formspec.."button[3.75,"..(7.0+math.max(1,#plot.traders))..";3.5,0.5;hire_trader;Hire a new random trader]";
   * 		-- TODO: hire mob
   * 	end
   * 
   * 
   * 	local replace_row = -1;
   * 	-- the player selected a material which ought to be replaced
   * 	if(     fields.build_chest_replacements ) then
   *                 local event = minetest.explode_table_event( fields.build_chest_replacements );
   *                 if( event and event.row and event.row > 0 ) then
   *                         replace_row = event.row;
   * 			fields.show_materials = "show_materials";
   *                 end
   * 
   * 	-- the player provided the name of the material for the replacement of the currently selected
   * 	elseif( fields.store_replacement    and fields.store_repalcement    ~= ""
   * 	    and fields.replace_row_with     and fields.replace_row_with     ~= ""
   * 	    and fields.replace_row_material and fields.replace_row_material ~= "") then
   * 
   *                 build_chest.replacements_apply( pos, meta, fields.replace_row_material, fields.replace_row_with, village_id );
   * 		fields.show_materials = "show_materials";
   * 
   * 
   * 	-- group selections for easily changing several nodes at once
   * 	elseif( fields.wood_selection ) then
   *                 build_chest.replacements_apply_for_group( pos, meta, 'wood',    fields.wood_selection,    fields.set_wood,    village_id );
   *                 fields.set_wood    = nil;
   * 		fields.show_materials = "show_materials";
   * 
   * 	elseif( fields.farming_selection ) then
   *                 build_chest.replacements_apply_for_group( pos, meta, 'farming', fields.farming_selection, fields.set_farming, village_id );
   *                 fields.set_farming = nil;
   * 		fields.show_materials = "show_materials";
   * 
   * 	elseif( fields.roof_selection ) then
   *                 build_chest.replacements_apply_for_group( pos, meta, 'roof',    fields.roof_selection,    fields.set_roof,    village_id );
   *                 fields.set_roof    = nil;
   * 		fields.show_materials = "show_materials";
   * 
   * 
   * 	-- actually store the new group replacement
   * 	elseif(  (fields.set_wood    and fields.set_wood     ~= "")
   * 	      or (fields.set_farming and fields.set_farming ~= "" )
   * 	      or (fields.set_roof    and fields.set_roof    ~= "" )) then
   * 		minetest.show_formspec( pname, "mg_villages:plotmarker",
   * 				handle_schematics.get_formspec_group_replacement( pos, fields, formspec ));
   * 		return;
   * 	end
   * 
   * 	-- show which materials (and replacements!) where used for the building
   *         if( (fields.show_materials       and fields.show_materials ~= "" )
   * 	 or (fields.replace_row_with     and fields.replace_row_with ~= "")
   * 	 or (fields.replace_row_material and fields.replace_row_material ~= "")) then
   * 
   * 		formspec = formspec.."button[9.9,0.4;2,0.5;info;Back]";
   * 		if( not( minetest.check_player_privs( pname, {protection_bypass=true}))) then
   * 			-- do not allow any changes; just show the materials and their replacements
   * 			minetest.show_formspec( pname, "mg_villages:plotmarker",
   * 				formspec..build_chest.replacements_get_list_formspec( pos, nil, 0, meta, village_id, building_name, replace_row ));
   * 		else
   * 			minetest.show_formspec( pname, "mg_villages:plotmarker",
   * 				formspec..build_chest.replacements_get_list_formspec( pos, nil, 1, nil,  village_id, building_name, replace_row ));
   * 		end
   * 		return;
   * 
   * 	-- place the building again
   * 	elseif(   (fields.reset_building  and fields.reset_building  ~= "")
   *            or (fields.remove_building and fields.remove_building ~= "")) then
   * 
   * 		formspec = formspec.."button[9.9,0.4;2,0.5;back;Back]";
   * 
   * 		if( not( minetest.check_player_privs( pname, {protection_bypass=true}))) then
   * 			minetest.show_formspec( pname, "mg_villages:plotmarker", formspec..
   * 				"label[3,3;You need the protection_bypass priv in order to use this functin.]" );
   * 			return;
   * 		end
   * 
   * 		local selected_building = build_chest.building[ building_name ];
   * 		local start_pos = {x=plot.x, y=plot.y, z=plot.z, brotate=plot.brotate};
   * 		if( selected_building.yoff ) then
   * 			start_pos.y = start_pos.y + selected_building.yoff;
   * 		end
   * 		local end_pos = {x=plot.x+plot.bsizex-1,
   * 				 y=plot.y+selected_building.yoff-1+selected_building.ysize,
   * 				 z=plot.z+plot.bsizez-1};
   * 
   * 		local replacements = build_chest.replacements_get_current( meta, village_id );
   * 
   * 		if( fields.remove_building and fields.remove_building ~= "" ) then
   * 			-- clear the space above ground, put dirt below ground, but keep the
   * 			-- surface intact
   * 			handle_schematics.clear_area( start_pos, end_pos, pos.y-1);
   * 			-- also clear the meta data to avoid strange effects
   * 			handle_schematics.clear_meta( start_pos, end_pos );
   * 			formspec = formspec.."label[3,3;The plot has been cleared.]";
   * 		else
   * 			-- actually place it (disregarding mirroring)
   * 			local error_msg = handle_schematics.place_building_from_file(
   * 						start_pos,
   * 						end_pos,
   * 						building_name,
   * 						replacements,
   * 						plot.o,
   * 						build_chest.building[ building_name ].axis, plot.mirror, 1, true );
   * 			formspec = formspec.."label[3,3;The building has been reset.]";
   * 			if( error_msg ) then
   * 				formspec = formspec..'label[4,3;Error: '..tostring( fields.error_msg ).."]";
   * 	                end
   * 		end
   * 		minetest.show_formspec( pname, "mg_villages:plotmarker", formspec );
   * 		return;
   * 
   * 	elseif( fields.info and fields.info ~= "" ) then
   * 		local show_material_text = "Change materials used";
   * 		if( not( minetest.check_player_privs( pname, {protection_bypass=true}))) then
   * 			show_material_text = "Show materials used";
   * 		end
   * 
   * 		minetest.show_formspec( pname, "mg_villages:plotmarker",
   * 			formspec..
   * 				"button[9.9,0.4;2,0.5;back;Back]"..
   * 				"button[3,3;5,0.5;create_backup;Create backup of current stage]"..
   * 				"button[4,4;3,0.5;show_materials;"..show_material_text.."]"..
   * 				"button[4,5;3,0.5;reset_building;Reset building]"..
   * 				"button[4,6;3,0.5;remove_building;Remove building]");
   * 		return;
   * 	end
   * 
   * 	local owner      = plot.owner;
   * 	local btype      = plot.btype;
   * 
   * 
   * 	local original_formspec = "size[8,3]"..
   * 		"button[7.0,0.0;1.0,0.5;info;Info]"..
   * 		"label[1.0,0.5;Plot No.: "..tostring( plot_nr ).."]"..
   * 		"label[2.5,0.5;Building:]"..
   * 		"label[3.5,0.5;"..tostring( mg_villages.BUILDINGS[btype].scm ).."]"..
   * 		"field[20,20;0.1,0.1;pos2str;Pos;"..minetest.pos_to_string( pos ).."]";
   * 		local formspec = "";
   * 	local ifinhabit = "";
   * 
   * 	-- Get Price
   * 	local price = "default:gold_ingot 2";
   * 
   * 	if (btype ~= 'road' and mg_villages.BUILDINGS[btype]) then
   * 		local plot_descr = 'Plot No. '..tostring( plot_nr ).. ' with '..tostring( mg_villages.BUILDINGS[btype].scm)
   * 
   * 		if (mg_villages.BUILDINGS[btype].price) then
   * 			price = mg_villages.BUILDINGS[btype].price;
   * 		elseif (mg_villages.BUILDINGS[btype].typ and mg_villages.prices[ mg_villages.BUILDINGS[btype].typ ]) then
   * 			price = mg_villages.prices[ mg_villages.BUILDINGS[btype].typ ];
   * 		end
   * 		-- Get if is inhabitant house
   * 		if (mg_villages.BUILDINGS[btype].inh and mg_villages.BUILDINGS[btype].inh > 0 ) then
   * 			ifinhabit = "label[1,1.5;Owners of this plot count as village inhabitants.]";
   * 		end
   * 	end
   * 	-- Determine price depending on building type
   * 	local price_stack= ItemStack( price );
   * 
   * 
   * 	-- If nobody owns the plot
   * 	if (not(owner) or owner=='') then
   * 
   * 		formspec = original_formspec ..
   * 			"label[1,1;You can buy this plot for]".. 
   * 			"label[3.8,1;"..tostring( price_stack:get_count() ).." x ]"..
   * 			"item_image[4.3,0.8;1,1;"..(  price_stack:get_name() ).."]"..
   * 			ifinhabit..
   * 			"button[2,2.5;1.5,0.5;buy;Buy plot]"..
   * 			"button_exit[4,2.5;1.5,0.5;abort;Exit]";
   * 
   * 		-- On Press buy button
   * 		if (fields['buy']) then
   * 			local inv = player:get_inventory();
   * 
   * 			if not mg_villages.all_villages[village_id].ownerlist then
   * 				mg_villages.all_villages[village_id].ownerlist = {}
   * 			end
   * 
   * 			-- Check if player already has a house in the village
   * 			if mg_villages.all_villages[village_id].ownerlist[pname] then
   * 				formspec = formspec.."label[1,1.9;Sorry. You already have a plot in this village.]";
   * 
   * 			-- Check if the price can be paid
   * 			elseif( inv and inv:contains_item( 'main', price_stack )) then
   * 				formspec = original_formspec..
   * 					"label[1,1;Congratulations! You have bought this plot.]"..
   * 					"button_exit[5.75,2.5;1.5,0.5;abort;Exit]";
   * 				mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].owner = pname;
   * 				if mg_villages.all_villages[village_id].ownerlist then
   * 					mg_villages.all_villages[village_id].ownerlist[pname] = true;
   * 				else
   * 					mg_villages.all_villages[village_id].ownerlist[pname] = true;
   * 				end
   * 				meta:set_string('infotext', 'Plot No. '..tostring( plot_nr ).. ' with '..tostring( mg_villages.BUILDINGS[btype].scm)..' (owned by '..tostring( pname )..')');
   * 				-- save the data so that it survives server restart
   * 				mg_villages.save_data();
   * 				-- substract the price from the players inventory
   * 				inv:remove_item( 'main', price_stack );
   * 			else
   * 				formspec = formspec.."label[1,1.9;Sorry. You are not able to pay the price.]";
   * 			end
   * 		end
   * 
   * 	-- If player is the owner of the plot
   * 	elseif (owner==pname) then
   * 
   * 		-- Check if inhabitant house
   * 		if(btype ~= 'road'
   * 			and mg_villages.BUILDINGS[btype]
   * 			and mg_villages.BUILDINGS[btype].inh
   * 			and mg_villages.BUILDINGS[btype].inh > 0 ) then
   * 
   * 			ifinhabit = "label[1,1.5;You are allowed to modify the common village area.]";
   * 		end
   * 
   * 		formspec = original_formspec.."size[8,3]"..
   * 			"label[1,1;This is your plot. You have bought it.]"..
   * 			"button[0.75,2.5;3,0.5;add_remove;Add/Remove Players]"..
   * 			ifinhabit..
   * 			"button_exit[3.75,2.5;2.0,0.5;abandon;Abandon plot]"..
   * 			"button_exit[5.75,2.5;1.5,0.5;abort;Exit]";
   * 
   * 		-- If Player wants to abandon plot
   * 		if(fields['abandon'] ) then
   * 			formspec = original_formspec..
   * 				"label[1,1;You have abandoned this plot.]"..
   * 				"button_exit[5.75,2.5;1.5,0.5;abort;Exit]";
   * 			mg_villages.all_villages[village_id].ownerlist[pname] = nil;
   * 			mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit = {}
   * 			mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].owner = nil;
   * 			-- Return price to player
   * 			local inv = player:get_inventory();
   * 			inv:add_item( 'main', price_stack );
   * 			meta:set_string('infotext', 'Plot No. '..tostring( plot_nr ).. ' with '..tostring( mg_villages.BUILDINGS[btype].scm) );
   * 			mg_villages.save_data();
   * 		end
   * 
   * 		-- If Player wants to add/remove trusted players
   * 		if (fields['add_remove']) then
   * 			local previousTrustees = mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit
   * 			local output = "";
   * 			if previousTrustees == nil then
   * 				previousTrustees = {}
   * 			else
   * 				for _, player in ipairs(previousTrustees) do
   * 					output = output..player.."\n"
   * 				end
   * 			end
   * 			formspec = "size[8,3]"..
   * 				"field[20,20;0.1,0.1;pos2str;Pos;"..minetest.pos_to_string( pos ).."]"..
   * 				"textarea[0.3,0.2;8,2.5;ownerplayers;Trusted Players;"..output.."]"..
   * 				"button[3.25,2.5;1.5,0.5;savetrustees;Save]";
   * 
   * 			mg_villages.save_data()
   * 		end
   * 
   * 		-- Save trusted players
   * 		if (fields["savetrustees"] == "Save") then
   * 
   * 			if not mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit then
   * 				mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit = {}
   * 			end
   * 
   * 			local x = 1;
   * 			for _, player in ipairs(fields.ownerplayers:split("\n")) do
   * 				mg_villages.all_villages[ village_id ].to_add_data.bpos[ plot_nr ].can_edit[x] = player
   * 				x = x + 1
   * 			end
   * 
   * 			mg_villages.save_data();
   * 		end
   * 
   * 	-- If A different Player owns plot
   * 	else
   * 		formspec = original_formspec.."label[1,1;"..tostring( owner ).." owns this plot.]"..
   * 					"button_exit[3,2.5;1.5,0.5;abort;Exit]";
   * 	end
   * 
   * 	minetest.show_formspec( pname, "mg_villages:plotmarker", formspec );
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_plotmarker_formspec);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"plotmarker_formspec");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.form_input_handler = function( player, formname, fields)
   * --	mg_villages.print(mg_villages.DEBUG_LEVEL_NORMAL,minetest.serialize(fields));
   * 	if( not( mg_villages.ENABLE_PROTECTION )) then
   * 		return false;
   * 	end
   * 	if( (formname == "mg_villages:plotmarker") and fields.pos2str and not( fields.abort )) then
   * 		local pos = minetest.string_to_pos( fields.pos2str );
   * 		mg_villages.plotmarker_formspec( pos, formname, fields, player );
   * 		return true;
   * 	end
   * 	return false;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_form_input_handler);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"form_input_handler");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_on_player_receive_fields( mg_villages.form_input_handler ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_player_receive_fields");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"form_input_handler");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_protection(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}



