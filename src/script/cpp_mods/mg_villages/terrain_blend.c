/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


#include <math.h>

/* __pow metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_pow(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,pow(lua_tonumber(L,idxa),lua_tonumber(L,idxb)));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__pow")||luaL_getmetafield(L,idxb,"__pow")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: mg_villages.village_area_mark_single_house_area
 * function(village_area, minp, maxp, pos, pr, village_nr, village) */
static int lcf1_mg_villages_village_area_mark_single_house_area (lua_State * L) {
  lua_checkstack(L,45);
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* local YFLATMIN = 2 */
  lua_pushnumber(L,2);
  assert(lua_gettop(L) == 8);
  
  /* -- Lowest flat area height
   * local FFAPROP = 0.5 */
  lua_pushnumber(L,0.5);
  assert(lua_gettop(L) == 9);
  
  /* -- front flat area proportion of dimension
   * local np_blend = {
   * 		offset = 0,
   * 		scale = 1,
   * 		spread = {x=12, y=12, z=12},
   * 		seed = 38393,
   * 		octaves = 3,
   * 		persist = 0.67
   * 	} */
  lua_createtable(L,0,6);
  lua_pushliteral(L,"offset");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"scale");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"spread");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,12);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,12);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,12);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"seed");
  lua_pushnumber(L,38393);
  lua_rawset(L,-3);
  lua_pushliteral(L,"octaves");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"persist");
  lua_pushnumber(L,0.67);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 10);
  
  /* local sidelen = maxp.x - minp.x + 1 */
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 11);
  
  /* local xdim, zdim */
  lua_settop(L,(lua_gettop(L) + 2));
  assert(lua_gettop(L) == 13);
  
  /* -- dimensions of house plus front flat area
   * if pos.brotate == 0 or pos.brotate == 2 then */
  enum { lc2 = 13 };
  lua_pushliteral(L,"brotate");
  lua_gettable(L,4);
  lua_pushnumber(L,0);
  const int lc3 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc3);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"brotate");
    lua_gettable(L,4);
    lua_pushnumber(L,2);
    const int lc4 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc4);
  }
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* xdim = pos.bsizex */
    lua_pushliteral(L,"bsizex");
    lua_gettable(L,4);
    lua_replace(L,12);
    assert(lua_gettop(L) == 13);
    
    /* zdim = pos.bsizez + math.floor(FFAPROP * pos.bsizez) */
    lua_pushliteral(L,"bsizez");
    lua_gettable(L,4);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bsizez");
    lua_gettable(L,4);
    lc_mul(L,9,-1);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,13);
    assert(lua_gettop(L) == 13);
  }
  else {
    
    /* else
     * xdim = pos.bsizex + math.floor(FFAPROP * pos.bsizex) */
    lua_pushliteral(L,"bsizex");
    lua_gettable(L,4);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"floor");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bsizex");
    lua_gettable(L,4);
    lc_mul(L,9,-1);
    lua_remove(L,-2);
    lua_call(L,1,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_replace(L,12);
    assert(lua_gettop(L) == 13);
    
    /* zdim = pos.bsizez */
    lua_pushliteral(L,"bsizez");
    lua_gettable(L,4);
    lua_replace(L,13);
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc2);
  assert(lua_gettop(L) == 13);
  
  /* -- 2D noise perlinmap
   * local chulens = {x=sidelen, y=sidelen, z=sidelen} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,11);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,11);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushvalue(L,11);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 14);
  
  /* local minpos = {x=minp.x, y=minp.z} */
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 15);
  
  /* local nvals_blend = minetest.get_perlin_map(np_blend, chulens):get2dMap_flat(minpos,nvals_buf) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin_map");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,10);
  lua_pushvalue(L,14);
  lua_call(L,2,1);
  lua_pushliteral(L,"get2dMap_flat");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,15);
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 16);
  
  /* -- buffer added by McCerealGuy
   * -- mark mapchunk-sized house area
   * local ni = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 17);
  
  /* --	for z = minp.z, maxp.z do
   * --	for x = minp.x, maxp.x do -- for each column do
   * for z = math.max( village.vz - village.vs, minp.z), math.min(village.vz + village.vs, maxp.z), 1 do */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"max");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vz");
  lua_gettable(L,7);
  lua_pushliteral(L,"vs");
  lua_gettable(L,7);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_call(L,2,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"min");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"vz");
  lua_gettable(L,7);
  lua_pushliteral(L,"vs");
  lua_gettable(L,7);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  lua_call(L,2,1);
  lua_pushnumber(L,1);
  if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc6_var = lua_tonumber(L,-3);
  const double lc7_limit = lua_tonumber(L,-2);
  const double lc8_step = lua_tonumber(L,-1);
  lua_pop(L,3);
  enum { lc9 = 17 };
  while ((((lc8_step > 0) && (lc6_var <= lc7_limit)) || ((lc8_step <= 0) && (lc6_var >= lc7_limit)))) {
    
    /* internal: local z at index 18 */
    lua_pushnumber(L,lc6_var);
    
    /* for x = math.max( village.vx - village.vs, minp.x), math.min(village.vx + village.vs, maxp.x), 1 do -- for each column do */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"vx");
    lua_gettable(L,7);
    lua_pushliteral(L,"vs");
    lua_gettable(L,7);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_call(L,2,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"min");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"vx");
    lua_gettable(L,7);
    lua_pushliteral(L,"vs");
    lua_gettable(L,7);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc10_var = lua_tonumber(L,-3);
    const double lc11_limit = lua_tonumber(L,-2);
    const double lc12_step = lua_tonumber(L,-1);
    lua_pop(L,3);
    enum { lc13 = 18 };
    while ((((lc12_step > 0) && (lc10_var <= lc11_limit)) || ((lc12_step <= 0) && (lc10_var >= lc11_limit)))) {
      
      /* internal: local x at index 19 */
      lua_pushnumber(L,lc10_var);
      
      /* -- for each column do
       * local xrm = x - minp.x */
      lua_pushliteral(L,"x");
      lua_gettable(L,2);
      lc_sub(L,19,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 20);
      
      /* -- relative to mapchunk minp
       * local zrm = z - minp.z */
      lua_pushliteral(L,"z");
      lua_gettable(L,2);
      lc_sub(L,18,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 21);
      
      /* local xr = x - village.vx */
      lua_pushliteral(L,"vx");
      lua_gettable(L,7);
      lc_sub(L,19,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 22);
      
      /* -- relative to blend centre
       * local zr = z - village.vz */
      lua_pushliteral(L,"vz");
      lua_gettable(L,7);
      lc_sub(L,18,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 23);
      
      /* local xre1 = (zdim / 2) * (xr / zr) */
      lua_pushnumber(L,2);
      lc_div(L,13,-1);
      lua_remove(L,-2);
      lc_div(L,22,23);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 24);
      
      /* local zre1 = zdim / 2 */
      lua_pushnumber(L,2);
      lc_div(L,13,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 25);
      
      /* local xre2 = xdim / 2 */
      lua_pushnumber(L,2);
      lc_div(L,12,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 26);
      
      /* local zre2 = (xdim / 2) * (zr / xr) */
      lua_pushnumber(L,2);
      lc_div(L,12,-1);
      lua_remove(L,-2);
      lc_div(L,23,22);
      lc_mul(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 27);
      
      /* local rade1 = math.sqrt(xre1 ^ 2 + zre1 ^ 2) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"sqrt");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_pow(L,24,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_pow(L,25,-1);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 28);
      
      /* local rade2 = math.sqrt(xre2 ^ 2 + zre2 ^ 2) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"sqrt");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_pow(L,26,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_pow(L,27,-1);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 29);
      
      /* local flatrad = math.min(rade1, rade2) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"min");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,28);
      lua_pushvalue(L,29);
      lua_call(L,2,1);
      assert(lua_gettop(L) == 30);
      
      /* -- radius at edge of rectangular house flat area
       * local n_absblend = math.abs(nvals_blend[ni]) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"abs");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,17);
      lua_gettable(L,16);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 31);
      
      /* local blenradn = village.vs - n_absblend * 2 */
      lua_pushliteral(L,"vs");
      lua_gettable(L,7);
      lua_pushnumber(L,2);
      lc_mul(L,31,-1);
      lua_remove(L,-2);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 32);
      
      /* -- vary blend radius
       * local flatradn = flatrad + n_absblend * 2 */
      lua_pushnumber(L,2);
      lc_mul(L,31,-1);
      lua_remove(L,-2);
      lc_add(L,30,-1);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 33);
      
      /* -- vary shape of house flat area
       * local nodrad = math.sqrt(xr ^ 2 + zr ^ 2) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"sqrt");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_pow(L,22,-1);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lc_pow(L,23,-1);
      lua_remove(L,-2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 34);
      
      /* -- node radius
       * -- only blend the terrain if it does not already belong to another village
       * if( village_area[ x ][ z ][ 2 ] == 0 ) then */
      enum { lc14 = 34 };
      lua_pushvalue(L,19);
      lua_gettable(L,1);
      lua_pushvalue(L,18);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      const int lc15 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc15);
      const int lc16 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc16) {
        
        /* if    x >= (pos.x-1) and x <= (pos.x + pos.bsizex + 1) -- area reserved for house
         * 			  and z >= (pos.z-1) and z <= (pos.z + pos.bsizez + 1) then */
        enum { lc17 = 34 };
        lua_pushliteral(L,"x");
        lua_gettable(L,4);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc18 = lc_le(L,-1,19);
        lua_pop(L,1);
        lua_pushboolean(L,lc18);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"x");
          lua_gettable(L,4);
          lua_pushliteral(L,"bsizex");
          lua_gettable(L,4);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          const int lc19 = lc_le(L,19,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc19);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"z");
          lua_gettable(L,4);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          const int lc20 = lc_le(L,-1,18);
          lua_pop(L,1);
          lua_pushboolean(L,lc20);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"z");
          lua_gettable(L,4);
          lua_pushliteral(L,"bsizez");
          lua_gettable(L,4);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          const int lc21 = lc_le(L,18,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc21);
        }
        const int lc22 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc22) {
          
          /* village_area[ x ][ z ] = {village_nr, 4} */
          lua_createtable(L,2,0);
          lua_pushvalue(L,6);
          lua_rawseti(L,-2,1);
          lua_pushnumber(L,4);
          lua_rawseti(L,-2,2);
          lua_pushvalue(L,19);
          lua_gettable(L,1);
          lua_insert(L,-2);
          lua_pushvalue(L,18);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 34);
        }
        else {
          
          /* elseif nodrad <= flatradn or (xr == 0 and zr == 0) then */
          enum { lc23 = 34 };
          lua_pushboolean(L,lc_le(L,34,33));
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,22);
            lua_pushnumber(L,0);
            const int lc24 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc24);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,23);
              lua_pushnumber(L,0);
              const int lc25 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc25);
            }
          }
          const int lc26 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc26) {
            
            /* -- irregular flat area around house
             * village_area[ x ][ z ] = {village_nr, 1} */
            lua_createtable(L,2,0);
            lua_pushvalue(L,6);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,1);
            lua_rawseti(L,-2,2);
            lua_pushvalue(L,19);
            lua_gettable(L,1);
            lua_insert(L,-2);
            lua_pushvalue(L,18);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 34);
          }
          else {
            
            /* elseif nodrad <= blenradn then */
            enum { lc27 = 34 };
            lua_pushboolean(L,lc_le(L,34,32));
            const int lc28 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc28) {
              
              /* -- terrain blend area
               * local blenprop = ((nodrad - flatradn) / (blenradn - flatradn)) */
              lc_sub(L,34,33);
              lc_sub(L,32,33);
              lc_div(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              assert(lua_gettop(L) == 35);
              
              /* village_area[ x ][ z ] = {village_nr, -1 * blenprop} */
              lua_createtable(L,2,0);
              lua_pushvalue(L,6);
              lua_rawseti(L,-2,1);
              lua_pushnumber(L,-1);
              lc_mul(L,-1,35);
              lua_remove(L,-2);
              lua_rawseti(L,-2,2);
              lua_pushvalue(L,19);
              lua_gettable(L,1);
              lua_insert(L,-2);
              lua_pushvalue(L,18);
              lua_insert(L,-2);
              lua_settable(L,-3);
              lua_pop(L,1);
              assert(lua_gettop(L) == 35);
            }
            else {
            }
            lua_settop(L,lc27);
          }
          lua_settop(L,lc23);
        }
        lua_settop(L,lc17);
        assert(lua_gettop(L) == 34);
      }
      lua_settop(L,lc14);
      assert(lua_gettop(L) == 34);
      
      /* ni = ni + 1 */
      lua_pushnumber(L,1);
      lc_add(L,17,-1);
      lua_remove(L,-2);
      lua_replace(L,17);
      assert(lua_gettop(L) == 34);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,16);
      lc10_var += lc12_step;
    }
    lua_settop(L,lc13);
    assert(lua_gettop(L) == 18);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc6_var += lc8_step;
  }
  lua_settop(L,lc9);
  assert(lua_gettop(L) == 17);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- this function needs to be fed house x, z dimensions and rotation
   * -- it will then calculate the minimum point (xbmin, avsurfy, zbmin) where the house should be spawned
   * -- and mark a mapchunk-sized 'house area' for terrain blending
   * -- buffer for get2dMap_flat, added by MrCerealGuy
   * local nvals_buf = {} */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.village_area_mark_single_house_area = function(village_area, minp, maxp, pos, pr, village_nr, village)
   * 
   * 	local YFLATMIN = 2 -- Lowest flat area height
   * 	local FFAPROP = 0.5 -- front flat area proportion of dimension
   * 	local np_blend = {
   * 		offset = 0,
   * 		scale = 1,
   * 		spread = {x=12, y=12, z=12},
   * 		seed = 38393,
   * 		octaves = 3,
   * 		persist = 0.67
   * 	}
   * 
   * 	local sidelen = maxp.x - minp.x + 1
   * 	
   * 	local xdim, zdim -- dimensions of house plus front flat area
   * 	if pos.brotate == 0 or pos.brotate == 2 then
   * 		xdim = pos.bsizex
   * 		zdim = pos.bsizez + math.floor(FFAPROP * pos.bsizez)
   * 	else
   * 		xdim = pos.bsizex + math.floor(FFAPROP * pos.bsizex)
   * 		zdim = pos.bsizez
   * 	end
   * 
   * 	-- 2D noise perlinmap
   * 	local chulens = {x=sidelen, y=sidelen, z=sidelen}
   * 	local minpos = {x=minp.x, y=minp.z}
   * 	local nvals_blend = minetest.get_perlin_map(np_blend, chulens):get2dMap_flat(minpos,nvals_buf)  -- buffer added by McCerealGuy
   * 
   * 	-- mark mapchunk-sized house area
   * 	local ni = 1
   * --	for z = minp.z, maxp.z do
   * --	for x = minp.x, maxp.x do -- for each column do
   * 	for z = math.max( village.vz - village.vs, minp.z), math.min(village.vz + village.vs, maxp.z), 1 do
   * 	for x = math.max( village.vx - village.vs, minp.x), math.min(village.vx + village.vs, maxp.x), 1 do -- for each column do
   * 
   * 		local xrm = x - minp.x -- relative to mapchunk minp
   * 		local zrm = z - minp.z
   * 		local xr = x - village.vx -- relative to blend centre
   * 		local zr = z - village.vz
   * 		local xre1 = (zdim / 2) * (xr / zr)
   * 		local zre1 = zdim / 2
   * 		local xre2 = xdim / 2
   * 		local zre2 = (xdim / 2) * (zr / xr)
   * 		local rade1 = math.sqrt(xre1 ^ 2 + zre1 ^ 2)
   * 		local rade2 = math.sqrt(xre2 ^ 2 + zre2 ^ 2)
   * 		local flatrad = math.min(rade1, rade2) -- radius at edge of rectangular house flat area
   * 		local n_absblend = math.abs(nvals_blend[ni])
   * 		local blenradn = village.vs - n_absblend * 2 -- vary blend radius
   * 		local flatradn = flatrad + n_absblend * 2 -- vary shape of house flat area
   * 		local nodrad = math.sqrt(xr ^ 2 + zr ^ 2) -- node radius
   * 
   * 		-- only blend the terrain if it does not already belong to another village
   * 		if( village_area[ x ][ z ][ 2 ] == 0 ) then
   * 			if    x >= (pos.x-1) and x <= (pos.x + pos.bsizex + 1) -- area reserved for house
   * 			  and z >= (pos.z-1) and z <= (pos.z + pos.bsizez + 1) then
   * 				village_area[ x ][ z ] = {village_nr, 4}
   * 			elseif nodrad <= flatradn or (xr == 0 and zr == 0) then -- irregular flat area around house
   * 				village_area[ x ][ z ] = {village_nr, 1}
   * 			elseif nodrad <= blenradn then -- terrain blend area
   * 				local blenprop = ((nodrad - flatradn) / (blenradn - flatradn))
   * 				village_area[ x ][ z ] = {village_nr, -1 * blenprop} -- terrain blending
   * 			else -- no change to terrain
   * 				--village_area[xrm][zrm] = {village_nr, 0}
   * 			end
   * 		end
   * 		ni = ni + 1
   * 	end
   * 	end
   * end */
  lua_pushvalue(L,(lc1 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_village_area_mark_single_house_area,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_area_mark_single_house_area");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_terrain_blend(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


