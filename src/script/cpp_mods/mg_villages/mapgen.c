/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: mg_villages.new_village_spawned
 * function( village_id) */
static int lcf1_mg_villages_new_village_spawned (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* -- dummy function
   * return village_id */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: mg_villages.part_of_village_spawned
 * function( village, minp, maxp, data, param2_data, a, cid) */
static int lcf1_mg_villages_part_of_village_spawned (lua_State * L) {
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* -- mobf needs a way to spawn its traders
   * if( minetest.get_modpath( 'mobf_trader' )) then */
  enum { lc1 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mobf_trader");
  lua_call(L,1,1);
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* mob_village_traders.part_of_village_spawned( village, minp, maxp, data, param2_data, a, cid ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mob_village_traders");
    lua_pushliteral(L,"part_of_village_spawned");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_pushvalue(L,7);
    lua_call(L,7,0);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(mgparams) */
static int lcf3 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* mg_villages.wseed = math.floor(mgparams.seed/10000000000) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"seed");
  lua_gettable(L,1);
  lua_pushnumber(L,10000000000);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"wseed");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.get_bseed
 * function(minp) */
static int lcf1_mg_villages_get_bseed (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* return mg_villages.wseed + math.floor(5*minp.x/47) + math.floor(873*minp.z/91) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"wseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,5);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,47);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,873);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,91);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: mg_villages.get_bseed2
 * function(minp) */
static int lcf1_mg_villages_get_bseed2 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* return mg_villages.wseed + math.floor(87*minp.x/47) + math.floor(73*minp.z/91) + math.floor(31*minp.y/12) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"wseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,87);
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,47);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,73);
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,91);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"floor");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,31);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,12);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static int lc_le(lua_State * L, int idxa, int idxb) {
  if (lua_type(L,idxa) == LUA_TNUMBER && lua_type(L,idxb) == LUA_TNUMBER) {
    return lua_tonumber(L,idxa) <= lua_tonumber(L,idxb);
  }
  else if (lua_type(L,idxa) == LUA_TSTRING && lua_type(L,idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L,idxa,idxb) || lua_rawequal(L,idxa,idxb);
  }
  else if (luaL_getmetafield(L,idxa,"__le")||luaL_getmetafield(L,idxb,"__le")) {
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
    lua_call(L,2,1);
    const int result = lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else if (luaL_getmetafield(L,idxa,"__lt")||luaL_getmetafield(L,idxb,"__lt")) {
    lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-1 : idxb);
    lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-2 : idxa);
    lua_call(L,2,1);
    const int result = ! lua_toboolean(L,-1);
    lua_pop(L,1);
    return result;
  }
  else {
    return luaL_error(L, "attempt to compare");
  }
}


/* name: mg_villages.inside_village
 * function(x, z, village, vnoise) */
static int lcf1_mg_villages_inside_village (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) <= 40 */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_vn");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_pushvalue(L,3);
  lua_call(L,4,1);
  lua_pushnumber(L,40);
  const int lc4 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc4);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.inside_village_area
 * function(x, z, village, vnoise) */
static int lcf1_mg_villages_inside_village_area (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) <= 80 */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_vn");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_pushvalue(L,3);
  lua_call(L,4,1);
  lua_pushnumber(L,80);
  const int lc5 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc5);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.inside_village_terrain_blend_area
 * function(x, z, village, vnoise) */
static int lcf1_mg_villages_inside_village_terrain_blend_area (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) <= 160 */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_vn");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_pushvalue(L,3);
  lua_call(L,4,1);
  lua_pushnumber(L,160);
  const int lc6 = lc_le(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc6);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* name: mg_villages.get_vnoise
 * function(x, z, village, vnoise) */
static int lcf1_mg_villages_get_vnoise (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* -- PM v
   * return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) */
  const int lc7 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_vn");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get2d");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"x");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  lua_pushvalue(L,3);
  lua_call(L,4,LUA_MULTRET);
  return (lua_gettop(L) - lc7);
  assert(lua_gettop(L) == 4);
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.get_vn
 * function(x, z, noise, village) */
static int lcf1_mg_villages_get_vn (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local vx, vz, vs = village.vx, village.vz, village.vs */
  lua_pushliteral(L,"vx");
  lua_gettable(L,4);
  lua_pushliteral(L,"vz");
  lua_gettable(L,4);
  lua_pushliteral(L,"vs");
  lua_gettable(L,4);
  assert(lua_gettop(L) == 7);
  
  /* return (noise - 2) * 20 +
   *                 (40 / (vs * vs)) * ((x - vx) * (x - vx) + (z - vz) * (z - vz)) */
  lua_pushnumber(L,2);
  lc_sub(L,3,-1);
  lua_remove(L,-2);
  lua_pushnumber(L,20);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,40);
  lc_mul(L,7,7);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,1,5);
  lc_sub(L,1,5);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_sub(L,2,6);
  lc_sub(L,2,6);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_mul(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* __unm metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_unm(lua_State * L, int idxa) {
  if (lua_isnumber(L,idxa)) {
    lua_pushnumber(L,- lua_tonumber(L, idxa));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__unm")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_call(L,1,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.villages_in_mapchunk
 * function( minp, mapchunk_size) */
static int lcf1_mg_villages_villages_in_mapchunk (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local noise1raw = minetest.get_perlin(12345, 6, 0.5, 256) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,12345);
  lua_pushnumber(L,6);
  lua_pushnumber(L,0.5);
  lua_pushnumber(L,256);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 3);
  
  /* local vcr = mg_villages.VILLAGE_CHECK_RADIUS */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"VILLAGE_CHECK_RADIUS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* local villages = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* for xi = -vcr, vcr do */
  lc_unm(L,4);
  if (!((lua_isnumber(L,-1) && lua_isnumber(L,4)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc8_var = lua_tonumber(L,-1);
  const double lc9_limit = lua_tonumber(L,4);
  const double lc10_step = 1;
  lua_pop(L,1);
  enum { lc11 = 5 };
  while ((((lc10_step > 0) && (lc8_var <= lc9_limit)) || ((lc10_step <= 0) && (lc8_var >= lc9_limit)))) {
    
    /* internal: local xi at index 6 */
    lua_pushnumber(L,lc8_var);
    
    /* for zi = -vcr, vcr do */
    lc_unm(L,4);
    if (!((lua_isnumber(L,-1) && lua_isnumber(L,4)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc12_var = lua_tonumber(L,-1);
    const double lc13_limit = lua_tonumber(L,4);
    const double lc14_step = 1;
    lua_pop(L,1);
    enum { lc15 = 6 };
    while ((((lc14_step > 0) && (lc12_var <= lc13_limit)) || ((lc14_step <= 0) && (lc12_var >= lc13_limit)))) {
      
      /* internal: local zi at index 7 */
      lua_pushnumber(L,lc12_var);
      
      /* for _, village in ipairs(mg_villages.villages_at_point({x = minp.x + xi * mapchunk_size, z = minp.z + zi * mapchunk_size}, noise1raw)) do
       * internal: local f, s, var = explist */
      enum { lc16 = 7 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
      const int lc17 = lua_gettop(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"villages_at_point");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,2);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lc_mul(L,6,2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lc_mul(L,7,2);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_rawset(L,-3);
      lua_pushvalue(L,3);
      lua_call(L,2,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc17),3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local _ with idx 11
         * internal: local village with idx 12 */
        
        
        /* villages[#villages+1] = village */
        lua_pushvalue(L,12);
        const double lc18 = lua_objlen(L,5);
        lua_pushnumber(L,lc18);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_settable(L,5);
        assert(lua_gettop(L) == 12);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc16);
      assert(lua_gettop(L) == 7);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc12_var += lc14_step;
    }
    lua_settop(L,lc15);
    assert(lua_gettop(L) == 6);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc8_var += lc10_step;
  }
  lua_settop(L,lc11);
  assert(lua_gettop(L) == 5);
  
  /* return villages */
  lua_pushvalue(L,5);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* name: mg_villages.check_if_ground
 * function( ci) */
static int lcf1_mg_villages_check_if_ground (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* -- pre-generate a list of no-ground-nodes for caching
   * if( ci==nil or replacements_group.node_is_ground[ minetest.get_content_id('air')]==nil) then */
  enum { lc22 = 1 };
  lua_pushvalue(L,1);
  lua_pushnil(L);
  const int lc23 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc23);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
    lua_pushliteral(L,"node_is_ground");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"air");
    lua_call(L,1,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnil(L);
    const int lc24 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc24);
  }
  const int lc25 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc25) {
    
    /* local no_ground_nodes = {'air','ignore','default:sandstonebrick','default:cactus','default:wood','default:junglewood',
     * 			'default:pine_wood','default:pine_tree','default:acacia_wood','default:acacia_tree', 'default:aspen_wood', 'default:aspen_tree',
     * 			'ethereal:mushroom_pore','ethereal:mushroom_trunk','ethereal:bamboo', 'ethereal:mushroom',
     *                         'ethereal:bush', 'default:grass', 'default:grass_1','default:grass_2','default:grass_3','default:grass_4','default:grass_5'} */
    lua_createtable(L,23,0);
    lua_pushliteral(L,"air");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"ignore");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:sandstonebrick");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"default:cactus");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"default:wood");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"default:junglewood");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"default:pine_wood");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"default:pine_tree");
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"default:acacia_wood");
    lua_rawseti(L,-2,9);
    lua_pushliteral(L,"default:acacia_tree");
    lua_rawseti(L,-2,10);
    lua_pushliteral(L,"default:aspen_wood");
    lua_rawseti(L,-2,11);
    lua_pushliteral(L,"default:aspen_tree");
    lua_rawseti(L,-2,12);
    lua_pushliteral(L,"ethereal:mushroom_pore");
    lua_rawseti(L,-2,13);
    lua_pushliteral(L,"ethereal:mushroom_trunk");
    lua_rawseti(L,-2,14);
    lua_pushliteral(L,"ethereal:bamboo");
    lua_rawseti(L,-2,15);
    lua_pushliteral(L,"ethereal:mushroom");
    lua_rawseti(L,-2,16);
    lua_pushliteral(L,"ethereal:bush");
    lua_rawseti(L,-2,17);
    lua_pushliteral(L,"default:grass");
    lua_rawseti(L,-2,18);
    lua_pushliteral(L,"default:grass_1");
    lua_rawseti(L,-2,19);
    lua_pushliteral(L,"default:grass_2");
    lua_rawseti(L,-2,20);
    lua_pushliteral(L,"default:grass_3");
    lua_rawseti(L,-2,21);
    lua_pushliteral(L,"default:grass_4");
    lua_rawseti(L,-2,22);
    lua_pushliteral(L,"default:grass_5");
    lua_rawseti(L,-2,23);
    assert(lua_gettop(L) == 2);
    
    /* -- TODO: add all those other tree and leaf nodes that might be added by mapgen
     * for _,name in ipairs( no_ground_nodes ) do
     * internal: local f, s, var = explist */
    enum { lc26 = 2 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushvalue(L,2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 6
       * internal: local name with idx 7 */
      
      
      /* if( minetest.registered_nodes[ name ]) then */
      enum { lc27 = 7 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,7);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc28 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc28) {
        
        /* replacements_group.node_is_ground[ minetest.get_content_id( name )] = false */
        lua_pushboolean(L,0);
        lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
        lua_pushliteral(L,"node_is_ground");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_content_id");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,7);
        lua_call(L,1,1);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 7);
      }
      lua_settop(L,lc27);
      assert(lua_gettop(L) == 7);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc26);
    assert(lua_gettop(L) == 2);
    
    /* local ground_nodes = {'ethereal:dry_dirt', 'default:dirt_with_dry_grass','default:stone','default:sandstone','default:desertstone',
     *                         'ethereal:grey_dirt', 'default:dirt_with_snow', 'default:dirt_with_grass', 'ethereal:grove_dirt', 'ethereal:green_dirt',
     * 			'ethereal:grove_dirt','ethereal:jungle_dirt'} */
    lua_createtable(L,12,0);
    lua_pushliteral(L,"ethereal:dry_dirt");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default:dirt_with_dry_grass");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default:stone");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"default:sandstone");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"default:desertstone");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"ethereal:grey_dirt");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"default:dirt_with_snow");
    lua_rawseti(L,-2,7);
    lua_pushliteral(L,"default:dirt_with_grass");
    lua_rawseti(L,-2,8);
    lua_pushliteral(L,"ethereal:grove_dirt");
    lua_rawseti(L,-2,9);
    lua_pushliteral(L,"ethereal:green_dirt");
    lua_rawseti(L,-2,10);
    lua_pushliteral(L,"ethereal:grove_dirt");
    lua_rawseti(L,-2,11);
    lua_pushliteral(L,"ethereal:jungle_dirt");
    lua_rawseti(L,-2,12);
    assert(lua_gettop(L) == 3);
    
    /* for _,name in ipairs( ground_nodes ) do
     * internal: local f, s, var = explist */
    enum { lc29 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushvalue(L,3);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 7
       * internal: local name with idx 8 */
      
      
      /* if( minetest.registered_nodes[ name ]) then */
      enum { lc30 = 8 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,8);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc31 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc31) {
        
        /* replacements_group.node_is_ground[ minetest.get_content_id( name )] = true */
        lua_pushboolean(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
        lua_pushliteral(L,"node_is_ground");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_content_id");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,8);
        lua_call(L,1,1);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc30);
      assert(lua_gettop(L) == 8);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc29);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc22);
  assert(lua_gettop(L) == 1);
  
  /* if( not( ci )) then */
  enum { lc32 = 1 };
  lua_pushboolean(L,!(lua_toboolean(L,1)));
  const int lc33 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc33) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc32);
  assert(lua_gettop(L) == 1);
  
  /* if( replacements_group.node_is_ground[ ci ] ~= nil) then */
  enum { lc34 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
  lua_pushliteral(L,"node_is_ground");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc35 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc35);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc36 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc36) {
    
    /* return replacements_group.node_is_ground[ ci ] */
    lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
    lua_pushliteral(L,"node_is_ground");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc34);
  assert(lua_gettop(L) == 1);
  
  /* -- analyze the node
   * -- only nodes on which walking is possible may be counted as ground
   * local node_name = minetest.get_name_from_content_id( ci ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_name_from_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* local def = minetest.registered_nodes[ node_name ] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* -- store information about this node type for later use
   * if(     not( def )) then */
  enum { lc37 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc38 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc38) {
    
    /* replacements_group.node_is_ground[ ci ] = false */
    lua_pushboolean(L,0);
    lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
    lua_pushliteral(L,"node_is_ground");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* elseif( not( def.walkable)) then */
    enum { lc39 = 3 };
    lua_pushliteral(L,"walkable");
    lua_gettable(L,3);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc40 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc40) {
      
      /* replacements_group.node_is_ground[ ci ] = false */
      lua_pushboolean(L,0);
      lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
      lua_pushliteral(L,"node_is_ground");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,1);
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 3);
    }
    else {
      
      /* elseif( def.groups and def.groups.tree ) then */
      enum { lc41 = 3 };
      lua_pushliteral(L,"groups");
      lua_gettable(L,3);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"groups");
        lua_gettable(L,3);
        lua_pushliteral(L,"tree");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      const int lc42 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc42) {
        
        /* replacements_group.node_is_ground[ ci ] = false */
        lua_pushboolean(L,0);
        lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
        lua_pushliteral(L,"node_is_ground");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 3);
      }
      else {
        
        /* elseif(	def.drop   and def.drop == 'default:dirt') then */
        enum { lc43 = 3 };
        lua_pushliteral(L,"drop");
        lua_gettable(L,3);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"drop");
          lua_gettable(L,3);
          lua_pushliteral(L,"default:dirt");
          const int lc44 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc44);
        }
        const int lc45 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc45) {
          
          /* replacements_group.node_is_ground[ ci ] = true */
          lua_pushboolean(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
          lua_pushliteral(L,"node_is_ground");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 3);
        }
        else {
          
          /* elseif( def.walkable == true and def.is_ground_content == true and not(def.node_box)) then */
          enum { lc46 = 3 };
          lua_pushliteral(L,"walkable");
          lua_gettable(L,3);
          lua_pushboolean(L,1);
          const int lc47 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc47);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"is_ground_content");
            lua_gettable(L,3);
            lua_pushboolean(L,1);
            const int lc48 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc48);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"node_box");
            lua_gettable(L,3);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          const int lc49 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc49) {
            
            /* replacements_group.node_is_ground[ ci ] = true */
            lua_pushboolean(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
            lua_pushliteral(L,"node_is_ground");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,1);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 3);
          }
          else {
            
            /* else
             * replacements_group.node_is_ground[ ci ] = false */
            lua_pushboolean(L,0);
            lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
            lua_pushliteral(L,"node_is_ground");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,1);
            lua_insert(L,-2);
            lua_settable(L,-3);
            lua_pop(L,1);
            assert(lua_gettop(L) == 3);
          }
          lua_settop(L,lc46);
        }
        lua_settop(L,lc43);
      }
      lua_settop(L,lc41);
    }
    lua_settop(L,lc39);
  }
  lua_settop(L,lc37);
  assert(lua_gettop(L) == 3);
  
  /* return replacements_group.node_is_ground[ ci ] */
  lua_getfield(L,LUA_ENVIRONINDEX,"replacements_group");
  lua_pushliteral(L,"node_is_ground");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: mg_villages.lower_or_raise_terrain_at_point
 * function( x, z, target_height, minp, maxp, vm, data, param2_data, a, cid, vh, treepos, has_artificial_snow, blend, force_ground, force_underground) */
static int lcf1_mg_villages_lower_or_raise_terrain_at_point (lua_State * L) {
  lua_checkstack(L,41);
  enum { lc_nformalargs = 16 };
  lua_settop(L,16);
  
  /* local surface_node  = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 17);
  
  /* local has_snow      = has_artificial_snow */
  lua_pushvalue(L,13);
  assert(lua_gettop(L) == 18);
  
  /* local tree          = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 19);
  
  /* local jtree         = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 20);
  
  /* local ptree         = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 21);
  
  /* local atree         = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 22);
  
  /* local asptree       = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 23);
  
  /* local old_height    = maxp.y */
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  assert(lua_gettop(L) == 24);
  
  /* local y = maxp.y */
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  assert(lua_gettop(L) == 25);
  
  /* local look_for_snow = true */
  lua_pushboolean(L,1);
  assert(lua_gettop(L) == 26);
  
  /* if( cid.c_snow==cid.c_ignore or cid.c_snow==cid.c_air
   * 	 or cid.c_ice ==cid.c_ignore or cid.c_ice ==cid.c_air ) then */
  enum { lc50 = 26 };
  lua_pushliteral(L,"c_snow");
  lua_gettable(L,10);
  lua_pushliteral(L,"c_ignore");
  lua_gettable(L,10);
  const int lc51 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc51);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"c_snow");
    lua_gettable(L,10);
    lua_pushliteral(L,"c_air");
    lua_gettable(L,10);
    const int lc52 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc52);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"c_ice");
    lua_gettable(L,10);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,10);
    const int lc53 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc53);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"c_ice");
    lua_gettable(L,10);
    lua_pushliteral(L,"c_air");
    lua_gettable(L,10);
    const int lc54 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc54);
  }
  const int lc55 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc55) {
    
    /* look_for_snow = nil */
    lua_pushnil(L);
    lua_replace(L,26);
    assert(lua_gettop(L) == 26);
  }
  lua_settop(L,lc50);
  assert(lua_gettop(L) == 26);
  
  /* -- if we are working on a mapchunk above, set all to air;
   * -- any terrain blending happens in the mapchunk below
   * if( minp.y > vh ) then */
  enum { lc56 = 26 };
  lua_pushliteral(L,"y");
  lua_gettable(L,4);
  const int lc57 = lua_lessthan(L,11,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc57);
  const int lc58 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc58) {
    
    /* local air_counted = 0 */
    lua_pushnumber(L,0);
    assert(lua_gettop(L) == 27);
    
    /* for y=minp.y, minp.y+16 do */
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    lua_pushnumber(L,16);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc59_var = lua_tonumber(L,-2);
    const double lc60_limit = lua_tonumber(L,-1);
    const double lc61_step = 1;
    lua_pop(L,2);
    enum { lc62 = 27 };
    while ((((lc61_step > 0) && (lc59_var <= lc60_limit)) || ((lc61_step <= 0) && (lc59_var >= lc60_limit)))) {
      
      /* internal: local y at index 28 */
      lua_pushnumber(L,lc59_var);
      
      /* if( data[a:index( x, y, z )] == cid.c_air ) then */
      enum { lc63 = 28 };
      lua_pushvalue(L,9);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,1);
      lua_pushvalue(L,28);
      lua_pushvalue(L,2);
      lua_call(L,4,1);
      lua_gettable(L,7);
      lua_pushliteral(L,"c_air");
      lua_gettable(L,10);
      const int lc64 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc64);
      const int lc65 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc65) {
        
        /* air_counted = air_counted + 1 */
        lua_pushnumber(L,1);
        lc_add(L,27,-1);
        lua_remove(L,-2);
        lua_replace(L,27);
        assert(lua_gettop(L) == 28);
      }
      lua_settop(L,lc63);
      assert(lua_gettop(L) == 28);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc59_var += lc61_step;
    }
    lua_settop(L,lc62);
    assert(lua_gettop(L) == 27);
    
    /* if( air_counted > 3 or blend==0) then */
    enum { lc66 = 27 };
    lua_pushnumber(L,3);
    const int lc67 = lua_lessthan(L,-1,27);
    lua_pop(L,1);
    lua_pushboolean(L,lc67);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,14);
      lua_pushnumber(L,0);
      const int lc68 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc68);
    }
    const int lc69 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc69) {
      
      /* for y=minp.y+15, maxp.y do */
      lua_pushliteral(L,"y");
      lua_gettable(L,4);
      lua_pushnumber(L,15);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_gettable(L,5);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc70_var = lua_tonumber(L,-2);
      const double lc71_limit = lua_tonumber(L,-1);
      const double lc72_step = 1;
      lua_pop(L,2);
      enum { lc73 = 27 };
      while ((((lc72_step > 0) && (lc70_var <= lc71_limit)) || ((lc72_step <= 0) && (lc70_var >= lc71_limit)))) {
        
        /* internal: local y at index 28 */
        lua_pushnumber(L,lc70_var);
        
        /* data[a:index( x, y, z)] = cid.c_air */
        lua_pushliteral(L,"c_air");
        lua_gettable(L,10);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,28);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 28);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,1);
        lc70_var += lc72_step;
      }
      lua_settop(L,lc73);
      assert(lua_gettop(L) == 27);
    }
    lua_settop(L,lc66);
    assert(lua_gettop(L) == 27);
    
    /* -- else do nothing
     * return; */
    return 0;
    assert(lua_gettop(L) == 27);
  }
  lua_settop(L,lc56);
  assert(lua_gettop(L) == 26);
  
  /* -- search for a surface and set everything above target_height to air
   * while( y > minp.y) do */
  enum { lc74 = 26 };
  while (1) {
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    const int lc75 = lua_lessthan(L,-1,25);
    lua_pop(L,1);
    lua_pushboolean(L,lc75);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* local ci = data[a:index(x, y, z)] */
    lua_pushvalue(L,9);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,25);
    lua_pushvalue(L,2);
    lua_call(L,4,1);
    lua_gettable(L,7);
    assert(lua_gettop(L) == 27);
    
    /* if(     look_for_snow and (ci == cid.c_snow or ci == cid.c_ice or ci == cid.c_snowblock)) then */
    enum { lc76 = 27 };
    lua_pushvalue(L,26);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,27);
      lua_pushliteral(L,"c_snow");
      lua_gettable(L,10);
      const int lc77 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc77);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,27);
        lua_pushliteral(L,"c_ice");
        lua_gettable(L,10);
        const int lc78 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc78);
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,27);
        lua_pushliteral(L,"c_snowblock");
        lua_gettable(L,10);
        const int lc79 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc79);
      }
    }
    const int lc80 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc80) {
      
      /* has_snow = true */
      lua_pushboolean(L,1);
      lua_replace(L,18);
      assert(lua_gettop(L) == 27);
    }
    else {
      
      /* elseif( ci == cid.c_tree ) then */
      enum { lc81 = 27 };
      lua_pushliteral(L,"c_tree");
      lua_gettable(L,10);
      const int lc82 = lua_equal(L,27,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc82);
      const int lc83 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc83) {
        
        /* tree  = true */
        lua_pushboolean(L,1);
        lua_replace(L,19);
        assert(lua_gettop(L) == 27);
      }
      else {
        
        /* -- no jungletrees for branches
         * 		elseif( ci == cid.c_jtree and data[a:index( x, y-1, z)]==cid.c_jtree) then */
        enum { lc84 = 27 };
        lua_pushvalue(L,27);
        lua_pushliteral(L,"c_jtree");
        lua_gettable(L,10);
        const int lc85 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc85);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,9);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lua_pushnumber(L,1);
          lc_sub(L,25,-1);
          lua_remove(L,-2);
          lua_pushvalue(L,2);
          lua_call(L,4,1);
          lua_gettable(L,7);
          lua_pushliteral(L,"c_jtree");
          lua_gettable(L,10);
          const int lc86 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc86);
        }
        const int lc87 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc87) {
          
          /* jtree = true */
          lua_pushboolean(L,1);
          lua_replace(L,20);
          assert(lua_gettop(L) == 27);
        }
        else {
          
          /* -- pinetrees
           * 		elseif( ci == cid.c_ptree and data[a:index( x, y-1, z)]==cid.c_ptree) then */
          enum { lc88 = 27 };
          lua_pushvalue(L,27);
          lua_pushliteral(L,"c_ptree");
          lua_gettable(L,10);
          const int lc89 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc89);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushvalue(L,9);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,1);
            lua_pushnumber(L,1);
            lc_sub(L,25,-1);
            lua_remove(L,-2);
            lua_pushvalue(L,2);
            lua_call(L,4,1);
            lua_gettable(L,7);
            lua_pushliteral(L,"c_ptree");
            lua_gettable(L,10);
            const int lc90 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc90);
          }
          const int lc91 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc91) {
            
            /* ptree = true */
            lua_pushboolean(L,1);
            lua_replace(L,21);
            assert(lua_gettop(L) == 27);
          }
          else {
            
            /* -- acacia
             * 		elseif( ci == cid.c_atree and data[a:index( x, y-1, z)]==cid.c_atree) then */
            enum { lc92 = 27 };
            lua_pushvalue(L,27);
            lua_pushliteral(L,"c_atree");
            lua_gettable(L,10);
            const int lc93 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc93);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,9);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,1);
              lua_pushnumber(L,1);
              lc_sub(L,25,-1);
              lua_remove(L,-2);
              lua_pushvalue(L,2);
              lua_call(L,4,1);
              lua_gettable(L,7);
              lua_pushliteral(L,"c_atree");
              lua_gettable(L,10);
              const int lc94 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc94);
            }
            const int lc95 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc95) {
              
              /* atree = true */
              lua_pushboolean(L,1);
              lua_replace(L,22);
              assert(lua_gettop(L) == 27);
            }
            else {
              
              /* -- aspen
               * 		elseif( ci == cid.c_asptree and data[a:index( x, y-1, z)]==cid.c_asptree) then */
              enum { lc96 = 27 };
              lua_pushvalue(L,27);
              lua_pushliteral(L,"c_asptree");
              lua_gettable(L,10);
              const int lc97 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc97);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushvalue(L,9);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,1);
                lua_pushnumber(L,1);
                lc_sub(L,25,-1);
                lua_remove(L,-2);
                lua_pushvalue(L,2);
                lua_call(L,4,1);
                lua_gettable(L,7);
                lua_pushliteral(L,"c_asptree");
                lua_gettable(L,10);
                const int lc98 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc98);
              }
              const int lc99 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc99) {
                
                /* asptree = true */
                lua_pushboolean(L,1);
                lua_replace(L,23);
                assert(lua_gettop(L) == 27);
              }
              else {
                
                /* elseif( not( surface_node) and ci ~= cid.c_air and ci ~= cid.c_ignore and mg_villages.check_if_ground( ci ) == true) then */
                enum { lc100 = 27 };
                lua_pushboolean(L,!(lua_toboolean(L,17)));
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"c_air");
                  lua_gettable(L,10);
                  const int lc101 = lua_equal(L,27,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc101);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"c_ignore");
                  lua_gettable(L,10);
                  const int lc102 = lua_equal(L,27,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc102);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                  lua_pushliteral(L,"check_if_ground");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,27);
                  lua_call(L,1,1);
                  lua_pushboolean(L,1);
                  const int lc103 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc103);
                }
                const int lc104 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc104) {
                  
                  /* -- we have found a surface of some kind
                   * surface_node = ci */
                  lua_pushvalue(L,27);
                  lua_replace(L,17);
                  assert(lua_gettop(L) == 27);
                  
                  /* old_height   = y */
                  lua_pushvalue(L,25);
                  lua_replace(L,24);
                  assert(lua_gettop(L) == 27);
                  
                  /* if( look_for_snow and surface_node == cid.c_dirt_with_snow and cid.c_dirt_with_snow~=cid.c_ignore) then */
                  enum { lc105 = 27 };
                  lua_pushvalue(L,26);
                  if (lua_toboolean(L,-1)) {
                    lua_pop(L,1);
                    lua_pushvalue(L,17);
                    lua_pushliteral(L,"c_dirt_with_snow");
                    lua_gettable(L,10);
                    const int lc106 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc106);
                  }
                  if (lua_toboolean(L,-1)) {
                    lua_pop(L,1);
                    lua_pushliteral(L,"c_dirt_with_snow");
                    lua_gettable(L,10);
                    lua_pushliteral(L,"c_ignore");
                    lua_gettable(L,10);
                    const int lc107 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc107);
                    lua_pushboolean(L,!(lua_toboolean(L,-1)));
                    lua_remove(L,-2);
                  }
                  const int lc108 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc108) {
                    
                    /* has_snow = true */
                    lua_pushboolean(L,1);
                    lua_replace(L,18);
                    assert(lua_gettop(L) == 27);
                  }
                  lua_settop(L,lc105);
                  assert(lua_gettop(L) == 27);
                }
                lua_settop(L,lc100);
              }
              lua_settop(L,lc96);
            }
            lua_settop(L,lc92);
          }
          lua_settop(L,lc88);
        }
        lua_settop(L,lc84);
      }
      lua_settop(L,lc81);
    }
    lua_settop(L,lc76);
    assert(lua_gettop(L) == 27);
    
    /* -- make sure there is air for the village
     * if( y > target_height ) then */
    enum { lc109 = 27 };
    const int lc110 = lua_lessthan(L,3,25);
    lua_pushboolean(L,lc110);
    const int lc111 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc111) {
      
      /* data[a:index( x, y, z)] = cid.c_air */
      lua_pushliteral(L,"c_air");
      lua_gettable(L,10);
      lua_pushvalue(L,9);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,1);
      lua_pushvalue(L,25);
      lua_pushvalue(L,2);
      lua_call(L,4,1);
      lua_insert(L,-2);
      lua_settable(L,7);
      assert(lua_gettop(L) == 27);
    }
    else {
      
      /* -- abort search once we've reached village ground level and found a surface node
       * 		elseif( y <= target_height and surface_node ) then */
      enum { lc112 = 27 };
      lua_pushboolean(L,lc_le(L,25,3));
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,17);
      }
      const int lc113 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc113) {
        
        /* y = minp.y - 1 */
        lua_pushliteral(L,"y");
        lua_gettable(L,4);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,25);
        assert(lua_gettop(L) == 27);
      }
      lua_settop(L,lc112);
    }
    lua_settop(L,lc109);
    assert(lua_gettop(L) == 27);
    
    /* y = y-1 */
    lua_pushnumber(L,1);
    lc_sub(L,25,-1);
    lua_remove(L,-2);
    lua_replace(L,25);
    assert(lua_gettop(L) == 27);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
  }
  lua_settop(L,lc74);
  assert(lua_gettop(L) == 26);
  
  /* if( not( surface_node ) and old_height == maxp.y ) then */
  enum { lc114 = 26 };
  lua_pushboolean(L,!(lua_toboolean(L,17)));
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,24);
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    const int lc115 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc115);
  }
  const int lc116 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc116) {
    
    /* if(     data[a:index( x, minp.y, z)]==cid.c_air) then */
    enum { lc117 = 26 };
    lua_pushvalue(L,9);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    lua_pushvalue(L,2);
    lua_call(L,4,1);
    lua_gettable(L,7);
    lua_pushliteral(L,"c_air");
    lua_gettable(L,10);
    const int lc118 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc118);
    const int lc119 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc119) {
      
      /* old_height = vh - 2 */
      lua_pushnumber(L,2);
      lc_sub(L,11,-1);
      lua_remove(L,-2);
      lua_replace(L,24);
      assert(lua_gettop(L) == 26);
    }
    else {
      
      /* elseif( minp.y < 0 ) then */
      enum { lc120 = 26 };
      lua_pushliteral(L,"y");
      lua_gettable(L,4);
      lua_pushnumber(L,0);
      const int lc121 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc121);
      const int lc122 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc122) {
        
        /* old_height = minp.y */
        lua_pushliteral(L,"y");
        lua_gettable(L,4);
        lua_replace(L,24);
        assert(lua_gettop(L) == 26);
      }
      lua_settop(L,lc120);
    }
    lua_settop(L,lc117);
    assert(lua_gettop(L) == 26);
  }
  lua_settop(L,lc114);
  assert(lua_gettop(L) == 26);
  
  /* if( not( surface_node ) or surface_node == cid.c_dirt) then */
  enum { lc123 = 26 };
  lua_pushboolean(L,!(lua_toboolean(L,17)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,17);
    lua_pushliteral(L,"c_dirt");
    lua_gettable(L,10);
    const int lc124 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc124);
  }
  const int lc125 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc125) {
    
    /* surface_node = cid.c_dirt_with_grass */
    lua_pushliteral(L,"c_dirt_with_grass");
    lua_gettable(L,10);
    lua_replace(L,17);
    assert(lua_gettop(L) == 26);
  }
  lua_settop(L,lc123);
  assert(lua_gettop(L) == 26);
  
  /* if( look_for_snow and has_snow and surface_node == cid.c_dirt_with_grass and target_height > 1) then */
  enum { lc126 = 26 };
  lua_pushvalue(L,26);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,18);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,17);
    lua_pushliteral(L,"c_dirt_with_grass");
    lua_gettable(L,10);
    const int lc127 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc127);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,1);
    const int lc128 = lua_lessthan(L,-1,3);
    lua_pop(L,1);
    lua_pushboolean(L,lc128);
  }
  const int lc129 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc129) {
    
    /* surface_node = cid.c_dirt_with_snow */
    lua_pushliteral(L,"c_dirt_with_snow");
    lua_gettable(L,10);
    lua_replace(L,17);
    assert(lua_gettop(L) == 26);
  }
  lua_settop(L,lc126);
  assert(lua_gettop(L) == 26);
  
  /* local below_1 = cid.c_dirt */
  lua_pushliteral(L,"c_dirt");
  lua_gettable(L,10);
  assert(lua_gettop(L) == 27);
  
  /* local below_2 = cid.c_stone */
  lua_pushliteral(L,"c_stone");
  lua_gettable(L,10);
  assert(lua_gettop(L) == 28);
  
  /* if(     force_ground and force_underground ) then */
  enum { lc130 = 28 };
  lua_pushvalue(L,15);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,16);
  }
  const int lc131 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc131) {
    
    /* below_1 = force_ground */
    lua_pushvalue(L,15);
    lua_replace(L,27);
    assert(lua_gettop(L) == 28);
    
    /* below_2 = force_underground */
    lua_pushvalue(L,16);
    lua_replace(L,28);
    assert(lua_gettop(L) == 28);
    
    /* surface_node = below_1 */
    lua_pushvalue(L,27);
    lua_replace(L,17);
    assert(lua_gettop(L) == 28);
  }
  else {
    
    /* elseif( surface_node == cid.c_desert_sand ) then */
    enum { lc132 = 28 };
    lua_pushliteral(L,"c_desert_sand");
    lua_gettable(L,10);
    const int lc133 = lua_equal(L,17,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc133);
    const int lc134 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc134) {
      
      /* below_1 = cid.c_desert_sand */
      lua_pushliteral(L,"c_desert_sand");
      lua_gettable(L,10);
      lua_replace(L,27);
      assert(lua_gettop(L) == 28);
      
      /* below_2 = cid.c_desert_stone */
      lua_pushliteral(L,"c_desert_stone");
      lua_gettable(L,10);
      lua_replace(L,28);
      assert(lua_gettop(L) == 28);
    }
    else {
      
      /* elseif( surface_node == cid.c_sand ) then */
      enum { lc135 = 28 };
      lua_pushliteral(L,"c_sand");
      lua_gettable(L,10);
      const int lc136 = lua_equal(L,17,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc136);
      const int lc137 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc137) {
        
        /* below_1 = cid.c_sand */
        lua_pushliteral(L,"c_sand");
        lua_gettable(L,10);
        lua_replace(L,27);
        assert(lua_gettop(L) == 28);
        
        /* below_2 = cid.c_stone */
        lua_pushliteral(L,"c_stone");
        lua_gettable(L,10);
        lua_replace(L,28);
        assert(lua_gettop(L) == 28);
      }
      else {
        
        /* elseif( cid.c_ethereal_clay_read
         * 	    and (surface_node == cid.c_ethereal_clay_red
         * 	      or surface_node == cid.c_ethereal_clay_orange)) then */
        enum { lc138 = 28 };
        lua_pushliteral(L,"c_ethereal_clay_read");
        lua_gettable(L,10);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,17);
          lua_pushliteral(L,"c_ethereal_clay_red");
          lua_gettable(L,10);
          const int lc139 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc139);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,17);
            lua_pushliteral(L,"c_ethereal_clay_orange");
            lua_gettable(L,10);
            const int lc140 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc140);
          }
        }
        const int lc141 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc141) {
          
          /* below_1 = cid.c_ethereal_clay_orange */
          lua_pushliteral(L,"c_ethereal_clay_orange");
          lua_gettable(L,10);
          lua_replace(L,27);
          assert(lua_gettop(L) == 28);
          
          /* below_2 = cid.c_ethereal_clay_orange */
          lua_pushliteral(L,"c_ethereal_clay_orange");
          lua_gettable(L,10);
          lua_replace(L,28);
          assert(lua_gettop(L) == 28);
        }
        else {
          
          /* elseif( surface_node == cid.c_sandstone ) then */
          enum { lc142 = 28 };
          lua_pushliteral(L,"c_sandstone");
          lua_gettable(L,10);
          const int lc143 = lua_equal(L,17,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc143);
          const int lc144 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc144) {
            
            /* below_1 = cid.c_sandstone */
            lua_pushliteral(L,"c_sandstone");
            lua_gettable(L,10);
            lua_replace(L,27);
            assert(lua_gettop(L) == 28);
            
            /* below_2 = cid.c_sandstone */
            lua_pushliteral(L,"c_sandstone");
            lua_gettable(L,10);
            lua_replace(L,28);
            assert(lua_gettop(L) == 28);
          }
          else {
            
            /* else
             * below_1 = cid.c_dirt */
            lua_pushliteral(L,"c_dirt");
            lua_gettable(L,10);
            lua_replace(L,27);
            assert(lua_gettop(L) == 28);
            
            /* below_2 = cid.c_stone */
            lua_pushliteral(L,"c_stone");
            lua_gettable(L,10);
            lua_replace(L,28);
            assert(lua_gettop(L) == 28);
          }
          lua_settop(L,lc142);
        }
        lua_settop(L,lc138);
      }
      lua_settop(L,lc135);
    }
    lua_settop(L,lc132);
  }
  lua_settop(L,lc130);
  assert(lua_gettop(L) == 28);
  
  /* -- do terrain blending; target_height has to be calculated based on old_height
   * if( target_height == maxp.y and old_height < maxp.y ) then */
  enum { lc145 = 28 };
  lua_pushvalue(L,3);
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  const int lc146 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc146);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    const int lc147 = lua_lessthan(L,24,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc147);
  }
  const int lc148 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc148) {
    
    /* local yblend = old_height */
    lua_pushvalue(L,24);
    assert(lua_gettop(L) == 29);
    
    /* if blend > 0 then */
    enum { lc149 = 29 };
    lua_pushnumber(L,0);
    const int lc150 = lua_lessthan(L,-1,14);
    lua_pop(L,1);
    lua_pushboolean(L,lc150);
    const int lc151 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc151) {
      
      /* -- leave some cliffs unblended
       * yblend = math.floor(vh + blend * (old_height - vh)) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"floor");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_sub(L,24,11);
      lc_mul(L,14,-1);
      lua_remove(L,-2);
      lc_add(L,11,-1);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_replace(L,29);
      assert(lua_gettop(L) == 29);
      
      /* target_height = yblend+1 */
      lua_pushnumber(L,1);
      lc_add(L,29,-1);
      lua_remove(L,-2);
      lua_replace(L,3);
      assert(lua_gettop(L) == 29);
    }
    else {
      
      /* else
       * target_height = old_height */
      lua_pushvalue(L,24);
      lua_replace(L,3);
      assert(lua_gettop(L) == 29);
    }
    lua_settop(L,lc149);
    assert(lua_gettop(L) == 29);
    
    /* for y = math.max( minp.y, yblend), maxp.y do */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"max");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    lua_pushvalue(L,29);
    lua_call(L,2,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc152_var = lua_tonumber(L,-2);
    const double lc153_limit = lua_tonumber(L,-1);
    const double lc154_step = 1;
    lua_pop(L,2);
    enum { lc155 = 29 };
    while ((((lc154_step > 0) && (lc152_var <= lc153_limit)) || ((lc154_step <= 0) && (lc152_var >= lc153_limit)))) {
      
      /* internal: local y at index 30 */
      lua_pushnumber(L,lc152_var);
      
      /* if( y<=MG_VILLAGES_WATER_LEVEL ) then */
      enum { lc156 = 30 };
      lc_getupvalue(L,lua_upvalueindex(1),0,1);
      const int lc157 = lc_le(L,30,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc157);
      const int lc158 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc158) {
        
        /* -- keep ice
         * if( data[a:index( x, y, z )] ~= cid.c_ice ) then */
        enum { lc159 = 30 };
        lua_pushvalue(L,9);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,30);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
        lua_gettable(L,7);
        lua_pushliteral(L,"c_ice");
        lua_gettable(L,10);
        const int lc160 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc160);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc161 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc161) {
          
          /* data[a:index( x, y, z)] = cid.c_water */
          lua_pushliteral(L,"c_water");
          lua_gettable(L,10);
          lua_pushvalue(L,9);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lua_pushvalue(L,30);
          lua_pushvalue(L,2);
          lua_call(L,4,1);
          lua_insert(L,-2);
          lua_settable(L,7);
          assert(lua_gettop(L) == 30);
        }
        lua_settop(L,lc159);
        assert(lua_gettop(L) == 30);
      }
      else {
        
        /* else
         * data[a:index( x, y, z)] = cid.c_air */
        lua_pushliteral(L,"c_air");
        lua_gettable(L,10);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,30);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 30);
      }
      lua_settop(L,lc156);
      assert(lua_gettop(L) == 30);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc152_var += lc154_step;
    }
    lua_settop(L,lc155);
    assert(lua_gettop(L) == 29);
  }
  lua_settop(L,lc145);
  assert(lua_gettop(L) == 28);
  
  /* -- only place the surface node if it is actually contained in this node
   * if( target_height >= minp.y and target_height < maxp.y ) then */
  enum { lc162 = 28 };
  lua_pushliteral(L,"y");
  lua_gettable(L,4);
  const int lc163 = lc_le(L,-1,3);
  lua_pop(L,1);
  lua_pushboolean(L,lc163);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"y");
    lua_gettable(L,5);
    const int lc164 = lua_lessthan(L,3,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc164);
  }
  const int lc165 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc165) {
    
    /* if( target_height < 1 ) then */
    enum { lc166 = 28 };
    lua_pushnumber(L,1);
    const int lc167 = lua_lessthan(L,3,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc167);
    const int lc168 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc168) {
    }
    else {
      
      /* -- no trees or snow below water level
       * 		elseif( tree  and not( mg_villages.ethereal_trees ) and treepos) then */
      enum { lc169 = 28 };
      lua_pushvalue(L,19);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"ethereal_trees");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,12);
      }
      const int lc170 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc170) {
        
        /* data[       a:index( x, target_height+1, z)] = cid.c_sapling */
        lua_pushliteral(L,"c_sapling");
        lua_gettable(L,10);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_pushnumber(L,1);
        lc_add(L,3,-1);
        lua_remove(L,-2);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 28);
        
        /* table.insert( treepos, {x=x, y=target_height+1, z=z, typ=0, snow=has_artificial_snow}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"table");
        lua_pushliteral(L,"insert");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,12);
        lua_createtable(L,0,5);
        lua_pushliteral(L,"x");
        lua_pushvalue(L,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushnumber(L,1);
        lc_add(L,3,-1);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushvalue(L,2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"typ");
        lua_pushnumber(L,0);
        lua_rawset(L,-3);
        lua_pushliteral(L,"snow");
        lua_pushvalue(L,13);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 28);
      }
      else {
        
        /* elseif( jtree and not( mg_villages.ethereal_trees ) and treepos) then */
        enum { lc171 = 28 };
        lua_pushvalue(L,20);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"ethereal_trees");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,12);
        }
        const int lc172 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc172) {
          
          /* data[       a:index( x, target_height+1, z)] = cid.c_jsapling */
          lua_pushliteral(L,"c_jsapling");
          lua_gettable(L,10);
          lua_pushvalue(L,9);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,1);
          lua_pushnumber(L,1);
          lc_add(L,3,-1);
          lua_remove(L,-2);
          lua_pushvalue(L,2);
          lua_call(L,4,1);
          lua_insert(L,-2);
          lua_settable(L,7);
          assert(lua_gettop(L) == 28);
          
          /* table.insert( treepos, {x=x, y=target_height+1, z=z, typ=1, snow=has_artificial_snow}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"table");
          lua_pushliteral(L,"insert");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,12);
          lua_createtable(L,0,5);
          lua_pushliteral(L,"x");
          lua_pushvalue(L,1);
          lua_rawset(L,-3);
          lua_pushliteral(L,"y");
          lua_pushnumber(L,1);
          lc_add(L,3,-1);
          lua_remove(L,-2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"z");
          lua_pushvalue(L,2);
          lua_rawset(L,-3);
          lua_pushliteral(L,"typ");
          lua_pushnumber(L,1);
          lua_rawset(L,-3);
          lua_pushliteral(L,"snow");
          lua_pushvalue(L,13);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 28);
        }
        else {
          
          /* elseif( ptree and not( mg_villages.ethereal_trees ) and treepos) then */
          enum { lc173 = 28 };
          lua_pushvalue(L,21);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"ethereal_trees");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushvalue(L,12);
          }
          const int lc174 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc174) {
            
            /* data[       a:index( x, target_height+1, z)] = cid.c_psapling */
            lua_pushliteral(L,"c_psapling");
            lua_gettable(L,10);
            lua_pushvalue(L,9);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,1);
            lua_pushnumber(L,1);
            lc_add(L,3,-1);
            lua_remove(L,-2);
            lua_pushvalue(L,2);
            lua_call(L,4,1);
            lua_insert(L,-2);
            lua_settable(L,7);
            assert(lua_gettop(L) == 28);
            
            /* table.insert( treepos, {x=x, y=target_height+1, z=z, typ=2, snow=has_artificial_snow}) */
            lua_getfield(L,LUA_ENVIRONINDEX,"table");
            lua_pushliteral(L,"insert");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,12);
            lua_createtable(L,0,5);
            lua_pushliteral(L,"x");
            lua_pushvalue(L,1);
            lua_rawset(L,-3);
            lua_pushliteral(L,"y");
            lua_pushnumber(L,1);
            lc_add(L,3,-1);
            lua_remove(L,-2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"z");
            lua_pushvalue(L,2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"typ");
            lua_pushnumber(L,2);
            lua_rawset(L,-3);
            lua_pushliteral(L,"snow");
            lua_pushvalue(L,13);
            lua_rawset(L,-3);
            lua_call(L,2,0);
            assert(lua_gettop(L) == 28);
          }
          else {
            
            /* elseif( atree and not( mg_villages.ethereal_trees ) and treepos) then */
            enum { lc175 = 28 };
            lua_pushvalue(L,22);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"ethereal_trees");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,12);
            }
            const int lc176 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc176) {
              
              /* data[       a:index( x, target_height+1, z)] = cid.c_asapling */
              lua_pushliteral(L,"c_asapling");
              lua_gettable(L,10);
              lua_pushvalue(L,9);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,1);
              lua_pushnumber(L,1);
              lc_add(L,3,-1);
              lua_remove(L,-2);
              lua_pushvalue(L,2);
              lua_call(L,4,1);
              lua_insert(L,-2);
              lua_settable(L,7);
              assert(lua_gettop(L) == 28);
              
              /* table.insert( treepos, {x=x, y=target_height+1, z=z, typ=3, snow=has_artificial_snow}) */
              lua_getfield(L,LUA_ENVIRONINDEX,"table");
              lua_pushliteral(L,"insert");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_createtable(L,0,5);
              lua_pushliteral(L,"x");
              lua_pushvalue(L,1);
              lua_rawset(L,-3);
              lua_pushliteral(L,"y");
              lua_pushnumber(L,1);
              lc_add(L,3,-1);
              lua_remove(L,-2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"z");
              lua_pushvalue(L,2);
              lua_rawset(L,-3);
              lua_pushliteral(L,"typ");
              lua_pushnumber(L,3);
              lua_rawset(L,-3);
              lua_pushliteral(L,"snow");
              lua_pushvalue(L,13);
              lua_rawset(L,-3);
              lua_call(L,2,0);
              assert(lua_gettop(L) == 28);
            }
            else {
              
              /* elseif( asptree and not( mg_villages.ethereal_trees ) and treepos) then */
              enum { lc177 = 28 };
              lua_pushvalue(L,23);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"ethereal_trees");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
              }
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushvalue(L,12);
              }
              const int lc178 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc178) {
                
                /* data[       a:index( x, target_height+1, z)] = cid.c_aspsapling */
                lua_pushliteral(L,"c_aspsapling");
                lua_gettable(L,10);
                lua_pushvalue(L,9);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,1);
                lua_pushnumber(L,1);
                lc_add(L,3,-1);
                lua_remove(L,-2);
                lua_pushvalue(L,2);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,7);
                assert(lua_gettop(L) == 28);
                
                /* table.insert( treepos, {x=x, y=target_height+1, z=z, typ=3, snow=has_artificial_snow}) */
                lua_getfield(L,LUA_ENVIRONINDEX,"table");
                lua_pushliteral(L,"insert");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,12);
                lua_createtable(L,0,5);
                lua_pushliteral(L,"x");
                lua_pushvalue(L,1);
                lua_rawset(L,-3);
                lua_pushliteral(L,"y");
                lua_pushnumber(L,1);
                lc_add(L,3,-1);
                lua_remove(L,-2);
                lua_rawset(L,-3);
                lua_pushliteral(L,"z");
                lua_pushvalue(L,2);
                lua_rawset(L,-3);
                lua_pushliteral(L,"typ");
                lua_pushnumber(L,3);
                lua_rawset(L,-3);
                lua_pushliteral(L,"snow");
                lua_pushvalue(L,13);
                lua_rawset(L,-3);
                lua_call(L,2,0);
                assert(lua_gettop(L) == 28);
              }
              else {
                
                /* elseif( has_snow ) then */
                enum { lc179 = 28 };
                if (lua_toboolean(L,18)) {
                  
                  /* data[       a:index( x, target_height+1, z)] = cid.c_snow */
                  lua_pushliteral(L,"c_snow");
                  lua_gettable(L,10);
                  lua_pushvalue(L,9);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,1);
                  lua_pushnumber(L,1);
                  lc_add(L,3,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,2);
                  lua_call(L,4,1);
                  lua_insert(L,-2);
                  lua_settable(L,7);
                  assert(lua_gettop(L) == 28);
                }
                lua_settop(L,lc179);
              }
              lua_settop(L,lc177);
            }
            lua_settop(L,lc175);
          }
          lua_settop(L,lc173);
        }
        lua_settop(L,lc171);
      }
      lua_settop(L,lc169);
    }
    lua_settop(L,lc166);
    assert(lua_gettop(L) == 28);
    
    /* data[               a:index( x, target_height,   z)] = surface_node */
    lua_pushvalue(L,17);
    lua_pushvalue(L,9);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,3);
    lua_pushvalue(L,2);
    lua_call(L,4,1);
    lua_insert(L,-2);
    lua_settable(L,7);
    assert(lua_gettop(L) == 28);
    
    /* if( target_height-1 >= minp.y ) then */
    enum { lc180 = 28 };
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    lua_pushnumber(L,1);
    lc_sub(L,3,-1);
    lua_remove(L,-2);
    const int lc181 = lc_le(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc181);
    const int lc182 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc182) {
      
      /* data[       a:index( x, target_height-1, z)] = below_1 */
      lua_pushvalue(L,27);
      lua_pushvalue(L,9);
      lua_pushliteral(L,"index");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,1);
      lua_pushnumber(L,1);
      lc_sub(L,3,-1);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,4,1);
      lua_insert(L,-2);
      lua_settable(L,7);
      assert(lua_gettop(L) == 28);
    }
    lua_settop(L,lc180);
    assert(lua_gettop(L) == 28);
  }
  lua_settop(L,lc162);
  assert(lua_gettop(L) == 28);
  
  /* -- not every column will get a coal block; some may get two
   * local coal_height1 = math.random( minp.y, maxp.y ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,4);
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 29);
  
  /* local coal_height2 = math.random( minp.y, maxp.y ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_gettable(L,4);
  lua_pushliteral(L,"y");
  lua_gettable(L,5);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 30);
  
  /* y = target_height-2 */
  lua_pushnumber(L,2);
  lc_sub(L,3,-1);
  lua_remove(L,-2);
  lua_replace(L,25);
  assert(lua_gettop(L) == 30);
  
  /* while( y > minp.y and y > target_height-40 and y <=maxp.y) do */
  enum { lc183 = 30 };
  while (1) {
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    const int lc184 = lua_lessthan(L,-1,25);
    lua_pop(L,1);
    lua_pushboolean(L,lc184);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,40);
      lc_sub(L,3,-1);
      lua_remove(L,-2);
      const int lc185 = lua_lessthan(L,-1,25);
      lua_pop(L,1);
      lua_pushboolean(L,lc185);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"y");
      lua_gettable(L,5);
      const int lc186 = lc_le(L,25,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc186);
    }
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* local old_node = data[a:index( x, y, z)] */
    lua_pushvalue(L,9);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,25);
    lua_pushvalue(L,2);
    lua_call(L,4,1);
    lua_gettable(L,7);
    assert(lua_gettop(L) == 31);
    
    /* -- abort as soon as we hit anything other than air
     * if( old_node == cid.c_air or old_node == cid.c_water ) then */
    enum { lc187 = 31 };
    lua_pushvalue(L,31);
    lua_pushliteral(L,"c_air");
    lua_gettable(L,10);
    const int lc188 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc188);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,31);
      lua_pushliteral(L,"c_water");
      lua_gettable(L,10);
      const int lc189 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc189);
    }
    const int lc190 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc190) {
      
      /* -- the occasional coal makes large stone cliffs slightly less boring
       * if( y == coal_height1 or y == coal_height2 ) then */
      enum { lc191 = 31 };
      lua_pushvalue(L,25);
      lua_pushvalue(L,29);
      const int lc192 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc192);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,25);
        lua_pushvalue(L,30);
        const int lc193 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc193);
      }
      const int lc194 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc194) {
        
        /* data[a:index( x, y, z )] = cid.c_stone_with_coal */
        lua_pushliteral(L,"c_stone_with_coal");
        lua_gettable(L,10);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,25);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 31);
      }
      else {
        
        /* else
         * data[a:index( x, y, z)] = below_2 */
        lua_pushvalue(L,28);
        lua_pushvalue(L,9);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,1);
        lua_pushvalue(L,25);
        lua_pushvalue(L,2);
        lua_call(L,4,1);
        lua_insert(L,-2);
        lua_settable(L,7);
        assert(lua_gettop(L) == 31);
      }
      lua_settop(L,lc191);
      assert(lua_gettop(L) == 31);
      
      /* y = y-1 */
      lua_pushnumber(L,1);
      lc_sub(L,25,-1);
      lua_remove(L,-2);
      lua_replace(L,25);
      assert(lua_gettop(L) == 31);
    }
    else {
      
      /* else
       * y = minp.y - 1 */
      lua_pushliteral(L,"y");
      lua_gettable(L,4);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_replace(L,25);
      assert(lua_gettop(L) == 31);
    }
    lua_settop(L,lc187);
    assert(lua_gettop(L) == 31);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
  }
  lua_settop(L,lc183);
  assert(lua_gettop(L) == 30);
  return 0;
}


/* name: mg_villages.flatten_village_area
 * function( villages, minp, maxp, vm, data, param2_data, a, village_area, cid) */
static int lcf1_mg_villages_flatten_village_area (lua_State * L) {
  lua_checkstack(L,30);
  enum { lc_nformalargs = 9 };
  lua_settop(L,9);
  
  /* local treepos = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 10);
  
  /* for z = minp.z, maxp.z do */
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc195_var = lua_tonumber(L,-2);
  const double lc196_limit = lua_tonumber(L,-1);
  const double lc197_step = 1;
  lua_pop(L,2);
  enum { lc198 = 10 };
  while ((((lc197_step > 0) && (lc195_var <= lc196_limit)) || ((lc197_step <= 0) && (lc195_var >= lc196_limit)))) {
    
    /* internal: local z at index 11 */
    lua_pushnumber(L,lc195_var);
    
    /* for x = minp.x, maxp.x do */
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc199_var = lua_tonumber(L,-2);
    const double lc200_limit = lua_tonumber(L,-1);
    const double lc201_step = 1;
    lua_pop(L,2);
    enum { lc202 = 11 };
    while ((((lc201_step > 0) && (lc199_var <= lc200_limit)) || ((lc201_step <= 0) && (lc199_var >= lc200_limit)))) {
      
      /* internal: local x at index 12 */
      lua_pushnumber(L,lc199_var);
      
      /* for village_nr, village in ipairs(villages) do
       * internal: local f, s, var = explist */
      enum { lc203 = 12 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
      lua_pushvalue(L,1);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local village_nr with idx 16
         * internal: local village with idx 17 */
        
        
        /* local force_ground = nil */
        lua_pushnil(L);
        assert(lua_gettop(L) == 18);
        
        /* local force_underground = nil */
        lua_pushnil(L);
        assert(lua_gettop(L) == 19);
        
        /* if( village.village_type
         * 			   and mg_villages.village_type_data[ village.village_type ] 
         * 			   and mg_villages.village_type_data[ village.village_type ].force_ground
         * 			   and mg_villages.village_type_data[ village.village_type ].force_underground ) then */
        enum { lc204 = 19 };
        lua_pushliteral(L,"village_type");
        lua_gettable(L,17);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"village_type_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"village_type");
          lua_gettable(L,17);
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"village_type_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"village_type");
          lua_gettable(L,17);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"force_ground");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"village_type_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"village_type");
          lua_gettable(L,17);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"force_underground");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        const int lc205 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc205) {
          
          /* force_ground      = minetest.get_content_id(mg_villages.village_type_data[ village.village_type ].force_ground) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_content_id");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"village_type_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"village_type");
          lua_gettable(L,17);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"force_ground");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lua_replace(L,18);
          assert(lua_gettop(L) == 19);
          
          /* force_underground = minetest.get_content_id(mg_villages.village_type_data[ village.village_type ].force_underground) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"get_content_id");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"village_type_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"village_type");
          lua_gettable(L,17);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"force_underground");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,1,1);
          lua_replace(L,19);
          assert(lua_gettop(L) == 19);
          
          /* if( not( force_ground ) or force_ground < 0 or force_ground == cid.c_ignore 
           * 				   or not( force_underground ) or force_underground < 0 or force_underground == cid.c_ignore ) then */
          enum { lc206 = 19 };
          lua_pushboolean(L,!(lua_toboolean(L,18)));
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushnumber(L,0);
            const int lc207 = lua_lessthan(L,18,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc207);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,18);
            lua_pushliteral(L,"c_ignore");
            lua_gettable(L,9);
            const int lc208 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc208);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushboolean(L,!(lua_toboolean(L,19)));
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushnumber(L,0);
            const int lc209 = lua_lessthan(L,19,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc209);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,19);
            lua_pushliteral(L,"c_ignore");
            lua_gettable(L,9);
            const int lc210 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc210);
          }
          const int lc211 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc211) {
            
            /* force_ground = nil */
            lua_pushnil(L);
            lua_replace(L,18);
            assert(lua_gettop(L) == 19);
            
            /* force_underground = nil */
            lua_pushnil(L);
            lua_replace(L,19);
            assert(lua_gettop(L) == 19);
          }
          lua_settop(L,lc206);
          assert(lua_gettop(L) == 19);
        }
        lua_settop(L,lc204);
        assert(lua_gettop(L) == 19);
        
        /* -- is village_nr the village that is the one that is relevant for this spot?
         * if(    village_area[ x ][ z ][ 1 ] > 0
         * 			   and village_area[ x ][ z ][ 1 ]==village_nr 
         * 			   and village_area[ x ][ z ][ 2 ]~= 0
         * 			   and data[a:index(x,village.vh,z)] ~= cid.c_ignore) then */
        enum { lc212 = 19 };
        lua_pushnumber(L,0);
        lua_pushvalue(L,12);
        lua_gettable(L,8);
        lua_pushvalue(L,11);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc213 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc213);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,12);
          lua_gettable(L,8);
          lua_pushvalue(L,11);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,16);
          const int lc214 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc214);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,12);
          lua_gettable(L,8);
          lua_pushvalue(L,11);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc215 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc215);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,7);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,12);
          lua_pushliteral(L,"vh");
          lua_gettable(L,17);
          lua_pushvalue(L,11);
          lua_call(L,4,1);
          lua_gettable(L,5);
          lua_pushliteral(L,"c_ignore");
          lua_gettable(L,9);
          const int lc216 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc216);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc217 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc217) {
          
          /* local has_artificial_snow = false */
          lua_pushboolean(L,0);
          assert(lua_gettop(L) == 20);
          
          /* if( village.artificial_snow and village.artificial_snow==1) then */
          enum { lc218 = 20 };
          lua_pushliteral(L,"artificial_snow");
          lua_gettable(L,17);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"artificial_snow");
            lua_gettable(L,17);
            lua_pushnumber(L,1);
            const int lc219 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc219);
          }
          const int lc220 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc220) {
            
            /* has_artificial_snow = true */
            lua_pushboolean(L,1);
            lua_replace(L,20);
            assert(lua_gettop(L) == 20);
          }
          lua_settop(L,lc218);
          assert(lua_gettop(L) == 20);
          
          /* if( village_area[ x ][ z ][ 2 ] > 0 ) then */
          enum { lc221 = 20 };
          lua_pushnumber(L,0);
          lua_pushvalue(L,12);
          lua_gettable(L,8);
          lua_pushvalue(L,11);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc222 = lua_lessthan(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc222);
          const int lc223 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc223) {
            
            /* -- inside a village
             * mg_villages.lower_or_raise_terrain_at_point( x, z, village.vh, minp, maxp, vm, data, param2_data, a, cid, village.vh,
             * 											nil,     has_artificial_snow, 0, force_ground, force_underground   ) */
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"lower_or_raise_terrain_at_point");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,12);
            lua_pushvalue(L,11);
            lua_pushliteral(L,"vh");
            lua_gettable(L,17);
            lua_pushvalue(L,2);
            lua_pushvalue(L,3);
            lua_pushvalue(L,4);
            lua_pushvalue(L,5);
            lua_pushvalue(L,6);
            lua_pushvalue(L,7);
            lua_pushvalue(L,9);
            lua_pushliteral(L,"vh");
            lua_gettable(L,17);
            lua_pushnil(L);
            lua_pushvalue(L,20);
            lua_pushnumber(L,0);
            lua_pushvalue(L,18);
            lua_pushvalue(L,19);
            lua_call(L,16,0);
            assert(lua_gettop(L) == 20);
          }
          else {
            
            /* elseif( mg_villages.ENABLE_TERRAIN_BLEND and village_area[ x ][ z ][ 2 ] < 0) then */
            enum { lc224 = 20 };
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"ENABLE_TERRAIN_BLEND");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,12);
              lua_gettable(L,8);
              lua_pushvalue(L,11);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,2);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,0);
              const int lc225 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc225);
            }
            const int lc226 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc226) {
              
              /* mg_villages.lower_or_raise_terrain_at_point( x, z, maxp.y,     minp, maxp, vm, data, param2_data, a, cid, village.vh,
               * 											treepos, has_artificial_snow, -1* village_area[ x ][ z ][ 2 ],
               * 											force_ground, force_underground) */
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"lower_or_raise_terrain_at_point");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_pushvalue(L,11);
              lua_pushliteral(L,"y");
              lua_gettable(L,3);
              lua_pushvalue(L,2);
              lua_pushvalue(L,3);
              lua_pushvalue(L,4);
              lua_pushvalue(L,5);
              lua_pushvalue(L,6);
              lua_pushvalue(L,7);
              lua_pushvalue(L,9);
              lua_pushliteral(L,"vh");
              lua_gettable(L,17);
              lua_pushvalue(L,10);
              lua_pushvalue(L,20);
              lua_pushnumber(L,-1);
              lua_pushvalue(L,12);
              lua_gettable(L,8);
              lua_pushvalue(L,11);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushnumber(L,2);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lc_mul(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,18);
              lua_pushvalue(L,19);
              lua_call(L,16,0);
              assert(lua_gettop(L) == 20);
            }
            lua_settop(L,lc224);
          }
          lua_settop(L,lc221);
          assert(lua_gettop(L) == 20);
        }
        lua_settop(L,lc212);
        assert(lua_gettop(L) == 19);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,4);
      }
      lua_settop(L,lc203);
      assert(lua_gettop(L) == 12);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc199_var += lc201_step;
    }
    lua_settop(L,lc202);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc195_var += lc197_step;
  }
  lua_settop(L,lc198);
  assert(lua_gettop(L) == 10);
  
  /* -- grow normal trees and jungletrees in those parts of the terrain where height blending occours
   * for _, tree in ipairs(treepos) do
   * internal: local f, s, var = explist */
  enum { lc227 = 10 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,10);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 14
     * internal: local tree with idx 15 */
    
    
    /* local plant_id = cid.c_jsapling */
    lua_pushliteral(L,"c_jsapling");
    lua_gettable(L,9);
    assert(lua_gettop(L) == 16);
    
    /* if( tree.typ == 0 ) then */
    enum { lc228 = 16 };
    lua_pushliteral(L,"typ");
    lua_gettable(L,15);
    lua_pushnumber(L,0);
    const int lc229 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc229);
    const int lc230 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc230) {
      
      /* plant_id = cid.c_sapling */
      lua_pushliteral(L,"c_sapling");
      lua_gettable(L,9);
      lua_replace(L,16);
      assert(lua_gettop(L) == 16);
    }
    else {
      
      /* elseif( tree.typ == 2 ) then */
      enum { lc231 = 16 };
      lua_pushliteral(L,"typ");
      lua_gettable(L,15);
      lua_pushnumber(L,2);
      const int lc232 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc232);
      const int lc233 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc233) {
        
        /* plant_id = cid.c_psapling */
        lua_pushliteral(L,"c_psapling");
        lua_gettable(L,9);
        lua_replace(L,16);
        assert(lua_gettop(L) == 16);
      }
      else {
        
        /* elseif( tree.typ == 3 ) then */
        enum { lc234 = 16 };
        lua_pushliteral(L,"typ");
        lua_gettable(L,15);
        lua_pushnumber(L,3);
        const int lc235 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc235);
        const int lc236 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc236) {
          
          /* plant_id = cid.c_asapling */
          lua_pushliteral(L,"c_asapling");
          lua_gettable(L,9);
          lua_replace(L,16);
          assert(lua_gettop(L) == 16);
        }
        lua_settop(L,lc234);
      }
      lua_settop(L,lc231);
    }
    lua_settop(L,lc228);
    assert(lua_gettop(L) == 16);
    
    /* mg_villages.grow_a_tree( {x=tree.x, y=tree.y, z=tree.z}, plant_id, minp, maxp, data, a, cid, nil, tree.snow ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"grow_a_tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,15);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,15);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,15);
    lua_rawset(L,-3);
    lua_pushvalue(L,16);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,5);
    lua_pushvalue(L,7);
    lua_pushvalue(L,9);
    lua_pushnil(L);
    lua_pushliteral(L,"snow");
    lua_gettable(L,15);
    lua_call(L,9,0);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc227);
  assert(lua_gettop(L) == 10);
  return 0;
}


/* name: mg_villages.repair_outer_shell
 * function( villages, minp, maxp, vm, data, param2_data, a, village_area, cid, edge_min, edge_max) */
static int lcf1_mg_villages_repair_outer_shell (lua_State * L) {
  lua_checkstack(L,27);
  enum { lc_nformalargs = 11 };
  lua_settop(L,11);
  
  /* -- find out if this part of the shell has already been generated or not
   * if(    data[a:index(minp.x,minp.y,minp.z)] == cid.c_ignore
   * 
   * 	   and data[a:index(maxp.x,minp.y,minp.z)] == cid.c_ignore
   * 	   and data[a:index(minp.x,maxp.y,minp.z)] == cid.c_ignore
   * 	   and data[a:index(minp.x,minp.y,maxp.z)] == cid.c_ignore
   * 
   * 	   and data[a:index(maxp.x,maxp.y,maxp.z)] == cid.c_ignore
   * 
   * 	   and data[a:index(maxp.x,maxp.y,minp.z)] == cid.c_ignore
   * 	   and data[a:index(maxp.x,minp.y,maxp.z)] == cid.c_ignore
   * 	   and data[a:index(minp.x,maxp.y,maxp.z)] == cid.c_ignore ) then */
  enum { lc237 = 11 };
  lua_pushvalue(L,7);
  lua_pushliteral(L,"index");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_call(L,4,1);
  lua_gettable(L,5);
  lua_pushliteral(L,"c_ignore");
  lua_gettable(L,9);
  const int lc238 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc238);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc239 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc239);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc240 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc240);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc241 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc241);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc242 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc242);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc243 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc243);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc244 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc244);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,7);
    lua_pushliteral(L,"index");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_call(L,4,1);
    lua_gettable(L,5);
    lua_pushliteral(L,"c_ignore");
    lua_gettable(L,9);
    const int lc245 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc245);
  }
  const int lc246 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc246) {
    
    /* -- no - none of the edges has been created yet; no point to place anything there
     * return; */
    return 0;
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc237);
  assert(lua_gettop(L) == 11);
  
  /* if( minp.x < edge_min.x ) then */
  enum { lc247 = 11 };
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_pushliteral(L,"x");
  lua_gettable(L,10);
  const int lc248 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc248);
  const int lc249 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc249) {
    
    /* edge_min.x = minp.x */
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc247);
  assert(lua_gettop(L) == 11);
  
  /* if( minp.y < edge_min.y ) then */
  enum { lc250 = 11 };
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_pushliteral(L,"y");
  lua_gettable(L,10);
  const int lc251 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc251);
  const int lc252 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc252) {
    
    /* edge_min.y = minp.y */
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc250);
  assert(lua_gettop(L) == 11);
  
  /* if( minp.z < edge_min.z ) then */
  enum { lc253 = 11 };
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_pushliteral(L,"z");
  lua_gettable(L,10);
  const int lc254 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc254);
  const int lc255 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc255) {
    
    /* edge_min.z = minp.z */
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc253);
  assert(lua_gettop(L) == 11);
  
  /* if( maxp.x > edge_max.x ) then */
  enum { lc256 = 11 };
  lua_pushliteral(L,"x");
  lua_gettable(L,11);
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  const int lc257 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc257);
  const int lc258 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc258) {
    
    /* edge_max.x = maxp.x */
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    lua_pushliteral(L,"x");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc256);
  assert(lua_gettop(L) == 11);
  
  /* if( maxp.y > edge_max.y ) then */
  enum { lc259 = 11 };
  lua_pushliteral(L,"y");
  lua_gettable(L,11);
  lua_pushliteral(L,"y");
  lua_gettable(L,3);
  const int lc260 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc260);
  const int lc261 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc261) {
    
    /* edge_max.y = maxp.y */
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc259);
  assert(lua_gettop(L) == 11);
  
  /* if( maxp.z > edge_max.z ) then */
  enum { lc262 = 11 };
  lua_pushliteral(L,"z");
  lua_gettable(L,11);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  const int lc263 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc263);
  const int lc264 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc264) {
    
    /* edge_max.z = maxp.z */
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc262);
  assert(lua_gettop(L) == 11);
  
  /* for z = minp.z, maxp.z do */
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc265_var = lua_tonumber(L,-2);
  const double lc266_limit = lua_tonumber(L,-1);
  const double lc267_step = 1;
  lua_pop(L,2);
  enum { lc268 = 11 };
  while ((((lc267_step > 0) && (lc265_var <= lc266_limit)) || ((lc267_step <= 0) && (lc265_var >= lc266_limit)))) {
    
    /* internal: local z at index 12 */
    lua_pushnumber(L,lc265_var);
    
    /* for x = minp.x, maxp.x do
     * 		-- inside a village */
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"x");
    lua_gettable(L,3);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc269_var = lua_tonumber(L,-2);
    const double lc270_limit = lua_tonumber(L,-1);
    const double lc271_step = 1;
    lua_pop(L,2);
    enum { lc272 = 12 };
    while ((((lc271_step > 0) && (lc269_var <= lc270_limit)) || ((lc271_step <= 0) && (lc269_var >= lc270_limit)))) {
      
      /* internal: local x at index 13 */
      lua_pushnumber(L,lc269_var);
      
      /* -- inside a village
       * if( village_area[ x ][ z ][ 2 ] > 0 ) then */
      enum { lc273 = 13 };
      lua_pushnumber(L,0);
      lua_pushvalue(L,13);
      lua_gettable(L,8);
      lua_pushvalue(L,12);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc274 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc274);
      const int lc275 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc275) {
        
        /* local y */
        lua_settop(L,(lua_gettop(L) + 1));
        assert(lua_gettop(L) == 14);
        
        /* local village = villages[ village_area[ x ][ z ][ 1 ]] */
        lua_pushvalue(L,13);
        lua_gettable(L,8);
        lua_pushvalue(L,12);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_gettable(L,1);
        assert(lua_gettop(L) == 15);
        
        /* -- the current node at the ground
         * local node    = data[a:index(x,village.vh,z)] */
        lua_pushvalue(L,7);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,13);
        lua_pushliteral(L,"vh");
        lua_gettable(L,15);
        lua_pushvalue(L,12);
        lua_call(L,4,1);
        lua_gettable(L,5);
        assert(lua_gettop(L) == 16);
        
        /* -- there ought to be something - but there is air
         * if( village and village.vh and (node==cid.c_air or node==cid.c_water)) then */
        enum { lc276 = 16 };
        lua_pushvalue(L,15);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"vh");
          lua_gettable(L,15);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,16);
          lua_pushliteral(L,"c_air");
          lua_gettable(L,9);
          const int lc277 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc277);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,16);
            lua_pushliteral(L,"c_water");
            lua_gettable(L,9);
            const int lc278 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc278);
          }
        }
        const int lc279 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc279) {
          
          /* y = village.vh-1 */
          lua_pushliteral(L,"vh");
          lua_gettable(L,15);
          lua_pushnumber(L,1);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_replace(L,14);
          assert(lua_gettop(L) == 16);
          
          /* -- search from village height downards for holes generated by cavegen and fill them up
           * while( y > minp.y ) do */
          enum { lc280 = 16 };
          while (1) {
            lua_pushliteral(L,"y");
            lua_gettable(L,2);
            const int lc281 = lua_lessthan(L,-1,14);
            lua_pop(L,1);
            lua_pushboolean(L,lc281);
            if (!(lua_toboolean(L,-1))) {
              break;
            }
            lua_pop(L,1);
            
            /* local ci = data[a:index(x, y, z)] */
            lua_pushvalue(L,7);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,13);
            lua_pushvalue(L,14);
            lua_pushvalue(L,12);
            lua_call(L,4,1);
            lua_gettable(L,5);
            assert(lua_gettop(L) == 17);
            
            /* if(     ci == cid.c_desert_stone or ci == cid.c_desert_sand ) then */
            enum { lc282 = 17 };
            lua_pushvalue(L,17);
            lua_pushliteral(L,"c_desert_stone");
            lua_gettable(L,9);
            const int lc283 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc283);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,17);
              lua_pushliteral(L,"c_desert_sand");
              lua_gettable(L,9);
              const int lc284 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc284);
            }
            const int lc285 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc285) {
              
              /* data[a:index(x, village.vh, z)] = cid.c_desert_sand */
              lua_pushliteral(L,"c_desert_sand");
              lua_gettable(L,9);
              lua_pushvalue(L,7);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,13);
              lua_pushliteral(L,"vh");
              lua_gettable(L,15);
              lua_pushvalue(L,12);
              lua_call(L,4,1);
              lua_insert(L,-2);
              lua_settable(L,5);
              assert(lua_gettop(L) == 17);
              
              /* y = minp.y-1 */
              lua_pushliteral(L,"y");
              lua_gettable(L,2);
              lua_pushnumber(L,1);
              lc_sub(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_replace(L,14);
              assert(lua_gettop(L) == 17);
            }
            else {
              
              /* elseif( ci == cid.c_sand ) then */
              enum { lc286 = 17 };
              lua_pushliteral(L,"c_sand");
              lua_gettable(L,9);
              const int lc287 = lua_equal(L,17,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc287);
              const int lc288 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc288) {
                
                /* data[a:index(x, village.vh, z)] = cid.c_sand */
                lua_pushliteral(L,"c_sand");
                lua_gettable(L,9);
                lua_pushvalue(L,7);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,13);
                lua_pushliteral(L,"vh");
                lua_gettable(L,15);
                lua_pushvalue(L,12);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,5);
                assert(lua_gettop(L) == 17);
                
                /* y = minp.y-1 */
                lua_pushliteral(L,"y");
                lua_gettable(L,2);
                lua_pushnumber(L,1);
                lc_sub(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_replace(L,14);
                assert(lua_gettop(L) == 17);
              }
              else {
                
                /* -- use dirt_with_grass as a fallback
                 * 					elseif( ci ~= cid.c_air and ci ~= cid.c_ignore and ci ~= cid.c_water and mg_villages.check_if_ground( ci ) == true) then */
                enum { lc289 = 17 };
                lua_pushliteral(L,"c_air");
                lua_gettable(L,9);
                const int lc290 = lua_equal(L,17,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc290);
                lua_pushboolean(L,!(lua_toboolean(L,-1)));
                lua_remove(L,-2);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"c_ignore");
                  lua_gettable(L,9);
                  const int lc291 = lua_equal(L,17,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc291);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushliteral(L,"c_water");
                  lua_gettable(L,9);
                  const int lc292 = lua_equal(L,17,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc292);
                  lua_pushboolean(L,!(lua_toboolean(L,-1)));
                  lua_remove(L,-2);
                }
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                  lua_pushliteral(L,"check_if_ground");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,17);
                  lua_call(L,1,1);
                  lua_pushboolean(L,1);
                  const int lc293 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc293);
                }
                const int lc294 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc294) {
                  
                  /* data[a:index(x, village.vh, z)] = cid.c_dirt_with_grass */
                  lua_pushliteral(L,"c_dirt_with_grass");
                  lua_gettable(L,9);
                  lua_pushvalue(L,7);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,13);
                  lua_pushliteral(L,"vh");
                  lua_gettable(L,15);
                  lua_pushvalue(L,12);
                  lua_call(L,4,1);
                  lua_insert(L,-2);
                  lua_settable(L,5);
                  assert(lua_gettop(L) == 17);
                  
                  /* y = minp.y-1 */
                  lua_pushliteral(L,"y");
                  lua_gettable(L,2);
                  lua_pushnumber(L,1);
                  lc_sub(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lua_replace(L,14);
                  assert(lua_gettop(L) == 17);
                }
                else {
                  
                  /* -- abort the search - there is no data available yet
                   * 					elseif( ci == cid.c_ignore ) then */
                  enum { lc295 = 17 };
                  lua_pushliteral(L,"c_ignore");
                  lua_gettable(L,9);
                  const int lc296 = lua_equal(L,17,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc296);
                  const int lc297 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc297) {
                    
                    /* y = minp.y-1 */
                    lua_pushliteral(L,"y");
                    lua_gettable(L,2);
                    lua_pushnumber(L,1);
                    lc_sub(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_replace(L,14);
                    assert(lua_gettop(L) == 17);
                  }
                  lua_settop(L,lc295);
                }
                lua_settop(L,lc289);
              }
              lua_settop(L,lc286);
            }
            lua_settop(L,lc282);
            assert(lua_gettop(L) == 17);
            
            /* y = y-1 */
            lua_pushnumber(L,1);
            lc_sub(L,14,-1);
            lua_remove(L,-2);
            lua_replace(L,14);
            assert(lua_gettop(L) == 17);
            
            /* internal: stack cleanup on scope exit */
            lua_pop(L,1);
          }
          lua_settop(L,lc280);
          assert(lua_gettop(L) == 16);
        }
        lua_settop(L,lc276);
        assert(lua_gettop(L) == 16);
        
        /* -- remove mudflow
         * y = village.vh + 1 */
        lua_pushliteral(L,"vh");
        lua_gettable(L,15);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_replace(L,14);
        assert(lua_gettop(L) == 16);
        
        /* while( y <= maxp.y ) do */
        enum { lc298 = 16 };
        while (1) {
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          const int lc299 = lc_le(L,14,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc299);
          if (!(lua_toboolean(L,-1))) {
            break;
          }
          lua_pop(L,1);
          
          /* local ci = data[a:index(x, y, z)] */
          lua_pushvalue(L,7);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,13);
          lua_pushvalue(L,14);
          lua_pushvalue(L,12);
          lua_call(L,4,1);
          lua_gettable(L,5);
          assert(lua_gettop(L) == 17);
          
          /* if( ci ~= cid.c_ignore and (ci==cid.c_dirt or ci==cid.c_dirt_with_grass or ci==cid.c_sand or ci==cid.c_desert_sand)) then */
          enum { lc300 = 17 };
          lua_pushliteral(L,"c_ignore");
          lua_gettable(L,9);
          const int lc301 = lua_equal(L,17,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc301);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushvalue(L,17);
            lua_pushliteral(L,"c_dirt");
            lua_gettable(L,9);
            const int lc302 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc302);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,17);
              lua_pushliteral(L,"c_dirt_with_grass");
              lua_gettable(L,9);
              const int lc303 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc303);
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,17);
              lua_pushliteral(L,"c_sand");
              lua_gettable(L,9);
              const int lc304 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc304);
            }
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,17);
              lua_pushliteral(L,"c_desert_sand");
              lua_gettable(L,9);
              const int lc305 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc305);
            }
          }
          const int lc306 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc306) {
            
            /* data[a:index(x,y,z)] = cid.c_air */
            lua_pushliteral(L,"c_air");
            lua_gettable(L,9);
            lua_pushvalue(L,7);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,13);
            lua_pushvalue(L,14);
            lua_pushvalue(L,12);
            lua_call(L,4,1);
            lua_insert(L,-2);
            lua_settable(L,5);
            assert(lua_gettop(L) == 17);
          }
          else {
            
            /* -- if there was a moresnow cover, add a snow on top of the new floor node
             * 				elseif( ci ~= cid.c_ignore
             * 					         and (ci==cid.c_msnow_1 or ci==cid.c_msnow_2 or ci==cid.c_msnow_3 or ci==cid.c_msnow_4 or
             * 					              ci==cid.c_msnow_5 or ci==cid.c_msnow_6 or ci==cid.c_msnow_7 or ci==cid.c_msnow_8 or
             * 					              ci==cid.c_msnow_9 or ci==cid.c_msnow_10 or ci==cid.c_msnow_11)) then */
            enum { lc307 = 17 };
            lua_pushliteral(L,"c_ignore");
            lua_gettable(L,9);
            const int lc308 = lua_equal(L,17,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc308);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,17);
              lua_pushliteral(L,"c_msnow_1");
              lua_gettable(L,9);
              const int lc309 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc309);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_2");
                lua_gettable(L,9);
                const int lc310 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc310);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_3");
                lua_gettable(L,9);
                const int lc311 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc311);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_4");
                lua_gettable(L,9);
                const int lc312 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc312);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_5");
                lua_gettable(L,9);
                const int lc313 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc313);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_6");
                lua_gettable(L,9);
                const int lc314 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc314);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_7");
                lua_gettable(L,9);
                const int lc315 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc315);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_8");
                lua_gettable(L,9);
                const int lc316 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc316);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_9");
                lua_gettable(L,9);
                const int lc317 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc317);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_10");
                lua_gettable(L,9);
                const int lc318 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc318);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,17);
                lua_pushliteral(L,"c_msnow_11");
                lua_gettable(L,9);
                const int lc319 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc319);
              }
            }
            const int lc320 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc320) {
              
              /* data[a:index(x, village.vh+1, z)] = cid.c_snow */
              lua_pushliteral(L,"c_snow");
              lua_gettable(L,9);
              lua_pushvalue(L,7);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,13);
              lua_pushliteral(L,"vh");
              lua_gettable(L,15);
              lua_pushnumber(L,1);
              lc_add(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,12);
              lua_call(L,4,1);
              lua_insert(L,-2);
              lua_settable(L,5);
              assert(lua_gettop(L) == 17);
              
              /* data[a:index(x, village.vh,   z)] = cid.c_dirt_with_snow */
              lua_pushliteral(L,"c_dirt_with_snow");
              lua_gettable(L,9);
              lua_pushvalue(L,7);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,13);
              lua_pushliteral(L,"vh");
              lua_gettable(L,15);
              lua_pushvalue(L,12);
              lua_call(L,4,1);
              lua_insert(L,-2);
              lua_settable(L,5);
              assert(lua_gettop(L) == 17);
            }
            else {
              
              /* elseif( ci == cid.c_ignore ) then */
              enum { lc321 = 17 };
              lua_pushliteral(L,"c_ignore");
              lua_gettable(L,9);
              const int lc322 = lua_equal(L,17,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc322);
              const int lc323 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc323) {
              }
              lua_settop(L,lc321);
            }
            lua_settop(L,lc307);
          }
          lua_settop(L,lc300);
          assert(lua_gettop(L) == 17);
          
          /* y = y+1 */
          lua_pushnumber(L,1);
          lc_add(L,14,-1);
          lua_remove(L,-2);
          lua_replace(L,14);
          assert(lua_gettop(L) == 17);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
        }
        lua_settop(L,lc298);
        assert(lua_gettop(L) == 16);
      }
      lua_settop(L,lc273);
      assert(lua_gettop(L) == 13);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc269_var += lc271_step;
    }
    lua_settop(L,lc272);
    assert(lua_gettop(L) == 12);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc265_var += lc267_step;
  }
  lua_settop(L,lc268);
  assert(lua_gettop(L) == 11);
  return 0;
}


/* name: mg_villages.village_area_mark_buildings
 * function( village_area, village_nr, bpos) */
static int lcf1_mg_villages_village_area_mark_buildings (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- mark the roads and buildings and the area between buildings in the village_area table
   * -- 2: road
   * -- 3: border around a road 
   * -- 4: building
   * -- 5: border around a building
   * for _, pos in ipairs( bpos ) do
   * internal: local f, s, var = explist */
  enum { lc324 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 7
     * internal: local pos with idx 8 */
    
    
    /* local reserved_for = 4 */
    lua_pushnumber(L,4);
    assert(lua_gettop(L) == 9);
    
    /* -- a building will be placed here
     * if( pos.btype and pos.btype == 'road' ) then */
    enum { lc325 = 9 };
    lua_pushliteral(L,"btype");
    lua_gettable(L,8);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"btype");
      lua_gettable(L,8);
      lua_pushliteral(L,"road");
      const int lc326 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc326);
    }
    const int lc327 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc327) {
      
      /* reserved_for = 2 */
      lua_pushnumber(L,2);
      lua_replace(L,9);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L,lc325);
    assert(lua_gettop(L) == 9);
    
    /* -- the building + a border of 1 around it
     * for x = -1, pos.bsizex do */
    lua_pushnumber(L,-1);
    lua_pushliteral(L,"bsizex");
    lua_gettable(L,8);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc328_var = lua_tonumber(L,-2);
    const double lc329_limit = lua_tonumber(L,-1);
    const double lc330_step = 1;
    lua_pop(L,2);
    enum { lc331 = 9 };
    while ((((lc330_step > 0) && (lc328_var <= lc329_limit)) || ((lc330_step <= 0) && (lc328_var >= lc329_limit)))) {
      
      /* internal: local x at index 10 */
      lua_pushnumber(L,lc328_var);
      
      /* for z = -1, pos.bsizez do */
      lua_pushnumber(L,-1);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,8);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc332_var = lua_tonumber(L,-2);
      const double lc333_limit = lua_tonumber(L,-1);
      const double lc334_step = 1;
      lua_pop(L,2);
      enum { lc335 = 10 };
      while ((((lc334_step > 0) && (lc332_var <= lc333_limit)) || ((lc334_step <= 0) && (lc332_var >= lc333_limit)))) {
        
        /* internal: local z at index 11 */
        lua_pushnumber(L,lc332_var);
        
        /* local p = {x=pos.x+x, z=pos.z+z} */
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,8);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,8);
        lc_add(L,-1,11);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 12);
        
        /* if( not( village_area[ p.x ] )) then */
        enum { lc336 = 12 };
        lua_pushliteral(L,"x");
        lua_gettable(L,12);
        lua_gettable(L,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc337 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc337) {
          
          /* village_area[ p.x ] = {} */
          lua_newtable(L);
          lua_pushliteral(L,"x");
          lua_gettable(L,12);
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc336);
        assert(lua_gettop(L) == 12);
        
        /* if( x==-1 or z==-1 or x==pos.bsizex or z==pos.bsizez ) then */
        enum { lc338 = 12 };
        lua_pushvalue(L,10);
        lua_pushnumber(L,-1);
        const int lc339 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc339);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,11);
          lua_pushnumber(L,-1);
          const int lc340 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc340);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,10);
          lua_pushliteral(L,"bsizex");
          lua_gettable(L,8);
          const int lc341 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc341);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,11);
          lua_pushliteral(L,"bsizez");
          lua_gettable(L,8);
          const int lc342 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc342);
        }
        const int lc343 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc343) {
          
          /* village_area[ p.x ][ p.z ] = { village_nr, reserved_for+1} */
          lua_createtable(L,2,0);
          lua_pushvalue(L,2);
          lua_rawseti(L,-2,1);
          lua_pushnumber(L,1);
          lc_add(L,9,-1);
          lua_remove(L,-2);
          lua_rawseti(L,-2,2);
          lua_pushliteral(L,"x");
          lua_gettable(L,12);
          lua_gettable(L,1);
          lua_insert(L,-2);
          lua_pushliteral(L,"z");
          lua_gettable(L,12);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 12);
        }
        else {
          
          /* else
           * village_area[ p.x ][ p.z ] = { village_nr, reserved_for } */
          lua_createtable(L,2,0);
          lua_pushvalue(L,2);
          lua_rawseti(L,-2,1);
          lua_pushvalue(L,9);
          lua_rawseti(L,-2,2);
          lua_pushliteral(L,"x");
          lua_gettable(L,12);
          lua_gettable(L,1);
          lua_insert(L,-2);
          lua_pushliteral(L,"z");
          lua_gettable(L,12);
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L,lc338);
        assert(lua_gettop(L) == 12);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc332_var += lc334_step;
      }
      lua_settop(L,lc335);
      assert(lua_gettop(L) == 10);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc328_var += lc330_step;
    }
    lua_settop(L,lc331);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc324);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: mg_villages.village_area_mark_dirt_roads
 * function( village_area, village_nr, dirt_roads) */
static int lcf1_mg_villages_village_area_mark_dirt_roads (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- mark the dirt roads
   * -- 8: dirt road
   * for _, pos in ipairs(dirt_roads) do
   * 		-- the building + a border of 1 around it
   * internal: local f, s, var = explist */
  enum { lc344 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,3);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 7
     * internal: local pos with idx 8 */
    
    
    /* -- the building + a border of 1 around it
     * for x = 0, pos.bsizex-1 do */
    lua_pushnumber(L,0);
    lua_pushliteral(L,"bsizex");
    lua_gettable(L,8);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc345_var = lua_tonumber(L,-2);
    const double lc346_limit = lua_tonumber(L,-1);
    const double lc347_step = 1;
    lua_pop(L,2);
    enum { lc348 = 8 };
    while ((((lc347_step > 0) && (lc345_var <= lc346_limit)) || ((lc347_step <= 0) && (lc345_var >= lc346_limit)))) {
      
      /* internal: local x at index 9 */
      lua_pushnumber(L,lc345_var);
      
      /* for z = 0, pos.bsizez-1 do */
      lua_pushnumber(L,0);
      lua_pushliteral(L,"bsizez");
      lua_gettable(L,8);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
        luaL_error(L,"'for' limit must be a number");
      }
      double lc349_var = lua_tonumber(L,-2);
      const double lc350_limit = lua_tonumber(L,-1);
      const double lc351_step = 1;
      lua_pop(L,2);
      enum { lc352 = 9 };
      while ((((lc351_step > 0) && (lc349_var <= lc350_limit)) || ((lc351_step <= 0) && (lc349_var >= lc350_limit)))) {
        
        /* internal: local z at index 10 */
        lua_pushnumber(L,lc349_var);
        
        /* local p = {x=pos.x+x, z=pos.z+z} */
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,8);
        lc_add(L,-1,9);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,8);
        lc_add(L,-1,10);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 11);
        
        /* if( not( village_area[ p.x ] )) then */
        enum { lc353 = 11 };
        lua_pushliteral(L,"x");
        lua_gettable(L,11);
        lua_gettable(L,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
        const int lc354 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc354) {
          
          /* village_area[ p.x ] = {} */
          lua_newtable(L);
          lua_pushliteral(L,"x");
          lua_gettable(L,11);
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L,lc353);
        assert(lua_gettop(L) == 11);
        
        /* village_area[ p.x ][ p.z ] = { village_nr, 8 } */
        lua_createtable(L,2,0);
        lua_pushvalue(L,2);
        lua_rawseti(L,-2,1);
        lua_pushnumber(L,8);
        lua_rawseti(L,-2,2);
        lua_pushliteral(L,"x");
        lua_gettable(L,11);
        lua_gettable(L,1);
        lua_insert(L,-2);
        lua_pushliteral(L,"z");
        lua_gettable(L,11);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 11);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
        lc349_var += lc351_step;
      }
      lua_settop(L,lc352);
      assert(lua_gettop(L) == 9);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc345_var += lc347_step;
    }
    lua_settop(L,lc348);
    assert(lua_gettop(L) == 8);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc344);
  assert(lua_gettop(L) == 3);
  return 0;
}


#include <math.h>

/* __pow metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_pow(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,pow(lua_tonumber(L,idxa),lua_tonumber(L,idxb)));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__pow")||luaL_getmetafield(L,idxb,"__pow")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.village_area_mark_inside_village_area
 * function( village_area, villages, village_noise, minp, maxp) */
static int lcf1_mg_villages_village_area_mark_inside_village_area (lua_State * L) {
  lua_checkstack(L,25);
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* -- mark the rest ( inside_village but not part of an actual building) as well		 
   * for x = minp.x, maxp.x do */
  lua_pushliteral(L,"x");
  lua_gettable(L,4);
  lua_pushliteral(L,"x");
  lua_gettable(L,5);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc355_var = lua_tonumber(L,-2);
  const double lc356_limit = lua_tonumber(L,-1);
  const double lc357_step = 1;
  lua_pop(L,2);
  enum { lc358 = 5 };
  while ((((lc357_step > 0) && (lc355_var <= lc356_limit)) || ((lc357_step <= 0) && (lc355_var >= lc356_limit)))) {
    
    /* internal: local x at index 6 */
    lua_pushnumber(L,lc355_var);
    
    /* if( not( village_area[ x ] )) then */
    enum { lc359 = 6 };
    lua_pushvalue(L,6);
    lua_gettable(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc360 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc360) {
      
      /* village_area[ x ] = {} */
      lua_newtable(L);
      lua_pushvalue(L,6);
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc359);
    assert(lua_gettop(L) == 6);
    
    /* for z = minp.z, maxp.z do */
    lua_pushliteral(L,"z");
    lua_gettable(L,4);
    lua_pushliteral(L,"z");
    lua_gettable(L,5);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc361_var = lua_tonumber(L,-2);
    const double lc362_limit = lua_tonumber(L,-1);
    const double lc363_step = 1;
    lua_pop(L,2);
    enum { lc364 = 6 };
    while ((((lc363_step > 0) && (lc361_var <= lc362_limit)) || ((lc363_step <= 0) && (lc361_var >= lc362_limit)))) {
      
      /* internal: local z at index 7 */
      lua_pushnumber(L,lc361_var);
      
      /* if( not( village_area[ x ][ z ] )) then */
      enum { lc365 = 7 };
      lua_pushvalue(L,6);
      lua_gettable(L,1);
      lua_pushvalue(L,7);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc366 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc366) {
        
        /* village_area[ x ][ z ] = { 0, 0 } */
        lua_createtable(L,2,0);
        lua_pushnumber(L,0);
        lua_rawseti(L,-2,1);
        lua_pushnumber(L,0);
        lua_rawseti(L,-2,2);
        lua_pushvalue(L,6);
        lua_gettable(L,1);
        lua_insert(L,-2);
        lua_pushvalue(L,7);
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 7);
        
        /* local n_rawnoise = village_noise:get2d({x = x, y = z}) */
        lua_pushvalue(L,3);
        lua_pushliteral(L,"get2d");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"x");
        lua_pushvalue(L,6);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushvalue(L,7);
        lua_rawset(L,-3);
        lua_call(L,2,1);
        assert(lua_gettop(L) == 8);
        
        /* -- create new blended terrain
         * for village_nr, village in ipairs(villages) do
         * internal: local f, s, var = explist */
        enum { lc367 = 8 };
        lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
        lua_pushvalue(L,2);
        lua_call(L,1,3);
        while (1) {
          
          /* internal: local var_1, ..., var_n = f(s, var)
           *           if var_1 == nil then break end
           *           var = var_1 */
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_call(L,2,2);
          if (lua_isnil(L,-2)) {
            break;
          }
          lua_pushvalue(L,-2);
          lua_replace(L,-4);
          
          /* internal: local village_nr with idx 12
           * internal: local village with idx 13 */
          
          
          /* local vn = mg_villages.get_vn(x, z, n_rawnoise, village) */
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"get_vn");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,6);
          lua_pushvalue(L,7);
          lua_pushvalue(L,8);
          lua_pushvalue(L,13);
          lua_call(L,4,1);
          assert(lua_gettop(L) == 14);
          
          /* if(     village.is_single_house ) then */
          enum { lc368 = 14 };
          lua_pushliteral(L,"is_single_house");
          lua_gettable(L,13);
          const int lc369 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc369) {
          }
          else {
            
            /* -- do nothing here; the village area will be specificly marked later on
             * 
             * 					-- the village core; this is where the houses stand (but there's no house or road at this particular spot)
             * 					elseif( vn <= 40 ) then */
            enum { lc370 = 14 };
            lua_pushnumber(L,40);
            const int lc371 = lc_le(L,14,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc371);
            const int lc372 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc372) {
              
              /* -- see mg_villages.inside_village
               * village_area[ x ][ z ] = { village_nr, 6} */
              lua_createtable(L,2,0);
              lua_pushvalue(L,12);
              lua_rawseti(L,-2,1);
              lua_pushnumber(L,6);
              lua_rawseti(L,-2,2);
              lua_pushvalue(L,6);
              lua_gettable(L,1);
              lua_insert(L,-2);
              lua_pushvalue(L,7);
              lua_insert(L,-2);
              lua_settable(L,-3);
              lua_pop(L,1);
              assert(lua_gettop(L) == 14);
            }
            else {
              
              /* -- the flattened land around the village where wheat, cotton, trees or grass may be grown (depending on village type)
               * 					elseif( vn <= 80 ) then */
              enum { lc373 = 14 };
              lua_pushnumber(L,80);
              const int lc374 = lc_le(L,14,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc374);
              const int lc375 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc375) {
                
                /* -- see mg_villages.inside_village_area
                 * village_area[ x ][ z ] = { village_nr, 1} */
                lua_createtable(L,2,0);
                lua_pushvalue(L,12);
                lua_rawseti(L,-2,1);
                lua_pushnumber(L,1);
                lua_rawseti(L,-2,2);
                lua_pushvalue(L,6);
                lua_gettable(L,1);
                lua_insert(L,-2);
                lua_pushvalue(L,7);
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 14);
              }
              else {
                
                /* -- terrain blending for the flattened land
                 * 					elseif( vn <= 160 and mg_villages.ENABLE_TERRAIN_BLEND) then */
                enum { lc376 = 14 };
                lua_pushnumber(L,160);
                const int lc377 = lc_le(L,14,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc377);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                  lua_pushliteral(L,"ENABLE_TERRAIN_BLEND");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                }
                const int lc378 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc378) {
                  
                  /* -- see mg_villages.inside_village_terrain_blend_area
                   * if n_rawnoise > -0.5 then */
                  enum { lc379 = 14 };
                  lua_pushnumber(L,-0.5);
                  const int lc380 = lua_lessthan(L,-1,8);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc380);
                  const int lc381 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc381) {
                    
                    /* -- leave some cliffs unblended
                     * local blend = (( vn - 80) / 80) ^ 2 */
                    lua_pushnumber(L,80);
                    lc_sub(L,14,-1);
                    lua_remove(L,-2);
                    lua_pushnumber(L,80);
                    lc_div(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    lua_pushnumber(L,2);
                    lc_pow(L,-2,-1);
                    lua_remove(L,-2);
                    lua_remove(L,-2);
                    assert(lua_gettop(L) == 15);
                    
                    /* -- 0 at village edge, 1 at normal terrain
                     * -- assign a negative value to terrain that needs to be adjusted in height
                     * village_area[ x ][ z ] = { village_nr, -1 * blend} */
                    lua_createtable(L,2,0);
                    lua_pushvalue(L,12);
                    lua_rawseti(L,-2,1);
                    lua_pushnumber(L,-1);
                    lc_mul(L,-1,15);
                    lua_remove(L,-2);
                    lua_rawseti(L,-2,2);
                    lua_pushvalue(L,6);
                    lua_gettable(L,1);
                    lua_insert(L,-2);
                    lua_pushvalue(L,7);
                    lua_insert(L,-2);
                    lua_settable(L,-3);
                    lua_pop(L,1);
                    assert(lua_gettop(L) == 15);
                  }
                  else {
                    
                    /* else
                     * -- no height adjustments for this terrain; the terrain is not considered to be part of the village
                     * village_area[ x ][ z ] = { village_nr, 0} */
                    lua_createtable(L,2,0);
                    lua_pushvalue(L,12);
                    lua_rawseti(L,-2,1);
                    lua_pushnumber(L,0);
                    lua_rawseti(L,-2,2);
                    lua_pushvalue(L,6);
                    lua_gettable(L,1);
                    lua_insert(L,-2);
                    lua_pushvalue(L,7);
                    lua_insert(L,-2);
                    lua_settable(L,-3);
                    lua_pop(L,1);
                    assert(lua_gettop(L) == 14);
                  }
                  lua_settop(L,lc379);
                  assert(lua_gettop(L) == 14);
                }
                lua_settop(L,lc376);
              }
              lua_settop(L,lc373);
            }
            lua_settop(L,lc370);
          }
          lua_settop(L,lc368);
          assert(lua_gettop(L) == 14);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,3);
        }
        lua_settop(L,lc367);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L,lc365);
      assert(lua_gettop(L) == 7);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc361_var += lc363_step;
    }
    lua_settop(L,lc364);
    assert(lua_gettop(L) == 6);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc355_var += lc357_step;
  }
  lua_settop(L,lc358);
  assert(lua_gettop(L) == 5);
  
  /* -- single houses get their own form of terrain blend
   * local pr = PseudoRandom(mg_villages.get_bseed(minp)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc382 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_bseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc382),1);
  assert(lua_gettop(L) == 6);
  
  /* for village_nr, village in ipairs( villages ) do
   * internal: local f, s, var = explist */
  enum { lc383 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local village_nr with idx 10
     * internal: local village with idx 11 */
    
    
    /* if( village and village.is_single_house and village.to_add_data and village.to_add_data.bpos and #village.to_add_data.bpos>=1) then */
    enum { lc384 = 11 };
    lua_pushvalue(L,11);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"is_single_house");
      lua_gettable(L,11);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,11);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,11);
      lua_pushliteral(L,"bpos");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,1);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,11);
      lua_pushliteral(L,"bpos");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc385 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc385);
      const int lc386 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc386);
    }
    const int lc387 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc387) {
      
      /* mg_villages.village_area_mark_single_house_area( village_area, minp, maxp, village.to_add_data.bpos[1], pr, village_nr, village ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_area_mark_single_house_area");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_pushvalue(L,4);
      lua_pushvalue(L,5);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,11);
      lua_pushliteral(L,"bpos");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,6);
      lua_pushvalue(L,10);
      lua_pushvalue(L,11);
      lua_call(L,7,0);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc384);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc383);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* name: mg_villages.village_area_get_height
 * function( village_area, villages, minp, maxp, data, param2_data, a, cid) */
static int lcf1_mg_villages_village_area_get_height (lua_State * L) {
  lua_checkstack(L,37);
  enum { lc_nformalargs = 8 };
  lua_settop(L,8);
  
  /* -- figuring out the height this way hardly works - because only a tiny part of the village may be contained in this chunk	
   * local height_sum   = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 9);
  
  /* local height_count = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 10);
  
  /* local height_statistic = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 11);
  
  /* -- initialize the variables for counting
   * for village_nr, village in ipairs( villages ) do
   * internal: local f, s, var = explist */
  enum { lc388 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local village_nr with idx 15
     * internal: local village with idx 16 */
    
    
    /* height_sum[       village_nr ] = 0 */
    lua_pushnumber(L,0);
    lua_pushvalue(L,15);
    lua_insert(L,-2);
    lua_settable(L,9);
    assert(lua_gettop(L) == 16);
    
    /* height_count[     village_nr ] = 0 */
    lua_pushnumber(L,0);
    lua_pushvalue(L,15);
    lua_insert(L,-2);
    lua_settable(L,10);
    assert(lua_gettop(L) == 16);
    
    /* height_statistic[ village_nr ] = {} */
    lua_newtable(L);
    lua_pushvalue(L,15);
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 16);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc388);
  assert(lua_gettop(L) == 11);
  
  /* -- try to find the optimal village height by looking at the borders defined by inside_village
   * for x = minp.x+1, maxp.x-1 do */
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"x");
  lua_gettable(L,4);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc389_var = lua_tonumber(L,-2);
  const double lc390_limit = lua_tonumber(L,-1);
  const double lc391_step = 1;
  lua_pop(L,2);
  enum { lc392 = 11 };
  while ((((lc391_step > 0) && (lc389_var <= lc390_limit)) || ((lc391_step <= 0) && (lc389_var >= lc390_limit)))) {
    
    /* internal: local x at index 12 */
    lua_pushnumber(L,lc389_var);
    
    /* for z = minp.z+1, maxp.z-1 do */
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"z");
    lua_gettable(L,4);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc393_var = lua_tonumber(L,-2);
    const double lc394_limit = lua_tonumber(L,-1);
    const double lc395_step = 1;
    lua_pop(L,2);
    enum { lc396 = 12 };
    while ((((lc395_step > 0) && (lc393_var <= lc394_limit)) || ((lc395_step <= 0) && (lc393_var >= lc394_limit)))) {
      
      /* internal: local z at index 13 */
      lua_pushnumber(L,lc393_var);
      
      /* if(     village_area[ x ][ z ][ 1 ] ~= 0
       *                             and village_area[ x ][ z ][ 2 ] ~= 0
       * 			    and ( village_area[ x+1 ][ z   ][ 2 ] <= 0
       * 			       or village_area[ x-1 ][ z   ][ 2 ] <= 0 
       * 			       or village_area[  x  ][ z+1 ][ 2 ] <= 0 
       * 			       or village_area[  x  ][ z-1 ][ 2 ] <= 0 )
       * 			  -- if the corners of the mapblock are inside the village area, they may count as borders here as well
       * 			  or ( x==minp.x+1 and village_area[ x-1 ][ z   ][ 1 ] >= 0 )
       * 			  or ( x==maxp.x-1 and village_area[ x+1 ][ z   ][ 1 ] >= 0 )
       * 			  or ( z==minp.z-1 and village_area[ x   ][ z-1 ][ 1 ] >= 0 )
       * 			  or ( z==maxp.z+1 and village_area[ x   ][ z+1 ][ 1 ] >= 0 )) then */
      enum { lc397 = 13 };
      lua_pushvalue(L,12);
      lua_gettable(L,1);
      lua_pushvalue(L,13);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      const int lc398 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc398);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,12);
        lua_gettable(L,1);
        lua_pushvalue(L,13);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0);
        const int lc399 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc399);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,1);
        lc_add(L,12,-1);
        lua_remove(L,-2);
        lua_gettable(L,1);
        lua_pushvalue(L,13);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,0);
        const int lc400 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc400);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushnumber(L,1);
          lc_sub(L,12,-1);
          lua_remove(L,-2);
          lua_gettable(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc401 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc401);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,12);
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_add(L,13,-1);
          lua_remove(L,-2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc402 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc402);
        }
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,12);
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_sub(L,13,-1);
          lua_remove(L,-2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc403 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc403);
        }
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,12);
        lua_pushliteral(L,"x");
        lua_gettable(L,3);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc404 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc404);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,0);
          lua_pushnumber(L,1);
          lc_sub(L,12,-1);
          lua_remove(L,-2);
          lua_gettable(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc405 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc405);
        }
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,12);
        lua_pushliteral(L,"x");
        lua_gettable(L,4);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc406 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc406);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,0);
          lua_pushnumber(L,1);
          lc_add(L,12,-1);
          lua_remove(L,-2);
          lua_gettable(L,1);
          lua_pushvalue(L,13);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc407 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc407);
        }
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,13);
        lua_pushliteral(L,"z");
        lua_gettable(L,3);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc408 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc408);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,0);
          lua_pushvalue(L,12);
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_sub(L,13,-1);
          lua_remove(L,-2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc409 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc409);
        }
      }
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,13);
        lua_pushliteral(L,"z");
        lua_gettable(L,4);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        const int lc410 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc410);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,0);
          lua_pushvalue(L,12);
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_add(L,13,-1);
          lua_remove(L,-2);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          const int lc411 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc411);
        }
      }
      const int lc412 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc412) {
        
        /* local y = maxp.y */
        lua_pushliteral(L,"y");
        lua_gettable(L,4);
        assert(lua_gettop(L) == 14);
        
        /* while( y > minp.y and y >= 0) do */
        enum { lc413 = 14 };
        while (1) {
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          const int lc414 = lua_lessthan(L,-1,14);
          lua_pop(L,1);
          lua_pushboolean(L,lc414);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushnumber(L,0);
            const int lc415 = lc_le(L,-1,14);
            lua_pop(L,1);
            lua_pushboolean(L,lc415);
          }
          if (!(lua_toboolean(L,-1))) {
            break;
          }
          lua_pop(L,1);
          
          /* local ci = data[a:index(x, y, z)] */
          lua_pushvalue(L,7);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,12);
          lua_pushvalue(L,14);
          lua_pushvalue(L,13);
          lua_call(L,4,1);
          lua_gettable(L,5);
          assert(lua_gettop(L) == 15);
          
          /* if(( ci ~= cid.c_air and ci ~= cid.c_ignore and mg_villages.check_if_ground( ci ) == true) or (y==0)) then */
          enum { lc416 = 15 };
          lua_pushliteral(L,"c_air");
          lua_gettable(L,8);
          const int lc417 = lua_equal(L,15,-1);
          lua_pop(L,1);
          lua_pushboolean(L,lc417);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"c_ignore");
            lua_gettable(L,8);
            const int lc418 = lua_equal(L,15,-1);
            lua_pop(L,1);
            lua_pushboolean(L,lc418);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
            lua_pushliteral(L,"check_if_ground");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,15);
            lua_call(L,1,1);
            lua_pushboolean(L,1);
            const int lc419 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc419);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,14);
            lua_pushnumber(L,0);
            const int lc420 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc420);
          }
          const int lc421 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc421) {
            
            /* local village_nr = village_area[ x ][ z ][ 1 ] */
            lua_pushvalue(L,12);
            lua_gettable(L,1);
            lua_pushvalue(L,13);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushnumber(L,1);
            lua_gettable(L,-2);
            lua_remove(L,-2);
            assert(lua_gettop(L) == 16);
            
            /* if( village_nr > 0 and height_sum[ village_nr ] ) then */
            enum { lc422 = 16 };
            lua_pushnumber(L,0);
            const int lc423 = lua_lessthan(L,-1,16);
            lua_pop(L,1);
            lua_pushboolean(L,lc423);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,16);
              lua_gettable(L,9);
            }
            const int lc424 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc424) {
              
              /* height_sum[   village_nr ] = height_sum[   village_nr ] + y */
              lua_pushvalue(L,16);
              lua_gettable(L,9);
              lc_add(L,-1,14);
              lua_remove(L,-2);
              lua_pushvalue(L,16);
              lua_insert(L,-2);
              lua_settable(L,9);
              assert(lua_gettop(L) == 16);
              
              /* height_count[ village_nr ] = height_count[ village_nr ] + 1 */
              lua_pushvalue(L,16);
              lua_gettable(L,10);
              lua_pushnumber(L,1);
              lc_add(L,-2,-1);
              lua_remove(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,16);
              lua_insert(L,-2);
              lua_settable(L,10);
              assert(lua_gettop(L) == 16);
              
              /* if( not( height_statistic[ village_nr ][ y ] )) then */
              enum { lc425 = 16 };
              lua_pushvalue(L,16);
              lua_gettable(L,11);
              lua_pushvalue(L,14);
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushboolean(L,!(lua_toboolean(L,-1)));
              lua_remove(L,-2);
              const int lc426 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc426) {
                
                /* height_statistic[ village_nr ][ y ] = 1 */
                lua_pushnumber(L,1);
                lua_pushvalue(L,16);
                lua_gettable(L,11);
                lua_insert(L,-2);
                lua_pushvalue(L,14);
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 16);
              }
              else {
                
                /* else
                 * height_statistic[ village_nr ][ y ] = height_statistic[ village_nr ][ y ] + 1 */
                lua_pushvalue(L,16);
                lua_gettable(L,11);
                lua_pushvalue(L,14);
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,1);
                lc_add(L,-2,-1);
                lua_remove(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,16);
                lua_gettable(L,11);
                lua_insert(L,-2);
                lua_pushvalue(L,14);
                lua_insert(L,-2);
                lua_settable(L,-3);
                lua_pop(L,1);
                assert(lua_gettop(L) == 16);
              }
              lua_settop(L,lc425);
              assert(lua_gettop(L) == 16);
            }
            lua_settop(L,lc422);
            assert(lua_gettop(L) == 16);
            
            /* y = minp.y - 1 */
            lua_pushliteral(L,"y");
            lua_gettable(L,3);
            lua_pushnumber(L,1);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_replace(L,14);
            assert(lua_gettop(L) == 16);
          }
          lua_settop(L,lc416);
          assert(lua_gettop(L) == 15);
          
          /* y = y-1 */
          lua_pushnumber(L,1);
          lc_sub(L,14,-1);
          lua_remove(L,-2);
          lua_replace(L,14);
          assert(lua_gettop(L) == 15);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,1);
        }
        lua_settop(L,lc413);
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L,lc397);
      assert(lua_gettop(L) == 13);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc393_var += lc395_step;
    }
    lua_settop(L,lc396);
    assert(lua_gettop(L) == 12);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc389_var += lc391_step;
  }
  lua_settop(L,lc392);
  assert(lua_gettop(L) == 11);
  
  /* for village_nr, village in ipairs( villages ) do
   * internal: local f, s, var = explist */
  enum { lc427 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local village_nr with idx 15
     * internal: local village with idx 16 */
    
    
    /* local tmin = maxp.y */
    lua_pushliteral(L,"y");
    lua_gettable(L,4);
    assert(lua_gettop(L) == 17);
    
    /* local tmax = minp.y */
    lua_pushliteral(L,"y");
    lua_gettable(L,3);
    assert(lua_gettop(L) == 18);
    
    /* local topt = 2 */
    lua_pushnumber(L,2);
    assert(lua_gettop(L) == 19);
    
    /* for k,v in pairs( height_statistic[ village_nr ] ) do
     * internal: local f, s, var = explist */
    enum { lc428 = 19 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    lua_pushvalue(L,15);
    lua_gettable(L,11);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local k with idx 23
       * internal: local v with idx 24 */
      
      
      /* if( k >= 2 and k < tmin and k >= minp.y) then */
      enum { lc429 = 24 };
      lua_pushnumber(L,2);
      const int lc430 = lc_le(L,-1,23);
      lua_pop(L,1);
      lua_pushboolean(L,lc430);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        const int lc431 = lua_lessthan(L,23,17);
        lua_pushboolean(L,lc431);
      }
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"y");
        lua_gettable(L,3);
        const int lc432 = lc_le(L,-1,23);
        lua_pop(L,1);
        lua_pushboolean(L,lc432);
      }
      const int lc433 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc433) {
        
        /* tmin = k */
        lua_pushvalue(L,23);
        lua_replace(L,17);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc429);
      assert(lua_gettop(L) == 24);
      
      /* if( k <= maxp.y and k > tmax ) then */
      enum { lc434 = 24 };
      lua_pushliteral(L,"y");
      lua_gettable(L,4);
      const int lc435 = lc_le(L,23,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc435);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        const int lc436 = lua_lessthan(L,18,23);
        lua_pushboolean(L,lc436);
      }
      const int lc437 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc437) {
        
        /* tmax = k */
        lua_pushvalue(L,23);
        lua_replace(L,18);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc434);
      assert(lua_gettop(L) == 24);
      
      /* if(    height_statistic[ village_nr ][ topt ] 
       * 			   and height_statistic[ village_nr ][ topt ] < height_statistic[ village_nr ][ k ]) then */
      enum { lc438 = 24 };
      lua_pushvalue(L,15);
      lua_gettable(L,11);
      lua_pushvalue(L,19);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,15);
        lua_gettable(L,11);
        lua_pushvalue(L,19);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,15);
        lua_gettable(L,11);
        lua_pushvalue(L,23);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc439 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc439);
      }
      const int lc440 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc440) {
        
        /* topt = k */
        lua_pushvalue(L,23);
        lua_replace(L,19);
        assert(lua_gettop(L) == 24);
      }
      lua_settop(L,lc438);
      assert(lua_gettop(L) == 24);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc428);
    assert(lua_gettop(L) == 19);
    
    /* --print('HEIGHT for village '..tostring( village.name )..' min:'..tostring( tmin )..' max:'..tostring(tmax)..' opt:'..tostring(topt)..' count:'..tostring( height_count[ village_nr ]));
     * -- the very first village gets a height of 1
     * if( village.nr and village.nr == 1 ) then */
    enum { lc441 = 19 };
    lua_pushliteral(L,"nr");
    lua_gettable(L,16);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"nr");
      lua_gettable(L,16);
      lua_pushnumber(L,1);
      const int lc442 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc442);
    }
    const int lc443 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc443) {
      
      /* village.optimal_height = 1 */
      lua_pushnumber(L,1);
      lua_pushliteral(L,"optimal_height");
      lua_insert(L,-2);
      lua_settable(L,16);
      assert(lua_gettop(L) == 19);
    }
    lua_settop(L,lc441);
    assert(lua_gettop(L) == 19);
    
    /* if( village.optimal_height ) then */
    enum { lc444 = 19 };
    lua_pushliteral(L,"optimal_height");
    lua_gettable(L,16);
    const int lc445 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc445) {
    }
    else {
      
      /* -- villages above a size of 40 are *always* place at a convenient height of 1
       * 		elseif( village.vs >= 40 and not(village.is_single_house)) then */
      enum { lc446 = 19 };
      lua_pushnumber(L,40);
      lua_pushliteral(L,"vs");
      lua_gettable(L,16);
      const int lc447 = lc_le(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc447);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushliteral(L,"is_single_house");
        lua_gettable(L,16);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc448 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc448) {
        
        /* village.optimal_height = 2 */
        lua_pushnumber(L,2);
        lua_pushliteral(L,"optimal_height");
        lua_insert(L,-2);
        lua_settable(L,16);
        assert(lua_gettop(L) == 19);
      }
      else {
        
        /* elseif( village.vs >= 30 and not(village.is_single_house)) then */
        enum { lc449 = 19 };
        lua_pushnumber(L,30);
        lua_pushliteral(L,"vs");
        lua_gettable(L,16);
        const int lc450 = lc_le(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc450);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"is_single_house");
          lua_gettable(L,16);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc451 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc451) {
          
          /* village.optimal_height = 41 - village.vs */
          lua_pushnumber(L,41);
          lua_pushliteral(L,"vs");
          lua_gettable(L,16);
          lc_sub(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"optimal_height");
          lua_insert(L,-2);
          lua_settable(L,16);
          assert(lua_gettop(L) == 19);
        }
        else {
          
          /* elseif( village.vs >= 25 and not(village.is_single_house)) then */
          enum { lc452 = 19 };
          lua_pushnumber(L,25);
          lua_pushliteral(L,"vs");
          lua_gettable(L,16);
          const int lc453 = lc_le(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc453);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"is_single_house");
            lua_gettable(L,16);
            lua_pushboolean(L,!(lua_toboolean(L,-1)));
            lua_remove(L,-2);
          }
          const int lc454 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc454) {
            
            /* village.optimal_height = 36 - village.vs */
            lua_pushnumber(L,36);
            lua_pushliteral(L,"vs");
            lua_gettable(L,16);
            lc_sub(L,-2,-1);
            lua_remove(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"optimal_height");
            lua_insert(L,-2);
            lua_settable(L,16);
            assert(lua_gettop(L) == 19);
          }
          else {
            
            /* -- in some cases, choose that height which was counted most often
             * 		elseif( topt and (tmax - tmin ) > 8 and height_count[ village_nr ] > 0) then */
            enum { lc455 = 19 };
            lua_pushvalue(L,19);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushnumber(L,8);
              lc_sub(L,18,17);
              const int lc456 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc456);
            }
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushnumber(L,0);
              lua_pushvalue(L,15);
              lua_gettable(L,10);
              const int lc457 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc457);
            }
            const int lc458 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc458) {
              
              /* local qmw */
              lua_settop(L,(lua_gettop(L) + 1));
              assert(lua_gettop(L) == 20);
              
              /* if( ( tmax - topt ) > ( topt - tmin )) then */
              enum { lc459 = 20 };
              lc_sub(L,19,17);
              lc_sub(L,18,19);
              const int lc460 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc460);
              const int lc461 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc461) {
                
                /* qmw = tmax */
                lua_pushvalue(L,18);
                lua_replace(L,20);
                assert(lua_gettop(L) == 20);
              }
              else {
                
                /* else
                 * qmw = tmin */
                lua_pushvalue(L,17);
                lua_replace(L,20);
                assert(lua_gettop(L) == 20);
              }
              lua_settop(L,lc459);
              assert(lua_gettop(L) == 20);
              
              /* village.optimal_height = qmw */
              lua_pushvalue(L,20);
              lua_pushliteral(L,"optimal_height");
              lua_insert(L,-2);
              lua_settable(L,16);
              assert(lua_gettop(L) == 20);
            }
            else {
              
              /* -- if no border height was found, there'd be no point in calculating anything;
               * 		-- also, this is done only if the village has its center inside this mapchunk	
               * 		elseif(  height_count[ village_nr ] > 0 ) then */
              enum { lc462 = 19 };
              lua_pushnumber(L,0);
              lua_pushvalue(L,15);
              lua_gettable(L,10);
              const int lc463 = lua_lessthan(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc463);
              const int lc464 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc464) {
                
                /* local max    = 0 */
                lua_pushnumber(L,0);
                assert(lua_gettop(L) == 20);
                
                /* local target = village.vh */
                lua_pushliteral(L,"vh");
                lua_gettable(L,16);
                assert(lua_gettop(L) == 21);
                
                /* local qmw    = 0 */
                lua_pushnumber(L,0);
                assert(lua_gettop(L) == 22);
                
                /* for k, v in pairs( height_statistic[ village_nr ] ) do
                 * internal: local f, s, var = explist */
                enum { lc465 = 22 };
                lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
                lua_pushvalue(L,15);
                lua_gettable(L,11);
                lua_call(L,1,3);
                while (1) {
                  
                  /* internal: local var_1, ..., var_n = f(s, var)
                   *           if var_1 == nil then break end
                   *           var = var_1 */
                  lua_pushvalue(L,-3);
                  lua_pushvalue(L,-3);
                  lua_pushvalue(L,-3);
                  lua_call(L,2,2);
                  if (lua_isnil(L,-2)) {
                    break;
                  }
                  lua_pushvalue(L,-2);
                  lua_replace(L,-4);
                  
                  /* internal: local k with idx 26
                   * internal: local v with idx 27 */
                  
                  
                  /* qmw = qmw + v * (k*k ) */
                  lc_mul(L,26,26);
                  lc_mul(L,27,-1);
                  lua_remove(L,-2);
                  lc_add(L,22,-1);
                  lua_remove(L,-2);
                  lua_replace(L,22);
                  assert(lua_gettop(L) == 27);
                  
                  /* if( v > max ) then */
                  enum { lc466 = 27 };
                  const int lc467 = lua_lessthan(L,20,27);
                  lua_pushboolean(L,lc467);
                  const int lc468 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc468) {
                    
                    /* target = k */
                    lua_pushvalue(L,26);
                    lua_replace(L,21);
                    assert(lua_gettop(L) == 27);
                    
                    /* max    = v */
                    lua_pushvalue(L,27);
                    lua_replace(L,20);
                    assert(lua_gettop(L) == 27);
                  }
                  lua_settop(L,lc466);
                  assert(lua_gettop(L) == 27);
                  
                  /* internal: stack cleanup on scope exit */
                  lua_pop(L,2);
                }
                lua_settop(L,lc465);
                assert(lua_gettop(L) == 22);
                
                /* if( height_count[ village_nr ] > 5 ) then */
                enum { lc469 = 22 };
                lua_pushnumber(L,5);
                lua_pushvalue(L,15);
                lua_gettable(L,10);
                const int lc470 = lua_lessthan(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc470);
                const int lc471 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc471) {
                  
                  /* qmw = math.floor( math.sqrt( qmw / height_count[ village_nr ]) +1.5) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"floor");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"sqrt");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,15);
                  lua_gettable(L,10);
                  lc_div(L,22,-1);
                  lua_remove(L,-2);
                  lua_call(L,1,1);
                  lua_pushnumber(L,1.5);
                  lc_add(L,-2,-1);
                  lua_remove(L,-2);
                  lua_remove(L,-2);
                  lua_call(L,1,1);
                  lua_replace(L,22);
                  assert(lua_gettop(L) == 22);
                  
                  /* -- round the value
                   * -- a height of 0 would be one below water level; so let's choose something higher;
                   * -- as this may be an island created withhin deep ocean, it might look better if it extends a bit from said ocean
                   * if( qmw < 1 ) then */
                  enum { lc472 = 22 };
                  lua_pushnumber(L,1);
                  const int lc473 = lua_lessthan(L,22,-1);
                  lua_pop(L,1);
                  lua_pushboolean(L,lc473);
                  const int lc474 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc474) {
                    
                    /* qmw = 2 */
                    lua_pushnumber(L,2);
                    lua_replace(L,22);
                    assert(lua_gettop(L) == 22);
                  }
                  lua_settop(L,lc472);
                  assert(lua_gettop(L) == 22);
                }
                else {
                  
                  /* else
                   * qmw = 0 */
                  lua_pushnumber(L,0);
                  lua_replace(L,22);
                  assert(lua_gettop(L) == 22);
                }
                lua_settop(L,lc469);
                assert(lua_gettop(L) == 22);
                
                /* village.optimal_height = qmw */
                lua_pushvalue(L,22);
                lua_pushliteral(L,"optimal_height");
                lua_insert(L,-2);
                lua_settable(L,16);
                assert(lua_gettop(L) == 22);
              }
              lua_settop(L,lc462);
            }
            lua_settop(L,lc455);
          }
          lua_settop(L,lc452);
        }
        lua_settop(L,lc449);
      }
      lua_settop(L,lc446);
    }
    lua_settop(L,lc444);
    assert(lua_gettop(L) == 19);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,5);
  }
  lua_settop(L,lc427);
  assert(lua_gettop(L) == 11);
  return 0;
}


/* name: mg_villages.change_village_height
 * function( village, new_height) */
static int lcf1_mg_villages_change_village_height (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* mg_villages.print( mg_villages.DEBUG_LEVEL_TIMING, 'CHANGING HEIGHT from '..tostring( village.vh )..' to '..tostring( new_height )) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"print");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"DEBUG_LEVEL_TIMING");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"CHANGING HEIGHT from ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushliteral(L,"vh");
  lua_gettable(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L," to ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  
  /* for _, pos in ipairs(village.to_add_data.bpos) do
   * internal: local f, s, var = explist */
  enum { lc475 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_pushliteral(L,"bpos");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 6
     * internal: local pos with idx 7 */
    
    
    /* pos.y = new_height */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,7);
    assert(lua_gettop(L) == 7);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc475);
  assert(lua_gettop(L) == 2);
  
  /* for _, pos in ipairs(village.to_add_data.dirt_roads) do
   * internal: local f, s, var = explist */
  enum { lc476 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushliteral(L,"to_add_data");
  lua_gettable(L,1);
  lua_pushliteral(L,"dirt_roads");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 6
     * internal: local pos with idx 7 */
    
    
    /* pos.y = new_height */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,7);
    assert(lua_gettop(L) == 7);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc476);
  assert(lua_gettop(L) == 2);
  
  /* village.vh = new_height */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"vh");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: mg_villages.grow_a_tree
 * function( pos, plant_id, minp, maxp, data, a, cid, pr, snow) */
static int lcf1_mg_villages_grow_a_tree (lua_State * L) {
  enum { lc_nformalargs = 9 };
  lua_settop(L,9);
  
  /* -- a normal tree; sometimes comes with apples
   * if(     plant_id == cid.c_sapling and minetest.registered_nodes[ 'default:tree']) then */
  enum { lc479 = 9 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"c_sapling");
  lua_gettable(L,7);
  const int lc480 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc480);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  const int lc481 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc481) {
    
    /* mg_villages.grow_tree(       data, a, pos, math.random(1, 4) == 1, math.random(1,100000), snow) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"grow_tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_pushvalue(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,4);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc482 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc482);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,100000);
    lua_call(L,2,1);
    lua_pushvalue(L,9);
    lua_call(L,6,0);
    assert(lua_gettop(L) == 9);
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 9);
  }
  else {
    
    /* -- a normal jungletree
     * 	elseif( plant_id == cid.c_jsapling and minetest.registered_nodes[ 'default:jungletree']) then */
    enum { lc483 = 9 };
    lua_pushvalue(L,2);
    lua_pushliteral(L,"c_jsapling");
    lua_gettable(L,7);
    const int lc484 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc484);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"default:jungletree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc485 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc485) {
      
      /* mg_villages.grow_jungletree( data, a, pos, math.random(1,100000), snow) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"grow_jungletree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,5);
      lua_pushvalue(L,6);
      lua_pushvalue(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,100000);
      lua_call(L,2,1);
      lua_pushvalue(L,9);
      lua_call(L,5,0);
      assert(lua_gettop(L) == 9);
      
      /* return true */
      lua_pushboolean(L,1);
      return 1;
      assert(lua_gettop(L) == 9);
    }
    else {
      
      /* -- a pine tree
       * 	elseif( plant_id == cid.c_psapling and minetest.registered_nodes[ 'default:pine_tree']) then */
      enum { lc486 = 9 };
      lua_pushvalue(L,2);
      lua_pushliteral(L,"c_psapling");
      lua_gettable(L,7);
      const int lc487 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc487);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"registered_nodes");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"default:pine_tree");
        lua_gettable(L,-2);
        lua_remove(L,-2);
      }
      const int lc488 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc488) {
        
        /* mg_villages.grow_pinetree(   data, a, pos, snow) */
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"grow_pinetree");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,5);
        lua_pushvalue(L,6);
        lua_pushvalue(L,1);
        lua_pushvalue(L,9);
        lua_call(L,4,0);
        assert(lua_gettop(L) == 9);
        
        /* return true */
        lua_pushboolean(L,1);
        return 1;
        assert(lua_gettop(L) == 9);
      }
      else {
        
        /* -- an acacia tree; it does not have its own grow function
         * 	elseif( plant_id == cid.c_asapling and minetest.registered_nodes[ 'default:acacia_tree']) then */
        enum { lc489 = 9 };
        lua_pushvalue(L,2);
        lua_pushliteral(L,"c_asapling");
        lua_gettable(L,7);
        const int lc490 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc490);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"default:acacia_tree");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        const int lc491 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc491) {
          
          /* data[ a:index( pos.x, pos.y, pos.z )] = cid.c_asapling */
          lua_pushliteral(L,"c_asapling");
          lua_gettable(L,7);
          lua_pushvalue(L,6);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"x");
          lua_gettable(L,1);
          lua_pushliteral(L,"y");
          lua_gettable(L,1);
          lua_pushliteral(L,"z");
          lua_gettable(L,1);
          lua_call(L,4,1);
          lua_insert(L,-2);
          lua_settable(L,5);
          assert(lua_gettop(L) == 9);
          
          /* return true */
          lua_pushboolean(L,1);
          return 1;
          assert(lua_gettop(L) == 9);
        }
        else {
          
          /* -- aspen tree from newer minetest game
           * 	elseif( plant_id == cid.c_aspsapling and minetest.registered_nodes[ 'default:aspen_tree']) then */
          enum { lc492 = 9 };
          lua_pushvalue(L,2);
          lua_pushliteral(L,"c_aspsapling");
          lua_gettable(L,7);
          const int lc493 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc493);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
            lua_pushliteral(L,"registered_nodes");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushliteral(L,"default:aspen_tree");
            lua_gettable(L,-2);
            lua_remove(L,-2);
          }
          const int lc494 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc494) {
            
            /* data[ a:index( pos.x, pos.y, pos.z )] = cid.c_aspsapling */
            lua_pushliteral(L,"c_aspsapling");
            lua_gettable(L,7);
            lua_pushvalue(L,6);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushliteral(L,"x");
            lua_gettable(L,1);
            lua_pushliteral(L,"y");
            lua_gettable(L,1);
            lua_pushliteral(L,"z");
            lua_gettable(L,1);
            lua_call(L,4,1);
            lua_insert(L,-2);
            lua_settable(L,5);
            assert(lua_gettop(L) == 9);
            
            /* return true */
            lua_pushboolean(L,1);
            return 1;
            assert(lua_gettop(L) == 9);
          }
          else {
            
            /* -- a savannatree from the mg mod
             * 	elseif( plant_id == cid.c_savannasapling and mg_villages.add_savannatree) then */
            enum { lc495 = 9 };
            lua_pushvalue(L,2);
            lua_pushliteral(L,"c_savannasapling");
            lua_gettable(L,7);
            const int lc496 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc496);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"add_savannatree");
              lua_gettable(L,-2);
              lua_remove(L,-2);
            }
            const int lc497 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc497) {
              
              /* mg_villages.add_savannatree(         data, a, pos.x, pos.y, pos.z, minp, maxp, pr) */
              lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
              lua_pushliteral(L,"add_savannatree");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,5);
              lua_pushvalue(L,6);
              lua_pushliteral(L,"x");
              lua_gettable(L,1);
              lua_pushliteral(L,"y");
              lua_gettable(L,1);
              lua_pushliteral(L,"z");
              lua_gettable(L,1);
              lua_pushvalue(L,3);
              lua_pushvalue(L,4);
              lua_pushvalue(L,8);
              lua_call(L,8,0);
              assert(lua_gettop(L) == 9);
              
              /* -- TODO: snow
               * return true */
              lua_pushboolean(L,1);
              return 1;
              assert(lua_gettop(L) == 9);
            }
            else {
              
              /* -- a pine tree from the mg mod
               * 	elseif( plant_id == cid.c_pinesapling    and mg_villages.add_pinetree   ) then */
              enum { lc498 = 9 };
              lua_pushvalue(L,2);
              lua_pushliteral(L,"c_pinesapling");
              lua_gettable(L,7);
              const int lc499 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc499);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"add_pinetree");
                lua_gettable(L,-2);
                lua_remove(L,-2);
              }
              const int lc500 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc500) {
                
                /* mg_villages.add_pinetree(            data, a, pos.x, pos.y, pos.z, minp, maxp, pr) */
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"add_pinetree");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,5);
                lua_pushvalue(L,6);
                lua_pushliteral(L,"x");
                lua_gettable(L,1);
                lua_pushliteral(L,"y");
                lua_gettable(L,1);
                lua_pushliteral(L,"z");
                lua_gettable(L,1);
                lua_pushvalue(L,3);
                lua_pushvalue(L,4);
                lua_pushvalue(L,8);
                lua_call(L,8,0);
                assert(lua_gettop(L) == 9);
                
                /* -- TODO: snow
                 * return true */
                lua_pushboolean(L,1);
                return 1;
                assert(lua_gettop(L) == 9);
              }
              lua_settop(L,lc498);
            }
            lua_settop(L,lc495);
          }
          lua_settop(L,lc492);
        }
        lua_settop(L,lc489);
      }
      lua_settop(L,lc486);
    }
    lua_settop(L,lc483);
  }
  lua_settop(L,lc479);
  assert(lua_gettop(L) == 9);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 9);
}


/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: mg_villages.village_area_fill_with_plants
 * function( village_area, villages, minp, maxp, data, param2_data, a, cid) */
static int lcf1_mg_villages_village_area_fill_with_plants (lua_State * L) {
  lua_checkstack(L,35);
  enum { lc_nformalargs = 8 };
  lua_settop(L,8);
  
  /* -- do not place any plants if we are working on the mapchunk above
   * if( minp.y > 0 ) then */
  enum { lc501 = 8 };
  lua_pushnumber(L,0);
  lua_pushliteral(L,"y");
  lua_gettable(L,3);
  const int lc502 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc502);
  const int lc503 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc503) {
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc501);
  assert(lua_gettop(L) == 8);
  
  /* -- trees which require grow functions to be called
   * cid.c_savannasapling  = minetest.get_content_id( 'mg:savannasapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg:savannasapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_savannasapling");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* cid.c_pinesapling     = minetest.get_content_id( 'mg:pinesapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg:pinesapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_pinesapling");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* -- add farmland
   * cid.c_wheat           = minetest.get_content_id( 'farming:wheat_8' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"farming:wheat_8");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_wheat");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* cid.c_cotton          = minetest.get_content_id( 'farming:cotton_8' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"farming:cotton_8");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_cotton");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* cid.c_shrub           = minetest.get_content_id( 'default:dry_shrub') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dry_shrub");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_shrub");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* -- these extra nodes are used in order to avoid abms on the huge fields around the villages
   * cid.c_soil_wet        = minetest.get_content_id( 'mg_villages:soil' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:soil");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_soil_wet");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* --'farming:soil_wet' );
   * cid.c_soil_sand       = minetest.get_content_id( 'mg_villages:desert_sand_soil') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:desert_sand_soil");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_soil_sand");
  lua_insert(L,-2);
  lua_settable(L,8);
  assert(lua_gettop(L) == 8);
  
  /* --'farming:desert_sand_soil_wet' );
   * -- desert sand soil is only available in minetest_next
   * if( not( cid.c_soil_sand )) then */
  enum { lc504 = 8 };
  lua_pushliteral(L,"c_soil_sand");
  lua_gettable(L,8);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc505 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc505) {
    
    /* cid.c_soil_sand = cid.c_soil_wet */
    lua_pushliteral(L,"c_soil_wet");
    lua_gettable(L,8);
    lua_pushliteral(L,"c_soil_sand");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc504);
  assert(lua_gettop(L) == 8);
  
  /* local c_feldweg         = minetest.get_content_id( 'cottages:feldweg') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"cottages:feldweg");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* if( not( c_feldweg )) then */
  enum { lc506 = 9 };
  lua_pushboolean(L,!(lua_toboolean(L,9)));
  const int lc507 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc507) {
    
    /* c_feldweg = cid.c_dirt_with_grass */
    lua_pushliteral(L,"c_dirt_with_grass");
    lua_gettable(L,8);
    lua_replace(L,9);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc506);
  assert(lua_gettop(L) == 9);
  
  /* if( mg_villages.realtest_trees ) then */
  enum { lc508 = 9 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"realtest_trees");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc509 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc509) {
    
    /* cid.c_soil_wet        = minetest.get_content_id( 'farming:soil' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"farming:soil");
    lua_call(L,1,1);
    lua_pushliteral(L,"c_soil_wet");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 9);
    
    /* -- TODO: the one from mg_villages would be better...but that one lacks textures
     * cid.c_soil_sand       = minetest.get_content_id( 'farming:soil' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"farming:soil");
    lua_call(L,1,1);
    lua_pushliteral(L,"c_soil_sand");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 9);
    
    /* -- TODO: the one from mg_villages would be better...but that one lacks textures
     * cid.c_wheat           = minetest.get_content_id( 'farming:spelt_4' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"farming:spelt_4");
    lua_call(L,1,1);
    lua_pushliteral(L,"c_wheat");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 9);
    
    /* cid.c_cotton          = minetest.get_content_id( 'farming:flax_4' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"farming:flax_4");
    lua_call(L,1,1);
    lua_pushliteral(L,"c_cotton");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc508);
  assert(lua_gettop(L) == 9);
  
  /* local pr = PseudoRandom(mg_villages.get_bseed(minp)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc510 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_bseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc510),1);
  assert(lua_gettop(L) == 10);
  
  /* for x = minp.x, maxp.x do */
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lua_pushliteral(L,"x");
  lua_gettable(L,4);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc511_var = lua_tonumber(L,-2);
  const double lc512_limit = lua_tonumber(L,-1);
  const double lc513_step = 1;
  lua_pop(L,2);
  enum { lc514 = 10 };
  while ((((lc513_step > 0) && (lc511_var <= lc512_limit)) || ((lc513_step <= 0) && (lc511_var >= lc512_limit)))) {
    
    /* internal: local x at index 11 */
    lua_pushnumber(L,lc511_var);
    
    /* for z = minp.z, maxp.z do
     * 			-- turn unused land (which is either dirt or desert sand) into a field that grows wheat */
    lua_pushliteral(L,"z");
    lua_gettable(L,3);
    lua_pushliteral(L,"z");
    lua_gettable(L,4);
    if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc515_var = lua_tonumber(L,-2);
    const double lc516_limit = lua_tonumber(L,-1);
    const double lc517_step = 1;
    lua_pop(L,2);
    enum { lc518 = 11 };
    while ((((lc517_step > 0) && (lc515_var <= lc516_limit)) || ((lc517_step <= 0) && (lc515_var >= lc516_limit)))) {
      
      /* internal: local z at index 12 */
      lua_pushnumber(L,lc515_var);
      
      /* -- turn unused land (which is either dirt or desert sand) into a field that grows wheat
       * if( village_area[ x ][ z ][ 2 ]==1 
       * 			 or village_area[ x ][ z ][ 2 ]==6) then */
      enum { lc519 = 12 };
      lua_pushvalue(L,11);
      lua_gettable(L,1);
      lua_pushvalue(L,12);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      const int lc520 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc520);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,11);
        lua_gettable(L,1);
        lua_pushvalue(L,12);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,2);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,6);
        const int lc521 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc521);
      }
      const int lc522 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc522) {
        
        /* local village_nr = village_area[ x ][ z ][ 1 ] */
        lua_pushvalue(L,11);
        lua_gettable(L,1);
        lua_pushvalue(L,12);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 13);
        
        /* local village    = villages[ village_nr ] */
        lua_pushvalue(L,13);
        lua_gettable(L,2);
        assert(lua_gettop(L) == 14);
        
        /* local h = village.vh */
        lua_pushliteral(L,"vh");
        lua_gettable(L,14);
        assert(lua_gettop(L) == 15);
        
        /* local g = data[a:index( x, h, z )] */
        lua_pushvalue(L,7);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,11);
        lua_pushvalue(L,15);
        lua_pushvalue(L,12);
        lua_call(L,4,1);
        lua_gettable(L,5);
        assert(lua_gettop(L) == 16);
        
        /* -- choose a plant/tree with a certain chance
         * -- Note: There are no checks weather the tree/plant will actually grow there or not;
         * --       Tree type is derived from wood type used in the village
         * local plant_id = data[a:index( x, h+1, z)] */
        lua_pushvalue(L,7);
        lua_pushliteral(L,"index");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushvalue(L,11);
        lua_pushnumber(L,1);
        lc_add(L,15,-1);
        lua_remove(L,-2);
        lua_pushvalue(L,12);
        lua_call(L,4,1);
        lua_gettable(L,5);
        assert(lua_gettop(L) == 17);
        
        /* local on_soil  = false */
        lua_pushboolean(L,0);
        assert(lua_gettop(L) == 18);
        
        /* local plant_selected = false */
        lua_pushboolean(L,0);
        assert(lua_gettop(L) == 19);
        
        /* local has_snow_cover = false */
        lua_pushboolean(L,0);
        assert(lua_gettop(L) == 20);
        
        /* for _,v in ipairs( village.to_add_data.plantlist ) do
         * internal: local f, s, var = explist */
        enum { lc523 = 20 };
        lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
        lua_pushliteral(L,"to_add_data");
        lua_gettable(L,14);
        lua_pushliteral(L,"plantlist");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,3);
        while (1) {
          
          /* internal: local var_1, ..., var_n = f(s, var)
           *           if var_1 == nil then break end
           *           var = var_1 */
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_call(L,2,2);
          if (lua_isnil(L,-2)) {
            break;
          }
          lua_pushvalue(L,-2);
          lua_replace(L,-4);
          
          /* internal: local _ with idx 24
           * internal: local v with idx 25 */
          
          
          /* if( plant_id == cid.c_snow or g==cid.c_dirt_with_snow or g==cid.c_snowblock) then */
          enum { lc524 = 25 };
          lua_pushvalue(L,17);
          lua_pushliteral(L,"c_snow");
          lua_gettable(L,8);
          const int lc525 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc525);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,16);
            lua_pushliteral(L,"c_dirt_with_snow");
            lua_gettable(L,8);
            const int lc526 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc526);
          }
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,16);
            lua_pushliteral(L,"c_snowblock");
            lua_gettable(L,8);
            const int lc527 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc527);
          }
          const int lc528 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc528) {
            
            /* has_snow_cover = true */
            lua_pushboolean(L,1);
            lua_replace(L,20);
            assert(lua_gettop(L) == 25);
          }
          lua_settop(L,lc524);
          assert(lua_gettop(L) == 25);
          
          /* -- select the first plant that fits; if the node is not air, keep what is currently inside
           * if( (plant_id==cid.c_air or plant_id==cid.c_snow) and (( v.p == 1 or pr:next( 1, v.p )==1 ))) then */
          enum { lc529 = 25 };
          lua_pushvalue(L,17);
          lua_pushliteral(L,"c_air");
          lua_gettable(L,8);
          const int lc530 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc530);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,17);
            lua_pushliteral(L,"c_snow");
            lua_gettable(L,8);
            const int lc531 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc531);
          }
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushliteral(L,"p");
            lua_gettable(L,25);
            lua_pushnumber(L,1);
            const int lc532 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc532);
            if (!(lua_toboolean(L,-1))) {
              lua_pop(L,1);
              lua_pushvalue(L,10);
              lua_pushliteral(L,"next");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushnumber(L,1);
              lua_pushliteral(L,"p");
              lua_gettable(L,25);
              lua_call(L,3,1);
              lua_pushnumber(L,1);
              const int lc533 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc533);
            }
          }
          const int lc534 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc534) {
            
            /* -- TODO: check if the plant grows on that soil
             * plant_id = v.id */
            lua_pushliteral(L,"id");
            lua_gettable(L,25);
            lua_replace(L,17);
            assert(lua_gettop(L) == 25);
            
            /* plant_selected = true */
            lua_pushboolean(L,1);
            lua_replace(L,19);
            assert(lua_gettop(L) == 25);
          }
          lua_settop(L,lc529);
          assert(lua_gettop(L) == 25);
          
          /* -- wheat and cotton require soil
           * if( plant_id == cid.c_wheat or plant_id == cid.c_cotton ) then */
          enum { lc535 = 25 };
          lua_pushvalue(L,17);
          lua_pushliteral(L,"c_wheat");
          lua_gettable(L,8);
          const int lc536 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc536);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,17);
            lua_pushliteral(L,"c_cotton");
            lua_gettable(L,8);
            const int lc537 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc537);
          }
          const int lc538 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc538) {
            
            /* on_soil = true */
            lua_pushboolean(L,1);
            lua_replace(L,18);
            assert(lua_gettop(L) == 25);
          }
          lua_settop(L,lc535);
          assert(lua_gettop(L) == 25);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,2);
        }
        lua_settop(L,lc523);
        assert(lua_gettop(L) == 20);
        
        /* local pos = {x=x, y=h+1, z=z} */
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushvalue(L,11);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushnumber(L,1);
        lc_add(L,15,-1);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushvalue(L,12);
        lua_rawset(L,-3);
        assert(lua_gettop(L) == 21);
        
        /* if( not( plant_selected )) then */
        enum { lc539 = 21 };
        lua_pushboolean(L,!(lua_toboolean(L,19)));
        const int lc540 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc540) {
          
          /* -- in case there is something there already (usually a tree trunk)
           * has_snow_cover = nil */
          lua_pushnil(L);
          lua_replace(L,20);
          assert(lua_gettop(L) == 21);
        }
        else {
          
          /* elseif( mg_villages.grow_a_tree( pos, plant_id, minp, maxp, data, a, cid, pr, has_snow_cover )) then */
          enum { lc541 = 21 };
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"grow_a_tree");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,21);
          lua_pushvalue(L,17);
          lua_pushvalue(L,3);
          lua_pushvalue(L,4);
          lua_pushvalue(L,5);
          lua_pushvalue(L,7);
          lua_pushvalue(L,8);
          lua_pushvalue(L,10);
          lua_pushvalue(L,20);
          lua_call(L,9,1);
          const int lc542 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc542) {
            
            /* param2_data[a:index( x, h+1, z)] = 0 */
            lua_pushnumber(L,0);
            lua_pushvalue(L,7);
            lua_pushliteral(L,"index");
            lua_gettable(L,-2);
            lua_insert(L,-2);
            lua_pushvalue(L,11);
            lua_pushnumber(L,1);
            lc_add(L,15,-1);
            lua_remove(L,-2);
            lua_pushvalue(L,12);
            lua_call(L,4,1);
            lua_insert(L,-2);
            lua_settable(L,6);
            assert(lua_gettop(L) == 21);
            
            /* -- make sure the tree trunk is not rotated
             * has_snow_cover = nil */
            lua_pushnil(L);
            lua_replace(L,20);
            assert(lua_gettop(L) == 21);
          }
          else {
            
            /* -- else the sapling might not grow
             * 					-- nothing to do; the function has grown the tree already
             * 	
             * 				-- grow wheat and cotton on normal wet soil (and re-plant if it had been removed by mudslide)
             * 				elseif( on_soil and (g==cid.c_dirt_with_grass or g==cid.c_soil_wet or g==cid.c_dirt_with_snow)) then */
            enum { lc543 = 21 };
            lua_pushvalue(L,18);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,16);
              lua_pushliteral(L,"c_dirt_with_grass");
              lua_gettable(L,8);
              const int lc544 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc544);
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,16);
                lua_pushliteral(L,"c_soil_wet");
                lua_gettable(L,8);
                const int lc545 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc545);
              }
              if (!(lua_toboolean(L,-1))) {
                lua_pop(L,1);
                lua_pushvalue(L,16);
                lua_pushliteral(L,"c_dirt_with_snow");
                lua_gettable(L,8);
                const int lc546 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc546);
              }
            }
            const int lc547 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc547) {
              
              /* -- wheat needs another option there
               * if( plant_id == cid.c_wheat ) then */
              enum { lc548 = 21 };
              lua_pushliteral(L,"c_wheat");
              lua_gettable(L,8);
              const int lc549 = lua_equal(L,17,-1);
              lua_pop(L,1);
              lua_pushboolean(L,lc549);
              const int lc550 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc550) {
                
                /* param2_data[a:index( x, h+1, z)] = 0 */
                lua_pushnumber(L,0);
                lua_pushvalue(L,7);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,11);
                lua_pushnumber(L,1);
                lc_add(L,15,-1);
                lua_remove(L,-2);
                lua_pushvalue(L,12);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,6);
                assert(lua_gettop(L) == 21);
              }
              else {
                
                /* else
                 * param2_data[a:index( x, h+1, z)] = math.random( 1, 179 ) */
                lua_getfield(L,LUA_ENVIRONINDEX,"math");
                lua_pushliteral(L,"random");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushnumber(L,1);
                lua_pushnumber(L,179);
                lua_call(L,2,1);
                lua_pushvalue(L,7);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,11);
                lua_pushnumber(L,1);
                lc_add(L,15,-1);
                lua_remove(L,-2);
                lua_pushvalue(L,12);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,6);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc548);
              assert(lua_gettop(L) == 21);
              
              /* data[a:index( x,  h,   z)] = cid.c_soil_wet */
              lua_pushliteral(L,"c_soil_wet");
              lua_gettable(L,8);
              lua_pushvalue(L,7);
              lua_pushliteral(L,"index");
              lua_gettable(L,-2);
              lua_insert(L,-2);
              lua_pushvalue(L,11);
              lua_pushvalue(L,15);
              lua_pushvalue(L,12);
              lua_call(L,4,1);
              lua_insert(L,-2);
              lua_settable(L,5);
              assert(lua_gettop(L) == 21);
              
              /* -- no plants in winter
               * if( has_snow_cover and mg_villages.use_soil_snow) then */
              enum { lc551 = 21 };
              lua_pushvalue(L,20);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                lua_pushliteral(L,"use_soil_snow");
                lua_gettable(L,-2);
                lua_remove(L,-2);
              }
              const int lc552 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc552) {
                
                /* data[a:index( x,  h+1, z)] = cid.c_msnow_soil */
                lua_pushliteral(L,"c_msnow_soil");
                lua_gettable(L,8);
                lua_pushvalue(L,7);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,11);
                lua_pushnumber(L,1);
                lc_add(L,15,-1);
                lua_remove(L,-2);
                lua_pushvalue(L,12);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,5);
                assert(lua_gettop(L) == 21);
                
                /* has_snow_cover = nil */
                lua_pushnil(L);
                lua_replace(L,20);
                assert(lua_gettop(L) == 21);
              }
              else {
                
                /* else
                 * data[a:index( x,  h+1, z)] = plant_id */
                lua_pushvalue(L,17);
                lua_pushvalue(L,7);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,11);
                lua_pushnumber(L,1);
                lc_add(L,15,-1);
                lua_remove(L,-2);
                lua_pushvalue(L,12);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,5);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L,lc551);
              assert(lua_gettop(L) == 21);
            }
            else {
              
              /* -- grow wheat and cotton on desert sand soil - or on soil previously placed (before mudslide overflew it; same as above)
               * 				elseif( on_soil and (g==cid.c_desert_sand or g==cid.c_soil_sand) and cid.c_soil_sand and cid.c_soil_sand > 0) then */
              enum { lc553 = 21 };
              lua_pushvalue(L,18);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushvalue(L,16);
                lua_pushliteral(L,"c_desert_sand");
                lua_gettable(L,8);
                const int lc554 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc554);
                if (!(lua_toboolean(L,-1))) {
                  lua_pop(L,1);
                  lua_pushvalue(L,16);
                  lua_pushliteral(L,"c_soil_sand");
                  lua_gettable(L,8);
                  const int lc555 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc555);
                }
              }
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushliteral(L,"c_soil_sand");
                lua_gettable(L,8);
              }
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushnumber(L,0);
                lua_pushliteral(L,"c_soil_sand");
                lua_gettable(L,8);
                const int lc556 = lua_lessthan(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc556);
              }
              const int lc557 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc557) {
                
                /* -- wheat needs another option there
                 * if( plant_id == cid.c_wheat ) then */
                enum { lc558 = 21 };
                lua_pushliteral(L,"c_wheat");
                lua_gettable(L,8);
                const int lc559 = lua_equal(L,17,-1);
                lua_pop(L,1);
                lua_pushboolean(L,lc559);
                const int lc560 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc560) {
                  
                  /* param2_data[a:index( x, h+1, z)] = 0 */
                  lua_pushnumber(L,0);
                  lua_pushvalue(L,7);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushnumber(L,1);
                  lc_add(L,15,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,12);
                  lua_call(L,4,1);
                  lua_insert(L,-2);
                  lua_settable(L,6);
                  assert(lua_gettop(L) == 21);
                }
                else {
                  
                  /* else
                   * param2_data[a:index( x, h+1, z)] = math.random( 1, 179 ) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,1);
                  lua_pushnumber(L,179);
                  lua_call(L,2,1);
                  lua_pushvalue(L,7);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushnumber(L,1);
                  lc_add(L,15,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,12);
                  lua_call(L,4,1);
                  lua_insert(L,-2);
                  lua_settable(L,6);
                  assert(lua_gettop(L) == 21);
                }
                lua_settop(L,lc558);
                assert(lua_gettop(L) == 21);
                
                /* data[a:index( x,  h,   z)] = cid.c_soil_sand */
                lua_pushliteral(L,"c_soil_sand");
                lua_gettable(L,8);
                lua_pushvalue(L,7);
                lua_pushliteral(L,"index");
                lua_gettable(L,-2);
                lua_insert(L,-2);
                lua_pushvalue(L,11);
                lua_pushvalue(L,15);
                lua_pushvalue(L,12);
                lua_call(L,4,1);
                lua_insert(L,-2);
                lua_settable(L,5);
                assert(lua_gettop(L) == 21);
                
                /* -- no plants in winter
                 * if( has_snow_cover and mg_villages.use_soil_snow) then */
                enum { lc561 = 21 };
                lua_pushvalue(L,20);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
                  lua_pushliteral(L,"use_soil_snow");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                }
                const int lc562 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc562) {
                  
                  /* data[a:index( x,  h+1, z)] = cid.c_msnow_soil */
                  lua_pushliteral(L,"c_msnow_soil");
                  lua_gettable(L,8);
                  lua_pushvalue(L,7);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushnumber(L,1);
                  lc_add(L,15,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,12);
                  lua_call(L,4,1);
                  lua_insert(L,-2);
                  lua_settable(L,5);
                  assert(lua_gettop(L) == 21);
                  
                  /* has_snow_cover = nil */
                  lua_pushnil(L);
                  lua_replace(L,20);
                  assert(lua_gettop(L) == 21);
                }
                else {
                  
                  /* else
                   * data[a:index( x,  h+1, z)] = plant_id */
                  lua_pushvalue(L,17);
                  lua_pushvalue(L,7);
                  lua_pushliteral(L,"index");
                  lua_gettable(L,-2);
                  lua_insert(L,-2);
                  lua_pushvalue(L,11);
                  lua_pushnumber(L,1);
                  lc_add(L,15,-1);
                  lua_remove(L,-2);
                  lua_pushvalue(L,12);
                  lua_call(L,4,1);
                  lua_insert(L,-2);
                  lua_settable(L,5);
                  assert(lua_gettop(L) == 21);
                }
                lua_settop(L,lc561);
                assert(lua_gettop(L) == 21);
              }
              else {
                
                /* elseif( on_soil ) then */
                enum { lc563 = 21 };
                if (lua_toboolean(L,18)) {
                  
                  /* if( math.random(1,5)==1 ) then */
                  enum { lc564 = 21 };
                  lua_getfield(L,LUA_ENVIRONINDEX,"math");
                  lua_pushliteral(L,"random");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushnumber(L,1);
                  lua_pushnumber(L,5);
                  lua_call(L,2,1);
                  lua_pushnumber(L,1);
                  const int lc565 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc565);
                  const int lc566 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc566) {
                    
                    /* data[a:index( pos.x,  pos.y, pos.z)] = cid.c_shrub */
                    lua_pushliteral(L,"c_shrub");
                    lua_gettable(L,8);
                    lua_pushvalue(L,7);
                    lua_pushliteral(L,"index");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_pushliteral(L,"x");
                    lua_gettable(L,21);
                    lua_pushliteral(L,"y");
                    lua_gettable(L,21);
                    lua_pushliteral(L,"z");
                    lua_gettable(L,21);
                    lua_call(L,4,1);
                    lua_insert(L,-2);
                    lua_settable(L,5);
                    assert(lua_gettop(L) == 21);
                  }
                  lua_settop(L,lc564);
                  assert(lua_gettop(L) == 21);
                }
                else {
                  
                  /* elseif( plant_id ) then */
                  enum { lc567 = 21 };
                  if (lua_toboolean(L,17)) {
                    
                    /* -- place the sapling or plant (moretrees uses spawn_tree)
                     * data[a:index( pos.x,  pos.y, pos.z)] = plant_id */
                    lua_pushvalue(L,17);
                    lua_pushvalue(L,7);
                    lua_pushliteral(L,"index");
                    lua_gettable(L,-2);
                    lua_insert(L,-2);
                    lua_pushliteral(L,"x");
                    lua_gettable(L,21);
                    lua_pushliteral(L,"y");
                    lua_gettable(L,21);
                    lua_pushliteral(L,"z");
                    lua_gettable(L,21);
                    lua_call(L,4,1);
                    lua_insert(L,-2);
                    lua_settable(L,5);
                    assert(lua_gettop(L) == 21);
                  }
                  lua_settop(L,lc567);
                }
                lua_settop(L,lc563);
              }
              lua_settop(L,lc553);
            }
            lua_settop(L,lc543);
          }
          lua_settop(L,lc541);
        }
        lua_settop(L,lc539);
        assert(lua_gettop(L) == 21);
        
        /* -- put a snow cover on plants where needed
         * if( has_snow_cover and cid.c_msnow_1 ~= cid.c_ignore) then */
        enum { lc568 = 21 };
        lua_pushvalue(L,20);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"c_msnow_1");
          lua_gettable(L,8);
          lua_pushliteral(L,"c_ignore");
          lua_gettable(L,8);
          const int lc569 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc569);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        const int lc570 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc570) {
          
          /* data[a:index( x,  h+2, z)] = cid.c_msnow_1 */
          lua_pushliteral(L,"c_msnow_1");
          lua_gettable(L,8);
          lua_pushvalue(L,7);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,11);
          lua_pushnumber(L,2);
          lc_add(L,15,-1);
          lua_remove(L,-2);
          lua_pushvalue(L,12);
          lua_call(L,4,1);
          lua_insert(L,-2);
          lua_settable(L,5);
          assert(lua_gettop(L) == 21);
        }
        lua_settop(L,lc568);
        assert(lua_gettop(L) == 21);
        
        /* -- place a water source now and then so that the fake soil can later be turned into real soil if needed
         * if( on_soil and x%3==0 and z%3==0 and h>minp.y) then */
        enum { lc571 = 21 };
        lua_pushvalue(L,18);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,3);
          lc_mod(L,11,-1);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc572 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc572);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushnumber(L,3);
          lc_mod(L,12,-1);
          lua_remove(L,-2);
          lua_pushnumber(L,0);
          const int lc573 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc573);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushliteral(L,"y");
          lua_gettable(L,3);
          const int lc574 = lua_lessthan(L,-1,15);
          lua_pop(L,1);
          lua_pushboolean(L,lc574);
        }
        const int lc575 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc575) {
          
          /* data[a:index( x, h-1, z)] = cid.c_water */
          lua_pushliteral(L,"c_water");
          lua_gettable(L,8);
          lua_pushvalue(L,7);
          lua_pushliteral(L,"index");
          lua_gettable(L,-2);
          lua_insert(L,-2);
          lua_pushvalue(L,11);
          lua_pushnumber(L,1);
          lc_sub(L,15,-1);
          lua_remove(L,-2);
          lua_pushvalue(L,12);
          lua_call(L,4,1);
          lua_insert(L,-2);
          lua_settable(L,5);
          assert(lua_gettop(L) == 21);
        }
        lua_settop(L,lc571);
        assert(lua_gettop(L) == 21);
      }
      lua_settop(L,lc519);
      assert(lua_gettop(L) == 12);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,1);
      lc515_var += lc517_step;
    }
    lua_settop(L,lc518);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc511_var += lc513_step;
  }
  lua_settop(L,lc514);
  assert(lua_gettop(L) == 10);
  return 0;
}


/* name: time_elapsed
 * function( t_last, msg) */
static int lcf1_time_elapsed (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* mg_villages.t_now = minetest.get_us_time() */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_us_time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"t_now");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 2);
  
  /* mg_villages.print( mg_villages.DEBUG_LEVEL_TIMING, 'TIME ELAPSED: '..tostring( mg_villages.t_now - t_last )..' '..msg ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"print");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"DEBUG_LEVEL_TIMING");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"TIME ELAPSED: ");
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"t_now");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_sub(L,-1,1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_pushliteral(L," ");
  lua_pushvalue(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  
  /* return mg_villages.t_now */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"t_now");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* name: mg_villages.save_data
 * function() */
static int lcf1_mg_villages_save_data (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* save_restore.save_data( 'mg_all_villages.data', mg_villages.all_villages ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"save_restore");
  lua_pushliteral(L,"save_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_all_villages.data");
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* name: mg_villages.place_villages_via_voxelmanip
 * function( villages, minp, maxp, vm, data, param2_data, a, top, seed) */
static int lcf1_mg_villages_place_villages_via_voxelmanip (lua_State * L) {
  lua_checkstack(L,47);
  enum { lc_nformalargs = 9 };
  lua_settop(L,9);
  
  /* local t1 = minetest.get_us_time() */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_us_time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 10);
  
  /* local cid = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_air    = minetest.get_content_id( 'air' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"air");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_air");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_ignore = minetest.get_content_id( 'ignore' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ignore");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_ignore");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_stone  = minetest.get_content_id( 'default:stone') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:stone");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_stone");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_dirt   = minetest.get_content_id( 'default:dirt') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_dirt");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_snow   = minetest.get_content_id( 'default:snow') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:snow");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_snow");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_snowblock   = minetest.get_content_id( 'default:snowblock') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:snowblock");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_snowblock");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_dirt_with_snow  = minetest.get_content_id( 'default:dirt_with_snow' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt_with_snow");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_dirt_with_snow");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_dirt_with_grass = minetest.get_content_id( 'default:dirt_with_grass' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt_with_grass");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_dirt_with_grass");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_desert_sand = minetest.get_content_id( 'default:desert_sand' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:desert_sand");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_desert_sand");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* -- PM v
   * cid.c_desert_stone  = minetest.get_content_id( 'default:desert_stone') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:desert_stone");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_desert_stone");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_sand = minetest.get_content_id( 'default:sand' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:sand");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_sand");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_tree = minetest.get_content_id( 'default:tree') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:tree");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_tree");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_sapling = minetest.get_content_id( 'default:sapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:sapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_sapling");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_jtree = minetest.get_content_id( 'default:jungletree') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:jungletree");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_jtree");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_jsapling = minetest.get_content_id( 'default:junglesapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:junglesapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_jsapling");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_ptree = minetest.get_content_id( 'default:pine_tree') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:pine_tree");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_ptree");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_psapling = minetest.get_content_id( 'default:pine_sapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:pine_sapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_psapling");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_atree    = minetest.get_content_id( 'default:acacia_tree') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:acacia_tree");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_atree");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_asapling = minetest.get_content_id( 'default:acacia_sapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:acacia_sapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_asapling");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_asptree    = minetest.get_content_id( 'default:aspen_tree') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:aspen_tree");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_asptree");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_aspsapling = minetest.get_content_id( 'default:aspen_sapling') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:aspen_sapling");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_aspsapling");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_water = minetest.get_content_id( 'default:water_source') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:water_source");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_water");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* -- PM ^
   * cid.c_stone_with_coal = minetest.get_content_id( 'default:stone_with_coal') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:stone_with_coal");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_stone_with_coal");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_sandstone       = minetest.get_content_id( 'default:sandstone') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:sandstone");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_sandstone");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_1  = minetest.get_content_id( 'moresnow:snow_top' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_1");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_2  = minetest.get_content_id( 'moresnow:snow_fence_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_fence_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_2");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_3  = minetest.get_content_id( 'moresnow:snow_stair_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_stair_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_3");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_4  = minetest.get_content_id( 'moresnow:snow_slab_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_slab_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_4");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_5  = minetest.get_content_id( 'moresnow:snow_panel_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_panel_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_5");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_6  = minetest.get_content_id( 'moresnow:snow_micro_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_micro_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_6");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_7  = minetest.get_content_id( 'moresnow:snow_outer_stair_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_outer_stair_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_7");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_8  = minetest.get_content_id( 'moresnow:snow_inner_stair_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_inner_stair_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_8");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_9  = minetest.get_content_id( 'moresnow:snow_ramp_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_ramp_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_9");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_10 = minetest.get_content_id( 'moresnow:snow_ramp_outer_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_ramp_outer_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_10");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_11 = minetest.get_content_id( 'moresnow:snow_ramp_inner_top') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_ramp_inner_top");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_11");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_msnow_soil=minetest.get_content_id( 'moresnow:snow_soil' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"moresnow:snow_soil");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_msnow_soil");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_ice      = minetest.get_content_id( 'default:ice' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:ice");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_ice");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* cid.c_plotmarker = minetest.get_content_id( 'mg_villages:plotmarker') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg_villages:plotmarker");
  lua_call(L,1,1);
  lua_pushliteral(L,"c_plotmarker");
  lua_insert(L,-2);
  lua_settable(L,11);
  assert(lua_gettop(L) == 11);
  
  /* if( minetest.get_modpath('ethereal')) then */
  enum { lc576 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal");
  lua_call(L,1,1);
  const int lc577 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc577) {
    
    /* cid.c_ethereal_clay_red    = minetest.get_content_id( 'bakedclay:red' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bakedclay:red");
    lua_call(L,1,1);
    lua_pushliteral(L,"c_ethereal_clay_red");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
    
    /* cid.c_ethereal_clay_orange = minetest.get_content_id( 'bakedclay:orange' ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"bakedclay:orange");
    lua_call(L,1,1);
    lua_pushliteral(L,"c_ethereal_clay_orange");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc576);
  assert(lua_gettop(L) == 11);
  
  /* t1 = time_elapsed( t1, 'defines' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"defines");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 11);
  
  /* local village_noise = minetest.get_perlin(7635, 3, 0.5, 16) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_perlin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,7635);
  lua_pushnumber(L,3);
  lua_pushnumber(L,0.5);
  lua_pushnumber(L,16);
  lua_call(L,4,1);
  assert(lua_gettop(L) == 12);
  
  /* -- determine which coordinates are inside the village and which are not
   * local village_area = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 13);
  
  /* for village_nr, village in ipairs(villages) do
   * 		-- generate the village structure: determine positions of buildings and roads
   * internal: local f, s, var = explist */
  enum { lc578 = 13 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local village_nr with idx 17
     * internal: local village with idx 18 */
    
    
    /* -- generate the village structure: determine positions of buildings and roads
     * mg_villages.generate_village( village, village_noise) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"generate_village");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,18);
    lua_pushvalue(L,12);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 18);
    
    /* if( not( village.is_single_house )) then */
    enum { lc579 = 18 };
    lua_pushliteral(L,"is_single_house");
    lua_gettable(L,18);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc580 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc580) {
      
      /* -- only add artificial snow if the village has at least a size of 15 (else it might look too artificial)
       * if( not( village.artificial_snow ) and village.vs > 15) then */
      enum { lc581 = 18 };
      lua_pushliteral(L,"artificial_snow");
      lua_gettable(L,18);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushnumber(L,15);
        lua_pushliteral(L,"vs");
        lua_gettable(L,18);
        const int lc582 = lua_lessthan(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc582);
      }
      const int lc583 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc583) {
        
        /* if( mg_villages.artificial_snow_probability and math.random( 1, mg_villages.artificial_snow_probability )==1
         * 				    -- forbid artificial snow for some village types
         * 			   	    and not( mg_villages.village_type_data[ village.village_type ].no_snow )
         * 				    and minetest.registered_nodes['default:snow']) then */
        enum { lc584 = 18 };
        lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
        lua_pushliteral(L,"artificial_snow_probability");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"artificial_snow_probability");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_call(L,2,1);
          lua_pushnumber(L,1);
          const int lc585 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc585);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
          lua_pushliteral(L,"village_type_data");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"village_type");
          lua_gettable(L,18);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"no_snow");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushboolean(L,!(lua_toboolean(L,-1)));
          lua_remove(L,-2);
        }
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"default:snow");
          lua_gettable(L,-2);
          lua_remove(L,-2);
        }
        const int lc586 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc586) {
          
          /* village.artificial_snow = 1 */
          lua_pushnumber(L,1);
          lua_pushliteral(L,"artificial_snow");
          lua_insert(L,-2);
          lua_settable(L,18);
          assert(lua_gettop(L) == 18);
        }
        else {
          
          /* else
           * village.artificial_snow = 0 */
          lua_pushnumber(L,0);
          lua_pushliteral(L,"artificial_snow");
          lua_insert(L,-2);
          lua_settable(L,18);
          assert(lua_gettop(L) == 18);
        }
        lua_settop(L,lc584);
        assert(lua_gettop(L) == 18);
      }
      lua_settop(L,lc581);
      assert(lua_gettop(L) == 18);
      
      /* -- will set village_area to N where .. is:
       * --  2: a building
       * --  3: border around a building
       * --  4: a road
       * --  5: border around a road
       * mg_villages.village_area_mark_buildings(   village_area, village_nr, village.to_add_data.bpos ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_area_mark_buildings");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,13);
      lua_pushvalue(L,17);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,18);
      lua_pushliteral(L,"bpos");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 18);
      
      /* -- will set village_area to N where .. is:
       * --  8: a dirt road
       * mg_villages.village_area_mark_dirt_roads(  village_area, village_nr, village.to_add_data.dirt_roads ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_area_mark_dirt_roads");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,13);
      lua_pushvalue(L,17);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,18);
      lua_pushliteral(L,"dirt_roads");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 18);
    }
    else {
      
      /* else
       * -- mark the terrain below single houses
       * mg_villages.village_area_mark_buildings(   village_area, village_nr, village.to_add_data.bpos ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"village_area_mark_buildings");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,13);
      lua_pushvalue(L,17);
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,18);
      lua_pushliteral(L,"bpos");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 18);
    }
    lua_settop(L,lc579);
    assert(lua_gettop(L) == 18);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc578);
  assert(lua_gettop(L) == 13);
  
  /* t1 = time_elapsed( t1, 'generate_village, mark_buildings and mark_dirt_roads' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"generate_village, mark_buildings and mark_dirt_roads");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 13);
  
  /* local emin */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 14);
  
  /* local emax */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 15);
  
  /* -- if no voxelmanip data was passed on, read the data here
   * if( not( vm ) or not( a) or not( data ) or not( param2_data ) ) then */
  enum { lc587 = 15 };
  lua_pushboolean(L,!(lua_toboolean(L,4)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,7)));
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,5)));
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,6)));
  }
  const int lc588 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc588) {
    
    /* vm, emin, emax = minetest.get_mapgen_object("voxelmanip") */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_mapgen_object");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"voxelmanip");
    lua_call(L,1,3);
    lua_replace(L,15);
    lua_replace(L,14);
    lua_replace(L,4);
    assert(lua_gettop(L) == 15);
    
    /* if( not( vm )) then */
    enum { lc589 = 15 };
    lua_pushboolean(L,!(lua_toboolean(L,4)));
    const int lc590 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc590) {
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc589);
    assert(lua_gettop(L) == 15);
    
    /* a = VoxelArea:new{
     * 			MinEdge={x=emin.x, y=emin.y, z=emin.z},
     * 			MaxEdge={x=emax.x, y=emax.y, z=emax.z},
     * 		} */
    lua_getfield(L,LUA_ENVIRONINDEX,"VoxelArea");
    lua_pushliteral(L,"new");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_createtable(L,0,2);
    lua_pushliteral(L,"MinEdge");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,14);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,14);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,14);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"MaxEdge");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,15);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,15);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,15);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_call(L,2,1);
    lua_replace(L,7);
    assert(lua_gettop(L) == 15);
    
    /* data = vm:get_data(data) */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"get_data");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,5);
    lua_call(L,2,1);
    lua_replace(L,5);
    assert(lua_gettop(L) == 15);
    
    /* param2_data = vm:get_param2_data(param2_data) */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"get_param2_data");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,6);
    lua_call(L,2,1);
    lua_replace(L,6);
    assert(lua_gettop(L) == 15);
  }
  lua_settop(L,lc587);
  assert(lua_gettop(L) == 15);
  
  /* t1 = time_elapsed( t1, 'get_vmap_data' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"get_vmap_data");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 15);
  
  /* -- all vm manipulation functions write their content to the *entire* volume/area - including those 16 nodes that
   * -- extend into neighbouring mapchunks; thus, cavegen griefing and mudflow can be repaired by placing everythiing again
   * local tmin = emin */
  lua_pushvalue(L,14);
  assert(lua_gettop(L) == 16);
  
  /* local tmax = emax */
  lua_pushvalue(L,15);
  assert(lua_gettop(L) == 17);
  
  /* -- if set to true, cavegen eating through houses and mudflow on roofs will NOT be repaired
   * if( not( mg_villages.UNDO_CAVEGEN_AND_MUDFLOW )) then */
  enum { lc591 = 17 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"UNDO_CAVEGEN_AND_MUDFLOW");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc592 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc592) {
    
    /* tmin = minp */
    lua_pushvalue(L,2);
    lua_replace(L,16);
    assert(lua_gettop(L) == 17);
    
    /* tmax = maxp */
    lua_pushvalue(L,3);
    lua_replace(L,17);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc591);
  assert(lua_gettop(L) == 17);
  
  /* -- will set village_area to N where .. is:
   * --  0: not part of any village
   * --  1: flattened area around the village; plants (wheat, cotton, trees, grass, ...) may be planted here
   * --  6: free/unused spot in the core area of the village where the buildings are
   * -- negative value: do terrain blending
   * mg_villages.village_area_mark_inside_village_area( village_area, villages, village_noise, tmin, tmax ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_area_mark_inside_village_area");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,13);
  lua_pushvalue(L,1);
  lua_pushvalue(L,12);
  lua_pushvalue(L,16);
  lua_pushvalue(L,17);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 17);
  
  /* t1 = time_elapsed( t1, 'mark_inside_village_area' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"mark_inside_village_area");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 17);
  
  /* -- determine optimal height for all villages that have their center in this mapchunk; sets village.optimal_height
   * t1 = time_elapsed( t1, 'get_height' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"get_height");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 17);
  
  /* mg_villages.village_area_get_height( village_area, villages, tmin, tmax, data, param2_data, a, cid ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_area_get_height");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,13);
  lua_pushvalue(L,1);
  lua_pushvalue(L,16);
  lua_pushvalue(L,17);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,11);
  lua_call(L,8,0);
  assert(lua_gettop(L) == 17);
  
  /* -- the villages in the first mapchunk are set to a fixed height of 1 so that players will not end up embedded in stone
   * if( not( mg_villages.all_villages ) or mg_villages.anz_villages < 1 ) then */
  enum { lc593 = 17 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"all_villages");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"anz_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    const int lc594 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc594);
  }
  const int lc595 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc595) {
    
    /* villages[1].optimal_height = 1 */
    lua_pushnumber(L,1);
    lua_pushnumber(L,1);
    lua_gettable(L,1);
    lua_insert(L,-2);
    lua_pushliteral(L,"optimal_height");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 17);
  }
  lua_settop(L,lc593);
  assert(lua_gettop(L) == 17);
  
  /* -- change height of those villages where an optimal_height could be determined
   * local village_data_updated = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 18);
  
  /* for _,village in ipairs(villages) do
   * internal: local f, s, var = explist */
  enum { lc596 = 18 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 22
     * internal: local village with idx 23 */
    
    
    /* if( village.optimal_height and village.optimal_height > 0 and village.optimal_height ~= village.vh ) then */
    enum { lc597 = 23 };
    lua_pushliteral(L,"optimal_height");
    lua_gettable(L,23);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
      lua_pushliteral(L,"optimal_height");
      lua_gettable(L,23);
      const int lc598 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc598);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"optimal_height");
      lua_gettable(L,23);
      lua_pushliteral(L,"vh");
      lua_gettable(L,23);
      const int lc599 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc599);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc600 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc600) {
      
      /* -- towers are usually found on elevated places
       * if( village.village_type == 'tower' ) then */
      enum { lc601 = 23 };
      lua_pushliteral(L,"village_type");
      lua_gettable(L,23);
      lua_pushliteral(L,"tower");
      const int lc602 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc602);
      const int lc603 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc603) {
        
        /* village.optimal_height = village.optimal_height + math.max( math.floor(village.vs/2), 2 ) */
        lua_pushliteral(L,"optimal_height");
        lua_gettable(L,23);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"max");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"floor");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"vs");
        lua_gettable(L,23);
        lua_pushnumber(L,2);
        lc_div(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,1,1);
        lua_pushnumber(L,2);
        lua_call(L,2,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"optimal_height");
        lua_insert(L,-2);
        lua_settable(L,23);
        assert(lua_gettop(L) == 23);
      }
      lua_settop(L,lc601);
      assert(lua_gettop(L) == 23);
      
      /* mg_villages.change_village_height( village, village.optimal_height ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"change_village_height");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,23);
      lua_pushliteral(L,"optimal_height");
      lua_gettable(L,23);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 23);
      
      /* village_data_updated = true */
      lua_pushboolean(L,1);
      lua_replace(L,18);
      assert(lua_gettop(L) == 23);
    }
    lua_settop(L,lc597);
    assert(lua_gettop(L) == 23);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc596);
  assert(lua_gettop(L) == 18);
  
  /* t1 = time_elapsed( t1, 'change_height' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"change_height");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 18);
  
  /* --mg_villages.flatten_village_area( villages, minp, maxp, vm, data, param2_data, a, village_area, cid );
   * mg_villages.flatten_village_area( villages, tmin, tmax, vm, data, param2_data, a, village_area, cid ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"flatten_village_area");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,16);
  lua_pushvalue(L,17);
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,13);
  lua_pushvalue(L,11);
  lua_call(L,9,0);
  assert(lua_gettop(L) == 18);
  
  /* t1 = time_elapsed( t1, 'flatten_village_area' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"flatten_village_area");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 18);
  
  /* -- repair cavegen griefings and mudflow which may have happened in the outer shell (which is part of other mapnodes)
   * local e1 = {x=minp.x,y=minp.y,z=minp.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,2);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 19);
  
  /* local e2 = {x=maxp.x,y=maxp.y,z=maxp.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,3);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 20);
  
  /* mg_villages.repair_outer_shell(   villages, {x=tmin.x,   y=tmin.y,z=tmin.z},    {x=tmin.x+16, y=tmax.y, z=tmax.z}, vm, data, param2_data, a, village_area, cid, e1, e2 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"repair_outer_shell");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,16);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,13);
  lua_pushvalue(L,11);
  lua_pushvalue(L,19);
  lua_pushvalue(L,20);
  lua_call(L,11,0);
  assert(lua_gettop(L) == 20);
  
  /* mg_villages.repair_outer_shell(   villages, {x=tmax.x-16,y=tmin.y,z=tmin.z},    {x=tmax.x,    y=tmax.y, z=tmax.z}, vm, data, param2_data, a, village_area, cid, e1, e2 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"repair_outer_shell");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,17);
  lua_pushnumber(L,16);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,13);
  lua_pushvalue(L,11);
  lua_pushvalue(L,19);
  lua_pushvalue(L,20);
  lua_call(L,11,0);
  assert(lua_gettop(L) == 20);
  
  /* mg_villages.repair_outer_shell(   villages, {x=tmin.x+16,y=tmin.y,z=tmin.z},    {x=tmax.x-16, y=tmax.y, z=tmin.z+16}, vm, data, param2_data, a, village_area, cid, e1, e2 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"repair_outer_shell");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,16);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,17);
  lua_pushnumber(L,16);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,16);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,13);
  lua_pushvalue(L,11);
  lua_pushvalue(L,19);
  lua_pushvalue(L,20);
  lua_call(L,11,0);
  assert(lua_gettop(L) == 20);
  
  /* mg_villages.repair_outer_shell(   villages, {x=tmin.x+16,y=tmin.y,z=tmax.z-16}, {x=tmax.x-16, y=tmax.y, z=tmax.z},    vm, data, param2_data, a, village_area, cid, e1, e2 ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"repair_outer_shell");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,16);
  lua_pushnumber(L,16);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,16);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,17);
  lua_pushnumber(L,16);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,17);
  lua_pushnumber(L,16);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,17);
  lua_rawset(L,-3);
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,13);
  lua_pushvalue(L,11);
  lua_pushvalue(L,19);
  lua_pushvalue(L,20);
  lua_call(L,11,0);
  assert(lua_gettop(L) == 20);
  
  /* --	mg_villages.repair_outer_shell(   villages, tmin, tmax, vm, data, param2_data, a, village_area, cid );
   * t1 = time_elapsed( t1, 'repair_outer_shell' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"repair_outer_shell");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 20);
  
  /* local c_feldweg =  minetest.get_content_id('cottages:feldweg') */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_content_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"cottages:feldweg");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 21);
  
  /* if( not( c_feldweg )) then */
  enum { lc604 = 21 };
  lua_pushboolean(L,!(lua_toboolean(L,21)));
  const int lc605 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc605) {
    
    /* c_feldweg = minetest.get_content_id('default:cobble') */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_content_id");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:cobble");
    lua_call(L,1,1);
    lua_replace(L,21);
    assert(lua_gettop(L) == 21);
  }
  lua_settop(L,lc604);
  assert(lua_gettop(L) == 21);
  
  /* for _, village in ipairs(villages) do
   * 
   * 		-- the village_id will be stored in the plot markers
   * internal: local f, s, var = explist */
  enum { lc606 = 21 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 25
     * internal: local village with idx 26 */
    
    
    /* -- the village_id will be stored in the plot markers
     * local village_id = tostring( village.vx )..':'..tostring( village.vz ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushliteral(L,"vx");
    lua_gettable(L,26);
    lua_call(L,1,1);
    lua_pushliteral(L,":");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushliteral(L,"vz");
    lua_gettable(L,26);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 27);
    
    /* village.anz_buildings = mg_villages.count_inhabitated_buildings(village) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"count_inhabitated_buildings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,26);
    lua_call(L,1,1);
    lua_pushliteral(L,"anz_buildings");
    lua_insert(L,-2);
    lua_settable(L,26);
    assert(lua_gettop(L) == 27);
    
    /* village.to_add_data = handle_schematics.place_buildings( village, tmin, tmax, data, param2_data, a, cid, village_id) */
    lua_getfield(L,LUA_ENVIRONINDEX,"handle_schematics");
    lua_pushliteral(L,"place_buildings");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,26);
    lua_pushvalue(L,16);
    lua_pushvalue(L,17);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_pushvalue(L,7);
    lua_pushvalue(L,11);
    lua_pushvalue(L,27);
    lua_call(L,8,1);
    lua_pushliteral(L,"to_add_data");
    lua_insert(L,-2);
    lua_settable(L,26);
    assert(lua_gettop(L) == 27);
    
    /* handle_schematics.place_dirt_roads(                village, tmin, tmax, data, param2_data, a, c_feldweg) */
    lua_getfield(L,LUA_ENVIRONINDEX,"handle_schematics");
    lua_pushliteral(L,"place_dirt_roads");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,26);
    lua_pushvalue(L,16);
    lua_pushvalue(L,17);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_pushvalue(L,7);
    lua_pushvalue(L,21);
    lua_call(L,7,0);
    assert(lua_gettop(L) == 27);
    
    /* -- grow trees which are part of buildings into saplings
     * for _,v in ipairs( village.to_add_data.extra_calls.trees ) do
     * internal: local f, s, var = explist */
    enum { lc607 = 27 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,26);
    lua_pushliteral(L,"extra_calls");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"trees");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 31
       * internal: local v with idx 32 */
      
      
      /* mg_villages.grow_a_tree( v, v.typ, minp, maxp, data, a, cid, nil, v.snow ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"grow_a_tree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,32);
      lua_pushliteral(L,"typ");
      lua_gettable(L,32);
      lua_pushvalue(L,2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,5);
      lua_pushvalue(L,7);
      lua_pushvalue(L,11);
      lua_pushnil(L);
      lua_pushliteral(L,"snow");
      lua_gettable(L,32);
      lua_call(L,9,0);
      assert(lua_gettop(L) == 32);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc607);
    assert(lua_gettop(L) == 27);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc606);
  assert(lua_gettop(L) == 21);
  
  /* t1 = time_elapsed( t1, 'place_buildings and place_dirt_roads' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"place_buildings and place_dirt_roads");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* mg_villages.village_area_fill_with_plants( village_area, villages, tmin, tmax, data, param2_data, a, cid ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_area_fill_with_plants");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,13);
  lua_pushvalue(L,1);
  lua_pushvalue(L,16);
  lua_pushvalue(L,17);
  lua_pushvalue(L,5);
  lua_pushvalue(L,6);
  lua_pushvalue(L,7);
  lua_pushvalue(L,11);
  lua_call(L,8,0);
  assert(lua_gettop(L) == 21);
  
  /* t1 = time_elapsed( t1, 'fill_with_plants' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"fill_with_plants");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* if( mg_villages.CREATE_HIGHLANDPOOLS ) then */
  enum { lc608 = 21 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"CREATE_HIGHLANDPOOLS");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc609 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc609) {
    
    /* mg_villages.do_highlandpools(minp, maxp, seed, vm, a, data, village_area, cid) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"do_highlandpools");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,9);
    lua_pushvalue(L,4);
    lua_pushvalue(L,7);
    lua_pushvalue(L,5);
    lua_pushvalue(L,13);
    lua_pushvalue(L,11);
    lua_call(L,8,0);
    assert(lua_gettop(L) == 21);
  }
  lua_settop(L,lc608);
  assert(lua_gettop(L) == 21);
  
  /* t1 = time_elapsed( t1, 'create highlandpools' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"create highlandpools");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* vm:set_data(data) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"set_data");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 21);
  
  /* vm:set_param2_data(param2_data) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"set_param2_data");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,6);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 21);
  
  /* t1 = time_elapsed( t1, 'vm data set' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"vm data set");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* -- only update lighting where we actually placed the nodes
   * vm:calc_lighting( e1, e2 ) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"calc_lighting");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,19);
  lua_pushvalue(L,20);
  lua_call(L,3,0);
  assert(lua_gettop(L) == 21);
  
  /* --minp, maxp ); --tmin, tmax)
   * t1 = time_elapsed( t1, 'vm calc lighting' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"vm calc lighting");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* vm:write_to_map(data) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"write_to_map");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 21);
  
  /* t1 = time_elapsed( t1, 'vm data written' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"vm data written");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* vm:update_liquids() */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"update_liquids");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 21);
  
  /* t1 = time_elapsed( t1, 'vm update liquids' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"vm update liquids");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 21);
  
  /* -- do on_construct calls AFTER the map data has been written - else i.e. realtest fences can not update themshevles
   * for _, village in ipairs(villages) do
   * internal: local f, s, var = explist */
  enum { lc610 = 21 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 25
     * internal: local village with idx 26 */
    
    
    /* for k, v in pairs( village.to_add_data.extra_calls.on_constr ) do
     * internal: local f, s, var = explist */
    enum { lc611 = 26 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,26);
    lua_pushliteral(L,"extra_calls");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"on_constr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local k with idx 30
       * internal: local v with idx 31 */
      
      
      /* local node_name = minetest.get_name_from_content_id( k ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_name_from_content_id");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,30);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 32);
      
      /* if( minetest.registered_nodes[ node_name ].on_construct ) then */
      enum { lc612 = 32 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"registered_nodes");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,32);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"on_construct");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc613 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc613) {
        
        /* for _, pos in ipairs(v) do
         * internal: local f, s, var = explist */
        enum { lc614 = 32 };
        lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
        lua_pushvalue(L,31);
        lua_call(L,1,3);
        while (1) {
          
          /* internal: local var_1, ..., var_n = f(s, var)
           *           if var_1 == nil then break end
           *           var = var_1 */
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_pushvalue(L,-3);
          lua_call(L,2,2);
          if (lua_isnil(L,-2)) {
            break;
          }
          lua_pushvalue(L,-2);
          lua_replace(L,-4);
          
          /* internal: local _ with idx 36
           * internal: local pos with idx 37 */
          
          
          /* minetest.registered_nodes[ node_name ].on_construct( pos ) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"registered_nodes");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,32);
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"on_construct");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,37);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 37);
          
          /* internal: stack cleanup on scope exit */
          lua_pop(L,2);
        }
        lua_settop(L,lc614);
        assert(lua_gettop(L) == 32);
      }
      lua_settop(L,lc612);
      assert(lua_gettop(L) == 32);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
    }
    lua_settop(L,lc611);
    assert(lua_gettop(L) == 26);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc610);
  assert(lua_gettop(L) == 21);
  
  /* -- the doors need to be adjusted as well
   * for _, village in ipairs(villages) do
   * internal: local f, s, var = explist */
  enum { lc615 = 21 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 25
     * internal: local village with idx 26 */
    
    
    /* if( village.to_add_data.extra_calls.door_b ) then */
    enum { lc616 = 26 };
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,26);
    lua_pushliteral(L,"extra_calls");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"door_b");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc617 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc617) {
      
      /* for k, v in pairs( village.to_add_data.extra_calls.door_b ) do
       * internal: local f, s, var = explist */
      enum { lc618 = 26 };
      lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,26);
      lua_pushliteral(L,"extra_calls");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"door_b");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local k with idx 30
         * internal: local v with idx 31 */
        
        
        /* local meta = minetest.get_meta( v ) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_meta");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,31);
        lua_call(L,1,1);
        assert(lua_gettop(L) == 32);
        
        /* local l = 2 */
        lua_pushnumber(L,2);
        assert(lua_gettop(L) == 33);
        
        /* -- b
         * local h = meta:get_int("right") + 1 */
        lua_pushvalue(L,32);
        lua_pushliteral(L,"get_int");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"right");
        lua_call(L,2,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 34);
        
        /* local replace = {
         * 			        { { type = "a", state = 0 }, { type = "a", state = 3 } },
         * 			        { { type = "b", state = 1 }, { type = "b", state = 2 } }
         * 			} */
        lua_createtable(L,2,0);
        lua_createtable(L,2,0);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"type");
        lua_pushliteral(L,"a");
        lua_rawset(L,-3);
        lua_pushliteral(L,"state");
        lua_pushnumber(L,0);
        lua_rawset(L,-3);
        lua_rawseti(L,-2,1);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"type");
        lua_pushliteral(L,"a");
        lua_rawset(L,-3);
        lua_pushliteral(L,"state");
        lua_pushnumber(L,3);
        lua_rawset(L,-3);
        lua_rawseti(L,-2,2);
        lua_rawseti(L,-2,1);
        lua_createtable(L,2,0);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"type");
        lua_pushliteral(L,"b");
        lua_rawset(L,-3);
        lua_pushliteral(L,"state");
        lua_pushnumber(L,1);
        lua_rawset(L,-3);
        lua_rawseti(L,-2,1);
        lua_createtable(L,0,2);
        lua_pushliteral(L,"type");
        lua_pushliteral(L,"b");
        lua_rawset(L,-3);
        lua_pushliteral(L,"state");
        lua_pushnumber(L,2);
        lua_rawset(L,-3);
        lua_rawseti(L,-2,2);
        lua_rawseti(L,-2,2);
        assert(lua_gettop(L) == 35);
        
        /* local new = replace[l][h] */
        lua_pushvalue(L,33);
        lua_gettable(L,35);
        lua_pushvalue(L,34);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        assert(lua_gettop(L) == 36);
        
        /* --			minetest.swap_node(v, {name = name .. "_" .. new.type, param2 = v.p2})
         * meta:set_int("state", new.state) */
        lua_pushvalue(L,32);
        lua_pushliteral(L,"set_int");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"state");
        lua_pushliteral(L,"state");
        lua_gettable(L,36);
        lua_call(L,3,0);
        assert(lua_gettop(L) == 36);
        
        /* -- wipe meta on top node as it's unused
         * minetest.set_node({x = v.x, y = v.y + 1, z = v.z}, { name = "doors:hidden" }) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"set_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_createtable(L,0,3);
        lua_pushliteral(L,"x");
        lua_pushliteral(L,"x");
        lua_gettable(L,31);
        lua_rawset(L,-3);
        lua_pushliteral(L,"y");
        lua_pushliteral(L,"y");
        lua_gettable(L,31);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_pushliteral(L,"z");
        lua_pushliteral(L,"z");
        lua_gettable(L,31);
        lua_rawset(L,-3);
        lua_createtable(L,0,1);
        lua_pushliteral(L,"name");
        lua_pushliteral(L,"doors:hidden");
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 36);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,7);
      }
      lua_settop(L,lc618);
      assert(lua_gettop(L) == 26);
    }
    lua_settop(L,lc616);
    assert(lua_gettop(L) == 26);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc615);
  assert(lua_gettop(L) == 21);
  
  /* local pr = PseudoRandom(mg_villages.get_bseed(minp)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"PseudoRandom");
  const int lc619 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"get_bseed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc619),1);
  assert(lua_gettop(L) == 22);
  
  /* for _, village in ipairs(villages) do
   * internal: local f, s, var = explist */
  enum { lc620 = 22 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 26
     * internal: local village with idx 27 */
    
    
    /* for _,v in ipairs( village.to_add_data.extra_calls.chests ) do
     * internal: local f, s, var = explist */
    enum { lc621 = 27 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushliteral(L,"to_add_data");
    lua_gettable(L,27);
    lua_pushliteral(L,"extra_calls");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"chests");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 31
       * internal: local v with idx 32 */
      
      
      /* local building_nr  = village.to_add_data.bpos[ v.bpos_i ] */
      lua_pushliteral(L,"to_add_data");
      lua_gettable(L,27);
      lua_pushliteral(L,"bpos");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"bpos_i");
      lua_gettable(L,32);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 33);
      
      /* local building_typ = mg_villages.BUILDINGS[ building_nr.btype ].scm */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"BUILDINGS");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"btype");
      lua_gettable(L,33);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"scm");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 34);
      
      /* mg_villages.fill_chest_random( v, pr, building_nr, building_typ ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"fill_chest_random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,32);
      lua_pushvalue(L,22);
      lua_pushvalue(L,33);
      lua_pushvalue(L,34);
      lua_call(L,4,0);
      assert(lua_gettop(L) == 34);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,4);
    }
    lua_settop(L,lc621);
    assert(lua_gettop(L) == 27);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc620);
  assert(lua_gettop(L) == 22);
  
  /* -- TODO: extra_calls.signs
   * -- useful for spawning mobs etc.
   * for _, village in ipairs(villages) do
   * internal: local f, s, var = explist */
  enum { lc622 = 22 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 26
     * internal: local village with idx 27 */
    
    
    /* mg_villages.part_of_village_spawned( village, minp, maxp, data, param2_data, a, cid ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"part_of_village_spawned");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,27);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    lua_pushvalue(L,7);
    lua_pushvalue(L,11);
    lua_call(L,7,0);
    assert(lua_gettop(L) == 27);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc622);
  assert(lua_gettop(L) == 22);
  
  /* -- initialize the pseudo random generator so that the chests will be filled in a reproducable pattern
   * local meta */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 23);
  
  /* for _, village in ipairs(villages) do
   * 		-- now add those buildings which are .mts files and need to be placed by minetest.place_schematic(...)
   * 		-- place_schematics is no longer needed	
   * 		--mg_villages.place_schematics( village.to_add_data.bpos, village.to_add_data.replacements, a, pr );
   * 		--t1 = time_elapsed( t1, 'place_schematics' );
   * internal: local f, s, var = explist */
  enum { lc623 = 23 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,1);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 27
     * internal: local village with idx 28 */
    
    
    /* -- now add those buildings which are .mts files and need to be placed by minetest.place_schematic(...)
     * -- place_schematics is no longer needed	
     * --mg_villages.place_schematics( village.to_add_data.bpos, village.to_add_data.replacements, a, pr );
     * --t1 = time_elapsed( t1, 'place_schematics' );
     * if( not( mg_villages.all_villages )) then */
    enum { lc624 = 28 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc625 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc625) {
      
      /* mg_villages.all_villages = {} */
      lua_newtable(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_insert(L,-2);
      lua_pushliteral(L,"all_villages");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 28);
    }
    lua_settop(L,lc624);
    assert(lua_gettop(L) == 28);
    
    /* -- unique id - there can only be one village at a given pair of x,z coordinates
     * local village_id = tostring( village.vx )..':'..tostring( village.vz ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushliteral(L,"vx");
    lua_gettable(L,28);
    lua_call(L,1,1);
    lua_pushliteral(L,":");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushliteral(L,"vz");
    lua_gettable(L,28);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 29);
    
    /* -- the village data is saved only once per village - and not whenever part of the village is generated
     * if( not( mg_villages.all_villages[ village_id ])) then */
    enum { lc626 = 29 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,29);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc627 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc627) {
      
      /* -- count how many villages we already have and assign each village a uniq number
       * local count = 1 */
      lua_pushnumber(L,1);
      assert(lua_gettop(L) == 30);
      
      /* for _,v in pairs( mg_villages.all_villages ) do
       * internal: local f, s, var = explist */
      enum { lc628 = 30 };
      lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local _ with idx 34
         * internal: local v with idx 35 */
        
        
        /* count = count + 1 */
        lua_pushnumber(L,1);
        lc_add(L,30,-1);
        lua_remove(L,-2);
        lua_replace(L,30);
        assert(lua_gettop(L) == 35);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc628);
      assert(lua_gettop(L) == 30);
      
      /* village.extra_calls = {} */
      lua_newtable(L);
      lua_pushliteral(L,"extra_calls");
      lua_insert(L,-2);
      lua_settable(L,28);
      assert(lua_gettop(L) == 30);
      
      /* -- do not save these values
       * village.nr = count */
      lua_pushvalue(L,30);
      lua_pushliteral(L,"nr");
      lua_insert(L,-2);
      lua_settable(L,28);
      assert(lua_gettop(L) == 30);
      
      /* mg_villages.anz_villages = count */
      lua_pushvalue(L,30);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_insert(L,-2);
      lua_pushliteral(L,"anz_villages");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 30);
      
      /* mg_villages.all_villages[ village_id ] = minetest.deserialize( minetest.serialize( village )) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"deserialize");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc629 = lua_gettop(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"serialize");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,28);
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc629),1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,29);
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 30);
      
      /* mg_villages.print( mg_villages.DEBUG_LEVEL_NORMAL, "Village No. "..tostring( count ).." of type \'"..
       * 					tostring( village.village_type ).."\' of size "..tostring( village.vs )..
       * 					" spawned at: x = "..village.vx..", z = "..village.vz) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"print");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"DEBUG_LEVEL_NORMAL");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"Village No. ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushvalue(L,30);
      lua_call(L,1,1);
      lua_pushliteral(L," of type '");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"village_type");
      lua_gettable(L,28);
      lua_call(L,1,1);
      lua_pushliteral(L,"' of size ");
      lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
      lua_pushliteral(L,"vs");
      lua_gettable(L,28);
      lua_call(L,1,1);
      lua_pushliteral(L," spawned at: x = ");
      lua_pushliteral(L,"vx");
      lua_gettable(L,28);
      lua_pushliteral(L,", z = ");
      lua_pushliteral(L,"vz");
      lua_gettable(L,28);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 30);
      
      /* village_data_updated = true */
      lua_pushboolean(L,1);
      lua_replace(L,18);
      assert(lua_gettop(L) == 30);
      
      /* -- hook for doing stuff that needs to be done exactly once per village
       * mg_villages.new_village_spawned( village_id ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"new_village_spawned");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,29);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 30);
    }
    lua_settop(L,lc626);
    assert(lua_gettop(L) == 29);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc623);
  assert(lua_gettop(L) == 23);
  
  /* -- always save the changed village data
   * t1 = time_elapsed( t1, 'update village data' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"update village data");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 23);
  
  /* mg_villages.save_data() */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"save_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,0);
  assert(lua_gettop(L) == 23);
  
  /* t1 = time_elapsed( t1, 'save village data' ) */
  lua_getfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"save village data");
  lua_call(L,2,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 23);
  return 0;
}


/* function(minp, maxp, seed) */
static int lcf652 (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* -- this is just for learning more about dungeons and caves; it is not used anywhere here
   * --	local structures = minetest.get_mapgen_object('gennotify');
   * --	print('STRUCTURES BY MAPGEN: '..minetest.serialize( structures ));
   * -- only generate village on the surface chunks
   * if( minp.y < -32 or minp.y > mg_villages.MAX_HEIGHT_TREATED) then */
  enum { lc630 = 3 };
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,-32);
  const int lc631 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc631);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"MAX_HEIGHT_TREATED");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    const int lc632 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc632);
  }
  const int lc633 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc633) {
    
    /* --64
     * return; */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc630);
  assert(lua_gettop(L) == 3);
  
  /* -- this function has to be called ONCE and AFTER all village types and buildings have been added
   * -- (which might have been done by other mods so we can't do this earlier)
   * if( not( mg_villages.village_types )) then */
  enum { lc634 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"village_types");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc635 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc635) {
    
    /* mg_villages.init_weights() */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"init_weights");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc634);
  assert(lua_gettop(L) == 3);
  
  /* local villages = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 4);
  
  /* -- create normal villages
   * if( mg_villages.ENABLE_VILLAGES == true ) then */
  enum { lc636 = 4 };
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"ENABLE_VILLAGES");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,1);
  const int lc637 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc637);
  const int lc638 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc638) {
    
    /* villages = mg_villages.villages_in_mapchunk( minp, maxp.x-minp.x+1 ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"villages_in_mapchunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc636);
  assert(lua_gettop(L) == 4);
  
  /* -- if this mapchunk contains no part of a village, probably a lone building may be found in it
   * if( mg_villages.INVERSE_HOUSE_DENSITY > 0 ) then */
  enum { lc639 = 4 };
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"INVERSE_HOUSE_DENSITY");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc640 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc640);
  const int lc641 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc641) {
    
    /* villages = mg_villages.houses_in_mapchunk(   minp, maxp.x-minp.x+1, villages ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"houses_in_mapchunk");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushliteral(L,"x");
    lua_gettable(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_call(L,3,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc639);
  assert(lua_gettop(L) == 4);
  
  /* -- check if the village exists already
   * local v_nr = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 5);
  
  /* for v_nr, village in ipairs(villages) do
   * internal: local f, s, var = explist */
  enum { lc642 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,4);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local v_nr with idx 9
     * internal: local village with idx 10 */
    
    
    /* local village_id = tostring( village.vx )..':'..tostring( village.vz ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushliteral(L,"vx");
    lua_gettable(L,10);
    lua_call(L,1,1);
    lua_pushliteral(L,":");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushliteral(L,"vz");
    lua_gettable(L,10);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 11);
    
    /* if( not( village.name ) or village.name == '') then */
    enum { lc643 = 11 };
    lua_pushliteral(L,"name");
    lua_gettable(L,10);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,10);
      lua_pushliteral(L,"");
      const int lc644 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc644);
    }
    const int lc645 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc645) {
      
      /* village.name = 'unknown' */
      lua_pushliteral(L,"unknown");
      lua_pushliteral(L,"name");
      lua_insert(L,-2);
      lua_settable(L,10);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc643);
    assert(lua_gettop(L) == 11);
    
    /* if( mg_villages.all_villages and mg_villages.all_villages[ village_id ]) then */
    enum { lc646 = 11 };
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"all_villages");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,11);
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    const int lc647 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc647) {
      
      /* villages[ v_nr ] = mg_villages.all_villages[ village_id ] */
      lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
      lua_pushliteral(L,"all_villages");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,11);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_insert(L,-2);
      lua_settable(L,4);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc646);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc642);
  assert(lua_gettop(L) == 5);
  
  /* if( villages and #villages > 0 ) then */
  enum { lc648 = 5 };
  lua_pushvalue(L,4);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
    const double lc649 = lua_objlen(L,4);
    lua_pushnumber(L,lc649);
    const int lc650 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc650);
  }
  const int lc651 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc651) {
    
    /* mg_villages.place_villages_via_voxelmanip( villages, minp, maxp, nil, data_vm, data_param2_data, nil, nil, seed ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_pushliteral(L,"place_villages_via_voxelmanip");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushnil(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"data_vm");
    lua_getfield(L,LUA_ENVIRONINDEX,"data_param2_data");
    lua_pushnil(L);
    lua_pushnil(L);
    lua_pushvalue(L,3);
    lua_call(L,9,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc648);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* ------------------------------------------------------------------------------
   * -- Interface for other mdos
   * -- this function gets executed only once per village - namely when the first
   * -- part of a village is generated;
   * -- relevant data about the vilalge can be found in the following data structure:
   * --     mg_villages.all_villages[ village_id ]
   * mg_villages.new_village_spawned = function( village_id )
   * 	-- dummy function
   * 	return village_id
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_new_village_spawned);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"new_village_spawned");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- use this function if you want to i.e. spawn mobs/traders/etc;
   * -- the village data structure contains information about the entire village;
   * -- minp, maxp indicates which part has actually been spawned;
   * -- the function may add information to the  village  data structure if needed;
   * -- the voxelmanip data (data, param2_data, a) is just for reading, i.e. finding
   * --   a good spawning position for the trader
   * mg_villages.part_of_village_spawned = function( village, minp, maxp, data, param2_data, a, cid )
   * 	-- mobf needs a way to spawn its traders
   * 	if( minetest.get_modpath( 'mobf_trader' )) then
   * 		mob_village_traders.part_of_village_spawned( village, minp, maxp, data, param2_data, a, cid );
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_part_of_village_spawned);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"part_of_village_spawned");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* ------------------------------------------------------------------------------
   * mg_villages.wseed = 0 */
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"wseed");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_on_mapgen_init(function(mgparams)
   *         mg_villages.wseed = math.floor(mgparams.seed/10000000000)
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_mapgen_init");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function mg_villages.get_bseed(minp)
   *         return mg_villages.wseed + math.floor(5*minp.x/47) + math.floor(873*minp.z/91)
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_bseed);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_bseed");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* function mg_villages.get_bseed2(minp)
   *         return mg_villages.wseed + math.floor(87*minp.x/47) + math.floor(73*minp.z/91) + math.floor(31*minp.y/12)
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_bseed2);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_bseed2");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- if you change any of the 3 constants below, also change them in the function
   * --   mg_villages.village_area_mark_inside_village_area
   * mg_villages.inside_village = function(x, z, village, vnoise)
   *         return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) <= 40
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_inside_village);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"inside_village");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.inside_village_area = function(x, z, village, vnoise)
   *         return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) <= 80
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_inside_village_area);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"inside_village_area");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.inside_village_terrain_blend_area = function(x, z, village, vnoise)
   *         return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village) <= 160
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_inside_village_terrain_blend_area);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"inside_village_terrain_blend_area");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.get_vnoise = function(x, z, village, vnoise) -- PM v
   *         return mg_villages.get_vn(x, z, vnoise:get2d({x = x, y = z}), village)
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_vnoise);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_vnoise");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- PM ^
   * mg_villages.get_vn = function(x, z, noise, village)
   *         local vx, vz, vs = village.vx, village.vz, village.vs
   *         return (noise - 2) * 20 +
   *                 (40 / (vs * vs)) * ((x - vx) * (x - vx) + (z - vz) * (z - vz))
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_get_vn);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"get_vn");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* mg_villages.villages_in_mapchunk = function( minp, mapchunk_size )
   * 	local noise1raw = minetest.get_perlin(12345, 6, 0.5, 256)
   * 	
   * 	local vcr = mg_villages.VILLAGE_CHECK_RADIUS
   * 	local villages = {}
   * 	for xi = -vcr, vcr do
   * 	for zi = -vcr, vcr do
   * 		for _, village in ipairs(mg_villages.villages_at_point({x = minp.x + xi * mapchunk_size, z = minp.z + zi * mapchunk_size}, noise1raw)) do
   * 			villages[#villages+1] = village
   * 		end
   * 	end
   * 	end
   * 	return villages;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_villages_in_mapchunk);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"villages_in_mapchunk");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- TODO: determine water level from mapgens?
   * local MG_VILLAGES_WATER_LEVEL = 1 */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc19 = 1 };
  assert((lua_gettop(L) == (lc19 + lc_nextra)));
  lua_pushnumber(L,1);
  lua_rawseti(L,(lc19 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* if( minetest.get_modpath( 'mg' )) then */
  enum { lc20 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg");
  lua_call(L,1,1);
  const int lc21 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc21) {
    
    /* MG_VILLAGES_WATER_LEVEL = 0 */
    lua_pushnumber(L,0);
    lc_setupvalue(L,(lc19 + lc_nextra),0,1);
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc20 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* --replacements_group.node_is_ground = {}; -- store nodes which have previously been identified as ground
   * mg_villages.check_if_ground = function( ci )
   * 
   * 	-- pre-generate a list of no-ground-nodes for caching
   * 	if( ci==nil or replacements_group.node_is_ground[ minetest.get_content_id('air')]==nil) then
   * 		local no_ground_nodes = {'air','ignore','default:sandstonebrick','default:cactus','default:wood','default:junglewood',
   * 			'default:pine_wood','default:pine_tree','default:acacia_wood','default:acacia_tree', 'default:aspen_wood', 'default:aspen_tree',
   * 			'ethereal:mushroom_pore','ethereal:mushroom_trunk','ethereal:bamboo', 'ethereal:mushroom',
   *                         'ethereal:bush', 'default:grass', 'default:grass_1','default:grass_2','default:grass_3','default:grass_4','default:grass_5'};
   * 		-- TODO: add all those other tree and leaf nodes that might be added by mapgen
   * 		for _,name in ipairs( no_ground_nodes ) do
   * 			if( minetest.registered_nodes[ name ]) then
   * 				replacements_group.node_is_ground[ minetest.get_content_id( name )] = false;
   * 			end
   * 		end
   * 		local ground_nodes = {'ethereal:dry_dirt', 'default:dirt_with_dry_grass','default:stone','default:sandstone','default:desertstone',
   *                         'ethereal:grey_dirt', 'default:dirt_with_snow', 'default:dirt_with_grass', 'ethereal:grove_dirt', 'ethereal:green_dirt',
   * 			'ethereal:grove_dirt','ethereal:jungle_dirt'};
   * 		for _,name in ipairs( ground_nodes ) do
   * 			if( minetest.registered_nodes[ name ]) then
   * 				replacements_group.node_is_ground[ minetest.get_content_id( name )] = true;
   * 			end
   * 		end
   * 	end
   * 
   * 	if( not( ci )) then
   * 		return false;
   * 	end
   * 	if( replacements_group.node_is_ground[ ci ] ~= nil) then
   * 		return replacements_group.node_is_ground[ ci ];
   * 	end
   * 	-- analyze the node
   * 	-- only nodes on which walking is possible may be counted as ground
   * 	local node_name = minetest.get_name_from_content_id( ci );
   * 	local def = minetest.registered_nodes[ node_name ];	
   * 	-- store information about this node type for later use
   * 	if(     not( def )) then
   * 		replacements_group.node_is_ground[ ci ] = false;
   * 	elseif( not( def.walkable)) then
   * 		replacements_group.node_is_ground[ ci ] = false;
   * 	elseif( def.groups and def.groups.tree ) then
   * 		replacements_group.node_is_ground[ ci ] = false;
   * 	elseif(	def.drop   and def.drop == 'default:dirt') then
   * 		replacements_group.node_is_ground[ ci ] = true;
   * 	elseif( def.walkable == true and def.is_ground_content == true and not(def.node_box)) then
   * 		replacements_group.node_is_ground[ ci ] = true;
   * 	else
   * 		replacements_group.node_is_ground[ ci ] = false;
   * 	end
   * 	return replacements_group.node_is_ground[ ci ];
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_check_if_ground);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"check_if_ground");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- call it once this way so that some grounds and non-grounds get identified
   * mg_villages.check_if_ground(nil) */
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_pushliteral(L,"check_if_ground");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- sets evrything at x,z and above height target_height to air;
   * -- the area below gets filled up in a suitable way (i.e. dirt with grss - dirt - stone)
   * mg_villages.lower_or_raise_terrain_at_point = function( x, z, target_height, minp, maxp, vm, data, param2_data, a, cid, vh, treepos, has_artificial_snow, blend, force_ground, force_underground )
   * 	local surface_node  = nil;
   * 	local has_snow      = has_artificial_snow;
   * 	local tree          = false;
   * 	local jtree         = false;
   * 	local ptree         = false;
   * 	local atree         = false;
   *         local asptree       = false;
   * 	local old_height    = maxp.y;
   * 	local y = maxp.y;
   * 
   * 	local look_for_snow = true;
   * 	if( cid.c_snow==cid.c_ignore or cid.c_snow==cid.c_air
   * 	 or cid.c_ice ==cid.c_ignore or cid.c_ice ==cid.c_air ) then
   * 		look_for_snow = nil;
   * 	end
   * 
   * 	-- if we are working on a mapchunk above, set all to air;
   * 	-- any terrain blending happens in the mapchunk below
   * 	if( minp.y > vh ) then
   * 		local air_counted = 0;
   * 		for y=minp.y, minp.y+16 do
   * 			if( data[a:index( x, y, z )] == cid.c_air ) then
   * 				air_counted = air_counted + 1;
   * 			end
   * 		end
   * 		if( air_counted > 3 or blend==0) then
   * 			for y=minp.y+15, maxp.y do
   * 				data[a:index( x, y, z)] = cid.c_air;
   * 			end
   * 		end
   * 		-- else do nothing
   * 		return;
   * 	end
   * 
   * 	-- search for a surface and set everything above target_height to air
   * 	while( y > minp.y) do
   * 		local ci = data[a:index(x, y, z)];
   * 		if(     look_for_snow and (ci == cid.c_snow or ci == cid.c_ice or ci == cid.c_snowblock)) then
   * 			has_snow = true;
   * 		elseif( ci == cid.c_tree ) then
   * 			tree  = true;
   * 		-- no jungletrees for branches
   * 		elseif( ci == cid.c_jtree and data[a:index( x, y-1, z)]==cid.c_jtree) then
   * 			jtree = true;
   * 		-- pinetrees
   * 		elseif( ci == cid.c_ptree and data[a:index( x, y-1, z)]==cid.c_ptree) then
   * 			ptree = true;
   * 		-- acacia
   * 		elseif( ci == cid.c_atree and data[a:index( x, y-1, z)]==cid.c_atree) then
   * 			atree = true;
   *                 -- aspen
   * 		elseif( ci == cid.c_asptree and data[a:index( x, y-1, z)]==cid.c_asptree) then
   * 			asptree = true;
   * 		elseif( not( surface_node) and ci ~= cid.c_air and ci ~= cid.c_ignore and mg_villages.check_if_ground( ci ) == true) then
   * 			-- we have found a surface of some kind
   * 			surface_node = ci;
   * 			old_height   = y;
   * 			if( look_for_snow and surface_node == cid.c_dirt_with_snow and cid.c_dirt_with_snow~=cid.c_ignore) then
   * 				has_snow = true;
   * 			end
   * 		end
   * 		-- make sure there is air for the village
   * 		if( y > target_height ) then
   * 			data[a:index( x, y, z)] = cid.c_air;
   * 		-- abort search once we've reached village ground level and found a surface node
   * 		elseif( y <= target_height and surface_node ) then
   * 			y = minp.y - 1;
   * 		end
   * 		y = y-1;
   * 	end
   * 		
   * 	if( not( surface_node ) and old_height == maxp.y ) then
   * 		if(     data[a:index( x, minp.y, z)]==cid.c_air) then
   * 			old_height = vh - 2;	
   * 		elseif( minp.y < 0 ) then
   * 			old_height = minp.y;	
   * 		end
   * 	end
   * 	if( not( surface_node ) or surface_node == cid.c_dirt) then
   * 		surface_node = cid.c_dirt_with_grass;
   * 	end
   * 	if( look_for_snow and has_snow and surface_node == cid.c_dirt_with_grass and target_height > 1) then
   * 		surface_node = cid.c_dirt_with_snow;
   * 	end
   * 	local below_1 = cid.c_dirt;
   * 	local below_2 = cid.c_stone;
   * 	if(     force_ground and force_underground ) then
   * 		below_1 = force_ground;
   * 		below_2 = force_underground;
   * 		surface_node = below_1;
   * 	elseif( surface_node == cid.c_desert_sand ) then
   * 		below_1 = cid.c_desert_sand;
   * 		below_2 = cid.c_desert_stone;
   * 	elseif( surface_node == cid.c_sand ) then
   * 		below_1 = cid.c_sand;
   * 		below_2 = cid.c_stone;
   * 	elseif( cid.c_ethereal_clay_read
   * 	    and (surface_node == cid.c_ethereal_clay_red
   * 	      or surface_node == cid.c_ethereal_clay_orange)) then
   * 		below_1 = cid.c_ethereal_clay_orange;
   * 		below_2 = cid.c_ethereal_clay_orange;
   * 	elseif( surface_node == cid.c_sandstone ) then
   * 		below_1 = cid.c_sandstone;
   * 		below_2 = cid.c_sandstone;
   * 	else
   * 		below_1 = cid.c_dirt;
   * 		below_2 = cid.c_stone;
   * 	end
   * 
   * 	-- do terrain blending; target_height has to be calculated based on old_height
   * 	if( target_height == maxp.y and old_height < maxp.y ) then
   * 		local yblend = old_height;
   * 		if blend > 0 then -- leave some cliffs unblended
   * 			yblend = math.floor(vh + blend * (old_height - vh))
   * 			target_height = yblend+1;
   * 		else	
   * 			target_height = old_height;
   * 		end
   * 		for y = math.max( minp.y, yblend), maxp.y do
   * 			if( y<=MG_VILLAGES_WATER_LEVEL ) then
   * 				-- keep ice
   * 				if( data[a:index( x, y, z )] ~= cid.c_ice ) then
   * 					data[a:index( x, y, z)] = cid.c_water;
   * 				end
   * 			else
   * 				data[a:index( x, y, z)] = cid.c_air;
   * 			end
   * 		end
   * 	end
   * 	
   * 	-- only place the surface node if it is actually contained in this node
   * 	if( target_height >= minp.y and target_height < maxp.y ) then
   * 		if( target_height < 1 ) then
   * 			-- no trees or snow below water level
   * 		elseif( tree  and not( mg_villages.ethereal_trees ) and treepos) then
   * 			data[       a:index( x, target_height+1, z)] = cid.c_sapling
   * 			table.insert( treepos, {x=x, y=target_height+1, z=z, typ=0, snow=has_artificial_snow});
   * 		elseif( jtree and not( mg_villages.ethereal_trees ) and treepos) then
   * 			data[       a:index( x, target_height+1, z)] = cid.c_jsapling
   * 			table.insert( treepos, {x=x, y=target_height+1, z=z, typ=1, snow=has_artificial_snow});
   * 		elseif( ptree and not( mg_villages.ethereal_trees ) and treepos) then
   * 			data[       a:index( x, target_height+1, z)] = cid.c_psapling
   * 			table.insert( treepos, {x=x, y=target_height+1, z=z, typ=2, snow=has_artificial_snow});
   * 		elseif( atree and not( mg_villages.ethereal_trees ) and treepos) then
   * 			data[       a:index( x, target_height+1, z)] = cid.c_asapling
   * 			table.insert( treepos, {x=x, y=target_height+1, z=z, typ=3, snow=has_artificial_snow});
   * 		elseif( asptree and not( mg_villages.ethereal_trees ) and treepos) then
   * 			data[       a:index( x, target_height+1, z)] = cid.c_aspsapling
   * 			table.insert( treepos, {x=x, y=target_height+1, z=z, typ=3, snow=has_artificial_snow});
   * 		elseif( has_snow ) then
   * 			data[       a:index( x, target_height+1, z)] = cid.c_snow;
   * 		end
   * 		data[               a:index( x, target_height,   z)] = surface_node;
   * 		if( target_height-1 >= minp.y ) then
   * 			data[       a:index( x, target_height-1, z)] = below_1;
   * 		end
   * 	end
   * 
   * 	-- not every column will get a coal block; some may get two
   * 	local coal_height1 = math.random( minp.y, maxp.y );
   * 	local coal_height2 = math.random( minp.y, maxp.y );
   * 	y = target_height-2;
   * 	while( y > minp.y and y > target_height-40 and y <=maxp.y) do
   * 		local old_node = data[a:index( x, y, z)];
   * 		-- abort as soon as we hit anything other than air
   * 		if( old_node == cid.c_air or old_node == cid.c_water ) then
   * 			-- the occasional coal makes large stone cliffs slightly less boring
   * 			if( y == coal_height1 or y == coal_height2 ) then
   * 				data[a:index( x, y, z )] = cid.c_stone_with_coal;
   * 			else
   * 				data[a:index( x, y, z)] = below_2;
   * 			end
   * 			y = y-1;
   * 		else
   * 			y = minp.y - 1;
   * 		end
   * 	end
   * end */
  lua_pushvalue(L,(lc19 + lc_nextra));
  lua_pushcclosure(L,lcf1_mg_villages_lower_or_raise_terrain_at_point,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"lower_or_raise_terrain_at_point");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- adjust the terrain level to the respective height of the village
   * mg_villages.flatten_village_area = function( villages, minp, maxp, vm, data, param2_data, a, village_area, cid )
   * 	local treepos = {};
   * 	for z = minp.z, maxp.z do
   * 	for x = minp.x, maxp.x do
   * 		for village_nr, village in ipairs(villages) do
   * 			local force_ground = nil;
   * 			local force_underground = nil;
   * 			if( village.village_type
   * 			   and mg_villages.village_type_data[ village.village_type ] 
   * 			   and mg_villages.village_type_data[ village.village_type ].force_ground
   * 			   and mg_villages.village_type_data[ village.village_type ].force_underground ) then
   * 				force_ground      = minetest.get_content_id(mg_villages.village_type_data[ village.village_type ].force_ground);
   * 				force_underground = minetest.get_content_id(mg_villages.village_type_data[ village.village_type ].force_underground);
   * 				if( not( force_ground ) or force_ground < 0 or force_ground == cid.c_ignore 
   * 				   or not( force_underground ) or force_underground < 0 or force_underground == cid.c_ignore ) then
   * 					force_ground = nil;
   * 					force_underground = nil;
   * 				end
   * 			end
   * 			-- is village_nr the village that is the one that is relevant for this spot?
   * 			if(    village_area[ x ][ z ][ 1 ] > 0
   * 			   and village_area[ x ][ z ][ 1 ]==village_nr 
   * 			   and village_area[ x ][ z ][ 2 ]~= 0
   * 			   and data[a:index(x,village.vh,z)] ~= cid.c_ignore) then
   * 
   * 				local has_artificial_snow = false;
   * 				if( village.artificial_snow and village.artificial_snow==1) then
   * 					has_artificial_snow = true;
   * 				end
   * 
   * 				if( village_area[ x ][ z ][ 2 ] > 0 ) then -- inside a village
   * 					mg_villages.lower_or_raise_terrain_at_point( x, z, village.vh, minp, maxp, vm, data, param2_data, a, cid, village.vh,
   * 											nil,     has_artificial_snow, 0, force_ground, force_underground   );
   * 				elseif( mg_villages.ENABLE_TERRAIN_BLEND and village_area[ x ][ z ][ 2 ] < 0) then
   * 					mg_villages.lower_or_raise_terrain_at_point( x, z, maxp.y,     minp, maxp, vm, data, param2_data, a, cid, village.vh,
   * 											treepos, has_artificial_snow, -1* village_area[ x ][ z ][ 2 ],
   * 											force_ground, force_underground);
   * 				end
   * 			end -- PM ^
   * 		end
   * 	end
   * 	end
   * 
   * 	-- grow normal trees and jungletrees in those parts of the terrain where height blending occours
   * 	for _, tree in ipairs(treepos) do
   * 		local plant_id = cid.c_jsapling;
   * 		if( tree.typ == 0 ) then
   * 			plant_id = cid.c_sapling;
   * 		elseif( tree.typ == 2 ) then
   * 			plant_id = cid.c_psapling;
   * 		elseif( tree.typ == 3 ) then
   * 			plant_id = cid.c_asapling;
   * 		end
   * 		mg_villages.grow_a_tree( {x=tree.x, y=tree.y, z=tree.z}, plant_id, minp, maxp, data, a, cid, nil, tree.snow ) -- no pseudorandom present
   * 	end
   * 
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_flatten_village_area);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"flatten_village_area");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- repair mapgen griefings
   * mg_villages.repair_outer_shell = function( villages, minp, maxp, vm, data, param2_data, a, village_area, cid, edge_min, edge_max )
   * 	-- find out if this part of the shell has already been generated or not
   * 	if(    data[a:index(minp.x,minp.y,minp.z)] == cid.c_ignore
   * 
   * 	   and data[a:index(maxp.x,minp.y,minp.z)] == cid.c_ignore
   * 	   and data[a:index(minp.x,maxp.y,minp.z)] == cid.c_ignore
   * 	   and data[a:index(minp.x,minp.y,maxp.z)] == cid.c_ignore
   * 
   * 	   and data[a:index(maxp.x,maxp.y,maxp.z)] == cid.c_ignore
   * 
   * 	   and data[a:index(maxp.x,maxp.y,minp.z)] == cid.c_ignore
   * 	   and data[a:index(maxp.x,minp.y,maxp.z)] == cid.c_ignore
   * 	   and data[a:index(minp.x,maxp.y,maxp.z)] == cid.c_ignore ) then
   * 
   * 		-- no - none of the edges has been created yet; no point to place anything there
   * 		return;
   * 	end
   * 
   * 	if( minp.x < edge_min.x ) then
   * 		edge_min.x = minp.x;
   * 	end
   * 	if( minp.y < edge_min.y ) then
   * 		edge_min.y = minp.y;
   * 	end
   * 	if( minp.z < edge_min.z ) then
   * 		edge_min.z = minp.z;
   * 	end
   * 	if( maxp.x > edge_max.x ) then
   * 		edge_max.x = maxp.x;
   * 	end
   * 	if( maxp.y > edge_max.y ) then
   * 		edge_max.y = maxp.y;
   * 	end
   * 	if( maxp.z > edge_max.z ) then
   * 		edge_max.z = maxp.z;
   * 	end
   * 
   * 
   * 	for z = minp.z, maxp.z do
   * 	for x = minp.x, maxp.x do
   * 		-- inside a village
   * 		if( village_area[ x ][ z ][ 2 ] > 0 ) then
   * 			local y;
   * 			local village = villages[ village_area[ x ][ z ][ 1 ]];
   * 			-- the current node at the ground
   * 			local node    = data[a:index(x,village.vh,z)];
   * 			-- there ought to be something - but there is air
   * 			if( village and village.vh and (node==cid.c_air or node==cid.c_water)) then 
   * 				y = village.vh-1;
   * 				-- search from village height downards for holes generated by cavegen and fill them up
   * 				while( y > minp.y ) do
   * 					local ci = data[a:index(x, y, z)];
   * 					if(     ci == cid.c_desert_stone or ci == cid.c_desert_sand ) then
   * 						data[a:index(x, village.vh, z)] = cid.c_desert_sand;
   * 						y = minp.y-1;
   * 					elseif( ci == cid.c_sand ) then
   * 						data[a:index(x, village.vh, z)] = cid.c_sand;
   * 						y = minp.y-1;
   * 					-- use dirt_with_grass as a fallback
   * 					elseif( ci ~= cid.c_air and ci ~= cid.c_ignore and ci ~= cid.c_water and mg_villages.check_if_ground( ci ) == true) then
   * 						data[a:index(x, village.vh, z)] = cid.c_dirt_with_grass;
   * 						y = minp.y-1;
   * 					-- abort the search - there is no data available yet
   * 					elseif( ci == cid.c_ignore ) then
   * 						y = minp.y-1;
   * 					end
   * 					y = y-1;
   * 				end
   * 			end
   * 					
   * 			-- remove mudflow
   * 			y = village.vh + 1;
   * 			while( y <= maxp.y ) do
   * 				local ci = data[a:index(x, y, z)];
   * 				if( ci ~= cid.c_ignore and (ci==cid.c_dirt or ci==cid.c_dirt_with_grass or ci==cid.c_sand or ci==cid.c_desert_sand)) then
   * 					data[a:index(x,y,z)] = cid.c_air;
   * 				-- if there was a moresnow cover, add a snow on top of the new floor node
   * 				elseif( ci ~= cid.c_ignore
   * 					         and (ci==cid.c_msnow_1 or ci==cid.c_msnow_2 or ci==cid.c_msnow_3 or ci==cid.c_msnow_4 or
   * 					              ci==cid.c_msnow_5 or ci==cid.c_msnow_6 or ci==cid.c_msnow_7 or ci==cid.c_msnow_8 or
   * 					              ci==cid.c_msnow_9 or ci==cid.c_msnow_10 or ci==cid.c_msnow_11)) then
   * 					data[a:index(x, village.vh+1, z)] = cid.c_snow;
   * 					data[a:index(x, village.vh,   z)] = cid.c_dirt_with_snow;
   * 				elseif( ci == cid.c_ignore ) then
   * 					--data[a:index(x,y,z)] = cid.c_air;
   * 				end
   * 				y = y+1;
   * 			end
   * 		end
   * 	end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_repair_outer_shell);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"repair_outer_shell");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- helper functions for mg_villages.place_villages_via_voxelmanip
   * -- this one marks the positions of buildings plus a frame around them 
   * mg_villages.village_area_mark_buildings = function( village_area, village_nr, bpos)
   * 
   * 	-- mark the roads and buildings and the area between buildings in the village_area table
   * 	-- 2: road
   * 	-- 3: border around a road 
   * 	-- 4: building
   * 	-- 5: border around a building
   * 	for _, pos in ipairs( bpos ) do
   * 		local reserved_for = 4; -- a building will be placed here
   * 		if( pos.btype and pos.btype == 'road' ) then
   * 			reserved_for = 2; -- the building will be a road
   * 		end
   * 		-- the building + a border of 1 around it
   * 		for x = -1, pos.bsizex do
   * 			for z = -1, pos.bsizez do
   * 				local p = {x=pos.x+x, z=pos.z+z};
   * 				if( not( village_area[ p.x ] )) then
   * 					village_area[ p.x ] = {};
   * 				end
   * 				if( x==-1 or z==-1 or x==pos.bsizex or z==pos.bsizez ) then
   * 					village_area[ p.x ][ p.z ] = { village_nr, reserved_for+1}; -- border around a building
   * 				else
   * 					village_area[ p.x ][ p.z ] = { village_nr, reserved_for }; -- the actual building
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_village_area_mark_buildings);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_area_mark_buildings");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.village_area_mark_dirt_roads = function( village_area, village_nr, dirt_roads )
   * 	-- mark the dirt roads
   * 	-- 8: dirt road
   * 	for _, pos in ipairs(dirt_roads) do
   * 		-- the building + a border of 1 around it
   * 		for x = 0, pos.bsizex-1 do
   * 			for z = 0, pos.bsizez-1 do
   * 				local p = {x=pos.x+x, z=pos.z+z};
   * 				if( not( village_area[ p.x ] )) then
   * 					village_area[ p.x ] = {};
   * 				end
   * 				village_area[ p.x ][ p.z ] = { village_nr, 8 }; -- the actual dirt road
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_village_area_mark_dirt_roads);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_area_mark_dirt_roads");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.village_area_mark_inside_village_area = function( village_area, villages, village_noise, minp, maxp )
   * 	-- mark the rest ( inside_village but not part of an actual building) as well		 
   * 	for x = minp.x, maxp.x do
   * 		if( not( village_area[ x ] )) then
   * 			village_area[ x ] = {};
   * 		end
   * 		for z = minp.z, maxp.z do
   * 			if( not( village_area[ x ][ z ] )) then
   * 				village_area[ x ][ z ] = { 0, 0 };
   * 
   * 				local n_rawnoise = village_noise:get2d({x = x, y = z}) -- create new blended terrain
   * 				for village_nr, village in ipairs(villages) do
   * 					local vn = mg_villages.get_vn(x, z, n_rawnoise, village);
   * 					if(     village.is_single_house ) then
   * 						-- do nothing here; the village area will be specificly marked later on
   * 
   * 					-- the village core; this is where the houses stand (but there's no house or road at this particular spot)
   * 					elseif( vn <= 40 ) then -- see mg_villages.inside_village
   * 						village_area[ x ][ z ] = { village_nr, 6};
   * 
   * 					-- the flattened land around the village where wheat, cotton, trees or grass may be grown (depending on village type)
   * 					elseif( vn <= 80 ) then -- see mg_villages.inside_village_area
   * 						village_area[ x ][ z ] = { village_nr, 1};
   * 
   * 					-- terrain blending for the flattened land
   * 					elseif( vn <= 160 and mg_villages.ENABLE_TERRAIN_BLEND) then -- see mg_villages.inside_village_terrain_blend_area
   * 						if n_rawnoise > -0.5 then -- leave some cliffs unblended
   * 							local blend = (( vn - 80) / 80) ^ 2 -- 0 at village edge, 1 at normal terrain
   * 							-- assign a negative value to terrain that needs to be adjusted in height
   * 							village_area[ x ][ z ] = { village_nr, -1 * blend};
   * 						else
   * 							-- no height adjustments for this terrain; the terrain is not considered to be part of the village
   * 							village_area[ x ][ z ] = { village_nr, 0};
   * 						end
   * 					end
   * 				end
   * 			end
   * 		end
   * 	end
   * 	
   * 	-- single houses get their own form of terrain blend
   * 	local pr = PseudoRandom(mg_villages.get_bseed(minp));
   * 	for village_nr, village in ipairs( villages ) do
   * 		if( village and village.is_single_house and village.to_add_data and village.to_add_data.bpos and #village.to_add_data.bpos>=1) then
   * 			mg_villages.village_area_mark_single_house_area( village_area, minp, maxp, village.to_add_data.bpos[1], pr, village_nr, village );
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_village_area_mark_inside_village_area);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_area_mark_inside_village_area");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- analyzes optimal height for villages which have their center inside this mapchunk
   * mg_villages.village_area_get_height = function( village_area, villages, minp, maxp, data, param2_data, a, cid )
   * -- figuring out the height this way hardly works - because only a tiny part of the village may be contained in this chunk	
   * 	local height_sum   = {};
   * 	local height_count = {};
   * 	local height_statistic = {};
   * 	-- initialize the variables for counting
   * 	for village_nr, village in ipairs( villages ) do
   * 		height_sum[       village_nr ] = 0;
   * 		height_count[     village_nr ] = 0;
   * 		height_statistic[ village_nr ] = {};
   * 	end
   * 	-- try to find the optimal village height by looking at the borders defined by inside_village
   * 	for x = minp.x+1, maxp.x-1 do
   * 		for z = minp.z+1, maxp.z-1 do
   * 			if(     village_area[ x ][ z ][ 1 ] ~= 0
   *                             and village_area[ x ][ z ][ 2 ] ~= 0
   * 			    and ( village_area[ x+1 ][ z   ][ 2 ] <= 0
   * 			       or village_area[ x-1 ][ z   ][ 2 ] <= 0 
   * 			       or village_area[  x  ][ z+1 ][ 2 ] <= 0 
   * 			       or village_area[  x  ][ z-1 ][ 2 ] <= 0 )
   * 			  -- if the corners of the mapblock are inside the village area, they may count as borders here as well
   * 			  or ( x==minp.x+1 and village_area[ x-1 ][ z   ][ 1 ] >= 0 )
   * 			  or ( x==maxp.x-1 and village_area[ x+1 ][ z   ][ 1 ] >= 0 )
   * 			  or ( z==minp.z-1 and village_area[ x   ][ z-1 ][ 1 ] >= 0 )
   * 			  or ( z==maxp.z+1 and village_area[ x   ][ z+1 ][ 1 ] >= 0 )) then
   * 
   * 				local y = maxp.y;
   * 				while( y > minp.y and y >= 0) do
   * 					local ci = data[a:index(x, y, z)];
   * 					if(( ci ~= cid.c_air and ci ~= cid.c_ignore and mg_villages.check_if_ground( ci ) == true) or (y==0)) then
   * 						local village_nr = village_area[ x ][ z ][ 1 ];
   * 						if( village_nr > 0 and height_sum[ village_nr ] ) then
   * 							height_sum[   village_nr ] = height_sum[   village_nr ] + y;
   * 							height_count[ village_nr ] = height_count[ village_nr ] + 1;
   * 			
   * 							if( not( height_statistic[ village_nr ][ y ] )) then
   * 								height_statistic[ village_nr ][ y ] = 1;
   * 							else
   * 								height_statistic[ village_nr ][ y ] = height_statistic[ village_nr ][ y ] + 1;
   * 							end
   * 						end
   * 						y = minp.y - 1;
   * 					end
   * 					y = y-1;
   * 				end
   * 			end
   * 		end
   * 	end
   * 	for village_nr, village in ipairs( villages ) do
   * 
   * 		local tmin = maxp.y;
   * 		local tmax = minp.y;
   * 		local topt = 2;
   * 		for k,v in pairs( height_statistic[ village_nr ] ) do
   * 			if( k >= 2 and k < tmin and k >= minp.y) then
   * 				tmin = k;
   * 			end
   * 			if( k <= maxp.y and k > tmax ) then
   * 				tmax = k;
   * 			end
   * 			if(    height_statistic[ village_nr ][ topt ] 
   * 			   and height_statistic[ village_nr ][ topt ] < height_statistic[ village_nr ][ k ]) then
   * 				topt = k;
   * 			end
   * 		end
   * 		--print('HEIGHT for village '..tostring( village.name )..' min:'..tostring( tmin )..' max:'..tostring(tmax)..' opt:'..tostring(topt)..' count:'..tostring( height_count[ village_nr ]));
   * 
   * 		-- the very first village gets a height of 1
   * 		if( village.nr and village.nr == 1 ) then
   * 			village.optimal_height = 1;
   * 		end
   * 
   * 		if( village.optimal_height ) then
   * 		-- villages above a size of 40 are *always* place at a convenient height of 1
   * 		elseif( village.vs >= 40 and not(village.is_single_house)) then
   * 			village.optimal_height = 2;
   * 		elseif( village.vs >= 30 and not(village.is_single_house)) then
   * 			village.optimal_height = 41 - village.vs;
   * 		elseif( village.vs >= 25 and not(village.is_single_house)) then
   * 			village.optimal_height = 36 - village.vs;
   * 		
   * 		-- in some cases, choose that height which was counted most often
   * 		elseif( topt and (tmax - tmin ) > 8 and height_count[ village_nr ] > 0) then
   * 
   * 			local qmw;
   * 			if( ( tmax - topt ) > ( topt - tmin )) then
   * 				qmw = tmax;
   * 			else
   * 				qmw = tmin;
   * 			end
   * 			village.optimal_height = qmw;
   * 			
   * 		-- if no border height was found, there'd be no point in calculating anything;
   * 		-- also, this is done only if the village has its center inside this mapchunk	
   * 		elseif(  height_count[ village_nr ] > 0 ) then
   * 
   * 			local max    = 0;
   * 			local target = village.vh;
   * 			local qmw    = 0;
   * 			for k, v in pairs( height_statistic[ village_nr ] ) do
   * 				qmw = qmw + v * (k*k );
   * 				if( v > max ) then
   * 					target = k;
   * 					max    = v;
   * 				end
   * 			end
   * 			if( height_count[ village_nr ] > 5 ) then
   * 				qmw = math.floor( math.sqrt( qmw / height_count[ village_nr ]) +1.5); -- round the value
   * 				-- a height of 0 would be one below water level; so let's choose something higher;
   * 				-- as this may be an island created withhin deep ocean, it might look better if it extends a bit from said ocean
   * 				if( qmw < 1 ) then
   * 					qmw = 2;
   * 				end
   * 			else
   * 				qmw = 0; -- if in doubt, a height of 0 usually works well
   * 			end
   * 
   * 			village.optimal_height = qmw;
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_village_area_get_height);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_area_get_height");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.change_village_height = function( village, new_height )
   * 	mg_villages.print( mg_villages.DEBUG_LEVEL_TIMING, 'CHANGING HEIGHT from '..tostring( village.vh )..' to '..tostring( new_height ));
   * 	for _, pos in ipairs(village.to_add_data.bpos) do
   * 		pos.y = new_height;
   * 	end
   * 	for _, pos in ipairs(village.to_add_data.dirt_roads) do
   * 		pos.y = new_height;
   * 	end
   * 	village.vh = new_height;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_change_village_height);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"change_village_height");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- those functions from the mg mod do not have their own namespace
   * if( minetest.get_modpath( 'mg' )) then */
  enum { lc477 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"mg");
  lua_call(L,1,1);
  const int lc478 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc478) {
    
    /* mg_villages.add_savannatree = add_savannatree */
    lua_getfield(L,LUA_ENVIRONINDEX,"add_savannatree");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"add_savannatree");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* mg_villages.add_pinetree    = add_pinetree */
    lua_getfield(L,LUA_ENVIRONINDEX,"add_pinetree");
    lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
    lua_insert(L,-2);
    lua_pushliteral(L,"add_pinetree");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc477 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.grow_a_tree = function( pos, plant_id, minp, maxp, data, a, cid, pr, snow )
   * 	-- a normal tree; sometimes comes with apples
   * 	if(     plant_id == cid.c_sapling and minetest.registered_nodes[ 'default:tree']) then
   * 		mg_villages.grow_tree(       data, a, pos, math.random(1, 4) == 1, math.random(1,100000), snow)
   * 		return true;
   * 	-- a normal jungletree
   * 	elseif( plant_id == cid.c_jsapling and minetest.registered_nodes[ 'default:jungletree']) then
   * 		mg_villages.grow_jungletree( data, a, pos, math.random(1,100000), snow)
   * 		return true;
   * 	-- a pine tree
   * 	elseif( plant_id == cid.c_psapling and minetest.registered_nodes[ 'default:pine_tree']) then
   * 		mg_villages.grow_pinetree(   data, a, pos, snow);
   * 		return true;
   * 	-- an acacia tree; it does not have its own grow function
   * 	elseif( plant_id == cid.c_asapling and minetest.registered_nodes[ 'default:acacia_tree']) then
   * 		data[ a:index( pos.x, pos.y, pos.z )] = cid.c_asapling;
   * 		return true;
   *         -- aspen tree from newer minetest game
   * 	elseif( plant_id == cid.c_aspsapling and minetest.registered_nodes[ 'default:aspen_tree']) then
   * 		data[ a:index( pos.x, pos.y, pos.z )] = cid.c_aspsapling;
   * 		return true;
   * 	-- a savannatree from the mg mod
   * 	elseif( plant_id == cid.c_savannasapling and mg_villages.add_savannatree) then
   * 		mg_villages.add_savannatree(         data, a, pos.x, pos.y, pos.z, minp, maxp, pr) -- TODO: snow
   * 		return true;
   * 	-- a pine tree from the mg mod
   * 	elseif( plant_id == cid.c_pinesapling    and mg_villages.add_pinetree   ) then
   * 		mg_villages.add_pinetree(            data, a, pos.x, pos.y, pos.z, minp, maxp, pr) -- TODO: snow
   * 		return true;
   * 	end
   * 	return false;
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_grow_a_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_a_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- places trees and plants at empty spaces
   * mg_villages.village_area_fill_with_plants = function( village_area, villages, minp, maxp, data, param2_data, a, cid )
   * 	-- do not place any plants if we are working on the mapchunk above
   * 	if( minp.y > 0 ) then
   * 		return;
   * 	end
   * 	-- trees which require grow functions to be called
   * 	cid.c_savannasapling  = minetest.get_content_id( 'mg:savannasapling');
   * 	cid.c_pinesapling     = minetest.get_content_id( 'mg:pinesapling');
   * 	-- add farmland
   * 	cid.c_wheat           = minetest.get_content_id( 'farming:wheat_8' );
   * 	cid.c_cotton          = minetest.get_content_id( 'farming:cotton_8' );
   * 	cid.c_shrub           = minetest.get_content_id( 'default:dry_shrub');
   * 	-- these extra nodes are used in order to avoid abms on the huge fields around the villages
   * 	cid.c_soil_wet        = minetest.get_content_id( 'mg_villages:soil' ); --'farming:soil_wet' );
   * 	cid.c_soil_sand       = minetest.get_content_id( 'mg_villages:desert_sand_soil'); --'farming:desert_sand_soil_wet' );
   * 	-- desert sand soil is only available in minetest_next
   * 	if( not( cid.c_soil_sand )) then
   * 		cid.c_soil_sand = cid.c_soil_wet;
   * 	end
   * 	local c_feldweg         = minetest.get_content_id( 'cottages:feldweg');
   * 	if( not( c_feldweg )) then
   * 		c_feldweg = cid.c_dirt_with_grass;
   * 	end
   * 
   * 	if( mg_villages.realtest_trees ) then
   * 		cid.c_soil_wet        = minetest.get_content_id( 'farming:soil' ); -- TODO: the one from mg_villages would be better...but that one lacks textures
   * 		cid.c_soil_sand       = minetest.get_content_id( 'farming:soil' ); -- TODO: the one from mg_villages would be better...but that one lacks textures
   * 		cid.c_wheat           = minetest.get_content_id( 'farming:spelt_4' );
   * 		cid.c_cotton          = minetest.get_content_id( 'farming:flax_4' );
   * --		cid.c_shrub           = minetest.get_content_id( 'default:dry_shrub');
   * 	end
   * 
   * 	local pr = PseudoRandom(mg_villages.get_bseed(minp));
   * 	for x = minp.x, maxp.x do
   * 		for z = minp.z, maxp.z do
   * 			-- turn unused land (which is either dirt or desert sand) into a field that grows wheat
   * 			if( village_area[ x ][ z ][ 2 ]==1 
   * 			 or village_area[ x ][ z ][ 2 ]==6) then
   * 
   * 				local village_nr = village_area[ x ][ z ][ 1 ];
   * 				local village    = villages[ village_nr ];
   * 				local h = village.vh;
   * 				local g = data[a:index( x, h, z )];
   * 
   * 				-- choose a plant/tree with a certain chance
   * 				-- Note: There are no checks weather the tree/plant will actually grow there or not;
   * 				--       Tree type is derived from wood type used in the village
   * 				local plant_id = data[a:index( x, h+1, z)];
   * 				local on_soil  = false;
   * 				local plant_selected = false;
   * 				local has_snow_cover = false;
   * 				for _,v in ipairs( village.to_add_data.plantlist ) do
   * 					if( plant_id == cid.c_snow or g==cid.c_dirt_with_snow or g==cid.c_snowblock) then
   * 						has_snow_cover = true;
   * 					end
   * 					-- select the first plant that fits; if the node is not air, keep what is currently inside
   * 					if( (plant_id==cid.c_air or plant_id==cid.c_snow) and (( v.p == 1 or pr:next( 1, v.p )==1 ))) then
   * 						-- TODO: check if the plant grows on that soil
   * 						plant_id = v.id;
   * 						plant_selected = true;
   * 					end
   * 					-- wheat and cotton require soil
   * 					if( plant_id == cid.c_wheat or plant_id == cid.c_cotton ) then
   * 						on_soil = true;
   * 					end
   * 				end
   * 
   * 				local pos = {x=x, y=h+1, z=z};
   * 				if( not( plant_selected )) then -- in case there is something there already (usually a tree trunk)
   * 					has_snow_cover = nil;
   * 
   * 				elseif( mg_villages.grow_a_tree( pos, plant_id, minp, maxp, data, a, cid, pr, has_snow_cover )) then
   * 					param2_data[a:index( x, h+1, z)] = 0; -- make sure the tree trunk is not rotated
   * 					has_snow_cover = nil; -- else the sapling might not grow
   * 					-- nothing to do; the function has grown the tree already
   * 	
   * 				-- grow wheat and cotton on normal wet soil (and re-plant if it had been removed by mudslide)
   * 				elseif( on_soil and (g==cid.c_dirt_with_grass or g==cid.c_soil_wet or g==cid.c_dirt_with_snow)) then	
   * 					-- wheat needs another option there
   * 					if( plant_id == cid.c_wheat ) then
   * 						param2_data[a:index( x, h+1, z)] = 0;
   * 					else
   * 						param2_data[a:index( x, h+1, z)] = math.random( 1, 179 );
   * 					end
   * 					data[a:index( x,  h,   z)] = cid.c_soil_wet;
   * 					-- no plants in winter
   * 					if( has_snow_cover and mg_villages.use_soil_snow) then
   * 						data[a:index( x,  h+1, z)] = cid.c_msnow_soil;
   * 						has_snow_cover = nil;
   * 					else
   * 						data[a:index( x,  h+1, z)] = plant_id;
   * 					end
   * 
   * 				-- grow wheat and cotton on desert sand soil - or on soil previously placed (before mudslide overflew it; same as above)
   * 				elseif( on_soil and (g==cid.c_desert_sand or g==cid.c_soil_sand) and cid.c_soil_sand and cid.c_soil_sand > 0) then
   * 					-- wheat needs another option there
   * 					if( plant_id == cid.c_wheat ) then
   * 						param2_data[a:index( x, h+1, z)] = 0;
   * 					else
   * 						param2_data[a:index( x, h+1, z)] = math.random( 1, 179 );
   * 					end
   * 					data[a:index( x,  h,   z)] = cid.c_soil_sand;
   * 					-- no plants in winter
   * 					if( has_snow_cover and mg_villages.use_soil_snow) then
   * 						data[a:index( x,  h+1, z)] = cid.c_msnow_soil;
   * 						has_snow_cover = nil;
   * 					else
   * 						data[a:index( x,  h+1, z)] = plant_id;
   * 					end
   * 
   * 				elseif( on_soil ) then
   * 					if( math.random(1,5)==1 ) then
   * 						data[a:index( pos.x,  pos.y, pos.z)] = cid.c_shrub;
   * 					end
   * 
   * 				elseif( plant_id ) then -- place the sapling or plant (moretrees uses spawn_tree)
   * 					data[a:index( pos.x,  pos.y, pos.z)] = plant_id;
   * 				end
   * 
   * 				-- put a snow cover on plants where needed
   * 				if( has_snow_cover and cid.c_msnow_1 ~= cid.c_ignore) then
   * 					data[a:index( x,  h+2, z)] = cid.c_msnow_1;
   * 				end
   * 
   * 				-- place a water source now and then so that the fake soil can later be turned into real soil if needed
   * 				if( on_soil and x%3==0 and z%3==0 and h>minp.y) then
   * 					data[a:index( x, h-1, z)] = cid.c_water;
   * 				end
   * 			end
   * 		end
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_village_area_fill_with_plants);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"village_area_fill_with_plants");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* time_elapsed = function( t_last, msg )
   * 	mg_villages.t_now = minetest.get_us_time();
   * 	mg_villages.print( mg_villages.DEBUG_LEVEL_TIMING, 'TIME ELAPSED: '..tostring( mg_villages.t_now - t_last )..' '..msg );
   * 	return mg_villages.t_now;
   * end */
  lua_pushcfunction(L,lcf1_time_elapsed);
  lua_setfield(L,LUA_ENVIRONINDEX,"time_elapsed");
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.save_data = function()
   * 	save_restore.save_data( 'mg_all_villages.data', mg_villages.all_villages );
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_save_data);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"save_data");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* mg_villages.place_villages_via_voxelmanip = function( villages, minp, maxp, vm, data, param2_data, a, top, seed )
   * 	local t1 = minetest.get_us_time();
   * 
   * 	local cid = {}
   * 	cid.c_air    = minetest.get_content_id( 'air' );
   * 	cid.c_ignore = minetest.get_content_id( 'ignore' );
   * 	cid.c_stone  = minetest.get_content_id( 'default:stone');
   * 	cid.c_dirt   = minetest.get_content_id( 'default:dirt');
   * 	cid.c_snow   = minetest.get_content_id( 'default:snow');
   * 	cid.c_snowblock   = minetest.get_content_id( 'default:snowblock');
   * 	cid.c_dirt_with_snow  = minetest.get_content_id( 'default:dirt_with_snow' );
   * 	cid.c_dirt_with_grass = minetest.get_content_id( 'default:dirt_with_grass' );
   * 	cid.c_desert_sand = minetest.get_content_id( 'default:desert_sand' ); -- PM v
   * 	cid.c_desert_stone  = minetest.get_content_id( 'default:desert_stone');
   * 	cid.c_sand = minetest.get_content_id( 'default:sand' ); 
   * 	cid.c_tree = minetest.get_content_id( 'default:tree');
   * 	cid.c_sapling = minetest.get_content_id( 'default:sapling');
   * 	cid.c_jtree = minetest.get_content_id( 'default:jungletree');
   * 	cid.c_jsapling = minetest.get_content_id( 'default:junglesapling');
   * 	cid.c_ptree = minetest.get_content_id( 'default:pine_tree');
   * 	cid.c_psapling = minetest.get_content_id( 'default:pine_sapling');
   * 	cid.c_atree    = minetest.get_content_id( 'default:acacia_tree');
   * 	cid.c_asapling = minetest.get_content_id( 'default:acacia_sapling');
   * 	cid.c_asptree    = minetest.get_content_id( 'default:aspen_tree');
   * 	cid.c_aspsapling = minetest.get_content_id( 'default:aspen_sapling');
   * 	cid.c_water = minetest.get_content_id( 'default:water_source'); -- PM ^
   * 	cid.c_stone_with_coal = minetest.get_content_id( 'default:stone_with_coal');
   * 	cid.c_sandstone       = minetest.get_content_id( 'default:sandstone');
   * 
   * 	cid.c_msnow_1  = minetest.get_content_id( 'moresnow:snow_top' );
   * 	cid.c_msnow_2  = minetest.get_content_id( 'moresnow:snow_fence_top');
   * 	cid.c_msnow_3  = minetest.get_content_id( 'moresnow:snow_stair_top');
   * 	cid.c_msnow_4  = minetest.get_content_id( 'moresnow:snow_slab_top');
   * 	cid.c_msnow_5  = minetest.get_content_id( 'moresnow:snow_panel_top');
   * 	cid.c_msnow_6  = minetest.get_content_id( 'moresnow:snow_micro_top');
   * 	cid.c_msnow_7  = minetest.get_content_id( 'moresnow:snow_outer_stair_top');
   * 	cid.c_msnow_8  = minetest.get_content_id( 'moresnow:snow_inner_stair_top');
   * 	cid.c_msnow_9  = minetest.get_content_id( 'moresnow:snow_ramp_top');	
   * 	cid.c_msnow_10 = minetest.get_content_id( 'moresnow:snow_ramp_outer_top');
   * 	cid.c_msnow_11 = minetest.get_content_id( 'moresnow:snow_ramp_inner_top');
   * 	cid.c_msnow_soil=minetest.get_content_id( 'moresnow:snow_soil' );
   * 
   * 	cid.c_ice      = minetest.get_content_id( 'default:ice' );
   * 
   * 	cid.c_plotmarker = minetest.get_content_id( 'mg_villages:plotmarker');
   * 
   * 	if( minetest.get_modpath('ethereal')) then
   * 		cid.c_ethereal_clay_red    = minetest.get_content_id( 'bakedclay:red' );
   * 		cid.c_ethereal_clay_orange = minetest.get_content_id( 'bakedclay:orange' );
   * 	end
   * 	
   * 
   * 	t1 = time_elapsed( t1, 'defines' );
   * 
   * 	local village_noise = minetest.get_perlin(7635, 3, 0.5, 16);
   * 
   * 	-- determine which coordinates are inside the village and which are not
   * 	local village_area = {};
   * 
   * 	for village_nr, village in ipairs(villages) do
   * 		-- generate the village structure: determine positions of buildings and roads
   * 		mg_villages.generate_village( village, village_noise);
   * 
   * 		if( not( village.is_single_house )) then
   * 			-- only add artificial snow if the village has at least a size of 15 (else it might look too artificial)
   * 			if( not( village.artificial_snow ) and village.vs > 15) then
   * 				if( mg_villages.artificial_snow_probability and math.random( 1, mg_villages.artificial_snow_probability )==1
   * 				    -- forbid artificial snow for some village types
   * 			   	    and not( mg_villages.village_type_data[ village.village_type ].no_snow )
   * 				    and minetest.registered_nodes['default:snow']) then
   * 					village.artificial_snow = 1;
   * 				else
   * 					village.artificial_snow = 0;
   * 				end
   * 			end
   * 	
   * 			-- will set village_area to N where .. is:
   * 			--  2: a building
   * 			--  3: border around a building
   * 			--  4: a road
   * 			--  5: border around a road
   * 			mg_villages.village_area_mark_buildings(   village_area, village_nr, village.to_add_data.bpos );
   * 			-- will set village_area to N where .. is:
   * 			--  8: a dirt road
   * 			mg_villages.village_area_mark_dirt_roads(  village_area, village_nr, village.to_add_data.dirt_roads );
   * 		else -- mark the terrain below single houses
   * 			mg_villages.village_area_mark_buildings(   village_area, village_nr, village.to_add_data.bpos );
   * 		end
   *         end
   * 	t1 = time_elapsed( t1, 'generate_village, mark_buildings and mark_dirt_roads' );
   * 
   * 	local emin;
   * 	local emax;
   * 	-- if no voxelmanip data was passed on, read the data here
   * 	if( not( vm ) or not( a) or not( data ) or not( param2_data ) ) then
   * 		vm, emin, emax = minetest.get_mapgen_object("voxelmanip")
   * 		if( not( vm )) then 
   * 			return;
   * 		end
   * 
   * 		a = VoxelArea:new{
   * 			MinEdge={x=emin.x, y=emin.y, z=emin.z},
   * 			MaxEdge={x=emax.x, y=emax.y, z=emax.z},
   * 		}
   * 
   * 		data = vm:get_data(data);
   * 		param2_data = vm:get_param2_data(param2_data);
   * 	end
   * 	t1 = time_elapsed( t1, 'get_vmap_data' );
   * 
   * 	-- all vm manipulation functions write their content to the *entire* volume/area - including those 16 nodes that
   * 	-- extend into neighbouring mapchunks; thus, cavegen griefing and mudflow can be repaired by placing everythiing again
   * 	local tmin = emin;
   * 	local tmax = emax;
   * 	-- if set to true, cavegen eating through houses and mudflow on roofs will NOT be repaired
   * 	if( not( mg_villages.UNDO_CAVEGEN_AND_MUDFLOW )) then
   * 		tmin = minp;
   * 		tmax = maxp;
   * 	end
   * 	-- will set village_area to N where .. is:
   * 	--  0: not part of any village
   * 	--  1: flattened area around the village; plants (wheat, cotton, trees, grass, ...) may be planted here
   *   	--  6: free/unused spot in the core area of the village where the buildings are
   *         -- negative value: do terrain blending
   * 	mg_villages.village_area_mark_inside_village_area( village_area, villages, village_noise, tmin, tmax );
   * 	t1 = time_elapsed( t1, 'mark_inside_village_area' );
   * 
   * 	-- determine optimal height for all villages that have their center in this mapchunk; sets village.optimal_height
   * 	t1 = time_elapsed( t1, 'get_height' );
   * 
   * 	mg_villages.village_area_get_height( village_area, villages, tmin, tmax, data, param2_data, a, cid );
   * 	-- the villages in the first mapchunk are set to a fixed height of 1 so that players will not end up embedded in stone
   * 	if( not( mg_villages.all_villages ) or mg_villages.anz_villages < 1 ) then
   * 		villages[1].optimal_height = 1;
   * 	end
   * 
   * 
   * 	-- change height of those villages where an optimal_height could be determined
   * 	local village_data_updated = false;
   * 	for _,village in ipairs(villages) do
   * 		if( village.optimal_height and village.optimal_height > 0 and village.optimal_height ~= village.vh ) then
   * 			-- towers are usually found on elevated places
   * 			if( village.village_type == 'tower' ) then
   * 				village.optimal_height = village.optimal_height + math.max( math.floor(village.vs/2), 2 );
   * 			end
   * 			mg_villages.change_village_height( village, village.optimal_height );
   * 			village_data_updated = true;
   * 		end
   * 	end
   * 	t1 = time_elapsed( t1, 'change_height' );
   * 
   * 	--mg_villages.flatten_village_area( villages, minp, maxp, vm, data, param2_data, a, village_area, cid );
   * 	mg_villages.flatten_village_area( villages, tmin, tmax, vm, data, param2_data, a, village_area, cid );
   * 	t1 = time_elapsed( t1, 'flatten_village_area' );
   * 	-- repair cavegen griefings and mudflow which may have happened in the outer shell (which is part of other mapnodes)
   * 	local e1 = {x=minp.x,y=minp.y,z=minp.z};
   * 	local e2 = {x=maxp.x,y=maxp.y,z=maxp.z};
   * 	mg_villages.repair_outer_shell(   villages, {x=tmin.x,   y=tmin.y,z=tmin.z},    {x=tmin.x+16, y=tmax.y, z=tmax.z}, vm, data, param2_data, a, village_area, cid, e1, e2 );
   * 	mg_villages.repair_outer_shell(   villages, {x=tmax.x-16,y=tmin.y,z=tmin.z},    {x=tmax.x,    y=tmax.y, z=tmax.z}, vm, data, param2_data, a, village_area, cid, e1, e2 );
   * 	mg_villages.repair_outer_shell(   villages, {x=tmin.x+16,y=tmin.y,z=tmin.z},    {x=tmax.x-16, y=tmax.y, z=tmin.z+16}, vm, data, param2_data, a, village_area, cid, e1, e2 );
   * 	mg_villages.repair_outer_shell(   villages, {x=tmin.x+16,y=tmin.y,z=tmax.z-16}, {x=tmax.x-16, y=tmax.y, z=tmax.z},    vm, data, param2_data, a, village_area, cid, e1, e2 );
   * --	mg_villages.repair_outer_shell(   villages, tmin, tmax, vm, data, param2_data, a, village_area, cid );
   * 
   * 	t1 = time_elapsed( t1, 'repair_outer_shell' );
   * 
   * 	local c_feldweg =  minetest.get_content_id('cottages:feldweg');
   * 	if( not( c_feldweg )) then
   * 		c_feldweg = minetest.get_content_id('default:cobble');
   * 	end
   * 
   * 	for _, village in ipairs(villages) do
   * 
   * 		-- the village_id will be stored in the plot markers
   * 		local village_id = tostring( village.vx )..':'..tostring( village.vz );
   * 		village.anz_buildings = mg_villages.count_inhabitated_buildings(village);
   * 		village.to_add_data = handle_schematics.place_buildings( village, tmin, tmax, data, param2_data, a, cid, village_id);
   * 
   * 		handle_schematics.place_dirt_roads(                village, tmin, tmax, data, param2_data, a, c_feldweg);
   * 
   * 		-- grow trees which are part of buildings into saplings
   * 		for _,v in ipairs( village.to_add_data.extra_calls.trees ) do
   * 			mg_villages.grow_a_tree( v, v.typ, minp, maxp, data, a, cid, nil, v.snow ); -- TODO: supply pseudorandom value?
   * 		end
   * 	end
   * 	t1 = time_elapsed( t1, 'place_buildings and place_dirt_roads' );
   * 
   * 	mg_villages.village_area_fill_with_plants( village_area, villages, tmin, tmax, data, param2_data, a, cid );
   * 	t1 = time_elapsed( t1, 'fill_with_plants' );
   * 
   * 	if( mg_villages.CREATE_HIGHLANDPOOLS ) then
   * 		mg_villages.do_highlandpools(minp, maxp, seed, vm, a, data, village_area, cid);
   * 	end
   * 	t1 = time_elapsed( t1, 'create highlandpools' );
   * 
   * 	vm:set_data(data)
   * 	vm:set_param2_data(param2_data)
   * 	t1 = time_elapsed( t1, 'vm data set' );
   * 
   * 	-- only update lighting where we actually placed the nodes
   * 	vm:calc_lighting( e1, e2 ); --minp, maxp ); --tmin, tmax)
   * 	t1 = time_elapsed( t1, 'vm calc lighting' );
   * 
   * 	vm:write_to_map(data)
   * 	t1 = time_elapsed( t1, 'vm data written' );
   * 
   * 	vm:update_liquids()
   * 	t1 = time_elapsed( t1, 'vm update liquids' );
   * 
   * 	-- do on_construct calls AFTER the map data has been written - else i.e. realtest fences can not update themshevles
   * 	for _, village in ipairs(villages) do
   * 		for k, v in pairs( village.to_add_data.extra_calls.on_constr ) do
   * 			local node_name = minetest.get_name_from_content_id( k );
   * 			if( minetest.registered_nodes[ node_name ].on_construct ) then
   * 				for _, pos in ipairs(v) do
   * 					minetest.registered_nodes[ node_name ].on_construct( pos );
   * 				end
   * 			end
   * 		end
   * 	end
   * 
   * 	-- the doors need to be adjusted as well
   * 	for _, village in ipairs(villages) do
   * 	  if( village.to_add_data.extra_calls.door_b ) then
   * 		for k, v in pairs( village.to_add_data.extra_calls.door_b ) do
   * 			local meta = minetest.get_meta( v );
   * 
   * 			local l = 2 -- b
   * 			local h = meta:get_int("right") + 1
   * 
   * 			local replace = {
   * 			        { { type = "a", state = 0 }, { type = "a", state = 3 } },
   * 			        { { type = "b", state = 1 }, { type = "b", state = 2 } }
   * 			}
   * 			local new = replace[l][h]
   * --			minetest.swap_node(v, {name = name .. "_" .. new.type, param2 = v.p2})
   * 			meta:set_int("state", new.state)
   * 			-- wipe meta on top node as it's unused
   * 			minetest.set_node({x = v.x, y = v.y + 1, z = v.z}, { name = "doors:hidden" })
   * 		end
   *           end
   * 	end
   * 
   * 
   * 	local pr = PseudoRandom(mg_villages.get_bseed(minp));
   * 	for _, village in ipairs(villages) do
   * 		for _,v in ipairs( village.to_add_data.extra_calls.chests ) do
   * 			local building_nr  = village.to_add_data.bpos[ v.bpos_i ];
   * 			local building_typ = mg_villages.BUILDINGS[ building_nr.btype ].scm;
   * 			mg_villages.fill_chest_random( v, pr, building_nr, building_typ );
   * 		end
   * 	end
   * 	-- TODO: extra_calls.signs
   * 
   * 	
   * 	-- useful for spawning mobs etc.
   * 	for _, village in ipairs(villages) do
   * 		mg_villages.part_of_village_spawned( village, minp, maxp, data, param2_data, a, cid );
   * 	end
   * 
   * 	-- initialize the pseudo random generator so that the chests will be filled in a reproducable pattern
   * 	local meta
   * 	for _, village in ipairs(villages) do
   * 		-- now add those buildings which are .mts files and need to be placed by minetest.place_schematic(...)
   * 		-- place_schematics is no longer needed	
   * 		--mg_villages.place_schematics( village.to_add_data.bpos, village.to_add_data.replacements, a, pr );
   * 		--t1 = time_elapsed( t1, 'place_schematics' );
   * 
   * 		if( not( mg_villages.all_villages )) then
   * 			mg_villages.all_villages = {};
   * 		end
   * 		-- unique id - there can only be one village at a given pair of x,z coordinates
   * 		local village_id = tostring( village.vx )..':'..tostring( village.vz );	
   * 		-- the village data is saved only once per village - and not whenever part of the village is generated
   * 		if( not( mg_villages.all_villages[ village_id ])) then
   * 
   * 			-- count how many villages we already have and assign each village a uniq number
   * 			local count = 1;
   * 			for _,v in pairs( mg_villages.all_villages ) do
   * 				count = count + 1;
   * 			end
   * 			village.extra_calls = {}; -- do not save these values
   * 			village.nr = count;
   * 			mg_villages.anz_villages = count;
   * 			mg_villages.all_villages[ village_id ] = minetest.deserialize( minetest.serialize( village ));
   * 
   * 			mg_villages.print( mg_villages.DEBUG_LEVEL_NORMAL, "Village No. "..tostring( count ).." of type \'"..
   * 					tostring( village.village_type ).."\' of size "..tostring( village.vs )..
   * 					" spawned at: x = "..village.vx..", z = "..village.vz)
   * 			village_data_updated = true;
   * 
   * 			-- hook for doing stuff that needs to be done exactly once per village
   * 			mg_villages.new_village_spawned( village_id );
   * 		end
   * 	end
   * 	-- always save the changed village data
   * 	t1 = time_elapsed( t1, 'update village data' );
   * 	mg_villages.save_data();
   * 	t1 = time_elapsed( t1, 'save village data' );
   * 
   * end */
  lua_pushcfunction(L,lcf1_mg_villages_place_villages_via_voxelmanip);
  lua_getfield(L,LUA_ENVIRONINDEX,"mg_villages");
  lua_insert(L,-2);
  lua_pushliteral(L,"place_villages_via_voxelmanip");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* --minetest.set_gen_notify('dungeon, temple, cave_begin, cave_end, large_cave_begin, large_cave_end',{});
   * -- the actual mapgen
   * -- It only does changes if there is at least one village in the area that is to be generated.
   * minetest.register_on_generated(function(minp, maxp, seed)
   * -- this is just for learning more about dungeons and caves; it is not used anywhere here
   * --	local structures = minetest.get_mapgen_object('gennotify');
   * --	print('STRUCTURES BY MAPGEN: '..minetest.serialize( structures ));
   * 
   * 	-- only generate village on the surface chunks
   * 	if( minp.y < -32 or minp.y > mg_villages.MAX_HEIGHT_TREATED) then --64
   * 		return;
   * 	end
   * 	
   * 	-- this function has to be called ONCE and AFTER all village types and buildings have been added
   * 	-- (which might have been done by other mods so we can't do this earlier)
   * 	if( not( mg_villages.village_types )) then
   * 		mg_villages.init_weights();
   * 	end
   * 
   * 
   * 	local villages = {};
   * 	-- create normal villages
   * 	if( mg_villages.ENABLE_VILLAGES == true ) then
   * 		villages = mg_villages.villages_in_mapchunk( minp, maxp.x-minp.x+1 );
   * 	end
   * 
   * 	-- if this mapchunk contains no part of a village, probably a lone building may be found in it
   * 	if( mg_villages.INVERSE_HOUSE_DENSITY > 0 ) then
   * 		villages = mg_villages.houses_in_mapchunk(   minp, maxp.x-minp.x+1, villages );
   * 	end
   * 
   * 	-- check if the village exists already
   * 	local v_nr = 1;
   * 	for v_nr, village in ipairs(villages) do
   * 		local village_id = tostring( village.vx )..':'..tostring( village.vz );
   * 
   * 		if( not( village.name ) or village.name == '') then
   * 			village.name = 'unknown';
   * 		end
   * 
   * 		if( mg_villages.all_villages and mg_villages.all_villages[ village_id ]) then
   * 			villages[ v_nr ] = mg_villages.all_villages[ village_id ];
   * 		end
   * 	end
   * 
   * 	if( villages and #villages > 0 ) then
   * 		mg_villages.place_villages_via_voxelmanip( villages, minp, maxp, nil, data_vm, data_param2_data, nil, nil, seed );
   * 	end
   * end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_on_generated");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushcfunction(L,lcf652);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_mg_villages_mapgen(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}



