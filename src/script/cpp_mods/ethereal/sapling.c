/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: ethereal.register_sapling
 * function(name, desc, texture, height) */
static int lcf1_ethereal_register_sapling (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* minetest.register_node(name .. "_sapling", {
   * 		description = S(desc .. " Tree Sapling"),
   * 		drawtype = "plantlike",
   * 		visual_scale = 1.0,
   * 		tiles = {texture .. ".png"},
   * 		inventory_image = texture .. ".png",
   * 		wield_image = texture .. ".png",
   * 		paramtype = "light",
   * 		sunlight_propagates = true,
   * 		is_ground_content = false,
   * 		walkable = false,
   * 		selection_box = {
   * 			type = "fixed",
   * 			fixed = {-0.5, -0.5, -0.5, 0.5, -5/16, 0.5}
   * 		},
   * 		groups = {
   * 			snappy = 2, dig_immediate = 3, flammable = 2,
   * 			ethereal_sapling = 1, sapling = 1, attached_node = 1
   * 		},
   * 		sounds = default.node_sound_defaults(),
   * 		grown_height = height,
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushliteral(L,"_sapling");
  lua_concat(L,2);
  lua_createtable(L,0,14);
  lua_pushliteral(L,"description");
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  lua_pushvalue(L,2);
  lua_pushliteral(L," Tree Sapling");
  lua_concat(L,2);
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"plantlike");
  lua_rawset(L,-3);
  lua_pushliteral(L,"visual_scale");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushvalue(L,3);
  lua_pushliteral(L,".png");
  lua_concat(L,2);
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushvalue(L,3);
  lua_pushliteral(L,".png");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"wield_image");
  lua_pushvalue(L,3);
  lua_pushliteral(L,".png");
  lua_concat(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sunlight_propagates");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"selection_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,-0.3125);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"snappy");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dig_immediate");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"flammable");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"ethereal_sapling");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sapling");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"attached_node");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"grown_height");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: ethereal.add_tree
 * function (pos, ofx, ofy, ofz, schem) */
static int lcf1_ethereal_add_tree (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* -- check for schematic
   * if not schem then */
  enum { lc2 = 5 };
  lua_pushboolean(L,!(lua_toboolean(L,5)));
  const int lc3 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc3) {
    
    /* print (S("Schematic not found")) */
    lua_getfield(L,LUA_ENVIRONINDEX,"print");
    const int lc4 = lua_gettop(L);
    lc_getupvalue(L,lua_upvalueindex(1),0,1);
    lua_pushliteral(L,"Schematic not found");
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc4),0);
    assert(lua_gettop(L) == 5);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc2);
  assert(lua_gettop(L) == 5);
  
  /* -- remove sapling and place schematic
   * minetest.swap_node(pos, {name = "air"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"swap_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"air");
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 5);
  
  /* minetest.place_schematic(
   * 		{x = pos.x - ofx, y = pos.y - ofy, z = pos.z - ofz},
   * 		schem, 0, nil, false) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"place_schematic");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lc_sub(L,-1,2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_sub(L,-1,3);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lc_sub(L,-1,4);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushvalue(L,5);
  lua_pushnumber(L,0);
  lua_pushnil(L);
  lua_pushboolean(L,0);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: ethereal.grow_yellow_tree
 * function(pos) */
static int lcf1_ethereal_grow_yellow_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 4, 0, 4, path .. "yellowtree.mts") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_pushnumber(L,4);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"yellowtree.mts");
  lua_concat(L,2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_big_tree
 * function(pos) */
static int lcf1_ethereal_grow_big_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 4, 0, 4, path .. "bigtree.mts") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_pushnumber(L,4);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"bigtree.mts");
  lua_concat(L,2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_banana_tree
 * function(pos) */
static int lcf1_ethereal_grow_banana_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 3, 0, 3, ethereal.bananatree) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,3);
  lua_pushnumber(L,0);
  lua_pushnumber(L,3);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"bananatree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_frost_tree
 * function(pos) */
static int lcf1_ethereal_grow_frost_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 4, 0, 4, path .. "frosttrees.mts") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_pushnumber(L,4);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"frosttrees.mts");
  lua_concat(L,2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_mushroom_tree
 * function(pos) */
static int lcf1_ethereal_grow_mushroom_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 4, 0, 4, path .. "mushroomone.mts") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_pushnumber(L,4);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"mushroomone.mts");
  lua_concat(L,2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_palm_tree
 * function(pos) */
static int lcf1_ethereal_grow_palm_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 4, 0, 4, path .. "palmtree.mts") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,4);
  lua_pushnumber(L,0);
  lua_pushnumber(L,4);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"palmtree.mts");
  lua_concat(L,2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_willow_tree
 * function(pos) */
static int lcf1_ethereal_grow_willow_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 5, 0, 5, path .. "willow.mts") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,5);
  lua_pushnumber(L,0);
  lua_pushnumber(L,5);
  lc_getupvalue(L,lua_upvalueindex(1),0,2);
  lua_pushliteral(L,"willow.mts");
  lua_concat(L,2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_redwood_tree
 * function(pos) */
static int lcf1_ethereal_grow_redwood_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if math.random(1, 2) == 1 then */
  enum { lc6 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,2);
  lua_call(L,2,1);
  lua_pushnumber(L,1);
  const int lc7 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc7);
  const int lc8 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc8) {
    
    /* ethereal.add_tree(pos, 9, 3, 9, path .. "redwood.mts") */
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"add_tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushnumber(L,9);
    lua_pushnumber(L,3);
    lua_pushnumber(L,9);
    lc_getupvalue(L,lua_upvalueindex(1),0,2);
    lua_pushliteral(L,"redwood.mts");
    lua_concat(L,2);
    lua_call(L,5,0);
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* else
     * ethereal.add_tree(pos, 8, 6, 8, path .. "redwood_tree.mts") */
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"add_tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushnumber(L,8);
    lua_pushnumber(L,6);
    lua_pushnumber(L,8);
    lc_getupvalue(L,lua_upvalueindex(1),0,2);
    lua_pushliteral(L,"redwood_tree.mts");
    lua_concat(L,2);
    lua_call(L,5,0);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_orange_tree
 * function(pos) */
static int lcf1_ethereal_grow_orange_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 1, 0, 1, ethereal.orangetree) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,1);
  lua_pushnumber(L,0);
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"orangetree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_bamboo_tree
 * function(pos) */
static int lcf1_ethereal_grow_bamboo_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 1, 0, 1, ethereal.bambootree) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,1);
  lua_pushnumber(L,0);
  lua_pushnumber(L,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"bambootree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: ethereal.grow_birch_tree
 * function(pos) */
static int lcf1_ethereal_grow_birch_tree (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ethereal.add_tree(pos, 2, 0, 2, ethereal.birchtree) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"add_tree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,2);
  lua_pushnumber(L,0);
  lua_pushnumber(L,2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"birchtree");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,5,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: enough_height
 * function(pos, height) */
static int lcf1_enough_height (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local nod = minetest.line_of_sight(
   * 		{x = pos.x, y = pos.y + 1, z = pos.z},
   * 		{x = pos.x, y = pos.y + height, z = pos.z}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"line_of_sight");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 3);
  
  /* if not nod then */
  enum { lc10 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc11 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc11) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: ethereal.grow_sapling
 * function (pos, node) */
static int lcf1_ethereal_grow_sapling (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local under =  minetest.get_node({
   * 		x = pos.x,
   * 		y = pos.y - 1,
   * 		z = pos.z
   * 	}).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* if not minetest.registered_nodes[node.name] then */
  enum { lc12 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc13 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc13) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc12);
  assert(lua_gettop(L) == 3);
  
  /* local height = minetest.registered_nodes[node.name].grown_height */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"grown_height");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* -- do we have enough height to grow sapling into tree?
   * if not height or not enough_height(pos, height) then */
  enum { lc14 = 4 };
  lua_pushboolean(L,!(lua_toboolean(L,4)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,3);
    lua_pushvalue(L,1);
    lua_pushvalue(L,4);
    lua_call(L,2,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc15 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc15) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc14);
  assert(lua_gettop(L) == 4);
  
  /* -- Check if Ethereal Sapling is growing on correct substrate
   * if node.name == "ethereal:yellow_tree_sapling"
   * 	and under == "default:dirt_with_snow" then */
  enum { lc16 = 4 };
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_pushliteral(L,"ethereal:yellow_tree_sapling");
  const int lc17 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc17);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,3);
    lua_pushliteral(L,"default:dirt_with_snow");
    const int lc18 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc18);
  }
  const int lc19 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc19) {
    
    /* ethereal.grow_yellow_tree(pos) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"grow_yellow_tree");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* elseif node.name == "ethereal:big_tree_sapling"
     * 	and under == "ethereal:green_dirt" then */
    enum { lc20 = 4 };
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"ethereal:big_tree_sapling");
    const int lc21 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc21);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,3);
      lua_pushliteral(L,"ethereal:green_dirt");
      const int lc22 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc22);
    }
    const int lc23 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc23) {
      
      /* ethereal.grow_big_tree(pos) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
      lua_pushliteral(L,"grow_big_tree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* elseif node.name == "ethereal:banana_tree_sapling"
       * 	and under == "ethereal:grove_dirt" then */
      enum { lc24 = 4 };
      lua_pushliteral(L,"name");
      lua_gettable(L,2);
      lua_pushliteral(L,"ethereal:banana_tree_sapling");
      const int lc25 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc25);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,3);
        lua_pushliteral(L,"ethereal:grove_dirt");
        const int lc26 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc26);
      }
      const int lc27 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc27) {
        
        /* ethereal.grow_banana_tree(pos) */
        lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
        lua_pushliteral(L,"grow_banana_tree");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 4);
      }
      else {
        
        /* elseif node.name == "ethereal:frost_tree_sapling"
         * 	and under == "ethereal:crystal_dirt" then */
        enum { lc28 = 4 };
        lua_pushliteral(L,"name");
        lua_gettable(L,2);
        lua_pushliteral(L,"ethereal:frost_tree_sapling");
        const int lc29 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc29);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,3);
          lua_pushliteral(L,"ethereal:crystal_dirt");
          const int lc30 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc30);
        }
        const int lc31 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc31) {
          
          /* ethereal.grow_frost_tree(pos) */
          lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
          lua_pushliteral(L,"grow_frost_tree");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 4);
        }
        else {
          
          /* elseif node.name == "ethereal:mushroom_sapling"
           * 	and under == "ethereal:mushroom_dirt" then */
          enum { lc32 = 4 };
          lua_pushliteral(L,"name");
          lua_gettable(L,2);
          lua_pushliteral(L,"ethereal:mushroom_sapling");
          const int lc33 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc33);
          if (lua_toboolean(L,-1)) {
            lua_pop(L,1);
            lua_pushvalue(L,3);
            lua_pushliteral(L,"ethereal:mushroom_dirt");
            const int lc34 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc34);
          }
          const int lc35 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc35) {
            
            /* ethereal.grow_mushroom_tree(pos) */
            lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
            lua_pushliteral(L,"grow_mushroom_tree");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,1);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 4);
          }
          else {
            
            /* elseif node.name == "ethereal:palm_sapling"
             * 	and under == "default:sand" then */
            enum { lc36 = 4 };
            lua_pushliteral(L,"name");
            lua_gettable(L,2);
            lua_pushliteral(L,"ethereal:palm_sapling");
            const int lc37 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc37);
            if (lua_toboolean(L,-1)) {
              lua_pop(L,1);
              lua_pushvalue(L,3);
              lua_pushliteral(L,"default:sand");
              const int lc38 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc38);
            }
            const int lc39 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc39) {
              
              /* ethereal.grow_palm_tree(pos) */
              lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
              lua_pushliteral(L,"grow_palm_tree");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,1);
              lua_call(L,1,0);
              assert(lua_gettop(L) == 4);
            }
            else {
              
              /* elseif node.name == "ethereal:willow_sapling"
               * 	and under == "ethereal:gray_dirt" then */
              enum { lc40 = 4 };
              lua_pushliteral(L,"name");
              lua_gettable(L,2);
              lua_pushliteral(L,"ethereal:willow_sapling");
              const int lc41 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc41);
              if (lua_toboolean(L,-1)) {
                lua_pop(L,1);
                lua_pushvalue(L,3);
                lua_pushliteral(L,"ethereal:gray_dirt");
                const int lc42 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc42);
              }
              const int lc43 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc43) {
                
                /* ethereal.grow_willow_tree(pos) */
                lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                lua_pushliteral(L,"grow_willow_tree");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,1);
                lua_call(L,1,0);
                assert(lua_gettop(L) == 4);
              }
              else {
                
                /* elseif node.name == "ethereal:redwood_sapling"
                 * 	and under == "bakedclay:red" then */
                enum { lc44 = 4 };
                lua_pushliteral(L,"name");
                lua_gettable(L,2);
                lua_pushliteral(L,"ethereal:redwood_sapling");
                const int lc45 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc45);
                if (lua_toboolean(L,-1)) {
                  lua_pop(L,1);
                  lua_pushvalue(L,3);
                  lua_pushliteral(L,"bakedclay:red");
                  const int lc46 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc46);
                }
                const int lc47 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc47) {
                  
                  /* ethereal.grow_redwood_tree(pos) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                  lua_pushliteral(L,"grow_redwood_tree");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,1);
                  lua_call(L,1,0);
                  assert(lua_gettop(L) == 4);
                }
                else {
                  
                  /* elseif node.name == "ethereal:orange_tree_sapling"
                   * 	and under == "ethereal:prairie_dirt" then */
                  enum { lc48 = 4 };
                  lua_pushliteral(L,"name");
                  lua_gettable(L,2);
                  lua_pushliteral(L,"ethereal:orange_tree_sapling");
                  const int lc49 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc49);
                  if (lua_toboolean(L,-1)) {
                    lua_pop(L,1);
                    lua_pushvalue(L,3);
                    lua_pushliteral(L,"ethereal:prairie_dirt");
                    const int lc50 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc50);
                  }
                  const int lc51 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc51) {
                    
                    /* ethereal.grow_orange_tree(pos) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                    lua_pushliteral(L,"grow_orange_tree");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,1);
                    lua_call(L,1,0);
                    assert(lua_gettop(L) == 4);
                  }
                  else {
                    
                    /* elseif node.name == "ethereal:bamboo_sprout"
                     * 	and under == "ethereal:bamboo_dirt" then */
                    enum { lc52 = 4 };
                    lua_pushliteral(L,"name");
                    lua_gettable(L,2);
                    lua_pushliteral(L,"ethereal:bamboo_sprout");
                    const int lc53 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc53);
                    if (lua_toboolean(L,-1)) {
                      lua_pop(L,1);
                      lua_pushvalue(L,3);
                      lua_pushliteral(L,"ethereal:bamboo_dirt");
                      const int lc54 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc54);
                    }
                    const int lc55 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc55) {
                      
                      /* ethereal.grow_bamboo_tree(pos) */
                      lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                      lua_pushliteral(L,"grow_bamboo_tree");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_pushvalue(L,1);
                      lua_call(L,1,0);
                      assert(lua_gettop(L) == 4);
                    }
                    else {
                      
                      /* elseif node.name == "ethereal:birch_sapling"
                       * 	and under == "ethereal:green_dirt" then */
                      enum { lc56 = 4 };
                      lua_pushliteral(L,"name");
                      lua_gettable(L,2);
                      lua_pushliteral(L,"ethereal:birch_sapling");
                      const int lc57 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc57);
                      if (lua_toboolean(L,-1)) {
                        lua_pop(L,1);
                        lua_pushvalue(L,3);
                        lua_pushliteral(L,"ethereal:green_dirt");
                        const int lc58 = lua_equal(L,-2,-1);
                        lua_pop(L,2);
                        lua_pushboolean(L,lc58);
                      }
                      const int lc59 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc59) {
                        
                        /* ethereal.grow_birch_tree(pos) */
                        lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                        lua_pushliteral(L,"grow_birch_tree");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_pushvalue(L,1);
                        lua_call(L,1,0);
                        assert(lua_gettop(L) == 4);
                      }
                      lua_settop(L,lc56);
                    }
                    lua_settop(L,lc52);
                  }
                  lua_settop(L,lc48);
                }
                lua_settop(L,lc44);
              }
              lua_settop(L,lc40);
            }
            lua_settop(L,lc36);
          }
          lua_settop(L,lc32);
        }
        lua_settop(L,lc28);
      }
      lua_settop(L,lc24);
    }
    lua_settop(L,lc20);
  }
  lua_settop(L,lc16);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* function(pos, node) */
static int lcf63 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local light_level = minetest.get_node_light(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_light");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if not light_level or light_level < 13 then */
  enum { lc60 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,13);
    const int lc61 = lua_lessthan(L,3,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc61);
  }
  const int lc62 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc62) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc60);
  assert(lua_gettop(L) == 3);
  
  /* ethereal.grow_sapling(pos, node) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"grow_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local S = ethereal.intllib */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"intllib");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Bamboo Sprout
   * minetest.register_node("ethereal:bamboo_sprout", {
   * 	description = S("Bamboo Sprout"),
   * 	drawtype = "plantlike",
   * 	tiles = {"bamboo_sprout.png"},
   * 	inventory_image = "bamboo_sprout.png",
   * 	wield_image = "bamboo_sprout.png",
   * 	paramtype = "light",
   * 	sunlight_propagates = true,
   * 	walkable = false,
   * 	groups = {
   * 		snappy = 3, attached_node = 1, flammable = 2,
   * 		dig_immediate = 3, ethereal_sapling = 1
   * 	},
   * 	sounds = default.node_sound_defaults(),
   * 	selection_box = {
   * 		type = "fixed",
   * 		fixed = {-0.5, -0.5, -0.5, 0.5, -5/16, 0.5},
   * 	},
   * 	on_use = minetest.item_eat(-2),
   * 	grown_height = 11,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:bamboo_sprout");
  lua_createtable(L,0,13);
  lua_pushliteral(L,"description");
  lc_getupvalue(L,(lc1 + lc_nextra),0,1);
  lua_pushliteral(L,"Bamboo Sprout");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"plantlike");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"bamboo_sprout.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushliteral(L,"bamboo_sprout.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wield_image");
  lua_pushliteral(L,"bamboo_sprout.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sunlight_propagates");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,5);
  lua_pushliteral(L,"snappy");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"attached_node");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"flammable");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dig_immediate");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"ethereal_sapling");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"selection_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,-0.3125);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_use");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"item_eat");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,-2);
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"grown_height");
  lua_pushnumber(L,11);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Register Saplings
   * ethereal.register_sapling = function(name, desc, texture, height)
   * 
   * 	minetest.register_node(name .. "_sapling", {
   * 		description = S(desc .. " Tree Sapling"),
   * 		drawtype = "plantlike",
   * 		visual_scale = 1.0,
   * 		tiles = {texture .. ".png"},
   * 		inventory_image = texture .. ".png",
   * 		wield_image = texture .. ".png",
   * 		paramtype = "light",
   * 		sunlight_propagates = true,
   * 		is_ground_content = false,
   * 		walkable = false,
   * 		selection_box = {
   * 			type = "fixed",
   * 			fixed = {-0.5, -0.5, -0.5, 0.5, -5/16, 0.5}
   * 		},
   * 		groups = {
   * 			snappy = 2, dig_immediate = 3, flammable = 2,
   * 			ethereal_sapling = 1, sapling = 1, attached_node = 1
   * 		},
   * 		sounds = default.node_sound_defaults(),
   * 		grown_height = height,
   * 	})
   * end */
  lua_pushvalue(L,(lc1 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_register_sapling,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"register_sapling");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:willow", "Willow", "willow_sapling", 14) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:willow");
  lua_pushliteral(L,"Willow");
  lua_pushliteral(L,"willow_sapling");
  lua_pushnumber(L,14);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:yellow_tree", "Healing", "yellow_tree_sapling", 19) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:yellow_tree");
  lua_pushliteral(L,"Healing");
  lua_pushliteral(L,"yellow_tree_sapling");
  lua_pushnumber(L,19);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:big_tree", "Big", "ethereal_big_tree_sapling", 7) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:big_tree");
  lua_pushliteral(L,"Big");
  lua_pushliteral(L,"ethereal_big_tree_sapling");
  lua_pushnumber(L,7);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:banana_tree", "Banana", "banana_tree_sapling", 8) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:banana_tree");
  lua_pushliteral(L,"Banana");
  lua_pushliteral(L,"banana_tree_sapling");
  lua_pushnumber(L,8);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:frost_tree", "Frost", "ethereal_frost_tree_sapling", 19) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:frost_tree");
  lua_pushliteral(L,"Frost");
  lua_pushliteral(L,"ethereal_frost_tree_sapling");
  lua_pushnumber(L,19);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:mushroom", "Mushroom", "ethereal_mushroom_sapling", 11) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:mushroom");
  lua_pushliteral(L,"Mushroom");
  lua_pushliteral(L,"ethereal_mushroom_sapling");
  lua_pushnumber(L,11);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:palm", "Palm", "moretrees_palm_sapling", 9) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:palm");
  lua_pushliteral(L,"Palm");
  lua_pushliteral(L,"moretrees_palm_sapling");
  lua_pushnumber(L,9);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:redwood", "Redwood", "redwood_sapling", 31) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:redwood");
  lua_pushliteral(L,"Redwood");
  lua_pushliteral(L,"redwood_sapling");
  lua_pushnumber(L,31);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:orange_tree", "Orange", "orange_tree_sapling", 6) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:orange_tree");
  lua_pushliteral(L,"Orange");
  lua_pushliteral(L,"orange_tree_sapling");
  lua_pushnumber(L,6);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.register_sapling("ethereal:birch", "Birch", "moretrees_birch_sapling", 7) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"register_sapling");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:birch");
  lua_pushliteral(L,"Birch");
  lua_pushliteral(L,"moretrees_birch_sapling");
  lua_pushnumber(L,7);
  lua_call(L,4,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* ethereal.add_tree = function (pos, ofx, ofy, ofz, schem)
   * 	-- check for schematic
   * 	if not schem then
   * 		print (S("Schematic not found"))
   * 		return
   * 	end
   * 	-- remove sapling and place schematic
   * 	minetest.swap_node(pos, {name = "air"})
   * 	minetest.place_schematic(
   * 		{x = pos.x - ofx, y = pos.y - ofy, z = pos.z - ofz},
   * 		schem, 0, nil, false)
   * end */
  lua_pushvalue(L,(lc1 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_add_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"add_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local path = minetest.get_modpath("ethereal").."/schematics/" */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc5 = 2 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal");
  lua_call(L,1,1);
  lua_pushliteral(L,"/schematics/");
  lua_concat(L,2);
  lua_rawseti(L,(lc5 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- grow tree functions
   * function ethereal.grow_yellow_tree(pos)
   * 	ethereal.add_tree(pos, 4, 0, 4, path .. "yellowtree.mts")
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_yellow_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_yellow_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_big_tree(pos)
   * 	ethereal.add_tree(pos, 4, 0, 4, path .. "bigtree.mts")
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_big_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_big_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_banana_tree(pos)
   * 	ethereal.add_tree(pos, 3, 0, 3, ethereal.bananatree)
   * end */
  lua_pushcfunction(L,lcf1_ethereal_grow_banana_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_banana_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_frost_tree(pos)
   * 	ethereal.add_tree(pos, 4, 0, 4, path .. "frosttrees.mts")
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_frost_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_frost_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_mushroom_tree(pos)
   * 	ethereal.add_tree(pos, 4, 0, 4, path .. "mushroomone.mts")
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_mushroom_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_mushroom_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_palm_tree(pos)
   * 	ethereal.add_tree(pos, 4, 0, 4, path .. "palmtree.mts")
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_palm_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_palm_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_willow_tree(pos)
   * 	ethereal.add_tree(pos, 5, 0, 5, path .. "willow.mts")
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_willow_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_willow_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_redwood_tree(pos)
   * 	if math.random(1, 2) == 1 then
   * 		ethereal.add_tree(pos, 9, 3, 9, path .. "redwood.mts") -- shinji
   * 	else
   * 		ethereal.add_tree(pos, 8, 6, 8, path .. "redwood_tree.mts") -- iska
   * 	end
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_redwood_tree,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_redwood_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_orange_tree(pos)
   * 	ethereal.add_tree(pos, 1, 0, 1, ethereal.orangetree)
   * end */
  lua_pushcfunction(L,lcf1_ethereal_grow_orange_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_orange_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_bamboo_tree(pos)
   * 	ethereal.add_tree(pos, 1, 0, 1, ethereal.bambootree)
   * end */
  lua_pushcfunction(L,lcf1_ethereal_grow_bamboo_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_bamboo_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function ethereal.grow_birch_tree(pos)
   * 	ethereal.add_tree(pos, 2, 0, 2, ethereal.birchtree)
   * end */
  lua_pushcfunction(L,lcf1_ethereal_grow_birch_tree);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_birch_tree");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- check if sapling has enough height room to grow
   * local function enough_height(pos, height)
   * 
   * 	local nod = minetest.line_of_sight(
   * 		{x = pos.x, y = pos.y + 1, z = pos.z},
   * 		{x = pos.x, y = pos.y + height, z = pos.z})
   * 
   * 	if not nod then
   * 		return false -- obstructed
   * 	else
   * 		return true -- can grow
   * 	end
   * end */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc9 = 3 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_pushcfunction(L,lcf1_enough_height);
  lua_rawseti(L,(lc9 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* ethereal.grow_sapling = function (pos, node)
   * 
   * 	local under =  minetest.get_node({
   * 		x = pos.x,
   * 		y = pos.y - 1,
   * 		z = pos.z
   * 	}).name
   * 
   * 	if not minetest.registered_nodes[node.name] then
   * 		return
   * 	end
   * 
   * 	local height = minetest.registered_nodes[node.name].grown_height
   * 
   * 	-- do we have enough height to grow sapling into tree?
   * 	if not height or not enough_height(pos, height) then
   * 		return
   * 	end
   * 
   * 	-- Check if Ethereal Sapling is growing on correct substrate
   * 	if node.name == "ethereal:yellow_tree_sapling"
   * 	and under == "default:dirt_with_snow" then
   * 		ethereal.grow_yellow_tree(pos)
   * 
   * 	elseif node.name == "ethereal:big_tree_sapling"
   * 	and under == "ethereal:green_dirt" then
   * 		ethereal.grow_big_tree(pos)
   * 
   * 	elseif node.name == "ethereal:banana_tree_sapling"
   * 	and under == "ethereal:grove_dirt" then
   * 		ethereal.grow_banana_tree(pos)
   * 
   * 	elseif node.name == "ethereal:frost_tree_sapling"
   * 	and under == "ethereal:crystal_dirt" then
   * 		ethereal.grow_frost_tree(pos)
   * 
   * 	elseif node.name == "ethereal:mushroom_sapling"
   * 	and under == "ethereal:mushroom_dirt" then
   * 		ethereal.grow_mushroom_tree(pos)
   * 
   * 	elseif node.name == "ethereal:palm_sapling"
   * 	and under == "default:sand" then
   * 		ethereal.grow_palm_tree(pos)
   * 
   * 	elseif node.name == "ethereal:willow_sapling"
   * 	and under == "ethereal:gray_dirt" then
   * 		ethereal.grow_willow_tree(pos)
   * 
   * 	elseif node.name == "ethereal:redwood_sapling"
   * 	and under == "bakedclay:red" then
   * 		ethereal.grow_redwood_tree(pos)
   * 
   * 	elseif node.name == "ethereal:orange_tree_sapling"
   * 	and under == "ethereal:prairie_dirt" then
   * 		ethereal.grow_orange_tree(pos)
   * 
   * 	elseif node.name == "ethereal:bamboo_sprout"
   * 	and under == "ethereal:bamboo_dirt" then
   * 		ethereal.grow_bamboo_tree(pos)
   * 
   * 	elseif node.name == "ethereal:birch_sapling"
   * 	and under == "ethereal:green_dirt" then
   * 		ethereal.grow_birch_tree(pos)
   * 	end
   * 
   * end */
  lua_pushvalue(L,(lc9 + lc_nextra));
  lua_pushcclosure(L,lcf1_ethereal_grow_sapling,1);
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_insert(L,-2);
  lua_pushliteral(L,"grow_sapling");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* -- Grow saplings
   * minetest.register_abm({
   * 	label = "Ethereal grow sapling",
   * 	nodenames = {"group:ethereal_sapling"},
   * 	interval = 10,
   * 	chance = 50,
   * 	catch_up = false,
   * 	action = function(pos, node)
   * 
   * 		local light_level = minetest.get_node_light(pos)
   * 
   * 		if not light_level or light_level < 13 then
   * 			return
   * 		end
   * 
   * 		ethereal.grow_sapling(pos, node)
   * 	end,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,6);
  lua_pushliteral(L,"label");
  lua_pushliteral(L,"Ethereal grow sapling");
  lua_rawset(L,-3);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:ethereal_sapling");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushnumber(L,10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,50);
  lua_rawset(L,-3);
  lua_pushliteral(L,"catch_up");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushcfunction(L,lcf63);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 3);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_ethereal_sapling(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


