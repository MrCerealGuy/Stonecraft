/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* function(pos, node) */
static int lcf2 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local near = minetest.find_node_near(pos, 1,
   * 			{"default:water_source", "default:river_water_source"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_node_near");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushnumber(L,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:water_source");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:river_water_source");
  lua_rawseti(L,-2,2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 3);
  
  /* if near then */
  enum { lc1 = 3 };
  if (lua_toboolean(L,3)) {
    
    /* minetest.swap_node(near, {name = "default:ice"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:ice");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(pos, node) */
static int lcf18 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local water_node = "default:water" */
  lua_pushliteral(L,"default:water");
  assert(lua_gettop(L) == 3);
  
  /* if pos.y > 2 then */
  enum { lc3 = 3 };
  lua_pushnumber(L,2);
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  const int lc4 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc4);
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* water_node = "default:river_water" */
    lua_pushliteral(L,"default:river_water");
    lua_replace(L,3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc3);
  assert(lua_gettop(L) == 3);
  
  /* if node.name == "default:ice"
   * 		or node.name == "default:snowblock"
   * 		or node.name == "ethereal:icebrick"
   * 		or node.name == "ethereal:snowbrick" then */
  enum { lc6 = 3 };
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_pushliteral(L,"default:ice");
  const int lc7 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc7);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"default:snowblock");
    const int lc8 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc8);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"ethereal:icebrick");
    const int lc9 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc9);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"ethereal:snowbrick");
    const int lc10 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc10);
  }
  const int lc11 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc11) {
    
    /* minetest.swap_node(pos, {name = water_node.."_source"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushvalue(L,3);
    lua_pushliteral(L,"_source");
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* elseif node.name == "default:snow" then */
    enum { lc12 = 3 };
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"default:snow");
    const int lc13 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc13);
    const int lc14 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc14) {
      
      /* minetest.swap_node(pos, {name = water_node.."_flowing"}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"swap_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lua_pushvalue(L,3);
      lua_pushliteral(L,"_flowing");
      lua_concat(L,2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 3);
    }
    else {
      
      /* elseif node.name == "default:dirt_with_snow" then */
      enum { lc15 = 3 };
      lua_pushliteral(L,"name");
      lua_gettable(L,2);
      lua_pushliteral(L,"default:dirt_with_snow");
      const int lc16 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc16);
      const int lc17 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc17) {
        
        /* minetest.swap_node(pos, {name = "default:dirt_with_grass"}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"swap_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_createtable(L,0,1);
        lua_pushliteral(L,"name");
        lua_pushliteral(L,"default:dirt_with_grass");
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L,lc15);
    }
    lua_settop(L,lc12);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 3);
  
  /* nodeupdate(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"nodeupdate");
  lua_pushvalue(L,1);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* function(pos, node) */
static int lcf22 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if node == "ethereal:dry_dirt" then */
  enum { lc19 = 2 };
  lua_pushliteral(L,"ethereal:dry_dirt");
  const int lc20 = lua_equal(L,2,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc20);
  const int lc21 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc21) {
    
    /* minetest.swap_node(pos, {name = "default:dirt"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:dirt");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* else
     * minetest.swap_node(pos, {name = "ethereal:green_dirt"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"ethereal:green_dirt");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc19);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(pos, node) */
static int lcf29 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local num = #minetest.find_nodes_in_area(
   * 			{x = pos.x - 1, y = pos.y, z = pos.z},
   * 			{x = pos.x + 1, y = pos.y, z = pos.z},
   * 			{"group:water"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_nodes_in_area");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:water");
  lua_rawseti(L,-2,1);
  lua_call(L,3,1);
  const double lc23 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc23);
  assert(lua_gettop(L) == 3);
  
  /* num = num + #minetest.find_nodes_in_area(
   * 			{x = pos.x, y = pos.y, z = pos.z - 1},
   * 			{x = pos.x, y = pos.y, z = pos.z + 1},
   * 			{"group:water"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_nodes_in_area");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:water");
  lua_rawseti(L,-2,1);
  lua_call(L,3,1);
  const double lc24 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc24);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_replace(L,3);
  assert(lua_gettop(L) == 3);
  
  /* num = num + #minetest.find_nodes_in_area(
   * 			{x = pos.x, y = pos.y + 1, z = pos.z},
   * 			{x = pos.x, y = pos.y + 1, z = pos.z},
   * 			{"group:water"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_nodes_in_area");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:water");
  lua_rawseti(L,-2,1);
  lua_call(L,3,1);
  const double lc25 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc25);
  lc_add(L,3,-1);
  lua_remove(L,-2);
  lua_replace(L,3);
  assert(lua_gettop(L) == 3);
  
  /* if num > 0 then */
  enum { lc26 = 3 };
  lua_pushnumber(L,0);
  const int lc27 = lua_lessthan(L,-1,3);
  lua_pop(L,1);
  lua_pushboolean(L,lc27);
  const int lc28 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc28) {
    
    /* minetest.swap_node(pos, {name = "air"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"air");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
    
    /* minetest.add_item(pos, {name = node.name}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"add_item");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc26);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local S = ethereal.intllib */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"intllib");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Ice Brick
   * minetest.register_node("ethereal:icebrick", {
   * 	description = S("Ice Brick"),
   * 	tiles = {"brick_ice.png"},
   * 	paramtype = "light",
   * 	freezemelt = "default:water_source",
   * 	is_ground_content = false,
   * 	groups = {cracky = 3, melts = 1},
   * 	sounds = default.node_sound_glass_defaults(),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:icebrick");
  lua_createtable(L,0,7);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Ice Brick");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"brick_ice.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"freezemelt");
  lua_pushliteral(L,"default:water_source");
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"cracky");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"melts");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_glass_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_craft({
   * 	output = 'ethereal:icebrick 4',
   * 	recipe = {
   * 		{'default:ice', 'default:ice'},
   * 		{'default:ice', 'default:ice'},
   * 	}
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"ethereal:icebrick 4");
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,2,0);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:ice");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:ice");
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:ice");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:ice");
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Snow Brick
   * minetest.register_node("ethereal:snowbrick", {
   * 	description = S("Snow Brick"),
   * 	tiles = {"brick_snow.png"},
   * 	paramtype = "light",
   * 	freezemelt = "default:water_source",
   * 	is_ground_content = false,
   * 	groups = {crumbly = 3, melts = 1},
   * 	sounds = default.node_sound_dirt_defaults({
   * 		footstep = {name="default_snow_footstep", gain = 0.25},
   * 		dug = {name="default_snow_footstep", gain = 0.75},
   * 	}),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:snowbrick");
  lua_createtable(L,0,7);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Snow Brick");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"brick_snow.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"freezemelt");
  lua_pushliteral(L,"default:water_source");
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"melts");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_dirt_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"footstep");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default_snow_footstep");
  lua_rawset(L,-3);
  lua_pushliteral(L,"gain");
  lua_pushnumber(L,0.25);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"dug");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"name");
  lua_pushliteral(L,"default_snow_footstep");
  lua_rawset(L,-3);
  lua_pushliteral(L,"gain");
  lua_pushnumber(L,0.75);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_craft({
   * 	output = 'ethereal:snowbrick 4',
   * 	recipe = {
   * 		{'default:snowblock', 'default:snowblock'},
   * 		{'default:snowblock', 'default:snowblock'},
   * 	}
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"ethereal:snowbrick 4");
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,2,0);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:snowblock");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:snowblock");
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:snowblock");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:snowblock");
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- If Crystal Spike, Crystal Dirt, Snow near Water, change Water to Ice
   * minetest.register_abm({
   * 	label = "Ethereal freeze water",
   * 	nodenames = {
   * 		"ethereal:crystal_spike", "default:snow", "default:snowblock",
   * 		"ethereal:snowbrick"
   * 	},
   * 	neighbors = {"default:water_source", "default:river_water_source"},
   * 	interval = 15,
   * 	chance = 4,
   * 	catch_up = false,
   * 	action = function(pos, node)
   * 
   * 		local near = minetest.find_node_near(pos, 1,
   * 			{"default:water_source", "default:river_water_source"})
   * 
   * 		if near then
   * 			minetest.swap_node(near, {name = "default:ice"})
   * 		end
   * 	end,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,7);
  lua_pushliteral(L,"label");
  lua_pushliteral(L,"Ethereal freeze water");
  lua_rawset(L,-3);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,4,0);
  lua_pushliteral(L,"ethereal:crystal_spike");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:snow");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:snowblock");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"ethereal:snowbrick");
  lua_rawseti(L,-2,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"neighbors");
  lua_createtable(L,2,0);
  lua_pushliteral(L,"default:water_source");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:river_water_source");
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushnumber(L,15);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"catch_up");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushcfunction(L,lcf2);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- If Heat Source near Ice or Snow then melt
   * minetest.register_abm({
   * 	label = "Ethereal melt snow/ice",
   * 	nodenames = {
   * 		"default:ice", "default:snowblock", "default:snow",
   * 		"default:dirt_with_snow", "ethereal:snowbrick", "ethereal:icebrick"
   * 	},
   * 	neighbors = {
   * 		"fire:basic_fire", "default:lava_source", "default:lava_flowing",
   * 		"default:furnace_active", "default:torch"
   * 	},
   * 	interval = 5,
   * 	chance = 4,
   * 	catch_up = false,
   * 	action = function(pos, node)
   * 
   * 		local water_node = "default:water"
   * 
   * 		if pos.y > 2 then
   * 			water_node = "default:river_water"
   * 		end
   * 
   * 		if node.name == "default:ice"
   * 		or node.name == "default:snowblock"
   * 		or node.name == "ethereal:icebrick"
   * 		or node.name == "ethereal:snowbrick" then
   * 			minetest.swap_node(pos, {name = water_node.."_source"})
   * 
   * 		elseif node.name == "default:snow" then
   * 			minetest.swap_node(pos, {name = water_node.."_flowing"})
   * 
   * 		elseif node.name == "default:dirt_with_snow" then
   * 			minetest.swap_node(pos, {name = "default:dirt_with_grass"})
   * 		end
   * 
   * 		nodeupdate(pos)
   * 	end,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,7);
  lua_pushliteral(L,"label");
  lua_pushliteral(L,"Ethereal melt snow/ice");
  lua_rawset(L,-3);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,6,0);
  lua_pushliteral(L,"default:ice");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:snowblock");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:snow");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"default:dirt_with_snow");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"ethereal:snowbrick");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"ethereal:icebrick");
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"neighbors");
  lua_createtable(L,5,0);
  lua_pushliteral(L,"fire:basic_fire");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:lava_source");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:lava_flowing");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"default:furnace_active");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"default:torch");
  lua_rawseti(L,-2,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"catch_up");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushcfunction(L,lcf18);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- If Water Source near Dry Dirt, change to normal Dirt
   * minetest.register_abm({
   * 	label = "Ethereal wet dry dirt",
   * 	nodenames = {"ethereal:dry_dirt", "default:dirt_with_dry_grass"},
   * 	neighbors = {"group:water"},
   * 	interval = 15,
   * 	chance = 2,
   * 	catch_up = false,
   * 	action = function(pos, node)
   * 
   * 		if node == "ethereal:dry_dirt" then
   * 			minetest.swap_node(pos, {name = "default:dirt"})
   * 		else
   * 			minetest.swap_node(pos, {name = "ethereal:green_dirt"})
   * 		end
   * 	end,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,7);
  lua_pushliteral(L,"label");
  lua_pushliteral(L,"Ethereal wet dry dirt");
  lua_rawset(L,-3);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,2,0);
  lua_pushliteral(L,"ethereal:dry_dirt");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:dirt_with_dry_grass");
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"neighbors");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:water");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushnumber(L,15);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"catch_up");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushcfunction(L,lcf22);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- If torch touching water then drop as item
   * minetest.register_abm({
   * 	label = "Ethereal drop torch",
   * 	nodenames = {"default:torch"},
   * 	neighbors = {"group:water"},
   * 	interval = 5,
   * 	chance = 1,
   * 	catch_up = false,
   * 	action = function(pos, node)
   * 
   * 		local num = #minetest.find_nodes_in_area(
   * 			{x = pos.x - 1, y = pos.y, z = pos.z},
   * 			{x = pos.x + 1, y = pos.y, z = pos.z},
   * 			{"group:water"})
   * 
   * 		num = num + #minetest.find_nodes_in_area(
   * 			{x = pos.x, y = pos.y, z = pos.z - 1},
   * 			{x = pos.x, y = pos.y, z = pos.z + 1},
   * 			{"group:water"})
   * 
   * 		num = num + #minetest.find_nodes_in_area(
   * 			{x = pos.x, y = pos.y + 1, z = pos.z},
   * 			{x = pos.x, y = pos.y + 1, z = pos.z},
   * 			{"group:water"})
   * 
   * 		if num > 0 then
   * 
   * 			minetest.swap_node(pos, {name = "air"})
   * 
   * 			minetest.add_item(pos, {name = node.name})
   * 		end
   * 	end,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_abm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,7);
  lua_pushliteral(L,"label");
  lua_pushliteral(L,"Ethereal drop torch");
  lua_rawset(L,-3);
  lua_pushliteral(L,"nodenames");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:torch");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"neighbors");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:water");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"interval");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"chance");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"catch_up");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"action");
  lua_pushcfunction(L,lcf29);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_ethereal_water(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


