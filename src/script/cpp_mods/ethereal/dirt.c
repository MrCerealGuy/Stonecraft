/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: grass_spread
 * function(pos, node) */
static int lcf1_grass_spread (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* -- not enough light
   * local above = {x = pos.x, y = pos.y + 1, z = pos.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 3);
  
  /* if (minetest.get_node_light(above) or 0) < 13 then */
  enum { lc7 = 3 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_light");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushnumber(L,13);
  const int lc8 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc8);
  const int lc9 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc9) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc7);
  assert(lua_gettop(L) == 3);
  
  /* -- water above grass
   * local name = minetest.get_node(above).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* local def = minetest.registered_nodes[name] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* if name == "ignore" or not def or def.liquidtype ~= "none" then */
  enum { lc10 = 5 };
  lua_pushvalue(L,4);
  lua_pushliteral(L,"ignore");
  const int lc11 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc11);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushboolean(L,!(lua_toboolean(L,5)));
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"liquidtype");
    lua_gettable(L,5);
    lua_pushliteral(L,"none");
    const int lc12 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc12);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc13 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc13) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 5);
  
  /* local curr_max, curr_type, num  = 0, "" */
  lua_pushnumber(L,0);
  lua_pushliteral(L,"");
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 8);
  
  /* -- find all default and ethereal grasses in area around dirt
   * local positions, grasses = minetest.find_nodes_in_area(
   * 		{x = pos.x - 1, y = pos.y - 2, z = pos.z - 1},
   * 		{x = pos.x + 1, y = pos.y + 2, z = pos.z + 1},
   * 		{"group:ethereal_grass", "default:dirt_with_grass",
   * 		"default:dirt_with_dry_grass", "default:dirt_with_snow"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_nodes_in_area");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_createtable(L,4,0);
  lua_pushliteral(L,"group:ethereal_grass");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:dirt_with_grass");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default:dirt_with_dry_grass");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"default:dirt_with_snow");
  lua_rawseti(L,-2,4);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 10);
  
  /* -- count new grass nodes
   * for n = 1, #dirts do */
  lua_pushnumber(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),0,1);
  const double lc17 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc17);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc14_var = lua_tonumber(L,-2);
  const double lc15_limit = lua_tonumber(L,-1);
  const double lc16_step = 1;
  lua_pop(L,2);
  enum { lc18 = 10 };
  while ((((lc16_step > 0) && (lc14_var <= lc15_limit)) || ((lc16_step <= 0) && (lc14_var >= lc15_limit)))) {
    
    /* internal: local n at index 11 */
    lua_pushnumber(L,lc14_var);
    
    /* num = grasses[ dirts[n] ] or 0 */
    lc_getupvalue(L,lua_upvalueindex(1),0,1);
    lua_pushvalue(L,11);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_gettable(L,10);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    lua_replace(L,8);
    assert(lua_gettop(L) == 11);
    
    /* if num > curr_max then */
    enum { lc19 = 11 };
    const int lc20 = lua_lessthan(L,6,8);
    lua_pushboolean(L,lc20);
    const int lc21 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc21) {
      
      /* curr_max = num */
      lua_pushvalue(L,8);
      lua_replace(L,6);
      assert(lua_gettop(L) == 11);
      
      /* curr_type = dirts[n] */
      lc_getupvalue(L,lua_upvalueindex(1),0,1);
      lua_pushvalue(L,11);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_replace(L,7);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc19);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc14_var += lc16_step;
  }
  lua_settop(L,lc18);
  assert(lua_gettop(L) == 10);
  
  /* -- no grass nearby, keep as dirt
   * if curr_type == "" then */
  enum { lc22 = 10 };
  lua_pushliteral(L,"");
  const int lc23 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc23);
  const int lc24 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc24) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc22);
  assert(lua_gettop(L) == 10);
  
  /* -- change default green grass to ethereal green grass
   * if curr_type == "default:dirt_with_grass" then */
  enum { lc25 = 10 };
  lua_pushliteral(L,"default:dirt_with_grass");
  const int lc26 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc26);
  const int lc27 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc27) {
    
    /* curr_type = "ethereal:green_dirt" */
    lua_pushliteral(L,"ethereal:green_dirt");
    lua_replace(L,7);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L,lc25);
  assert(lua_gettop(L) == 10);
  
  /* minetest.swap_node(pos, {name = curr_type}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"swap_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"name");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 10);
  return 0;
}


/* name: grass_devoid
 * function(pos, node) */
static int lcf1_grass_devoid (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local above = {x = pos.x, y = pos.y + 1, z = pos.z} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 3);
  
  /* local name = minetest.get_node(above).name */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* local nodedef = minetest.registered_nodes[name] */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_nodes");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 5);
  
  /* if name ~= "ignore" and nodedef and not ((nodedef.sunlight_propagates or
   * 			nodedef.paramtype == "light") and
   * 			nodedef.liquidtype == "none") then */
  enum { lc28 = 5 };
  lua_pushliteral(L,"ignore");
  const int lc29 = lua_equal(L,4,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc29);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushvalue(L,5);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"sunlight_propagates");
    lua_gettable(L,5);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"paramtype");
      lua_gettable(L,5);
      lua_pushliteral(L,"light");
      const int lc30 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc30);
    }
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"liquidtype");
      lua_gettable(L,5);
      lua_pushliteral(L,"none");
      const int lc31 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc31);
    }
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc32 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc32) {
    
    /* minetest.swap_node(pos, {name = "default:dirt"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"default:dirt");
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc28);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: flower_spread
 * function(pos, node) */
static int lcf1_flower_spread (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* if (minetest.get_node_light(pos) or 0) < 13 then */
  enum { lc33 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_light");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,0);
  }
  lua_pushnumber(L,13);
  const int lc34 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc34);
  const int lc35 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc35) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc33);
  assert(lua_gettop(L) == 2);
  
  /* local pos0 = {x = pos.x - 4, y = pos.y - 2, z = pos.z - 4} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 3);
  
  /* local pos1 = {x = pos.x + 4, y = pos.y + 2, z = pos.z + 4} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,2);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_pushnumber(L,4);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 4);
  
  /* local num = #minetest.find_nodes_in_area_under_air(pos0, pos1, "group:flora") */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_nodes_in_area_under_air");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_pushliteral(L,"group:flora");
  lua_call(L,3,1);
  const double lc36 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc36);
  assert(lua_gettop(L) == 5);
  
  /* if num > 3
   * 	and node.name == "ethereal:crystalgrass" then */
  enum { lc37 = 5 };
  lua_pushnumber(L,3);
  const int lc38 = lua_lessthan(L,-1,5);
  lua_pop(L,1);
  lua_pushboolean(L,lc38);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"ethereal:crystalgrass");
    const int lc39 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc39);
  }
  const int lc40 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc40) {
    
    /* local grass = minetest.find_nodes_in_area_under_air(
     * 			pos0, pos1, {"ethereal:crystalgrass"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"find_nodes_in_area_under_air");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"ethereal:crystalgrass");
    lua_rawseti(L,-2,1);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 6);
    
    /* if #grass > 4
     * 		and not minetest.find_node_near(pos, 4, {"ethereal:crystal_spike"}) then */
    enum { lc41 = 6 };
    lua_pushnumber(L,4);
    const double lc42 = lua_objlen(L,6);
    lua_pushnumber(L,lc42);
    const int lc43 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc43);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_node_near");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_pushnumber(L,4);
      lua_createtable(L,1,0);
      lua_pushliteral(L,"ethereal:crystal_spike");
      lua_rawseti(L,-2,1);
      lua_call(L,3,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc44 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc44) {
      
      /* pos = grass[math.random(#grass)] */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const double lc45 = lua_objlen(L,6);
      lua_pushnumber(L,lc45);
      lua_call(L,1,1);
      lua_gettable(L,6);
      lua_replace(L,1);
      assert(lua_gettop(L) == 6);
      
      /* pos.y = pos.y - 1 */
      lua_pushliteral(L,"y");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 6);
      
      /* if minetest.get_node(pos).name == "ethereal:crystal_dirt" then */
      enum { lc46 = 6 };
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"ethereal:crystal_dirt");
      const int lc47 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc47);
      const int lc48 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc48) {
        
        /* pos.y = pos.y + 1 */
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_add(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 6);
        
        /* minetest.swap_node(pos, {name = "ethereal:crystal_spike"}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"swap_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_createtable(L,0,1);
        lua_pushliteral(L,"name");
        lua_pushliteral(L,"ethereal:crystal_spike");
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc46);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc41);
    assert(lua_gettop(L) == 6);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  else {
    
    /* elseif num > 3
     * 	and node.name == "ethereal:dry_shrub" then */
    enum { lc49 = 5 };
    lua_pushnumber(L,3);
    const int lc50 = lua_lessthan(L,-1,5);
    lua_pop(L,1);
    lua_pushboolean(L,lc50);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,2);
      lua_pushliteral(L,"ethereal:dry_shrub");
      const int lc51 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc51);
    }
    const int lc52 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc52) {
      
      /* local grass = minetest.find_nodes_in_area_under_air(
       * 			pos0, pos1, {"ethereal:dry_shrub"}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"find_nodes_in_area_under_air");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,3);
      lua_pushvalue(L,4);
      lua_createtable(L,1,0);
      lua_pushliteral(L,"ethereal:dry_shrub");
      lua_rawseti(L,-2,1);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 6);
      
      /* if #grass > 8
       * 		and not minetest.find_node_near(pos, 4, {"ethereal:fire_flower"}) then */
      enum { lc53 = 6 };
      lua_pushnumber(L,8);
      const double lc54 = lua_objlen(L,6);
      lua_pushnumber(L,lc54);
      const int lc55 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc55);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"find_node_near");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_pushnumber(L,4);
        lua_createtable(L,1,0);
        lua_pushliteral(L,"ethereal:fire_flower");
        lua_rawseti(L,-2,1);
        lua_call(L,3,1);
        lua_pushboolean(L,!(lua_toboolean(L,-1)));
        lua_remove(L,-2);
      }
      const int lc56 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc56) {
        
        /* pos = grass[math.random(#grass)] */
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const double lc57 = lua_objlen(L,6);
        lua_pushnumber(L,lc57);
        lua_call(L,1,1);
        lua_gettable(L,6);
        lua_replace(L,1);
        assert(lua_gettop(L) == 6);
        
        /* pos.y = pos.y - 1 */
        lua_pushliteral(L,"y");
        lua_gettable(L,1);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"y");
        lua_insert(L,-2);
        lua_settable(L,1);
        assert(lua_gettop(L) == 6);
        
        /* if minetest.get_node(pos).name == "ethereal:fiery_dirt" then */
        enum { lc58 = 6 };
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"get_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,1);
        lua_call(L,1,1);
        lua_pushliteral(L,"name");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"ethereal:fiery_dirt");
        const int lc59 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc59);
        const int lc60 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc60) {
          
          /* pos.y = pos.y + 1 */
          lua_pushliteral(L,"y");
          lua_gettable(L,1);
          lua_pushnumber(L,1);
          lc_add(L,-2,-1);
          lua_remove(L,-2);
          lua_remove(L,-2);
          lua_pushliteral(L,"y");
          lua_insert(L,-2);
          lua_settable(L,1);
          assert(lua_gettop(L) == 6);
          
          /* minetest.swap_node(pos, {name = "ethereal:fire_flower"}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"swap_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,1);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"ethereal:fire_flower");
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L,lc58);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L,lc53);
      assert(lua_gettop(L) == 6);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 6);
    }
    else {
      
      /* elseif num > 3 then */
      enum { lc61 = 5 };
      lua_pushnumber(L,3);
      const int lc62 = lua_lessthan(L,-1,5);
      lua_pop(L,1);
      lua_pushboolean(L,lc62);
      const int lc63 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc63) {
        
        /* return */
        return 0;
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L,lc61);
    }
    lua_settop(L,lc49);
  }
  lua_settop(L,lc37);
  assert(lua_gettop(L) == 5);
  
  /* local seedling = minetest.find_nodes_in_area_under_air(
   * 		pos0, pos1, {"group:soil"}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"find_nodes_in_area_under_air");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_createtable(L,1,0);
  lua_pushliteral(L,"group:soil");
  lua_rawseti(L,-2,1);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 6);
  
  /* if #seedling > 0 then */
  enum { lc64 = 6 };
  lua_pushnumber(L,0);
  const double lc65 = lua_objlen(L,6);
  lua_pushnumber(L,lc65);
  const int lc66 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc66);
  const int lc67 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc67) {
    
    /* pos = seedling[math.random(#seedling)] */
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc68 = lua_objlen(L,6);
    lua_pushnumber(L,lc68);
    lua_call(L,1,1);
    lua_gettable(L,6);
    lua_replace(L,1);
    assert(lua_gettop(L) == 6);
    
    /* -- default farming has desert sand as soil, so dont spread on this
     * if minetest.get_node(pos).name == "default:desert_sand" then */
    enum { lc69 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"default:desert_sand");
    const int lc70 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc70);
    const int lc71 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc71) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc69);
    assert(lua_gettop(L) == 6);
    
    /* pos.y = pos.y + 1 */
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 6);
    
    /* if (minetest.get_node_light(pos) or 0) < 13 then */
    enum { lc72 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node_light");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushnumber(L,0);
    }
    lua_pushnumber(L,13);
    const int lc73 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc73);
    const int lc74 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc74) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc72);
    assert(lua_gettop(L) == 6);
    
    /* minetest.swap_node(pos, {name = node.name}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"swap_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_createtable(L,0,1);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc64);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* name: grow_papyrus
 * function(pos, node) */
static int lcf1_grow_papyrus (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local oripos = pos.y */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 3);
  
  /* local high = 4 */
  lua_pushnumber(L,4);
  assert(lua_gettop(L) == 4);
  
  /* pos.y = pos.y - 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 4);
  
  /* local nod = minetest.get_node_or_nil(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_or_nil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* if not nod
   * 	or minetest.get_item_group(nod.name, "soil") < 1
   * 	or minetest.find_node_near(pos, 3, {"group:water"}) == nil then */
  enum { lc75 = 5 };
  lua_pushboolean(L,!(lua_toboolean(L,5)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_item_group");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"name");
    lua_gettable(L,5);
    lua_pushliteral(L,"soil");
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc76 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc76);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"find_node_near");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushnumber(L,3);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"group:water");
    lua_rawseti(L,-2,1);
    lua_call(L,3,1);
    lua_pushnil(L);
    const int lc77 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc77);
  }
  const int lc78 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc78) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc75);
  assert(lua_gettop(L) == 5);
  
  /* if node.name == "ethereal:bamboo" then */
  enum { lc79 = 5 };
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_pushliteral(L,"ethereal:bamboo");
  const int lc80 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc80);
  const int lc81 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc81) {
    
    /* high = 8 */
    lua_pushnumber(L,8);
    lua_replace(L,4);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc79);
  assert(lua_gettop(L) == 5);
  
  /* pos.y = pos.y + 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 5);
  
  /* local height = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 6);
  
  /* while height < high
   * 	and minetest.get_node(pos).name == node.name do */
  enum { lc82 = 6 };
  while (1) {
    const int lc83 = lua_lessthan(L,6,4);
    lua_pushboolean(L,lc83);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"get_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"name");
      lua_gettable(L,2);
      const int lc84 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc84);
    }
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* height = height + 1 */
    lua_pushnumber(L,1);
    lc_add(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,6);
    assert(lua_gettop(L) == 6);
    
    /* pos.y = pos.y + 1 */
    lua_pushliteral(L,"y");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"y");
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc82);
  assert(lua_gettop(L) == 6);
  
  /* nod = minetest.get_node_or_nil(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_or_nil");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_replace(L,5);
  assert(lua_gettop(L) == 6);
  
  /* if nod
   * 	and nod.name == "air"
   * 	and height < high then */
  enum { lc85 = 6 };
  lua_pushvalue(L,5);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_pushliteral(L,"name");
    lua_gettable(L,5);
    lua_pushliteral(L,"air");
    const int lc86 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc86);
  }
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    const int lc87 = lua_lessthan(L,6,4);
    lua_pushboolean(L,lc87);
  }
  const int lc88 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc88) {
    
    /* if node.name == "ethereal:bamboo"
     * 		and height == (high - 1) then */
    enum { lc89 = 6 };
    lua_pushliteral(L,"name");
    lua_gettable(L,2);
    lua_pushliteral(L,"ethereal:bamboo");
    const int lc90 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc90);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushvalue(L,6);
      lua_pushnumber(L,1);
      lc_sub(L,4,-1);
      lua_remove(L,-2);
      const int lc91 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc91);
    }
    const int lc92 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc92) {
      
      /* ethereal.grow_bamboo_tree({x = pos.x, y = oripos, z = pos.z}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
      lua_pushliteral(L,"grow_bamboo_tree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_createtable(L,0,3);
      lua_pushliteral(L,"x");
      lua_pushliteral(L,"x");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"y");
      lua_pushvalue(L,3);
      lua_rawset(L,-3);
      lua_pushliteral(L,"z");
      lua_pushliteral(L,"z");
      lua_gettable(L,1);
      lua_rawset(L,-3);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 6);
    }
    else {
      
      /* else
       * minetest.swap_node(pos, {name = node.name}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"swap_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lua_pushliteral(L,"name");
      lua_gettable(L,2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc89);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc85);
  assert(lua_gettop(L) == 6);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,25);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local S = ethereal.intllib */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"intllib");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- override default dirt (to stop caves cutting away dirt)
   * minetest.override_item("default:dirt", {is_ground_content = ethereal.cavedirt}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"override_item");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"is_ground_content");
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"cavedirt");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- green dirt
   * minetest.register_node("ethereal:green_dirt", {
   * 	description = S("Green Dirt"),
   * 	tiles = {
   * 		"default_grass.png",
   * 		"default_dirt.png",
   * 		"default_dirt.png^default_grass_side.png"
   * 	},
   * 	is_ground_content = ethereal.cavedirt,
   * 	groups = {crumbly = 3, soil = 1, ethereal_grass = 1},
   * 	soil = {
   * 		base = "ethereal:green_dirt",
   * 		dry = "farming:soil",
   * 		wet = "farming:soil_wet"
   * 	},
   * 	drop = "default:dirt",
   * 	sounds = default.node_sound_dirt_defaults()
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:green_dirt");
  lua_createtable(L,0,7);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Green Dirt");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,3,0);
  lua_pushliteral(L,"default_grass.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default_dirt.png");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"default_dirt.png^default_grass_side.png");
  lua_rawseti(L,-2,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"cavedirt");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"soil");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"ethereal_grass");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"soil");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"base");
  lua_pushliteral(L,"ethereal:green_dirt");
  lua_rawset(L,-3);
  lua_pushliteral(L,"dry");
  lua_pushliteral(L,"farming:soil");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wet");
  lua_pushliteral(L,"farming:soil_wet");
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"default:dirt");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_dirt_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- dry dirt
   * minetest.register_node("ethereal:dry_dirt", {
   * 	description = S("Dried Dirt"),
   * 	tiles = {"ethereal_dry_dirt.png"},
   * 	is_ground_content = ethereal.cavedirt,
   * 	groups = {crumbly = 3},
   * 	sounds = default.node_sound_dirt_defaults()
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:dry_dirt");
  lua_createtable(L,0,5);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Dried Dirt");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal_dry_dirt.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"is_ground_content");
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"cavedirt");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_dirt_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_craft({
   * 	type = "cooking",
   * 	output = "ethereal:dry_dirt",
   * 	recipe = "default:dirt",
   * 	cooktime = 3,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,4);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"cooking");
  lua_rawset(L,-3);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"ethereal:dry_dirt");
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_pushliteral(L,"default:dirt");
  lua_rawset(L,-3);
  lua_pushliteral(L,"cooktime");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local dirts = {
   * 	"Bamboo", "Jungle", "Grove", "Prairie", "Cold",
   * 	"Crystal", "Mushroom", "Fiery", "Gray"
   * } */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 2 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_createtable(L,9,0);
  lua_pushliteral(L,"Bamboo");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"Jungle");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"Grove");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"Prairie");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"Cold");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"Crystal");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"Mushroom");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"Fiery");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"Gray");
  lua_rawseti(L,-2,9);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* for n = 1, #dirts do */
  lua_pushnumber(L,1);
  lc_getupvalue(L,(lc1 + lc_nextra),0,1);
  const double lc5 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc5);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc2_var = lua_tonumber(L,-2);
  const double lc3_limit = lua_tonumber(L,-1);
  const double lc4_step = 1;
  lua_pop(L,2);
  enum { lc6 = 2 };
  while ((((lc4_step > 0) && (lc2_var <= lc3_limit)) || ((lc4_step <= 0) && (lc2_var >= lc3_limit)))) {
    
    /* internal: local n at index 3 */
    lua_pushnumber(L,lc2_var);
    
    /* local desc = dirts[n] */
    lc_getupvalue(L,(lc1 + lc_nextra),0,1);
    lua_pushvalue(L,(3 + lc_nextra));
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) - lc_nextra == 4);
    
    /* local name = desc:lower() */
    lua_pushvalue(L,(4 + lc_nextra));
    lua_pushliteral(L,"lower");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,1);
    assert(lua_gettop(L) - lc_nextra == 5);
    
    /* minetest.register_node("ethereal:"..name.."_dirt", {
     * 		description = S(desc.." Dirt"),
     * 		tiles = {
     * 			"ethereal_grass_"..name.."_top.png",
     * 			"default_dirt.png",
     * 			"default_dirt.png^ethereal_grass_"..name.."_side.png"
     * 		},
     * 		is_ground_content = ethereal.cavedirt,
     * 		groups = {crumbly = 3, soil = 1, ethereal_grass = 1},
     * 		soil = {
     * 			base = "ethereal:"..name.."_dirt",
     * 			dry = "farming:soil",
     * 			wet = "farming:soil_wet"
     * 		},
     * 		drop = "default:dirt",
     * 		sounds = default.node_sound_dirt_defaults()
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"ethereal:");
    lua_pushvalue(L,(5 + lc_nextra));
    lua_pushliteral(L,"_dirt");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_createtable(L,0,7);
    lua_pushliteral(L,"description");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushvalue(L,(4 + lc_nextra));
    lua_pushliteral(L," Dirt");
    lua_concat(L,2);
    lua_call(L,1,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,3,0);
    lua_pushliteral(L,"ethereal_grass_");
    lua_pushvalue(L,(5 + lc_nextra));
    lua_pushliteral(L,"_top.png");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"default_dirt.png");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"default_dirt.png^ethereal_grass_");
    lua_pushvalue(L,(5 + lc_nextra));
    lua_pushliteral(L,"_side.png");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawseti(L,-2,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"cavedirt");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"crumbly");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"soil");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"ethereal_grass");
    lua_pushnumber(L,1);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"soil");
    lua_createtable(L,0,3);
    lua_pushliteral(L,"base");
    lua_pushliteral(L,"ethereal:");
    lua_pushvalue(L,(5 + lc_nextra));
    lua_pushliteral(L,"_dirt");
    lua_concat(L,2);
    lua_concat(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"dry");
    lua_pushliteral(L,"farming:soil");
    lua_rawset(L,-3);
    lua_pushliteral(L,"wet");
    lua_pushliteral(L,"farming:soil_wet");
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"drop");
    lua_pushliteral(L,"default:dirt");
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_dirt_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
    lc2_var += lc4_step;
  }
  lua_settop(L,(lc6 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- re-register dirt types for abm
   * dirts = {
   * 	"ethereal:bamboo_dirt", "ethereal:jungle_dirt", "ethereal:grove_dirt",
   * 	"ethereal:prairie_dirt", "ethereal:cold_dirt", "ethereal:crystal_dirt",
   * 	"ethereal:mushroom_dirt", "ethereal:fiery_dirt", "ethereal:gray_dirt",
   * 	"default:dirt_with_grass", "default:dirt_with_dry_grass", "ethereal:green_dirt",
   * 	"default:dirt_with_snow", "default:dirt_with_dry_grass"
   * } */
  lua_createtable(L,14,0);
  lua_pushliteral(L,"ethereal:bamboo_dirt");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"ethereal:jungle_dirt");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"ethereal:grove_dirt");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"ethereal:prairie_dirt");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"ethereal:cold_dirt");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"ethereal:crystal_dirt");
  lua_rawseti(L,-2,6);
  lua_pushliteral(L,"ethereal:mushroom_dirt");
  lua_rawseti(L,-2,7);
  lua_pushliteral(L,"ethereal:fiery_dirt");
  lua_rawseti(L,-2,8);
  lua_pushliteral(L,"ethereal:gray_dirt");
  lua_rawseti(L,-2,9);
  lua_pushliteral(L,"default:dirt_with_grass");
  lua_rawseti(L,-2,10);
  lua_pushliteral(L,"default:dirt_with_dry_grass");
  lua_rawseti(L,-2,11);
  lua_pushliteral(L,"ethereal:green_dirt");
  lua_rawseti(L,-2,12);
  lua_pushliteral(L,"default:dirt_with_snow");
  lua_rawseti(L,-2,13);
  lua_pushliteral(L,"default:dirt_with_dry_grass");
  lua_rawseti(L,-2,14);
  lc_setupvalue(L,(lc1 + lc_nextra),0,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- check surrounding grass and change dirt to same colour
   * local grass_spread = function(pos, node)
   * 
   * 	-- not enough light
   * 	local above = {x = pos.x, y = pos.y + 1, z = pos.z}
   * 
   * 	if (minetest.get_node_light(above) or 0) < 13 then
   * 		return
   * 	end
   * 
   * 	-- water above grass
   * 	local name = minetest.get_node(above).name
   * 	local def = minetest.registered_nodes[name]
   * 
   * 	if name == "ignore" or not def or def.liquidtype ~= "none" then
   * 		return
   * 	end
   * 
   * 	local curr_max, curr_type, num  = 0, ""
   * 
   * 	-- find all default and ethereal grasses in area around dirt
   * 	local positions, grasses = minetest.find_nodes_in_area(
   * 		{x = pos.x - 1, y = pos.y - 2, z = pos.z - 1},
   * 		{x = pos.x + 1, y = pos.y + 2, z = pos.z + 1},
   * 		{"group:ethereal_grass", "default:dirt_with_grass",
   * 		"default:dirt_with_dry_grass", "default:dirt_with_snow"})
   * 
   * 	-- count new grass nodes
   * 	for n = 1, #dirts do
   * 
   * 		num = grasses[ dirts[n] ] or 0
   * 
   * 		if num > curr_max then
   * 			curr_max = num
   * 			curr_type = dirts[n]
   * 		end
   * 	end
   * 
   * 	-- no grass nearby, keep as dirt
   * 	if curr_type == "" then
   * 		return
   * 	end
   * 
   * 	-- change default green grass to ethereal green grass
   * 	if curr_type == "default:dirt_with_grass" then
   * 		curr_type = "ethereal:green_dirt"
   * 	end
   * 
   * 	minetest.swap_node(pos, {name = curr_type})
   * end */
  lua_pushvalue(L,(lc1 + lc_nextra));
  lua_pushcclosure(L,lcf1_grass_spread,1);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* -- any grass with a block above will turn into dirt
   * local grass_devoid = function(pos, node)
   * 
   * 	local above = {x = pos.x, y = pos.y + 1, z = pos.z}
   * 	local name = minetest.get_node(above).name
   * 	local nodedef = minetest.registered_nodes[name]
   * 
   * 	if name ~= "ignore" and nodedef and not ((nodedef.sunlight_propagates or
   * 			nodedef.paramtype == "light") and
   * 			nodedef.liquidtype == "none") then
   * 
   * 		minetest.swap_node(pos, {name = "default:dirt"})
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_grass_devoid);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* -- flower spread, also crystal and fire flower regeneration
   * local flower_spread = function(pos, node)
   * 
   * 	if (minetest.get_node_light(pos) or 0) < 13 then
   * 		return
   * 	end
   * 
   * 	local pos0 = {x = pos.x - 4, y = pos.y - 2, z = pos.z - 4}
   * 	local pos1 = {x = pos.x + 4, y = pos.y + 2, z = pos.z + 4}
   * 
   * 	local num = #minetest.find_nodes_in_area_under_air(pos0, pos1, "group:flora")
   * 
   * 	if num > 3
   * 	and node.name == "ethereal:crystalgrass" then
   * 
   * 		local grass = minetest.find_nodes_in_area_under_air(
   * 			pos0, pos1, {"ethereal:crystalgrass"})
   * 
   * 		if #grass > 4
   * 		and not minetest.find_node_near(pos, 4, {"ethereal:crystal_spike"}) then
   * 
   * 			pos = grass[math.random(#grass)]
   * 
   * 			pos.y = pos.y - 1
   * 
   * 			if minetest.get_node(pos).name == "ethereal:crystal_dirt" then
   * 
   * 				pos.y = pos.y + 1
   * 
   * 				minetest.swap_node(pos, {name = "ethereal:crystal_spike"})
   * 			end
   * 		end
   * 
   * 		return
   * 
   * 	elseif num > 3
   * 	and node.name == "ethereal:dry_shrub" then
   * 
   * 		local grass = minetest.find_nodes_in_area_under_air(
   * 			pos0, pos1, {"ethereal:dry_shrub"})
   * 
   * 		if #grass > 8
   * 		and not minetest.find_node_near(pos, 4, {"ethereal:fire_flower"}) then
   * 
   * 			pos = grass[math.random(#grass)]
   * 
   * 			pos.y = pos.y - 1
   * 
   * 			if minetest.get_node(pos).name == "ethereal:fiery_dirt" then
   * 
   * 				pos.y = pos.y + 1
   * 
   * 				minetest.swap_node(pos, {name = "ethereal:fire_flower"})
   * 			end
   * 		end
   * 
   * 		return
   * 
   * 	elseif num > 3 then
   * 		return
   * 	end
   * 
   * 	local seedling = minetest.find_nodes_in_area_under_air(
   * 		pos0, pos1, {"group:soil"})
   * 
   * 	if #seedling > 0 then
   * 
   * 		pos = seedling[math.random(#seedling)]
   * 
   * 		-- default farming has desert sand as soil, so dont spread on this
   * 		if minetest.get_node(pos).name == "default:desert_sand" then
   * 			return
   * 		end
   * 
   * 		pos.y = pos.y + 1
   * 
   * 		if (minetest.get_node_light(pos) or 0) < 13 then
   * 			return
   * 		end
   * 
   * 		minetest.swap_node(pos, {name = node.name})
   * 	end
   * end */
  lua_pushcfunction(L,lcf1_flower_spread);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* -- grow papyrus up to 4 high and bamboo up to 8 high
   * local grow_papyrus = function(pos, node)
   * 
   * 	local oripos = pos.y
   * 	local high = 4
   * 
   * 	pos.y = pos.y - 1
   * 
   * 	local nod = minetest.get_node_or_nil(pos)
   * 
   * 	if not nod
   * 	or minetest.get_item_group(nod.name, "soil") < 1
   * 	or minetest.find_node_near(pos, 3, {"group:water"}) == nil then
   * 		return
   * 	end
   * 
   * 	if node.name == "ethereal:bamboo" then
   * 		high = 8
   * 	end
   * 
   * 	pos.y = pos.y + 1
   * 
   * 	local height = 0
   * 
   * 	while height < high
   * 	and minetest.get_node(pos).name == node.name do
   * 		height = height + 1
   * 		pos.y = pos.y + 1
   * 	end
   * 
   * 	nod = minetest.get_node_or_nil(pos)
   * 
   * 	if nod
   * 	and nod.name == "air"
   * 	and height < high then
   * 
   * 		if node.name == "ethereal:bamboo"
   * 		and height == (high - 1) then
   * 
   * 			ethereal.grow_bamboo_tree({x = pos.x, y = oripos, z = pos.z})
   * 		else
   * 			minetest.swap_node(pos, {name = node.name})
   * 		end
   * 	end
   * 
   * end */
  lua_pushcfunction(L,lcf1_grow_papyrus);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* -- loop through active abm's
   * for _, ab in pairs(minetest.registered_abms) do
   * internal: local f, s, var = explist */
  enum { lc93 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"registered_abms");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local _ with idx 10
     * internal: local ab with idx 11 */
    
    
    /* local label = ab.label or "" */
    lua_pushliteral(L,"label");
    lua_gettable(L,(11 + lc_nextra));
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
    }
    assert(lua_gettop(L) - lc_nextra == 12);
    
    /* local node1 = ab.nodenames and ab.nodenames[1] or "" */
    lua_pushliteral(L,"nodenames");
    lua_gettable(L,(11 + lc_nextra));
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"nodenames");
      lua_gettable(L,(11 + lc_nextra));
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
    }
    assert(lua_gettop(L) - lc_nextra == 13);
    
    /* local node2 = ab.nodenames and ab.nodenames[2] or "" */
    lua_pushliteral(L,"nodenames");
    lua_gettable(L,(11 + lc_nextra));
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"nodenames");
      lua_gettable(L,(11 + lc_nextra));
      lua_pushnumber(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
    }
    assert(lua_gettop(L) - lc_nextra == 14);
    
    /* local neigh = ab.neighbors and ab.neighbors[1] or "" */
    lua_pushliteral(L,"neighbors");
    lua_gettable(L,(11 + lc_nextra));
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"neighbors");
      lua_gettable(L,(11 + lc_nextra));
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
    }
    assert(lua_gettop(L) - lc_nextra == 15);
    
    /* -- find dirt to grass abm and replace with spread function
     * if label == "Grass spread"
     * 	or (node1 == "default:dirt"
     * 	and neigh == "default:dirt_with_grass") then */
    enum { lc94 = 15 };
    lua_pushvalue(L,(12 + lc_nextra));
    lua_pushliteral(L,"Grass spread");
    const int lc95 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc95);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushvalue(L,(13 + lc_nextra));
      lua_pushliteral(L,"default:dirt");
      const int lc96 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc96);
      if (lua_toboolean(L,-1)) {
        lua_pop(L,1);
        lua_pushvalue(L,(15 + lc_nextra));
        lua_pushliteral(L,"default:dirt_with_grass");
        const int lc97 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc97);
      }
    }
    const int lc98 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc98) {
      
      /* --ab.interval = 2
       * --ab.chance = 1
       * ab.nodenames = {"default:dirt_with_grass", "default:dirt"} */
      lua_createtable(L,2,0);
      lua_pushliteral(L,"default:dirt_with_grass");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"default:dirt");
      lua_rawseti(L,-2,2);
      lua_pushliteral(L,"nodenames");
      lua_insert(L,-2);
      lua_settable(L,(11 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 15);
      
      /* ab.neighbors = {"air"} */
      lua_createtable(L,1,0);
      lua_pushliteral(L,"air");
      lua_rawseti(L,-2,1);
      lua_pushliteral(L,"neighbors");
      lua_insert(L,-2);
      lua_settable(L,(11 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 15);
      
      /* ab.action = grass_spread */
      lua_pushvalue(L,(3 + lc_nextra));
      lua_pushliteral(L,"action");
      lua_insert(L,-2);
      lua_settable(L,(11 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 15);
    }
    else {
      
      /* -- find grass devoid of light to dirt abm and change to devoid function
       * 	elseif label == "Grass covered"
       * 	or (node1 == "default:dirt_with_grass"
       * 	and node2 == "default:dirt_with_dry_grass") then */
      enum { lc99 = 15 };
      lua_pushvalue(L,(12 + lc_nextra));
      lua_pushliteral(L,"Grass covered");
      const int lc100 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc100);
      if (!(lua_toboolean(L,-1))) {
        lua_pop(L,1);
        lua_pushvalue(L,(13 + lc_nextra));
        lua_pushliteral(L,"default:dirt_with_grass");
        const int lc101 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc101);
        if (lua_toboolean(L,-1)) {
          lua_pop(L,1);
          lua_pushvalue(L,(14 + lc_nextra));
          lua_pushliteral(L,"default:dirt_with_dry_grass");
          const int lc102 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc102);
        }
      }
      const int lc103 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc103) {
        
        /* --ab.interval = 2
         * --ab.chance = 1
         * ab.nodenames = {
         * 			"default:dirt_with_grass", "default:dirt_with_dry_grass",
         * 			"default:dirt_with_snow", "group:ethereal_grass"
         * 		} */
        lua_createtable(L,4,0);
        lua_pushliteral(L,"default:dirt_with_grass");
        lua_rawseti(L,-2,1);
        lua_pushliteral(L,"default:dirt_with_dry_grass");
        lua_rawseti(L,-2,2);
        lua_pushliteral(L,"default:dirt_with_snow");
        lua_rawseti(L,-2,3);
        lua_pushliteral(L,"group:ethereal_grass");
        lua_rawseti(L,-2,4);
        lua_pushliteral(L,"nodenames");
        lua_insert(L,-2);
        lua_settable(L,(11 + lc_nextra));
        assert(lua_gettop(L) - lc_nextra == 15);
        
        /* ab.action = grass_devoid */
        lua_pushvalue(L,(4 + lc_nextra));
        lua_pushliteral(L,"action");
        lua_insert(L,-2);
        lua_settable(L,(11 + lc_nextra));
        assert(lua_gettop(L) - lc_nextra == 15);
      }
      else {
        
        /* -- find flower spread abm and change to spread function
         * 	elseif label == "Flower spread"
         * 	or node1 == "group:flora" then */
        enum { lc104 = 15 };
        lua_pushvalue(L,(12 + lc_nextra));
        lua_pushliteral(L,"Flower spread");
        const int lc105 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc105);
        if (!(lua_toboolean(L,-1))) {
          lua_pop(L,1);
          lua_pushvalue(L,(13 + lc_nextra));
          lua_pushliteral(L,"group:flora");
          const int lc106 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc106);
        }
        const int lc107 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc107) {
          
          /* --ab.interval = 1
           * --ab.chance = 1
           * ab.nodenames = {"group:flora"} */
          lua_createtable(L,1,0);
          lua_pushliteral(L,"group:flora");
          lua_rawseti(L,-2,1);
          lua_pushliteral(L,"nodenames");
          lua_insert(L,-2);
          lua_settable(L,(11 + lc_nextra));
          assert(lua_gettop(L) - lc_nextra == 15);
          
          /* ab.neighbors = {"group:soil"} */
          lua_createtable(L,1,0);
          lua_pushliteral(L,"group:soil");
          lua_rawseti(L,-2,1);
          lua_pushliteral(L,"neighbors");
          lua_insert(L,-2);
          lua_settable(L,(11 + lc_nextra));
          assert(lua_gettop(L) - lc_nextra == 15);
          
          /* ab.action = flower_spread */
          lua_pushvalue(L,(5 + lc_nextra));
          lua_pushliteral(L,"action");
          lua_insert(L,-2);
          lua_settable(L,(11 + lc_nextra));
          assert(lua_gettop(L) - lc_nextra == 15);
        }
        else {
          
          /* -- find grow papyrus abm and change to grow_papyrus function
           * 	elseif label == "Grow papyrus"
           * 	or node1 == "default:papyrus" then */
          enum { lc108 = 15 };
          lua_pushvalue(L,(12 + lc_nextra));
          lua_pushliteral(L,"Grow papyrus");
          const int lc109 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc109);
          if (!(lua_toboolean(L,-1))) {
            lua_pop(L,1);
            lua_pushvalue(L,(13 + lc_nextra));
            lua_pushliteral(L,"default:papyrus");
            const int lc110 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc110);
          }
          const int lc111 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc111) {
            
            /* --ab.interval = 2
             * --ab.chance = 1
             * ab.nodenames = {"default:papyrus", "ethereal:bamboo"} */
            lua_createtable(L,2,0);
            lua_pushliteral(L,"default:papyrus");
            lua_rawseti(L,-2,1);
            lua_pushliteral(L,"ethereal:bamboo");
            lua_rawseti(L,-2,2);
            lua_pushliteral(L,"nodenames");
            lua_insert(L,-2);
            lua_settable(L,(11 + lc_nextra));
            assert(lua_gettop(L) - lc_nextra == 15);
            
            /* ab.neighbors = {"group:soil"} */
            lua_createtable(L,1,0);
            lua_pushliteral(L,"group:soil");
            lua_rawseti(L,-2,1);
            lua_pushliteral(L,"neighbors");
            lua_insert(L,-2);
            lua_settable(L,(11 + lc_nextra));
            assert(lua_gettop(L) - lc_nextra == 15);
            
            /* ab.action = grow_papyrus */
            lua_pushvalue(L,(6 + lc_nextra));
            lua_pushliteral(L,"action");
            lua_insert(L,-2);
            lua_settable(L,(11 + lc_nextra));
            assert(lua_gettop(L) - lc_nextra == 15);
          }
          lua_settop(L,(lc108 + lc_nextra));
        }
        lua_settop(L,(lc104 + lc_nextra));
      }
      lua_settop(L,(lc99 + lc_nextra));
    }
    lua_settop(L,(lc94 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 15);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,6);
  }
  lua_settop(L,(lc93 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* -- If Baked Clay mod not active, make Red, Orange and Grey nodes
   * if not minetest.get_modpath("bakedclay") then */
  enum { lc112 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"bakedclay");
  lua_call(L,1,1);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc113 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc113) {
    
    /* minetest.register_node(":bakedclay:red", {
     * 		description = S("Red Baked Clay"),
     * 		tiles = {"baked_clay_red.png"},
     * 		groups = {cracky = 3},
     * 		is_ground_content = ethereal.cavedirt,
     * 		sounds = default.node_sound_stone_defaults(),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,":bakedclay:red");
    lua_createtable(L,0,5);
    lua_pushliteral(L,"description");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushliteral(L,"Red Baked Clay");
    lua_call(L,1,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"baked_clay_red.png");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,1);
    lua_pushliteral(L,"cracky");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"cavedirt");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_stone_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 6);
    
    /* minetest.register_node(":bakedclay:orange", {
     * 		description = S("Orange Baked Clay"),
     * 		tiles = {"baked_clay_orange.png"},
     * 		groups = {cracky = 3},
     * 		is_ground_content = ethereal.cavedirt,
     * 		sounds = default.node_sound_stone_defaults(),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,":bakedclay:orange");
    lua_createtable(L,0,5);
    lua_pushliteral(L,"description");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushliteral(L,"Orange Baked Clay");
    lua_call(L,1,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"baked_clay_orange.png");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,1);
    lua_pushliteral(L,"cracky");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"cavedirt");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_stone_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 6);
    
    /* minetest.register_node(":bakedclay:grey", {
     * 		description = S("Grey Baked Clay"),
     * 		tiles = {"baked_clay_grey.png"},
     * 		groups = {cracky = 3},
     * 		is_ground_content = ethereal.cavedirt,
     * 		sounds = default.node_sound_stone_defaults(),
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,":bakedclay:grey");
    lua_createtable(L,0,5);
    lua_pushliteral(L,"description");
    lua_pushvalue(L,(1 + lc_nextra));
    lua_pushliteral(L,"Grey Baked Clay");
    lua_call(L,1,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"tiles");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"baked_clay_grey.png");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"groups");
    lua_createtable(L,0,1);
    lua_pushliteral(L,"cracky");
    lua_pushnumber(L,3);
    lua_rawset(L,-3);
    lua_rawset(L,-3);
    lua_pushliteral(L,"is_ground_content");
    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
    lua_pushliteral(L,"cavedirt");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"sounds");
    lua_getfield(L,LUA_ENVIRONINDEX,"default");
    lua_pushliteral(L,"node_sound_stone_defaults");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    lua_rawset(L,-3);
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 6);
  }
  lua_settop(L,(lc112 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* -- Quicksand (old style, sinking inside shows black instead of yellow effect,
   * -- works ok with noclip enabled though)
   * minetest.register_node("ethereal:quicksand", {
   * 	description = S("Quicksand"),
   * 	tiles = {"default_sand.png"},
   * 	drop = "default:sand",
   * 	liquid_viscosity = 15,
   * 	liquidtype = "source",
   * 	liquid_alternative_flowing = "ethereal:quicksand",
   * 	liquid_alternative_source = "ethereal:quicksand",
   * 	liquid_renewable = false,
   * 	liquid_range = 0,
   * 	drowning = 1,
   * 	walkable = false,
   * 	climbable = false,
   * 	post_effect_color = {r = 230, g = 210, b = 160, a = 245},
   * 	groups = {crumbly = 3, sand = 1, liquid = 3, disable_jump = 1},
   * 	sounds = default.node_sound_sand_defaults(),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:quicksand");
  lua_createtable(L,0,15);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Quicksand");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default_sand.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"default:sand");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_viscosity");
  lua_pushnumber(L,15);
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquidtype");
  lua_pushliteral(L,"source");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_alternative_flowing");
  lua_pushliteral(L,"ethereal:quicksand");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_alternative_source");
  lua_pushliteral(L,"ethereal:quicksand");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_renewable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_range");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drowning");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"climbable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"post_effect_color");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"r");
  lua_pushnumber(L,230);
  lua_rawset(L,-3);
  lua_pushliteral(L,"g");
  lua_pushnumber(L,210);
  lua_rawset(L,-3);
  lua_pushliteral(L,"b");
  lua_pushnumber(L,160);
  lua_rawset(L,-3);
  lua_pushliteral(L,"a");
  lua_pushnumber(L,245);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sand");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"disable_jump");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_sand_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* -- Quicksand (new style, sinking inside shows yellow effect with or without noclip,
   * -- but old quicksand is shown as black until block placed nearby to update light)
   * minetest.register_node("ethereal:quicksand2", {
   * 	description = S("Quicksand"),
   * 	tiles = {"default_sand.png"},
   * 	drawtype = "glasslike",
   * 	paramtype = "light",
   * 	drop = "default:sand",
   * 	liquid_viscosity = 15,
   * 	liquidtype = "source",
   * 	liquid_alternative_flowing = "ethereal:quicksand2",
   * 	liquid_alternative_source = "ethereal:quicksand2",
   * 	liquid_renewable = false,
   * 	liquid_range = 0,
   * 	drowning = 1,
   * 	walkable = false,
   * 	climbable = false,
   * 	post_effect_color = {r = 230, g = 210, b = 160, a = 245},
   * 	groups = {crumbly = 3, sand = 1, liquid = 3, disable_jump = 1},
   * 	sounds = default.node_sound_sand_defaults(),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:quicksand2");
  lua_createtable(L,0,17);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Quicksand");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default_sand.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"glasslike");
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"default:sand");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_viscosity");
  lua_pushnumber(L,15);
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquidtype");
  lua_pushliteral(L,"source");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_alternative_flowing");
  lua_pushliteral(L,"ethereal:quicksand2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_alternative_source");
  lua_pushliteral(L,"ethereal:quicksand2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_renewable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid_range");
  lua_pushnumber(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drowning");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"climbable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"post_effect_color");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"r");
  lua_pushnumber(L,230);
  lua_rawset(L,-3);
  lua_pushliteral(L,"g");
  lua_pushnumber(L,210);
  lua_rawset(L,-3);
  lua_pushliteral(L,"b");
  lua_pushnumber(L,160);
  lua_rawset(L,-3);
  lua_pushliteral(L,"a");
  lua_pushnumber(L,245);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,4);
  lua_pushliteral(L,"crumbly");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sand");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"liquid");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"disable_jump");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_sand_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 6);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_ethereal_dirt(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


