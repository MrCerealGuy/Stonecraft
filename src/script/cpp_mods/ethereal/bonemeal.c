/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: enough_height
 * function(pos, height) */
static int lcf1_enough_height (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local nod = minetest.line_of_sight(
   * 		{x = pos.x, y = pos.y + 1, z = pos.z},
   * 		{x = pos.x, y = pos.y + height, z = pos.z}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"line_of_sight");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushliteral(L,"x");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lc_add(L,-1,2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushliteral(L,"z");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 3);
  
  /* if not nod then */
  enum { lc6 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc7 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc7) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  else {
    
    /* else
     * return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: growth
 * function(pointed_thing) */
static int lcf1_growth (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local pos = pointed_thing.under */
  lua_pushliteral(L,"under");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 2);
  
  /* local node = minetest.get_node(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if node.name == "ignore" then */
  enum { lc9 = 3 };
  lua_pushliteral(L,"name");
  lua_gettable(L,3);
  lua_pushliteral(L,"ignore");
  const int lc10 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc10);
  const int lc11 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc11) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc9);
  assert(lua_gettop(L) == 3);
  
  /* minetest.add_particlespawner({
   * 		amount = 4,
   * 		time = 0.15,
   * 		minpos = pos,
   * 		maxpos = pos,
   * 		minvel = {x = -1, y = 2, z = -1},
   * 		maxvel = {x = 1, y = 4, z = 1},
   * 		minacc = {x = -1, y = -1, z = -1},
   * 		maxacc = {x = 1, y = 1, z = 1},
   * 		minexptime = 1,
   * 		maxexptime = 1,
   * 		minsize = 1,
   * 		maxsize = 3,
   * 		texture = "bonemeal_particle.png",
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"add_particlespawner");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,13);
  lua_pushliteral(L,"amount");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"time");
  lua_pushnumber(L,0.15);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minpos");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxpos");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minvel");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,-1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,-1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxvel");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minacc");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,-1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,-1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,-1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxacc");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minexptime");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxexptime");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"minsize");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"maxsize");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"texture");
  lua_pushliteral(L,"bonemeal_particle.png");
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 3);
  
  /* -- 50/50 chance of growing a sapling
   * if minetest.get_item_group(node.name, "sapling") > 0 then */
  enum { lc12 = 3 };
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_item_group");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,3);
  lua_pushliteral(L,"sapling");
  lua_call(L,2,1);
  const int lc13 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc13);
  const int lc14 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc14) {
    
    /* if math.random(1, 2) == 1 then */
    enum { lc15 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"random");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_pushnumber(L,2);
    lua_call(L,2,1);
    lua_pushnumber(L,1);
    const int lc16 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc16);
    const int lc17 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc17) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc15);
    assert(lua_gettop(L) == 3);
    
    /* local under =  minetest.get_node({
     * 			x = pos.x,
     * 			y = pos.y - 1,
     * 			z = pos.z
     * 		}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_node");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_rawset(L,-3);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 4);
    
    /* local height = minetest.registered_nodes[node.name].grown_height */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"registered_nodes");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"grown_height");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 5);
    
    /* -- do we have enough height to grow sapling into tree?
     * if height and not enough_height(pos, height) then */
    enum { lc18 = 5 };
    lua_pushvalue(L,5);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),1,3);
      lua_pushvalue(L,2);
      lua_pushvalue(L,5);
      lua_call(L,2,1);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
    }
    const int lc19 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc19) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc18);
    assert(lua_gettop(L) == 5);
    
    /* -- specific check for palm tree's, so they grow on sand
     * if node.name == "ethereal:palm_sapling"
     * 		and under.name == "default:sand" then */
    enum { lc20 = 5 };
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lua_pushliteral(L,"ethereal:palm_sapling");
    const int lc21 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc21);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"name");
      lua_gettable(L,4);
      lua_pushliteral(L,"default:sand");
      const int lc22 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc22);
    }
    const int lc23 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc23) {
      
      /* ethereal.grow_palm_tree(pos) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
      lua_pushliteral(L,"grow_palm_tree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 5);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc20);
    assert(lua_gettop(L) == 5);
    
    /* -- check for soil under sapling
     * if minetest.get_item_group(under.name, "soil") == 0 then */
    enum { lc24 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"get_item_group");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"name");
    lua_gettable(L,4);
    lua_pushliteral(L,"soil");
    lua_call(L,2,1);
    lua_pushnumber(L,0);
    const int lc25 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc25);
    const int lc26 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc26) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc24);
    assert(lua_gettop(L) == 5);
    
    /* -- grow ethereal tree
     * if node.name == "ethereal:palm_sapling" then */
    enum { lc27 = 5 };
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lua_pushliteral(L,"ethereal:palm_sapling");
    const int lc28 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc28);
    const int lc29 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc29) {
      
      /* ethereal.grow_palm_tree(pos) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
      lua_pushliteral(L,"grow_palm_tree");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 5);
    }
    else {
      
      /* elseif node.name == "ethereal:yellow_tree_sapling" then */
      enum { lc30 = 5 };
      lua_pushliteral(L,"name");
      lua_gettable(L,3);
      lua_pushliteral(L,"ethereal:yellow_tree_sapling");
      const int lc31 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc31);
      const int lc32 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc32) {
        
        /* ethereal.grow_yellow_tree(pos) */
        lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
        lua_pushliteral(L,"grow_yellow_tree");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,2);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 5);
      }
      else {
        
        /* elseif node.name == "ethereal:big_tree_sapling" then */
        enum { lc33 = 5 };
        lua_pushliteral(L,"name");
        lua_gettable(L,3);
        lua_pushliteral(L,"ethereal:big_tree_sapling");
        const int lc34 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc34);
        const int lc35 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc35) {
          
          /* ethereal.grow_big_tree(pos) */
          lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
          lua_pushliteral(L,"grow_big_tree");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,2);
          lua_call(L,1,0);
          assert(lua_gettop(L) == 5);
        }
        else {
          
          /* elseif node.name == "ethereal:banana_tree_sapling" then */
          enum { lc36 = 5 };
          lua_pushliteral(L,"name");
          lua_gettable(L,3);
          lua_pushliteral(L,"ethereal:banana_tree_sapling");
          const int lc37 = lua_equal(L,-2,-1);
          lua_pop(L,2);
          lua_pushboolean(L,lc37);
          const int lc38 = lua_toboolean(L,-1);
          lua_pop(L,1);
          if (lc38) {
            
            /* ethereal.grow_banana_tree(pos) */
            lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
            lua_pushliteral(L,"grow_banana_tree");
            lua_gettable(L,-2);
            lua_remove(L,-2);
            lua_pushvalue(L,2);
            lua_call(L,1,0);
            assert(lua_gettop(L) == 5);
          }
          else {
            
            /* elseif node.name == "ethereal:frost_tree_sapling" then */
            enum { lc39 = 5 };
            lua_pushliteral(L,"name");
            lua_gettable(L,3);
            lua_pushliteral(L,"ethereal:frost_tree_sapling");
            const int lc40 = lua_equal(L,-2,-1);
            lua_pop(L,2);
            lua_pushboolean(L,lc40);
            const int lc41 = lua_toboolean(L,-1);
            lua_pop(L,1);
            if (lc41) {
              
              /* ethereal.grow_frost_tree(pos) */
              lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
              lua_pushliteral(L,"grow_frost_tree");
              lua_gettable(L,-2);
              lua_remove(L,-2);
              lua_pushvalue(L,2);
              lua_call(L,1,0);
              assert(lua_gettop(L) == 5);
            }
            else {
              
              /* elseif node.name == "ethereal:mushroom_sapling" then */
              enum { lc42 = 5 };
              lua_pushliteral(L,"name");
              lua_gettable(L,3);
              lua_pushliteral(L,"ethereal:mushroom_sapling");
              const int lc43 = lua_equal(L,-2,-1);
              lua_pop(L,2);
              lua_pushboolean(L,lc43);
              const int lc44 = lua_toboolean(L,-1);
              lua_pop(L,1);
              if (lc44) {
                
                /* ethereal.grow_mushroom_tree(pos) */
                lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                lua_pushliteral(L,"grow_mushroom_tree");
                lua_gettable(L,-2);
                lua_remove(L,-2);
                lua_pushvalue(L,2);
                lua_call(L,1,0);
                assert(lua_gettop(L) == 5);
              }
              else {
                
                /* elseif node.name == "ethereal:willow_sapling" then */
                enum { lc45 = 5 };
                lua_pushliteral(L,"name");
                lua_gettable(L,3);
                lua_pushliteral(L,"ethereal:willow_sapling");
                const int lc46 = lua_equal(L,-2,-1);
                lua_pop(L,2);
                lua_pushboolean(L,lc46);
                const int lc47 = lua_toboolean(L,-1);
                lua_pop(L,1);
                if (lc47) {
                  
                  /* ethereal.grow_willow_tree(pos) */
                  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                  lua_pushliteral(L,"grow_willow_tree");
                  lua_gettable(L,-2);
                  lua_remove(L,-2);
                  lua_pushvalue(L,2);
                  lua_call(L,1,0);
                  assert(lua_gettop(L) == 5);
                }
                else {
                  
                  /* elseif node.name == "ethereal:redwood_sapling" then */
                  enum { lc48 = 5 };
                  lua_pushliteral(L,"name");
                  lua_gettable(L,3);
                  lua_pushliteral(L,"ethereal:redwood_sapling");
                  const int lc49 = lua_equal(L,-2,-1);
                  lua_pop(L,2);
                  lua_pushboolean(L,lc49);
                  const int lc50 = lua_toboolean(L,-1);
                  lua_pop(L,1);
                  if (lc50) {
                    
                    /* ethereal.grow_redwood_tree(pos) */
                    lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                    lua_pushliteral(L,"grow_redwood_tree");
                    lua_gettable(L,-2);
                    lua_remove(L,-2);
                    lua_pushvalue(L,2);
                    lua_call(L,1,0);
                    assert(lua_gettop(L) == 5);
                  }
                  else {
                    
                    /* elseif node.name == "ethereal:orange_tree_sapling" then */
                    enum { lc51 = 5 };
                    lua_pushliteral(L,"name");
                    lua_gettable(L,3);
                    lua_pushliteral(L,"ethereal:orange_tree_sapling");
                    const int lc52 = lua_equal(L,-2,-1);
                    lua_pop(L,2);
                    lua_pushboolean(L,lc52);
                    const int lc53 = lua_toboolean(L,-1);
                    lua_pop(L,1);
                    if (lc53) {
                      
                      /* ethereal.grow_orange_tree(pos) */
                      lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                      lua_pushliteral(L,"grow_orange_tree");
                      lua_gettable(L,-2);
                      lua_remove(L,-2);
                      lua_pushvalue(L,2);
                      lua_call(L,1,0);
                      assert(lua_gettop(L) == 5);
                    }
                    else {
                      
                      /* elseif node.name == "ethereal:bamboo_sprout" then */
                      enum { lc54 = 5 };
                      lua_pushliteral(L,"name");
                      lua_gettable(L,3);
                      lua_pushliteral(L,"ethereal:bamboo_sprout");
                      const int lc55 = lua_equal(L,-2,-1);
                      lua_pop(L,2);
                      lua_pushboolean(L,lc55);
                      const int lc56 = lua_toboolean(L,-1);
                      lua_pop(L,1);
                      if (lc56) {
                        
                        /* ethereal.grow_bamboo_tree(pos) */
                        lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                        lua_pushliteral(L,"grow_bamboo_tree");
                        lua_gettable(L,-2);
                        lua_remove(L,-2);
                        lua_pushvalue(L,2);
                        lua_call(L,1,0);
                        assert(lua_gettop(L) == 5);
                      }
                      else {
                        
                        /* elseif node.name == "ethereal:birch_sapling" then */
                        enum { lc57 = 5 };
                        lua_pushliteral(L,"name");
                        lua_gettable(L,3);
                        lua_pushliteral(L,"ethereal:birch_sapling");
                        const int lc58 = lua_equal(L,-2,-1);
                        lua_pop(L,2);
                        lua_pushboolean(L,lc58);
                        const int lc59 = lua_toboolean(L,-1);
                        lua_pop(L,1);
                        if (lc59) {
                          
                          /* ethereal.grow_birch_tree(pos) */
                          lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
                          lua_pushliteral(L,"grow_birch_tree");
                          lua_gettable(L,-2);
                          lua_remove(L,-2);
                          lua_pushvalue(L,2);
                          lua_call(L,1,0);
                          assert(lua_gettop(L) == 5);
                        }
                        else {
                          
                          /* -- grow default tree
                           * 		elseif node.name == "default:sapling"
                           * 		and enough_height(pos, 7) then */
                          enum { lc60 = 5 };
                          lua_pushliteral(L,"name");
                          lua_gettable(L,3);
                          lua_pushliteral(L,"default:sapling");
                          const int lc61 = lua_equal(L,-2,-1);
                          lua_pop(L,2);
                          lua_pushboolean(L,lc61);
                          if (lua_toboolean(L,-1)) {
                            lua_pop(L,1);
                            lc_getupvalue(L,lua_upvalueindex(1),1,3);
                            lua_pushvalue(L,2);
                            lua_pushnumber(L,7);
                            lua_call(L,2,1);
                          }
                          const int lc62 = lua_toboolean(L,-1);
                          lua_pop(L,1);
                          if (lc62) {
                            
                            /* default.grow_new_apple_tree(pos) */
                            lua_getfield(L,LUA_ENVIRONINDEX,"default");
                            lua_pushliteral(L,"grow_new_apple_tree");
                            lua_gettable(L,-2);
                            lua_remove(L,-2);
                            lua_pushvalue(L,2);
                            lua_call(L,1,0);
                            assert(lua_gettop(L) == 5);
                          }
                          else {
                            
                            /* elseif node.name == "default:junglesapling"
                             * 		and enough_height(pos, 15) then */
                            enum { lc63 = 5 };
                            lua_pushliteral(L,"name");
                            lua_gettable(L,3);
                            lua_pushliteral(L,"default:junglesapling");
                            const int lc64 = lua_equal(L,-2,-1);
                            lua_pop(L,2);
                            lua_pushboolean(L,lc64);
                            if (lua_toboolean(L,-1)) {
                              lua_pop(L,1);
                              lc_getupvalue(L,lua_upvalueindex(1),1,3);
                              lua_pushvalue(L,2);
                              lua_pushnumber(L,15);
                              lua_call(L,2,1);
                            }
                            const int lc65 = lua_toboolean(L,-1);
                            lua_pop(L,1);
                            if (lc65) {
                              
                              /* default.grow_new_jungle_tree(pos) */
                              lua_getfield(L,LUA_ENVIRONINDEX,"default");
                              lua_pushliteral(L,"grow_new_jungle_tree");
                              lua_gettable(L,-2);
                              lua_remove(L,-2);
                              lua_pushvalue(L,2);
                              lua_call(L,1,0);
                              assert(lua_gettop(L) == 5);
                            }
                            else {
                              
                              /* elseif node.name == "default:pine_sapling"
                               * 		and enough_height(pos, 11) then */
                              enum { lc66 = 5 };
                              lua_pushliteral(L,"name");
                              lua_gettable(L,3);
                              lua_pushliteral(L,"default:pine_sapling");
                              const int lc67 = lua_equal(L,-2,-1);
                              lua_pop(L,2);
                              lua_pushboolean(L,lc67);
                              if (lua_toboolean(L,-1)) {
                                lua_pop(L,1);
                                lc_getupvalue(L,lua_upvalueindex(1),1,3);
                                lua_pushvalue(L,2);
                                lua_pushnumber(L,11);
                                lua_call(L,2,1);
                              }
                              const int lc68 = lua_toboolean(L,-1);
                              lua_pop(L,1);
                              if (lc68) {
                                
                                /* if minetest.find_node_near(pos, 1,
                                 * 				{"default:snow", "default:snowblock", "default:dirt_with_snow"}) then */
                                enum { lc69 = 5 };
                                lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
                                lua_pushliteral(L,"find_node_near");
                                lua_gettable(L,-2);
                                lua_remove(L,-2);
                                lua_pushvalue(L,2);
                                lua_pushnumber(L,1);
                                lua_createtable(L,3,0);
                                lua_pushliteral(L,"default:snow");
                                lua_rawseti(L,-2,1);
                                lua_pushliteral(L,"default:snowblock");
                                lua_rawseti(L,-2,2);
                                lua_pushliteral(L,"default:dirt_with_snow");
                                lua_rawseti(L,-2,3);
                                lua_call(L,3,1);
                                const int lc70 = lua_toboolean(L,-1);
                                lua_pop(L,1);
                                if (lc70) {
                                  
                                  /* default.grow_new_snowy_pine_tree(pos) */
                                  lua_getfield(L,LUA_ENVIRONINDEX,"default");
                                  lua_pushliteral(L,"grow_new_snowy_pine_tree");
                                  lua_gettable(L,-2);
                                  lua_remove(L,-2);
                                  lua_pushvalue(L,2);
                                  lua_call(L,1,0);
                                  assert(lua_gettop(L) == 5);
                                }
                                else {
                                  
                                  /* else
                                   * default.grow_new_pine_tree(pos) */
                                  lua_getfield(L,LUA_ENVIRONINDEX,"default");
                                  lua_pushliteral(L,"grow_new_pine_tree");
                                  lua_gettable(L,-2);
                                  lua_remove(L,-2);
                                  lua_pushvalue(L,2);
                                  lua_call(L,1,0);
                                  assert(lua_gettop(L) == 5);
                                }
                                lua_settop(L,lc69);
                                assert(lua_gettop(L) == 5);
                              }
                              else {
                                
                                /* elseif node.name == "default:acacia_sapling"
                                 * 		and enough_height(pos, 7) then */
                                enum { lc71 = 5 };
                                lua_pushliteral(L,"name");
                                lua_gettable(L,3);
                                lua_pushliteral(L,"default:acacia_sapling");
                                const int lc72 = lua_equal(L,-2,-1);
                                lua_pop(L,2);
                                lua_pushboolean(L,lc72);
                                if (lua_toboolean(L,-1)) {
                                  lua_pop(L,1);
                                  lc_getupvalue(L,lua_upvalueindex(1),1,3);
                                  lua_pushvalue(L,2);
                                  lua_pushnumber(L,7);
                                  lua_call(L,2,1);
                                }
                                const int lc73 = lua_toboolean(L,-1);
                                lua_pop(L,1);
                                if (lc73) {
                                  
                                  /* default.grow_new_acacia_tree(pos) */
                                  lua_getfield(L,LUA_ENVIRONINDEX,"default");
                                  lua_pushliteral(L,"grow_new_acacia_tree");
                                  lua_gettable(L,-2);
                                  lua_remove(L,-2);
                                  lua_pushvalue(L,2);
                                  lua_call(L,1,0);
                                  assert(lua_gettop(L) == 5);
                                }
                                else {
                                  
                                  /* elseif node.name == "default:aspen_sapling"
                                   * 		and enough_height(pos, 11) then */
                                  enum { lc74 = 5 };
                                  lua_pushliteral(L,"name");
                                  lua_gettable(L,3);
                                  lua_pushliteral(L,"default:aspen_sapling");
                                  const int lc75 = lua_equal(L,-2,-1);
                                  lua_pop(L,2);
                                  lua_pushboolean(L,lc75);
                                  if (lua_toboolean(L,-1)) {
                                    lua_pop(L,1);
                                    lc_getupvalue(L,lua_upvalueindex(1),1,3);
                                    lua_pushvalue(L,2);
                                    lua_pushnumber(L,11);
                                    lua_call(L,2,1);
                                  }
                                  const int lc76 = lua_toboolean(L,-1);
                                  lua_pop(L,1);
                                  if (lc76) {
                                    
                                    /* default.grow_new_aspen_tree(pos) */
                                    lua_getfield(L,LUA_ENVIRONINDEX,"default");
                                    lua_pushliteral(L,"grow_new_aspen_tree");
                                    lua_gettable(L,-2);
                                    lua_remove(L,-2);
                                    lua_pushvalue(L,2);
                                    lua_call(L,1,0);
                                    assert(lua_gettop(L) == 5);
                                  }
                                  lua_settop(L,lc74);
                                }
                                lua_settop(L,lc71);
                              }
                              lua_settop(L,lc66);
                            }
                            lua_settop(L,lc63);
                          }
                          lua_settop(L,lc60);
                        }
                        lua_settop(L,lc57);
                      }
                      lua_settop(L,lc54);
                    }
                    lua_settop(L,lc51);
                  }
                  lua_settop(L,lc48);
                }
                lua_settop(L,lc45);
              }
              lua_settop(L,lc42);
            }
            lua_settop(L,lc39);
          }
          lua_settop(L,lc36);
        }
        lua_settop(L,lc33);
      }
      lua_settop(L,lc30);
    }
    lua_settop(L,lc27);
    assert(lua_gettop(L) == 5);
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc12);
  assert(lua_gettop(L) == 3);
  
  /* local stage = "" */
  lua_pushliteral(L,"");
  assert(lua_gettop(L) == 4);
  
  /* -- grow registered crops
   * for n = 1, #crops do */
  lua_pushnumber(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),2,2);
  const double lc80 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc80);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc77_var = lua_tonumber(L,-2);
  const double lc78_limit = lua_tonumber(L,-1);
  const double lc79_step = 1;
  lua_pop(L,2);
  enum { lc81 = 4 };
  while ((((lc79_step > 0) && (lc77_var <= lc78_limit)) || ((lc79_step <= 0) && (lc77_var >= lc78_limit)))) {
    
    /* internal: local n at index 5 */
    lua_pushnumber(L,lc77_var);
    
    /* if string.find(node.name, crops[n][1]) then */
    enum { lc82 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"name");
    lua_gettable(L,3);
    lc_getupvalue(L,lua_upvalueindex(1),2,2);
    lua_pushvalue(L,5);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,2,1);
    const int lc83 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc83) {
      
      /* stage = tonumber( node.name:split("_")[2] ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
      lua_pushliteral(L,"name");
      lua_gettable(L,3);
      lua_pushliteral(L,"split");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"_");
      lua_call(L,2,1);
      lua_pushnumber(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,1);
      lua_replace(L,4);
      assert(lua_gettop(L) == 5);
      
      /* stage = math.min(stage + math.random(1, 4), crops[n][2]) */
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"min");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_pushnumber(L,4);
      lua_call(L,2,1);
      lc_add(L,4,-1);
      lua_remove(L,-2);
      lc_getupvalue(L,lua_upvalueindex(1),2,2);
      lua_pushvalue(L,5);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,2);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,2,1);
      lua_replace(L,4);
      assert(lua_gettop(L) == 5);
      
      /* minetest.set_node(pos, {name = crops[n][1] .. stage}) */
      lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
      lua_pushliteral(L,"set_node");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_createtable(L,0,1);
      lua_pushliteral(L,"name");
      lc_getupvalue(L,lua_upvalueindex(1),2,2);
      lua_pushvalue(L,5);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,4);
      lua_concat(L,2);
      lua_rawset(L,-3);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 5);
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc82);
    assert(lua_gettop(L) == 5);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc77_var += lc79_step;
  }
  lua_settop(L,lc81);
  assert(lua_gettop(L) == 4);
  
  /* -- grow grass and flowers
   * if minetest.get_item_group(node.name, "soil") > 0 then */
  enum { lc84 = 4 };
  lua_pushnumber(L,0);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_item_group");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"name");
  lua_gettable(L,3);
  lua_pushliteral(L,"soil");
  lua_call(L,2,1);
  const int lc85 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc85);
  const int lc86 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc86) {
    
    /* local dirt = minetest.find_nodes_in_area_under_air(
     * 			{x = pos.x - 2, y = pos.y - 1, z = pos.z - 2},
     * 			{x = pos.x + 2, y = pos.y + 1, z = pos.z + 2},
     * 			{"group:soil"}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"find_nodes_in_area_under_air");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,2);
    lc_sub(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"x");
    lua_pushliteral(L,"x");
    lua_gettable(L,2);
    lua_pushnumber(L,2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"y");
    lua_pushliteral(L,"y");
    lua_gettable(L,2);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_pushliteral(L,"z");
    lua_pushliteral(L,"z");
    lua_gettable(L,2);
    lua_pushnumber(L,2);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_rawset(L,-3);
    lua_createtable(L,1,0);
    lua_pushliteral(L,"group:soil");
    lua_rawseti(L,-2,1);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 5);
    
    /* for _,n in pairs(dirt) do
     * internal: local f, s, var = explist */
    enum { lc87 = 5 };
    lua_getfield(L,LUA_ENVIRONINDEX,"pairs");
    lua_pushvalue(L,5);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local _ with idx 9
       * internal: local n with idx 10 */
      
      
      /* local pos2 = n */
      lua_pushvalue(L,10);
      assert(lua_gettop(L) == 11);
      
      /* pos2.y = pos2.y + 1 */
      lua_pushliteral(L,"y");
      lua_gettable(L,11);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"y");
      lua_insert(L,-2);
      lua_settable(L,11);
      assert(lua_gettop(L) == 11);
      
      /* if math.random(0, 5) > 3 then */
      enum { lc88 = 11 };
      lua_pushnumber(L,3);
      lua_getfield(L,LUA_ENVIRONINDEX,"math");
      lua_pushliteral(L,"random");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,0);
      lua_pushnumber(L,5);
      lua_call(L,2,1);
      const int lc89 = lua_lessthan(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc89);
      const int lc90 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc90) {
        
        /* minetest.swap_node(pos2,
         * 					{name = plants[math.random(1, #plants)]}) */
        lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
        lua_pushliteral(L,"swap_node");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,11);
        lua_createtable(L,0,1);
        lua_pushliteral(L,"name");
        lc_getupvalue(L,lua_upvalueindex(1),3,1);
        lua_getfield(L,LUA_ENVIRONINDEX,"math");
        lua_pushliteral(L,"random");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,1);
        lc_getupvalue(L,lua_upvalueindex(1),3,1);
        const double lc91 = lua_objlen(L,-1);
        lua_pop(L,1);
        lua_pushnumber(L,lc91);
        lua_call(L,2,1);
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_rawset(L,-3);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 11);
      }
      else {
        
        /* else
         * if node.name == "default:dirt_with_dry_grass" then */
        enum { lc92 = 11 };
        lua_pushliteral(L,"name");
        lua_gettable(L,3);
        lua_pushliteral(L,"default:dirt_with_dry_grass");
        const int lc93 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc93);
        const int lc94 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc94) {
          
          /* minetest.swap_node(pos2,
           * 						{name = "default:dry_grass_" .. math.random(1, 5)}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"swap_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,11);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"default:dry_grass_");
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_pushnumber(L,5);
          lua_call(L,2,1);
          lua_concat(L,2);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 11);
        }
        else {
          
          /* else
           * minetest.swap_node(pos2,
           * 						{name = "default:grass_" .. math.random(1, 5)}) */
          lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
          lua_pushliteral(L,"swap_node");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushvalue(L,11);
          lua_createtable(L,0,1);
          lua_pushliteral(L,"name");
          lua_pushliteral(L,"default:grass_");
          lua_getfield(L,LUA_ENVIRONINDEX,"math");
          lua_pushliteral(L,"random");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_pushnumber(L,1);
          lua_pushnumber(L,5);
          lua_call(L,2,1);
          lua_concat(L,2);
          lua_rawset(L,-3);
          lua_call(L,2,0);
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L,lc92);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L,lc88);
      assert(lua_gettop(L) == 11);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,3);
    }
    lua_settop(L,lc87);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc84);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* function(itemstack, user, pointed_thing) */
static int lcf103 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* if pointed_thing.type == "node" then */
  enum { lc95 = 3 };
  lua_pushliteral(L,"type");
  lua_gettable(L,3);
  lua_pushliteral(L,"node");
  const int lc96 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc96);
  const int lc97 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc97) {
    
    /* -- Check if node protected
     * if minetest.is_protected(pointed_thing.under, user:get_player_name()) then */
    enum { lc98 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"is_protected");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc99 = lua_gettop(L);
    lua_pushliteral(L,"under");
    lua_gettable(L,3);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"get_player_name");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc99),1);
    const int lc100 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc100) {
      
      /* return */
      return 0;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc98);
    assert(lua_gettop(L) == 3);
    
    /* if not minetest.setting_getbool("creative_mode") then */
    enum { lc101 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"setting_getbool");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"creative_mode");
    lua_call(L,1,1);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc102 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc102) {
      
      /* local item = user:get_wielded_item() */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"get_wielded_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 4);
      
      /* item:take_item() */
      lua_pushvalue(L,4);
      lua_pushliteral(L,"take_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 4);
      
      /* user:set_wielded_item(item) */
      lua_pushvalue(L,2);
      lua_pushliteral(L,"set_wielded_item");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,4);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc101);
    assert(lua_gettop(L) == 3);
    
    /* growth(pointed_thing) */
    lc_getupvalue(L,lua_upvalueindex(1),0,4);
    lua_pushvalue(L,3);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* itemstack:take_item() */
    lua_pushvalue(L,1);
    lua_pushliteral(L,"take_item");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* return itemstack */
    lua_pushvalue(L,1);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc95);
  assert(lua_gettop(L) == 3);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local S = ethereal.intllib */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"intllib");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- bone item
   * minetest.register_craftitem("ethereal:bone", {
   * 	description = S("Bone"),
   * 	inventory_image = "bone.png",
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craftitem");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:bone");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Bone");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushliteral(L,"bone.png");
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- bonemeal recipes
   * minetest.register_craft({
   * 	type = "shapeless",
   * 	output = 'ethereal:bonemeal 2',
   * 	recipe = {'ethereal:bone'},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"shapeless");
  lua_rawset(L,-3);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"ethereal:bonemeal 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:bone");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_craft({
   * 	type = "shapeless",
   * 	output = 'ethereal:bonemeal 4',
   * 	recipe = {'bones:bones'},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"shapeless");
  lua_rawset(L,-3);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"ethereal:bonemeal 4");
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"bones:bones");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* minetest.register_craft( {
   * 	type = "shapeless",
   * 	output = "dye:white 2",
   * 	recipe = {"ethereal:bonemeal"},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craft");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"shapeless");
  lua_rawset(L,-3);
  lua_pushliteral(L,"output");
  lua_pushliteral(L,"dye:white 2");
  lua_rawset(L,-3);
  lua_pushliteral(L,"recipe");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:bonemeal");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- have animalmaterials bone craft into bonemeal if found
   * if minetest.get_modpath('animalmaterials') then */
  enum { lc1 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_modpath");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"animalmaterials");
  lua_call(L,1,1);
  const int lc2 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc2) {
    
    /* minetest.register_craft({
     * 		type = "shapeless",
     * 		output = 'ethereal:bonemeal 2',
     * 		recipe = {'animalmaterials:bone'},
     * 	}) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_craft");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,3);
    lua_pushliteral(L,"type");
    lua_pushliteral(L,"shapeless");
    lua_rawset(L,-3);
    lua_pushliteral(L,"output");
    lua_pushliteral(L,"ethereal:bonemeal 2");
    lua_rawset(L,-3);
    lua_pushliteral(L,"recipe");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"animalmaterials:bone");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- add bones to dirt
   * minetest.override_item("default:dirt", {
   * 	drop = {
   * 		max_items = 1,
   * 		items = {
   * 			{
   * 				items = {'ethereal:bone', 'default:dirt'},
   * 				rarity = 30,
   * 			},
   * 			{
   * 				items = {'default:dirt'},
   * 			}
   * 		}
   * 	},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"override_item");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"default:dirt");
  lua_createtable(L,0,1);
  lua_pushliteral(L,"drop");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"max_items");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"items");
  lua_createtable(L,2,0);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,2,0);
  lua_pushliteral(L,"ethereal:bone");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"default:dirt");
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,30);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,1);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"default:dirt");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local plants = {
   * 	"flowers:dandelion_white",
   * 	"flowers:dandelion_yellow",
   * 	"flowers:geranium",
   * 	"flowers:rose",
   * 	"flowers:tulip",
   * 	"flowers:viola",
   * } */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc3 = 2 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lua_createtable(L,6,0);
  lua_pushliteral(L,"flowers:dandelion_white");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"flowers:dandelion_yellow");
  lua_rawseti(L,-2,2);
  lua_pushliteral(L,"flowers:geranium");
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"flowers:rose");
  lua_rawseti(L,-2,4);
  lua_pushliteral(L,"flowers:tulip");
  lua_rawseti(L,-2,5);
  lua_pushliteral(L,"flowers:viola");
  lua_rawseti(L,-2,6);
  lua_rawseti(L,(lc3 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local crops = {
   * 	{"farming:cotton_", 8},
   * 	{"farming:wheat_", 8},
   * 	{"farming:tomato_", 8},
   * 	{"farming:corn_", 8},
   * 	{"farming:melon_", 8},
   * 	{"farming:pumpkin_", 8},
   * 	{"farming:beanpole_", 5},
   * 	{"farming:blueberry_", 4},
   * 	{"farming:raspberry_", 4},
   * 	{"farming:carrot_", 8},
   * 	{"farming:cocoa_", 3},
   * 	{"farming:coffee_", 5},
   * 	{"farming:cucumber_", 4},
   * 	{"farming:potato_", 4},
   * 	{"farming:grapes_", 8},
   * 	{"farming:rhubarb_", 3},
   * 	{"ethereal:strawberry_", 8},
   * 	{"ethereal:onion_", 5},
   * 	{"farming:barley_", 7},
   * } */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 3 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_createtable(L,19,0);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:cotton_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,1);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:wheat_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,2);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:tomato_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,3);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:corn_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,4);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:melon_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,5);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:pumpkin_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,6);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:beanpole_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,5);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,7);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:blueberry_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,4);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,8);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:raspberry_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,4);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,9);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:carrot_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,10);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:cocoa_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,3);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,11);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:coffee_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,5);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,12);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:cucumber_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,4);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,13);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:potato_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,4);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,14);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:grapes_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,15);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:rhubarb_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,3);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,16);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"ethereal:strawberry_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,8);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,17);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"ethereal:onion_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,5);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,18);
  lua_createtable(L,2,0);
  lua_pushliteral(L,"farming:barley_");
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,7);
  lua_rawseti(L,-2,2);
  lua_rawseti(L,-2,19);
  lua_rawseti(L,(lc4 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* -- check if sapling has enough height room to grow
   * local function enough_height(pos, height)
   * 
   * 	local nod = minetest.line_of_sight(
   * 		{x = pos.x, y = pos.y + 1, z = pos.z},
   * 		{x = pos.x, y = pos.y + height, z = pos.z})
   * 
   * 	if not nod then
   * 		return false -- obstructed
   * 	else
   * 		return true -- can grow
   * 	end
   * end */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc5 = 4 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_pushcfunction(L,lcf1_enough_height);
  lua_rawseti(L,(lc5 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* -- growing routine
   * local function growth(pointed_thing)
   * 
   * 	local pos = pointed_thing.under
   * 	local node = minetest.get_node(pos)
   * 
   * 	if node.name == "ignore" then
   * 		return
   * 	end
   * 
   * 	minetest.add_particlespawner({
   * 		amount = 4,
   * 		time = 0.15,
   * 		minpos = pos,
   * 		maxpos = pos,
   * 		minvel = {x = -1, y = 2, z = -1},
   * 		maxvel = {x = 1, y = 4, z = 1},
   * 		minacc = {x = -1, y = -1, z = -1},
   * 		maxacc = {x = 1, y = 1, z = 1},
   * 		minexptime = 1,
   * 		maxexptime = 1,
   * 		minsize = 1,
   * 		maxsize = 3,
   * 		texture = "bonemeal_particle.png",
   * 	})
   * 
   * 	-- 50/50 chance of growing a sapling
   * 	if minetest.get_item_group(node.name, "sapling") > 0 then
   * 
   * 		if math.random(1, 2) == 1 then
   * 			return
   * 		end
   * 
   * 		local under =  minetest.get_node({
   * 			x = pos.x,
   * 			y = pos.y - 1,
   * 			z = pos.z
   * 		})
   * 
   * 		local height = minetest.registered_nodes[node.name].grown_height
   * 
   * 		-- do we have enough height to grow sapling into tree?
   * 		if height and not enough_height(pos, height) then
   * 			return
   * 		end
   * 
   * 		-- specific check for palm tree's, so they grow on sand
   * 		if node.name == "ethereal:palm_sapling"
   * 		and under.name == "default:sand" then
   * 			ethereal.grow_palm_tree(pos)
   * 			return
   * 		end
   * 
   * 		-- check for soil under sapling
   * 		if minetest.get_item_group(under.name, "soil") == 0 then
   * 			return
   * 		end
   * 
   * 		-- grow ethereal tree
   * 		if node.name == "ethereal:palm_sapling" then
   * 			ethereal.grow_palm_tree(pos)
   * 
   * 		elseif node.name == "ethereal:yellow_tree_sapling" then
   * 			ethereal.grow_yellow_tree(pos)
   * 
   * 		elseif node.name == "ethereal:big_tree_sapling" then
   * 			ethereal.grow_big_tree(pos)
   * 
   * 		elseif node.name == "ethereal:banana_tree_sapling" then
   * 			ethereal.grow_banana_tree(pos)
   * 
   * 		elseif node.name == "ethereal:frost_tree_sapling" then
   * 			ethereal.grow_frost_tree(pos)
   * 
   * 		elseif node.name == "ethereal:mushroom_sapling" then
   * 			ethereal.grow_mushroom_tree(pos)
   * 
   * 		elseif node.name == "ethereal:willow_sapling" then
   * 			ethereal.grow_willow_tree(pos)
   * 
   * 		elseif node.name == "ethereal:redwood_sapling" then
   * 			ethereal.grow_redwood_tree(pos)
   * 
   * 		elseif node.name == "ethereal:orange_tree_sapling" then
   * 			ethereal.grow_orange_tree(pos)
   * 
   * 		elseif node.name == "ethereal:bamboo_sprout" then
   * 			ethereal.grow_bamboo_tree(pos)
   * 
   * 		elseif node.name == "ethereal:birch_sapling" then
   * 			ethereal.grow_birch_tree(pos)
   * 
   * 		-- grow default tree
   * 		elseif node.name == "default:sapling"
   * 		and enough_height(pos, 7) then
   * 			default.grow_new_apple_tree(pos)
   * 
   * 		elseif node.name == "default:junglesapling"
   * 		and enough_height(pos, 15) then
   * 			default.grow_new_jungle_tree(pos)
   * 
   * 		elseif node.name == "default:pine_sapling"
   * 		and enough_height(pos, 11) then
   * 
   * 			if minetest.find_node_near(pos, 1,
   * 				{"default:snow", "default:snowblock", "default:dirt_with_snow"}) then
   * 
   * 				default.grow_new_snowy_pine_tree(pos)
   * 			else
   * 				default.grow_new_pine_tree(pos)
   * 			end
   * 
   * 		elseif node.name == "default:acacia_sapling"
   * 		and enough_height(pos, 7) then
   * 			default.grow_new_acacia_tree(pos)
   * 
   * 		elseif node.name == "default:aspen_sapling"
   * 		and enough_height(pos, 11) then
   * 			default.grow_new_aspen_tree(pos)
   * 		end
   * 
   * 		return
   * 	end
   * 
   * 	local stage = ""
   * 
   * 	-- grow registered crops
   * 	for n = 1, #crops do
   * 
   * 		if string.find(node.name, crops[n][1]) then
   * 
   * 			stage = tonumber( node.name:split("_")[2] )
   * 			stage = math.min(stage + math.random(1, 4), crops[n][2])
   * 
   * 			minetest.set_node(pos, {name = crops[n][1] .. stage})
   * 
   * 			return
   * 
   * 		end
   * 
   * 	end
   * 
   * 	-- grow grass and flowers
   * 	if minetest.get_item_group(node.name, "soil") > 0 then
   * 
   * 		local dirt = minetest.find_nodes_in_area_under_air(
   * 			{x = pos.x - 2, y = pos.y - 1, z = pos.z - 2},
   * 			{x = pos.x + 2, y = pos.y + 1, z = pos.z + 2},
   * 			{"group:soil"})
   * 
   * 		for _,n in pairs(dirt) do
   * 
   * 			local pos2 = n
   * 
   * 			pos2.y = pos2.y + 1
   * 
   * 			if math.random(0, 5) > 3 then
   * 
   * 				minetest.swap_node(pos2,
   * 					{name = plants[math.random(1, #plants)]})
   * 			else
   * 
   * 				if node.name == "default:dirt_with_dry_grass" then
   * 					minetest.swap_node(pos2,
   * 						{name = "default:dry_grass_" .. math.random(1, 5)})
   * 				else
   * 					minetest.swap_node(pos2,
   * 						{name = "default:grass_" .. math.random(1, 5)})
   * 				end
   * 
   * 			end
   * 		end
   * 	end
   * end */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc8 = 5 };
  assert((lua_gettop(L) == (lc8 + lc_nextra)));
  lua_pushvalue(L,(lc8 + lc_nextra));
  lua_pushcclosure(L,lcf1_growth,1);
  lua_rawseti(L,(lc8 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* -- bonemeal item
   * minetest.register_craftitem("ethereal:bonemeal", {
   * 	description = S("Bone Meal"),
   * 	inventory_image = "bonemeal.png",
   * 
   * 	on_use = function(itemstack, user, pointed_thing)
   * 
   * 		if pointed_thing.type == "node" then
   * 
   * 			-- Check if node protected
   * 			if minetest.is_protected(pointed_thing.under, user:get_player_name()) then
   * 				return
   * 			end
   * 
   * 			if not minetest.setting_getbool("creative_mode") then
   * 
   * 				local item = user:get_wielded_item()
   * 
   * 				item:take_item()
   * 				user:set_wielded_item(item)
   * 			end
   * 
   * 			growth(pointed_thing)
   * 
   * 			itemstack:take_item()
   * 
   * 			return itemstack
   * 		end
   * 	end,
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craftitem");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:bonemeal");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Bone Meal");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushliteral(L,"bonemeal.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_use");
  lua_pushvalue(L,(lc8 + lc_nextra));
  lua_pushcclosure(L,lcf103,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 5);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_ethereal_bonemeal(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


