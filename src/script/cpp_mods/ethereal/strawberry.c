/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* function(itemstack, placer, pointed_thing) */
static int lcf2 (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* return farming.place_seed(itemstack, placer, pointed_thing, "ethereal:strawberry_1") */
  const int lc1 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"farming");
  lua_pushliteral(L,"place_seed");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_pushliteral(L,"ethereal:strawberry_1");
  lua_call(L,4,LUA_MULTRET);
  return (lua_gettop(L) - lc1);
  assert(lua_gettop(L) == 3);
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(pos, node) */
static int lcf20 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* -- are we on wet soil?
   * pos.y = pos.y - 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 2);
  
  /* if minetest.get_item_group(minetest.get_node(pos).name, "soil") < 3 then */
  enum { lc14 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_item_group");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"name");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"soil");
  lua_call(L,2,1);
  lua_pushnumber(L,3);
  const int lc15 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc15);
  const int lc16 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc16) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc14);
  assert(lua_gettop(L) == 2);
  
  /* pos.y = pos.y + 1 */
  lua_pushliteral(L,"y");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"y");
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 2);
  
  /* -- do we have enough light?
   * local light = minetest.get_node_light(pos) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"get_node_light");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if not light
   * 		or light < 13 then */
  enum { lc17 = 3 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushnumber(L,13);
    const int lc18 = lua_lessthan(L,3,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc18);
  }
  const int lc19 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc19) {
    
    /* return */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc17);
  assert(lua_gettop(L) == 3);
  
  /* -- grow to next stage
   * local num = node.name:split("_")[2] */
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  lua_pushliteral(L,"split");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"_");
  lua_call(L,2,1);
  lua_pushnumber(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 4);
  
  /* node.name = "ethereal:strawberry_" .. tonumber(num + 1) */
  lua_pushliteral(L,"ethereal:strawberry_");
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  lua_pushnumber(L,1);
  lc_add(L,4,-1);
  lua_remove(L,-2);
  lua_call(L,1,1);
  lua_concat(L,2);
  lua_pushliteral(L,"name");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 4);
  
  /* minetest.swap_node(pos, node) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"swap_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local S = ethereal.intllib */
  lua_getfield(L,LUA_ENVIRONINDEX,"ethereal");
  lua_pushliteral(L,"intllib");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Strawberry (can also be planted as seed)
   * minetest.register_craftitem("ethereal:strawberry", {
   * 	description = S("Strawberry"),
   * 	inventory_image = "strawberry.png",
   * 	wield_image = "strawberry.png",
   * 	on_place = function(itemstack, placer, pointed_thing)
   * 		return farming.place_seed(itemstack, placer, pointed_thing, "ethereal:strawberry_1")
   * 	end,
   * 	on_use = minetest.item_eat(1),
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_craftitem");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ethereal:strawberry");
  lua_createtable(L,0,5);
  lua_pushliteral(L,"description");
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"Strawberry");
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"inventory_image");
  lua_pushliteral(L,"strawberry.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wield_image");
  lua_pushliteral(L,"strawberry.png");
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_place");
  lua_pushcfunction(L,lcf2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"on_use");
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"item_eat");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_call(L,1,1);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Define Strawberry Bush growth stages
   * local crop_def = {
   * 	drawtype = "plantlike",
   * 	tiles = {"strawberry_1.png"},
   * 	paramtype = "light",
   * 	sunlight_propagates = true,
   * 	waving = 1,
   * 	walkable = false,
   * 	buildable_to = true,
   * 	drop = "",
   * 	selection_box = {
   * 		type = "fixed",
   * 		fixed = {-0.5, -0.5, -0.5, 0.5, -5/16, 0.5}
   * 	},
   * 	groups = {
   * 		snappy = 3, flammable  =2, plant = 1, attached_node = 1,
   * 		not_in_creative_inventory = 1, growing = 1
   * 	},
   * 	sounds = default.node_sound_leaves_defaults(),
   * } */
  lua_createtable(L,0,11);
  lua_pushliteral(L,"drawtype");
  lua_pushliteral(L,"plantlike");
  lua_rawset(L,-3);
  lua_pushliteral(L,"tiles");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_1.png");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"paramtype");
  lua_pushliteral(L,"light");
  lua_rawset(L,-3);
  lua_pushliteral(L,"sunlight_propagates");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"waving");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"walkable");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"buildable_to");
  lua_pushboolean(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  lua_pushliteral(L,"selection_box");
  lua_createtable(L,0,2);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"fixed");
  lua_rawset(L,-3);
  lua_pushliteral(L,"fixed");
  lua_createtable(L,6,0);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,-0.5);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,-0.3125);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0.5);
  lua_rawseti(L,-2,6);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"groups");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"snappy");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"flammable");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"plant");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"attached_node");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"not_in_creative_inventory");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"growing");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"sounds");
  lua_getfield(L,LUA_ENVIRONINDEX,"default");
  lua_pushliteral(L,"node_sound_leaves_defaults");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* --stage 1
   * minetest.register_node("ethereal:strawberry_1", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc3 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_1");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc3),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 2
   * crop_def.tiles = {"strawberry_2.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_2.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_2", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc4 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_2");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc4),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 3
   * crop_def.tiles = {"strawberry_3.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_3.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_3", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc5 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_3");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc5),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 4
   * crop_def.tiles = {"strawberry_4.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_4.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_4", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc6 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_4");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc6),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 5
   * crop_def.tiles = {"strawberry_5.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_5.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_5", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc7 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_5");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc7),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 6
   * crop_def.tiles = {"strawberry_6.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_6.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* crop_def.drop = {
   * 	items = {
   * 		{items = {"ethereal:strawberry 1"},rarity = 2},
   * 		{items = {"ethereal:strawberry 2"},rarity = 3},
   * 	}
   * } */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"items");
  lua_createtable(L,2,0);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:strawberry 1");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,2);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:strawberry 2");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_6", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc8 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_6");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc8),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 7
   * crop_def.tiles = {"strawberry_7.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_7.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* crop_def.drop = {
   * 	items = {
   * 		{items = {"ethereal:strawberry 1"},rarity = 1},
   * 		{items = {"ethereal:strawberry 2"},rarity = 3},
   * 	}
   * } */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"items");
  lua_createtable(L,2,0);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:strawberry 1");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:strawberry 2");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_7", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc9 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_7");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc9),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- stage 8
   * crop_def.tiles = {"strawberry_8.png"} */
  lua_createtable(L,1,0);
  lua_pushliteral(L,"strawberry_8.png");
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,"tiles");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* crop_def.groups.growing = 0 */
  lua_pushnumber(L,0);
  lua_pushliteral(L,"groups");
  lua_gettable(L,(2 + lc_nextra));
  lua_insert(L,-2);
  lua_pushliteral(L,"growing");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* crop_def.drop = {
   * 	items = {
   * 		{items = {"ethereal:strawberry 2"},rarity = 1},
   * 		{items = {"ethereal:strawberry 3"},rarity = 3},
   * 	}
   * } */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"items");
  lua_createtable(L,2,0);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:strawberry 2");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,1);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"items");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"ethereal:strawberry 3");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"rarity");
  lua_pushnumber(L,3);
  lua_rawset(L,-3);
  lua_rawseti(L,-2,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drop");
  lua_insert(L,-2);
  lua_settable(L,(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* minetest.register_node("ethereal:strawberry_8", table.copy(crop_def)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_node");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc10 = lua_gettop(L);
  lua_pushliteral(L,"ethereal:strawberry_8");
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"copy");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(2 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc10),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- growing routine if farming redo isn't present
   * if not farming or not farming.mod or farming.mod ~= "redo" then */
  enum { lc11 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"farming");
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"farming");
    lua_pushliteral(L,"mod");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"farming");
    lua_pushliteral(L,"mod");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"redo");
    const int lc12 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc12);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc13 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc13) {
    
    /* minetest.register_abm({
     * 	label = "Ethereal grow strawberry",
     * 	nodenames = {
     * 		"ethereal:strawberry_1", "ethereal:strawberry_2", "ethereal:strawberry_3",
     * 		"ethereal:strawberry_4", "ethereal:strawberry_5", "ethereal:strawberry_6",
     * 		"ethereal:strawberry_7"
     * 	},
     * 	neighbors = {"farming:soil_wet"},
     * 	interval = 9,
     * 	chance = 20,
     * 	catch_up = false,
     * 	action = function(pos, node)
     * 
     * 		-- are we on wet soil?
     * 		pos.y = pos.y - 1
     * 		if minetest.get_item_group(minetest.get_node(pos).name, "soil") < 3 then
     * 			return
     * 		end
     * 		pos.y = pos.y + 1
     * 		
     * 		-- do we have enough light?
     * 		local light = minetest.get_node_light(pos)
     * 
     * 		if not light
     * 		or light < 13 then
     * 			return
     * 		end
     * 		
     * 		-- grow to next stage
     * 		local num = node.name:split("_")[2]
     * 
     * 		node.name = "ethereal:strawberry_" .. tonumber(num + 1)
     * 
     * 		minetest.swap_node(pos, node)
     * 	end
     * }) */
    lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
    lua_pushliteral(L,"register_abm");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_createtable(L,0,7);
    lua_pushliteral(L,"label");
    lua_pushliteral(L,"Ethereal grow strawberry");
    lua_rawset(L,-3);
    lua_pushliteral(L,"nodenames");
    lua_createtable(L,7,0);
    lua_pushliteral(L,"ethereal:strawberry_1");
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,"ethereal:strawberry_2");
    lua_rawseti(L,-2,2);
    lua_pushliteral(L,"ethereal:strawberry_3");
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"ethereal:strawberry_4");
    lua_rawseti(L,-2,4);
    lua_pushliteral(L,"ethereal:strawberry_5");
    lua_rawseti(L,-2,5);
    lua_pushliteral(L,"ethereal:strawberry_6");
    lua_rawseti(L,-2,6);
    lua_pushliteral(L,"ethereal:strawberry_7");
    lua_rawseti(L,-2,7);
    lua_rawset(L,-3);
    lua_pushliteral(L,"neighbors");
    lua_createtable(L,1,0);
    lua_pushliteral(L,"farming:soil_wet");
    lua_rawseti(L,-2,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"interval");
    lua_pushnumber(L,9);
    lua_rawset(L,-3);
    lua_pushliteral(L,"chance");
    lua_pushnumber(L,20);
    lua_rawset(L,-3);
    lua_pushliteral(L,"catch_up");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    lua_pushliteral(L,"action");
    lua_pushcfunction(L,lcf20);
    lua_rawset(L,-3);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 2);
  }
  lua_settop(L,(lc11 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_ethereal_strawberry(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


