/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* name: add_ore
 * function(a, b, c, d, e, f, g) */
static int lcf1_add_ore (lua_State * L) {
  enum { lc_nformalargs = 7 };
  lua_settop(L,7);
  
  /* minetest.register_ore({
   * 		ore_type = "scatter",
   * 		ore = a,
   * 		wherein = b,
   * 		clust_scarcity = c,
   * 		clust_num_ores = d,
   * 		clust_size = e,
   * 		y_min = f,
   * 		y_max = g,
   * 	}) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_ore");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,8);
  lua_pushliteral(L,"ore_type");
  lua_pushliteral(L,"scatter");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ore");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"wherein");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_scarcity");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_num_ores");
  lua_pushvalue(L,4);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_size");
  lua_pushvalue(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y_min");
  lua_pushvalue(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y_max");
  lua_pushvalue(L,7);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- Baked Clay
   * minetest.register_ore({
   * 	ore_type         = "blob",
   * 	ore              = "bakedclay:red",
   * 	wherein          = {"bakedclay:orange"},
   * 	clust_scarcity   = 4 * 4 * 4,
   * 	clust_num_ores = 8,
   * 	clust_size       = 6,
   * 	y_min            = -10,
   * 	y_max            = 71,
   * 	noise_params     = {
   * 		offset = 0.35,
   * 		scale = 0.2,
   * 		spread = {x = 5, y = 5, z = 5},
   * 		seed = -316,
   * 		octaves = 1,
   * 		persist = 0.5
   * 	},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_ore");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,9);
  lua_pushliteral(L,"ore_type");
  lua_pushliteral(L,"blob");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ore");
  lua_pushliteral(L,"bakedclay:red");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wherein");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"bakedclay:orange");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_scarcity");
  lua_pushnumber(L,64);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_num_ores");
  lua_pushnumber(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_size");
  lua_pushnumber(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y_min");
  lua_pushnumber(L,-10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y_max");
  lua_pushnumber(L,71);
  lua_rawset(L,-3);
  lua_pushliteral(L,"noise_params");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"offset");
  lua_pushnumber(L,0.35);
  lua_rawset(L,-3);
  lua_pushliteral(L,"scale");
  lua_pushnumber(L,0.2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"spread");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"seed");
  lua_pushnumber(L,-316);
  lua_rawset(L,-3);
  lua_pushliteral(L,"octaves");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"persist");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* minetest.register_ore({
   * 	ore_type         = "blob",
   * 	ore              = "bakedclay:grey",
   * 	wherein          = {"bakedclay:orange"},
   * 	clust_scarcity   = 4 * 4 * 4,
   * 	clust_num_ores = 8,
   * 	clust_size       = 6,
   * 	y_min            = -10,
   * 	y_max            = 71,
   * 	noise_params     = {
   * 		offset = 0.35,
   * 		scale = 0.2,
   * 		spread = {x = 5, y = 5, z = 5},
   * 		seed = -613,
   * 		octaves = 1,
   * 		persist = 0.5
   * 	},
   * }) */
  lua_getfield(L,LUA_ENVIRONINDEX,"minetest");
  lua_pushliteral(L,"register_ore");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,9);
  lua_pushliteral(L,"ore_type");
  lua_pushliteral(L,"blob");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ore");
  lua_pushliteral(L,"bakedclay:grey");
  lua_rawset(L,-3);
  lua_pushliteral(L,"wherein");
  lua_createtable(L,1,0);
  lua_pushliteral(L,"bakedclay:orange");
  lua_rawseti(L,-2,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_scarcity");
  lua_pushnumber(L,64);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_num_ores");
  lua_pushnumber(L,8);
  lua_rawset(L,-3);
  lua_pushliteral(L,"clust_size");
  lua_pushnumber(L,6);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y_min");
  lua_pushnumber(L,-10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y_max");
  lua_pushnumber(L,71);
  lua_rawset(L,-3);
  lua_pushliteral(L,"noise_params");
  lua_createtable(L,0,6);
  lua_pushliteral(L,"offset");
  lua_pushnumber(L,0.35);
  lua_rawset(L,-3);
  lua_pushliteral(L,"scale");
  lua_pushnumber(L,0.2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"spread");
  lua_createtable(L,0,3);
  lua_pushliteral(L,"x");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"y");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_pushliteral(L,"z");
  lua_pushnumber(L,5);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_pushliteral(L,"seed");
  lua_pushnumber(L,-613);
  lua_rawset(L,-3);
  lua_pushliteral(L,"octaves");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"persist");
  lua_pushnumber(L,0.5);
  lua_rawset(L,-3);
  lua_rawset(L,-3);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* local add_ore = function(a, b, c, d, e, f, g)
   * 
   * 	minetest.register_ore({
   * 		ore_type = "scatter",
   * 		ore = a,
   * 		wherein = b,
   * 		clust_scarcity = c,
   * 		clust_num_ores = d,
   * 		clust_size = e,
   * 		y_min = f,
   * 		y_max = g,
   * 	})
   * end */
  lua_pushcfunction(L,lcf1_add_ore);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Coal
   * add_ore("default:stone_with_coal", "default:desert_stone", 24*24*24, 27, 6, -31000, -16) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_coal");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,13824);
  lua_pushnumber(L,27);
  lua_pushnumber(L,6);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-16);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Iron
   * add_ore("default:stone_with_iron", "default:desert_stone", 9*9*9, 5, 3, -63, -16) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_iron");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,729);
  lua_pushnumber(L,5);
  lua_pushnumber(L,3);
  lua_pushnumber(L,-63);
  lua_pushnumber(L,-16);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* add_ore("default:stone_with_iron", "default:desert_stone", 24*24*24, 27, 6, -31000, -64) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_iron");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,13824);
  lua_pushnumber(L,27);
  lua_pushnumber(L,6);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-64);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* --Mese
   * add_ore("default:stone_with_mese", "default:desert_stone", 14*14*14, 5, 3, -31000, -256) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_mese");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,2744);
  lua_pushnumber(L,5);
  lua_pushnumber(L,3);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-256);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Gold
   * add_ore("default:stone_with_gold", "default:desert_stone", 15*15*15, 3, 2, -255, -64) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_gold");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,3375);
  lua_pushnumber(L,3);
  lua_pushnumber(L,2);
  lua_pushnumber(L,-255);
  lua_pushnumber(L,-64);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* add_ore("default:stone_with_gold", "default:desert_stone", 13*13*13, 5, 3, -31000, -256) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_gold");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,2197);
  lua_pushnumber(L,5);
  lua_pushnumber(L,3);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-256);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Diamond
   * add_ore("default:stone_with_diamond", "default:desert_stone", 17*17*17, 4, 3, -255, -128) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_diamond");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,4913);
  lua_pushnumber(L,4);
  lua_pushnumber(L,3);
  lua_pushnumber(L,-255);
  lua_pushnumber(L,-128);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* add_ore("default:stone_with_diamond", "default:desert_stone", 15*15*15, 4, 3, -31000, -256) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_diamond");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,3375);
  lua_pushnumber(L,4);
  lua_pushnumber(L,3);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-256);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Copper
   * add_ore("default:stone_with_copper", "default:desert_stone", 9*9*9, 5, 3, -31000, -64) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"default:stone_with_copper");
  lua_pushliteral(L,"default:desert_stone");
  lua_pushnumber(L,729);
  lua_pushnumber(L,5);
  lua_pushnumber(L,3);
  lua_pushnumber(L,-31000);
  lua_pushnumber(L,-64);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Coral Sand
   * add_ore("ethereal:sandy", "default:sand", 10*10*10, 24, 4, -100, -10) */
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L,"ethereal:sandy");
  lua_pushliteral(L,"default:sand");
  lua_pushnumber(L,1000);
  lua_pushnumber(L,24);
  lua_pushnumber(L,4);
  lua_pushnumber(L,-100);
  lua_pushnumber(L,-10);
  lua_call(L,7,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


int lc_pmain_mod_ethereal_ores(lua_State * L) {
  luaL_openlibs(L);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);

  int status2 = lua_pcall(L, 0, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


